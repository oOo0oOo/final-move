{"tiers":[{"tactics":["simp","assumption","contradiction","tauto","decide","congr"],"cost":10,"goals":[["MeasureTheory/Integral/Lebesgue.lean",126,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\n\u22a2 \u222b\u207b (x : \u03b1), 0 \u2202\u03bc = 0",["simp","aesop","norm_num"]],["MeasureTheory/Integral/Lebesgue.lean",1179,"case intro.refine_5.hf\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\n\u03b9 : Type u_5\nl : Filter \u03b9\ninst\u271d : l.IsCountablyGenerated\nF : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nf bound : \u03b1 \u2192 \u211d\u22650\u221e\nhF_meas : \u2200\u1da0 (n : \u03b9) in l, Measurable (F n)\nh_bound : \u2200\u1da0 (n : \u03b9) in l, \u2200\u1d50 (a : \u03b1) \u2202\u03bc, F n a \u2264 bound a\nh_fin : \u222b\u207b (a : \u03b1), bound a \u2202\u03bc \u2260 \u22a4\nh_lim\u271d : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, Tendsto (fun n \u21a6 F n a) l (\ud835\udcdd (f a))\nx : \u2115 \u2192 \u03b9\nxl : Tendsto x atTop l\nhxl : \u2200 s \u2208 l, \u2203 a, \u2200 b \u2265 a, x b \u2208 s\nk : \u2115\nh : \u2200 b \u2265 k, x b \u2208 {x | (fun n \u21a6 Measurable (F n)) x} \u2229 {x | (fun n \u21a6 \u2200\u1d50 (a : \u03b1) \u2202\u03bc, F n a \u2264 bound a) x}\na : \u03b1\nh_lim : Tendsto (fun n \u21a6 F n a) l (\ud835\udcdd (f a))\n\u22a2 Tendsto x atTop l",["assumption","aesop","congr","gcongr","tauto"]],["SetTheory/Ordinal/Arithmetic.lean",2259,"\u22a2 lift.{u, v} \u21910 = \u21910",["simp","aesop"]],["SetTheory/Ordinal/Arithmetic.lean",1764,"o : Ordinal.{u}\nho : \u2200 a < o, succ a < o\n\u22a2 \u2200 a < o, succ a < o",["assumption","aesop","congr","tauto"]],["SetTheory/Ordinal/Arithmetic.lean",89,"case inl\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3\u271d : Type u_3\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt\u271d : \u03b3\u271d \u2192 \u03b3\u271d \u2192 Prop\nc a\u271d b : Ordinal.{u}\n\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d\u00b3 : IsWellOrder \u03b1 r\n\u03b2 : Type u\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nx\u271d\u00b2 : IsWellOrder \u03b2 s\n\u03b3 : Type u\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nx\u271d\u00b9 : IsWellOrder \u03b3 t\nx\u271d : type t + type r \u2264 type t + type s\nf : InitialSeg (Sum.Lex t r) (Sum.Lex t s)\nH\u2081 : \u2200 (a : \u03b3), f (Sum.inl a) = Sum.inl a\na : \u03b1\nx : \u03b3\nhx : Sum.inr a = Sum.inl x\n\u22a2 \u2203 b, Sum.inl x = Sum.inr b",["contradiction","aesop","tauto"]],["Algebra/Order/GroupWithZero/Unbundled.lean",1314,"M\u2080 : Type u_1\ninst\u271d\u2074 : MonoidWithZero M\u2080\ninst\u271d\u00b3 : LinearOrder M\u2080\ninst\u271d\u00b2 : ZeroLEOneClass M\u2080\ninst\u271d\u00b9 : PosMulStrictMono M\u2080\ninst\u271d : MulPosStrictMono M\u2080\na b : M\u2080\nha : 0 \u2264 a\nhb : 0 \u2264 b\n\u22a2 2 \u2260 0",["decide","omega","aesop","simp"]],["Order/LiminfLimsup.lean",829,"\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\n\u22a2 \u22a4 \u2208 {a | \u2200\u1da0 (n : \u03b1) in \u22a5, a \u2264 n}",["simp","aesop","tauto"]],["Order/LiminfLimsup.lean",1012,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nf : Filter \u03b2\np q : \u03b2 \u2192 Prop\nu : \u03b2 \u2192 \u03b1\nh : \u2200 (x : \u03b2), p x \u2192 q x\na : \u03b1\nha : a \u2208 {a | \u2200\u1da0 (x : \u03b2) in f, q x \u2192 u x \u2264 a}\n\u22a2 \u2200 (x : \u03b2), (q x \u2192 u x \u2264 a) \u2192 p x \u2192 u x \u2264 a",["tauto","aesop"]],["Order/LiminfLimsup.lean",1015,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nf : Filter \u03b2\np q : \u03b2 \u2192 Prop\nu : \u03b2 \u2192 \u03b1\nh : \u2200 (x : \u03b2), p x \u2192 q x\na : \u03b1\nha : a \u2208 {a | \u2200\u1da0 (x : \u03b2) in f, q x \u2192 a \u2264 u x}\n\u22a2 \u2200 (x : \u03b2), (q x \u2192 a \u2264 u x) \u2192 p x \u2192 a \u2264 u x",["tauto","aesop"]],["Order/LiminfLimsup.lean",1037,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nf : Filter \u03b2\np q : \u03b2 \u2192 Prop\nu : \u03b2 \u2192 \u03b1\n\u22a2 \u2200 (x : \u03b2), p x \u2227 q x \u2192 q x",["tauto","aesop","simp"]],["Order/LiminfLimsup.lean",1064,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nf : Filter \u03b2\np q : \u03b2 \u2192 Prop\nu : \u03b2 \u2192 \u03b1\n\u22a2 \u2200 (x : \u03b2), q x \u2192 p x \u2228 q x",["tauto","aesop"]],["Data/Real/EReal.lean",1200,"case neg\nx y : \u211d\nhy : 0 \u2264 \u2191y\nhxy : \u00acx \u2264 y\n\u22a2 ENNReal.ofReal x - ENNReal.ofReal y = (\u2191x).toENNReal - (\u2191y).toENNReal",["simp","aesop","congr","tauto","norm_num"]],["Data/Real/EReal.lean",1538,"a b : EReal\n\u22a2 a = \u22a4 \u2227 b < 0 \u2228 0 < a \u2227 b = \u22a5 \u2228 a = \u22a5 \u2227 0 < b \u2228 a < 0 \u2227 b = \u22a4 \u2194\n    a = \u22a5 \u2227 0 < b \u2228 0 < a \u2227 b = \u22a5 \u2228 a = \u22a4 \u2227 b < 0 \u2228 a < 0 \u2227 b = \u22a4",["tauto","aesop"]],["SetTheory/Game/PGame.lean",1344,"x : PGame\ni : x.LeftMoves\n\u22a2 (-x).moveRight (toRightMovesNeg i) = -x.moveLeft i",["simp","aesop"]],["SetTheory/Game/PGame.lean",752,"x : PGame\n\u22a2 ((\u2200 (i : x.LeftMoves), (\u2203 i', x.moveLeft i \u2264 moveLeft 0 i') \u2228 \u2203 j, (x.moveLeft i).moveRight j \u2264 0) \u2227\n      \u2200 (j : RightMoves 0), (\u2203 i, x \u2264 (moveRight 0 j).moveLeft i) \u2228 \u2203 j', x.moveRight j' \u2264 moveRight 0 j) \u2194\n    \u2200 (i : x.LeftMoves), \u2203 j, (x.moveLeft i).moveRight j \u2264 0",["simp","aesop"]],["SetTheory/Game/PGame.lean",747,"x : PGame\n\u22a2 ((\u2200 (i : LeftMoves 0), (\u2203 i', moveLeft 0 i \u2264 x.moveLeft i') \u2228 \u2203 j, (moveLeft 0 i).moveRight j \u2264 x) \u2227\n      \u2200 (j : x.RightMoves), (\u2203 i, 0 \u2264 (x.moveRight j).moveLeft i) \u2228 \u2203 j', moveRight 0 j' \u2264 x.moveRight j) \u2194\n    \u2200 (j : x.RightMoves), \u2203 i, 0 \u2264 (x.moveRight j).moveLeft i",["simp","aesop"]],["SetTheory/Game/PGame.lean",762,"x : PGame\n\u22a2 ((\u2203 i,\n        (\u2200 (i' : x.LeftMoves), x.moveLeft i' \u29cf moveLeft 0 i) \u2227\n          \u2200 (j : (moveLeft 0 i).RightMoves), x \u29cf (moveLeft 0 i).moveRight j) \u2228\n      \u2203 j,\n        (\u2200 (i : (x.moveRight j).LeftMoves), (x.moveRight j).moveLeft i \u29cf 0) \u2227\n          \u2200 (j' : RightMoves 0), x.moveRight j \u29cf moveRight 0 j') \u2194\n    \u2203 j, \u2200 (i : (x.moveRight j).LeftMoves), (x.moveRight j).moveLeft i \u29cf 0",["simp","aesop"]],["SetTheory/Game/PGame.lean",1332,"x : PGame\ni : x.RightMoves\n\u22a2 (-x).moveLeft (toLeftMovesNeg i) = -x.moveRight i",["simp","aesop"]],["SetTheory/Game/PGame.lean",1033,"x y : PGame\n\u22a2 \u00acy \u2264 x \u2194 x \u2264 y \u2227 \u00acy \u2264 x \u2228 \u00acy \u2264 x \u2227 \u00acx \u2264 y",["tauto"]],["SetTheory/Game/PGame.lean",1737,"xl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\n\u22a2 (IsEmpty (mk xl xr xL xR).LeftMoves \u2227 IsEmpty (mk yl yr yL yR).LeftMoves) \u2227\n      IsEmpty (mk xl xr xL xR).RightMoves \u2227 IsEmpty (mk yl yr yL yR).RightMoves \u2194\n    (IsEmpty (mk xl xr xL xR).LeftMoves \u2227 IsEmpty (mk xl xr xL xR).RightMoves) \u2227\n      IsEmpty (mk yl yr yL yR).LeftMoves \u2227 IsEmpty (mk yl yr yL yR).RightMoves",["tauto","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",138,"\u22a2 (fun n \u21a6 1) = fun x \u21a6 1 ^ 2",["simp","ring","aesop","norm_num"]],["Computability/AkraBazzi/AkraBazzi.lean",309,"x : \u211d\nhx : rexp 1 \u2264 x\n\u22a2 rexp 0 < rexp 1",["simp","aesop","norm_num"]],["Computability/AkraBazzi/AkraBazzi.lean",524,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\n\u22a2 \u2211 x : \u03b1, 0 = 0",["simp","aesop","norm_num"]],["Computability/AkraBazzi/AkraBazzi.lean",308,"x : \u211d\nhx : rexp 1 \u2264 x\n\u22a2 1 = rexp 0",["simp","aesop","norm_num"]],["Computability/AkraBazzi/AkraBazzi.lean",630,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhc\u2081_pos : 0 < c\u2081\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\n\u22a2 \u2191n \u2265 0",["positivity","aesop","linarith","norm_num","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",709,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nhc\u2083' : 0 < 1 - c\u2083\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nhn\u2083 : \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\n\u22a2 \u2191n \u2265 0",["positivity","aesop","linarith","norm_num","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",914,"case h\np : \u211d\nhp : p \u2260 0\na\u271d\u00b9 : \u211d\na\u271d : 0 < a\u271d\u00b9\n\u22a2 0 \u2264 \u2016deriv (fun z \u21a6 z ^ p * (1 - \u03b5 z)) a\u271d\u00b9\u2016",["positivity","aesop","norm_num","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",937,"case h\np : \u211d\nhp : p \u2260 0\na\u271d\u00b9 : \u211d\na\u271d : 0 < a\u271d\u00b9\n\u22a2 0 \u2264 \u2016deriv (fun z \u21a6 z ^ p * (1 + \u03b5 z)) a\u271d\u00b9\u2016",["positivity","aesop","norm_num","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",1239,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\n\u22a2 \u2191n \u2265 0",["positivity","aesop","linarith","norm_num","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",1388,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\n\u22a2 \u2191n \u2265 0",["positivity","aesop","linarith","norm_num","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",141,"\u22a2 0 < 2",["norm_num","omega","decide","aesop","linarith","positivity","tauto","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",198,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\n\u22a2 0 < 2",["norm_num","aesop","linarith","positivity","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",1306,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\n\u22a2 1 \u2264 2 * 1 * (1 / 2)",["norm_num","aesop","linarith","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",169,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nn : \u2115\nhn : \u2200 (i : \u03b1), \u2016\u2191(r i n) - b i * \u2191n\u2016 \u2264 \u2191n / log \u2191n ^ 2\ni : \u03b1\n\u22a2 \u2191(r i n) = b i * \u2191n + (\u2191(r i n) - b i * \u2191n)",["ring","aesop","linarith","abel","norm_num","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",479,"case h.e_a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nx\u271d : \u2115\n\u22a2 log \u2191x\u271d - log (b i) - log \u2191x\u271d = -log (b i)",["ring","aesop","linarith","abel","norm_num","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",840,"case h\np : \u211d\nhp : p \u2260 0\nx\u271d : \u211d\n\u22a2 p * x\u271d ^ (p - 1) * 1 = p * x\u271d ^ (p - 1)",["ring","aesop","linarith","norm_num","simp"]],["Computability/AkraBazzi/AkraBazzi.lean",864,"case h\np : \u211d\nhp : p \u2260 0\nx\u271d : \u211d\n\u22a2 p * x\u271d ^ (p - 1) * 1 = p * x\u271d ^ (p - 1)",["ring","aesop","linarith","norm_num","simp"]],["Data/Set/Lattice.lean",1541,"case h\n\u03b9 : Type u_12\n\u03b9' : Type u_13\n\u03b1 : Type u_14\n\u03b2 : Type u_15\ns : \u03b9 \u2192 Set \u03b1\nt : \u03b9' \u2192 Set \u03b2\nx\u271d : \u03b1 \u00d7 \u03b2\n\u22a2 x\u271d \u2208 \u22c3 x, s x.1 \u00d7\u02e2 t x.2 \u2194 x\u271d \u2208 (\u22c3 i, s i) \u00d7\u02e2 \u22c3 i, t i",["simp","aesop"]],["Data/Set/Lattice.lean",1706,"case h\n\u03b1 : Type u_1\n\u03c0 : \u03b1 \u2192 Type u_12\ni : Set \u03b1\ns : (a : \u03b1) \u2192 Set (\u03c0 a)\nx\u271d : (i : \u03b1) \u2192 \u03c0 i\n\u22a2 x\u271d \u2208 i.pi s \u2194 x\u271d \u2208 \u22c2 a \u2208 i, eval a \u207b\u00b9' s a",["simp","aesop"]],["MeasureTheory/Measure/Typeclasses.lean",351,"case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\n\u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns t : Set \u03b1\n\u22a2 IsZeroOrProbabilityMeasure 0",["infer_instance","tauto"]],["MeasureTheory/Measure/Typeclasses.lean",353,"case inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns t : Set \u03b1\nh\u271d : NeZero \u03bc\nh : \u03bc univ = \u22a4\n\u22a2 IsZeroOrProbabilityMeasure 0",["infer_instance","tauto"]],["MeasureTheory/Measure/Typeclasses.lean",605,"case intro.inl.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Countable \u03b9\nm : \u03b9 \u2192 Measure \u03b1\ninst\u271d : \u2200 (n : \u03b9), IsFiniteMeasure (m n)\nf : \u03b9 \u2192 \u2115\nhf : Injective f\ni : \u03b9\n\u22a2 IsFiniteMeasure (m i)",["infer_instance","aesop","tauto"]],["MeasureTheory/Measure/Typeclasses.lean",201,"\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nhs : NullMeasurableSet s \u03bc\nht : NullMeasurableSet t \u03bc\nhs' : \u03bc s \u2260 \u22a4\nht' : \u03bc t \u2260 \u22a4\nhst : \u03bc (s \\ t) \u2260 \u22a4\nhts : \u03bc (t \\ s) \u2260 \u22a4\n\u22a2 (\u03bc s).toReal - (\u03bc t).toReal = (\u03bc (s \u222a t)).toReal - (\u03bc t).toReal - ((\u03bc (s \u222a t)).toReal - (\u03bc s).toReal)",["abel","ring","aesop","linarith","norm_num","simp"]],["MeasureTheory/Measure/Typeclasses.lean",181,"case intro.intro.intro.intro\nX : Type u_5\ninst\u271d\u00b9 : MeasurableSpace X\n\u03bc : Measure X\ninst\u271d : IsFiniteMeasure \u03bc\nEs : \u2115 \u2192 Set X\nEs_mble : \u2200 (i : \u2115), NullMeasurableSet (Es i) \u03bc\nEs_disj : Pairwise fun n m \u21a6 Disjoint (Es n) (Es m)\ndecr : Antitone fun n \u21a6 \u22c3 i, \u22c3 (_ : i \u2265 n), Es i\nx : X\nhx : \u2200 (i : \u2115), \u2203 i_1 \u2265 i, x \u2208 Es i_1\nj : \u2115\nleft\u271d : j \u2265 0\nx_in_Es_j : x \u2208 Es j\nk : \u2115\nk_gt_j : k \u2265 j + 1\nx_in_Es_k : x \u2208 Es k\noops : x \u2260 x\n\u22a2 x \u2208 \u2205",["contradiction","aesop","tauto"]],["Analysis/Convolution.lean",813,"G : Type uG\nE' : Type uE'\ninst\u271d\u2078 : NormedAddCommGroup E'\ninst\u271d\u2077 : MeasurableSpace G\n\u03bc : Measure G\ninst\u271d\u2076 : SeminormedAddCommGroup G\ninst\u271d\u2075 : BorelSpace G\ninst\u271d\u2074 : SecondCountableTopology G\ninst\u271d\u00b3 : \u03bc.IsAddLeftInvariant\ninst\u271d\u00b2 : SFinite \u03bc\ninst\u271d\u00b9 : NormedSpace \u211d E'\ninst\u271d : CompleteSpace E'\n\u03b9 : Type u_1\ng : \u03b9 \u2192 G \u2192 E'\nl : Filter \u03b9\nx\u2080 : G\nz\u2080 : E'\n\u03c6 : \u03b9 \u2192 G \u2192 \u211d\nk : \u03b9 \u2192 G\nhn\u03c6 : \u2200\u1da0 (i : \u03b9) in l, \u2200 (x : G), 0 \u2264 \u03c6 i x\nhi\u03c6 : \u2200\u1da0 (i : \u03b9) in l, \u222b (x : G), \u03c6 i x \u2202\u03bc = 1\nhmg : \u2200\u1da0 (i : \u03b9) in l, AEStronglyMeasurable (g i) \u03bc\nhk : Tendsto k l (\ud835\udcdd x\u2080)\nh\u03c6 : \u2200 t \u2208 \ud835\udcdd 0, \u2200\u1da0 (x : \u03b9) in l, support (\u03c6 x) \u2286 t\nhcg :\n  \u2200 \u03b5 > 0,\n    \u2203 pa,\n      (\u2200\u1da0 (i : \u03b9) in l, pa i) \u2227 \u2203 \u03b5_1 > 0, \u2200 \u2983i : \u03b9\u2984, pa i \u2192 \u2200 \u2983x : G\u2984, dist x x\u2080 < \u03b5_1 \u2192 dist (uncurry g (i, x)) z\u2080 < \u03b5\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\n\u22a2 0 < 3",["norm_num","aesop","linarith","positivity","simp"]],["Topology/Category/Profinite/Nobeling.lean",440,"I : Type u\nC : Set (I \u2192 Bool)\ninst\u271d\u00b9 : LinearOrder I\ninst\u271d : WellFoundedLT I\nh : \u22a4 \u2264 Submodule.span \u2124 (Set.range (Products.eval C))\nl : Products I\nL : Products I \u2192 Prop := fun m \u21a6 Products.eval C m \u2208 Submodule.span \u2124 (Set.range (eval C))\nthis : L l\n\u22a2 Products.eval C l \u2208 \u2191(Submodule.span \u2124 (Set.range (eval C)))",["assumption","aesop","congr","tauto"]],["Topology/Category/Profinite/Nobeling.lean",1396,"I : Type u\nC : Set (I \u2192 Bool)\ninst\u271d\u00b9 : LinearOrder I\ninst\u271d : WellFoundedLT I\no : Ordinal.{u}\nhsC : contained C (Order.succ o)\nho : o < Ordinal.type fun x1 x2 \u21a6 x1 < x2\nl : Products I\nh : Products.isGood C l\nhh : term I ho \u2209 \u2191l\nhe :\n  Products.eval (\u03c0 C fun x \u21a6 ord I x < o) l \u2208 Submodule.span \u2124 (Products.eval (\u03c0 C fun x \u21a6 ord I x < o) '' {m | m < l})\nh' : \u2200 i \u2208 \u2191l, ord I i \u2264 o\nha : term I ho \u2208 \u2191l\n\u22a2 False",["contradiction","aesop","tauto"]],["Data/Set/Function.lean",1478,"\u03b9 : Type u_8\n\u03b1 : \u03b9 \u2192 Type u_9\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : (x : \u03b9) \u2192 Decidable (x \u2208 s)\n\u22a2 univ.pi (s.piecewise t fun x \u21a6 univ) = s.pi t",["simp","aesop"]],["Topology/Instances/ENNReal/Lemmas.lean",301,"case neg\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b2\ninst\u271d : SemilatticeSup \u03b2\nf : \u03b2 \u2192 \u211d\u22650\u221e\nhf : Antitone f\nh : \u2200 (\u03b5 : \u211d\u22650\u221e), 0 < \u03b5 \u2192 \u2203 n, f n \u2264 \u03b5\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : 0 < \u03b5\nn : \u03b2\nhn : f n \u2264 1 \u2293 \u03b5 / 2\nh\u03b5_top : \u00ac\u03b5 = \u22a4\n\u22a2 1 < 2",["norm_num","aesop","simp"]],["Topology/Instances/ENNReal/Lemmas.lean",1181,"\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\n\u22a2 2 \u2260 \u22a4",["decide","aesop","tauto","norm_num","simp"]],["MeasureTheory/Integral/FundThmCalculus.lean",1030,"g' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nG' : \u211d \u2192 EReal\nf_lt_G' : \u2200 (x : \u211d), \u2191(\u03c6 x) < G' x\nG'cont : LowerSemicontinuous G'\nG'int : Integrable (fun x \u21a6 (G' x).toReal) (volume.restrict (Icc a b))\nG'lt_top : \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Icc a b), G' x < \u22a4\nhG' : \u222b (x : \u211d) in Icc a b, (G' x).toReal \u2202volume < \u222b (x : \u211d) in Icc a b, \u03c6 x \u2202volume + \u03b5\ns : Set \u211d := {t | g t - g a \u2264 \u222b (u : \u211d) in a..t, (G' u).toReal} \u2229 Icc a b\ns_closed : IsClosed s\nt : \u211d\nht : t \u2208 {t | g t - g a \u2264 \u222b (u : \u211d) in a..t, (G' u).toReal} \u2229 Ico a b\nv : \u211d\nt_lt_v : v \u2208 Ioi t\ny : \u211d\ng'_lt_y' : \u2191(g' t) < \u2191y\ny_lt_G' : \u2191y < G' t\nI1 : \u2200\u1da0 (u : \u211d) in \ud835\udcdd[>] t, (u - t) * y \u2264 \u222b (w : \u211d) in t..u, (G' w).toReal\nI2 : \u2200\u1da0 (u : \u211d) in \ud835\udcdd[>] t, g u - g t \u2264 (u - t) * y\nI3 : \u2200\u1da0 (u : \u211d) in \ud835\udcdd[>] t, g u - g t \u2264 \u222b (w : \u211d) in t..u, (G' w).toReal\nI4 : \u2200\u1da0 (u : \u211d) in \ud835\udcdd[>] t, u \u2208 Ioc t (v \u2293 b)\nx : \u211d\nhx : g x - g t \u2264 \u222b (w : \u211d) in t..x, (G' w).toReal\nh'x : x \u2208 Ioc t (v \u2293 b)\n\u22a2 g x - g a = g t - g a + (g x - g t)",["abel","ring","aesop","linarith","norm_num","simp"]],["MeasureTheory/Function/LpSpace/Basic.lean",1433,"case h\n\u03b1 : Type u_1\nE : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : CompleteSpace E\nf : \u2115 \u2192 \u03b1 \u2192 E\np : \u211d\nhf : \u2200 (n : \u2115), AEStronglyMeasurable (f n) \u03bc\nhp1 : 1 \u2264 p\nB : \u2115 \u2192 \u211d\u22650\u221e\nhB : \u2211' (i : \u2115), B i \u2260 \u22a4\nh_cau : \u2200 (N n m : \u2115), N \u2264 n \u2192 N \u2264 m \u2192 eLpNorm' (f n - f m) p \u03bc < B N\nh_summable : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Summable fun i \u21a6 f (i + 1) x - f i x\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2203 l, Tendsto (fun n \u21a6 \u2211 i \u2208 Finset.range n, (f (i + 1) x - f i x)) atTop (\ud835\udcdd l)\nx : \u03b1\nl : E\nhx : Tendsto (fun n \u21a6 f n x - f 0 x) atTop (\ud835\udcdd l)\nh_rw_sum : (fun n \u21a6 \u2211 i \u2208 Finset.range n, (f (i + 1) x - f i x)) = fun n \u21a6 f n x - f 0 x\nn : \u2115\n\u22a2 f n x = f n x - f 0 x + f 0 x",["abel","aesop","norm_num","simp"]],["MeasureTheory/Function/LpSpace/Basic.lean",1498,"\u03b1 : Type u_1\nE : Type u_4\nm0 : MeasurableSpace \u03b1\np : \u211d\u22650\u221e\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\nhp : 1 \u2264 p\nf : \u2115 \u2192 \u03b1 \u2192 E\nhf : \u2200 (n : \u2115), MemLp (f n) p \u03bc\nf_lim : \u03b1 \u2192 E\nh_lim_meas : AEStronglyMeasurable f_lim \u03bc\nh_tendsto : \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, eLpNorm (f n - f_lim) p \u03bc \u2264 \u03b5\nN : \u2115\nh_tendsto_1 : eLpNorm (f N - f_lim) p \u03bc \u2264 1\n\u22a2 f_lim = f_lim - f N + f N",["abel","aesop","norm_num","simp"]],["MeasureTheory/Function/Jacobian.lean",533,"case e_a\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ns : Set E\nf : E \u2192 E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nA : E \u2192L[\u211d] E\n\u03b4 : \u211d\u22650\nhf : ApproximatesLinearOn f A s \u03b4\nhs : MeasurableSet s\nf' : E \u2192 E \u2192L[\u211d] E\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\nx : E\nhx : Tendsto (fun r \u21a6 \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd 1)\nxs : x \u2208 s\nz : E\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nB\u2081 : \u2200\u1da0 (r : \u211d) in \ud835\udcdd[>] 0, (s \u2229 ({x} + r \u2022 closedBall z \u03b5)).Nonempty\n\u03c1 : \u211d\n\u03c1pos : \u03c1 > 0\nh\u03c1 : ball x \u03c1 \u2229 s \u2286 {y | \u2016f y - f x - (f' x) (y - x)\u2016 \u2264 \u03b5 * \u2016y - x\u2016}\nB\u2082 : \u2200\u1da0 (r : \u211d) in \ud835\udcdd[>] 0, {x} + r \u2022 closedBall z \u03b5 \u2286 ball x \u03c1\nr : \u211d\ny : E\nys : y \u2208 s\nhy : y \u2208 {x} + r \u2022 closedBall z \u03b5\nr\u03c1 : {x} + r \u2022 closedBall z \u03b5 \u2286 ball x \u03c1\nrpos : 0 < r\na : E\naz : a \u2208 closedBall z \u03b5\nya : y = x + r \u2022 a\nnorm_a : \u2016a\u2016 \u2264 \u2016z\u2016 + \u03b5\nI : r * \u2016(f' x - A) a\u2016 \u2264 r * (\u2191\u03b4 + \u03b5) * (\u2016z\u2016 + \u03b5)\n\u22a2 (f' x) z - A z = (f' x) a - A a + ((f' x) z - A z - ((f' x) a - A a))",["abel","aesop","norm_num","simp"]],["MeasureTheory/Function/Jacobian.lean",844,"case e_a\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ns : Set E\nf : E \u2192 E\nf' : E \u2192 E \u2192L[\u211d] E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\n\u03b4 : (E \u2192L[\u211d] E) \u2192 \u211d\u22650\nh\u03b4 :\n  \u2200 (A : E \u2192L[\u211d] E),\n    0 < \u03b4 A \u2227\n      (\u2200 (B : E \u2192L[\u211d] E), \u2016B - A\u2016 \u2264 \u2191(\u03b4 A) \u2192 |B.det - A.det| \u2264 \u2191\u03b5) \u2227\n        \u2200 (t : Set E) (g : E \u2192 E), ApproximatesLinearOn g A t (\u03b4 A) \u2192 \u03bc (g '' t) \u2264 (ENNReal.ofReal |A.det| + \u2191\u03b5) * \u03bc t\nt : \u2115 \u2192 Set E\nA : \u2115 \u2192 E \u2192L[\u211d] E\nt_disj : Pairwise (Disjoint on t)\nt_meas : \u2200 (n : \u2115), MeasurableSet (t n)\nt_cover : s \u2286 \u22c3 n, t n\nht : \u2200 (n : \u2115), ApproximatesLinearOn f (A n) (s \u2229 t n) (\u03b4 (A n))\nn : \u2115\nx : E\nhx : \u2016f' x - A n\u2016\u208a \u2264 \u03b4 (A n)\n\u22a2 (A n).det = (f' x).det - ((f' x).det - (A n).det)",["abel","ring","aesop","linarith","norm_num","simp"]],["MeasureTheory/Function/Jacobian.lean",982,"case e_a\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ns : Set E\nf : E \u2192 E\nf' : E \u2192 E \u2192L[\u211d] E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\nhf : InjOn f s\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\n\u03b4 : (E \u2192L[\u211d] E) \u2192 \u211d\u22650\nh\u03b4 :\n  \u2200 (A : E \u2192L[\u211d] E),\n    0 < \u03b4 A \u2227\n      (\u2200 (B : E \u2192L[\u211d] E), \u2016B - A\u2016 \u2264 \u2191(\u03b4 A) \u2192 |B.det - A.det| \u2264 \u2191\u03b5) \u2227\n        \u2200 (t : Set E) (g : E \u2192 E), ApproximatesLinearOn g A t (\u03b4 A) \u2192 ENNReal.ofReal |A.det| * \u03bc t \u2264 \u03bc (g '' t) + \u2191\u03b5 * \u03bc t\nt : \u2115 \u2192 Set E\nA : \u2115 \u2192 E \u2192L[\u211d] E\nt_disj : Pairwise (Disjoint on t)\nt_meas : \u2200 (n : \u2115), MeasurableSet (t n)\nt_cover : s \u2286 \u22c3 n, t n\nht : \u2200 (n : \u2115), ApproximatesLinearOn f (A n) (s \u2229 t n) (\u03b4 (A n))\ns_eq : s = \u22c3 n, s \u2229 t n\nn : \u2115\nx : E\nhx : \u2016f' x - A n\u2016\u208a \u2264 \u03b4 (A n)\n\u22a2 (f' x).det = (A n).det + ((f' x).det - (A n).det)",["abel","ring","linarith","norm_num","simp"]],["Geometry/Manifold/ChartedSpace.lean",1186,"H : Type u\ninst\u271d : TopologicalSpace H\nG : StructureGroupoid H\n\u22a2 PartialHomeomorph.refl H \u2208 atlas H H",["simp","aesop","congr","tauto","norm_num"]],["Geometry/Manifold/ChartedSpace.lean",183,"case mk.mk\nH\u271d : Type u\nH' : Type u_1\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9 : TopologicalSpace H\u271d\nH : Type u\ninst\u271d : TopologicalSpace H\nmembers\u271d\u00b9 : Set (PartialHomeomorph H H)\ntrans'\u271d\u00b9 : \u2200 (e e' : PartialHomeomorph H H), e \u2208 members\u271d\u00b9 \u2192 e' \u2208 members\u271d\u00b9 \u2192 e \u226b\u2095 e' \u2208 members\u271d\u00b9\nsymm'\u271d\u00b9 : \u2200 e \u2208 members\u271d\u00b9, e.symm \u2208 members\u271d\u00b9\nid_mem'\u271d\u00b9 : PartialHomeomorph.refl H \u2208 members\u271d\u00b9\nlocality'\u271d\u00b9 :\n  \u2200 (e : PartialHomeomorph H H), (\u2200 x \u2208 e.source, \u2203 s, IsOpen s \u2227 x \u2208 s \u2227 e.restr s \u2208 members\u271d\u00b9) \u2192 e \u2208 members\u271d\u00b9\nmem_of_eqOnSource'\u271d\u00b9 : \u2200 (e e' : PartialHomeomorph H H), e \u2208 members\u271d\u00b9 \u2192 e' \u2248 e \u2192 e' \u2208 members\u271d\u00b9\nmembers\u271d : Set (PartialHomeomorph H H)\ntrans'\u271d : \u2200 (e e' : PartialHomeomorph H H), e \u2208 members\u271d \u2192 e' \u2208 members\u271d \u2192 e \u226b\u2095 e' \u2208 members\u271d\nsymm'\u271d : \u2200 e \u2208 members\u271d, e.symm \u2208 members\u271d\nid_mem'\u271d : PartialHomeomorph.refl H \u2208 members\u271d\nlocality'\u271d :\n  \u2200 (e : PartialHomeomorph H H), (\u2200 x \u2208 e.source, \u2203 s, IsOpen s \u2227 x \u2208 s \u2227 e.restr s \u2208 members\u271d) \u2192 e \u2208 members\u271d\nmem_of_eqOnSource'\u271d : \u2200 (e e' : PartialHomeomorph H H), e \u2208 members\u271d \u2192 e' \u2248 e \u2192 e' \u2208 members\u271d\nh :\n  (fun s \u21a6 s.members)\n      { members := members\u271d\u00b9, trans' := trans'\u271d\u00b9, symm' := symm'\u271d\u00b9, id_mem' := id_mem'\u271d\u00b9, locality' := locality'\u271d\u00b9,\n        mem_of_eqOnSource' := mem_of_eqOnSource'\u271d\u00b9 } =\n    (fun s \u21a6 s.members)\n      { members := members\u271d, trans' := trans'\u271d, symm' := symm'\u271d, id_mem' := id_mem'\u271d, locality' := locality'\u271d,\n        mem_of_eqOnSource' := mem_of_eqOnSource'\u271d }\n\u22a2 { members := members\u271d\u00b9, trans' := trans'\u271d\u00b9, symm' := symm'\u271d\u00b9, id_mem' := id_mem'\u271d\u00b9, locality' := locality'\u271d\u00b9,\n      mem_of_eqOnSource' := mem_of_eqOnSource'\u271d\u00b9 } =\n    { members := members\u271d, trans' := trans'\u271d, symm' := symm'\u271d, id_mem' := id_mem'\u271d, locality' := locality'\u271d,\n      mem_of_eqOnSource' := mem_of_eqOnSource'\u271d }",["congr","aesop"]],["Geometry/Manifold/ChartedSpace.lean",1242,"H : Type u\ninst\u271d\u00b2 : TopologicalSpace H\n\u03b1 : Type u_5\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ne : PartialHomeomorph \u03b1 H\nh : e.source = univ\nG : StructureGroupoid H\ninst\u271d : ClosedUnderRestriction G\ne' e'' : PartialHomeomorph \u03b1 H\nhe' : e' \u2208 atlas H \u03b1\nhe'' : e'' \u2208 atlas H \u03b1\n\u22a2 ClosedUnderRestriction G",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["Geometry/Manifold/ChartedSpace.lean",1216,"H : Type u\nH' : Type u_1\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\n\u03b1 : Type u_5\ninst\u271d : TopologicalSpace \u03b1\ne : PartialHomeomorph \u03b1 H\nh : e.source = univ\nx\u271d : \u03b1\n\u22a2 (fun x \u21a6 e) x\u271d \u2208 {e}",["tauto","aesop","norm_num","simp"]],["Analysis/Analytic/Basic.lean",261,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nx : E\nhx : \u2016x\u2016\u2091 < p.radius\nn : \u2115\n\u22a2 \u2016p n\u2016 * \u220f i : Fin n, \u2016x\u2016 = \u2016p n\u2016 * \u2191\u2016x\u2016\u208a ^ n",["simp","aesop","norm_num"]],["RingTheory/DedekindDomain/Ideal.lean",920,"case e_a\nT : Type u_4\ninst\u271d\u00b9 : CommRing T\ninst\u271d : IsDedekindDomain T\nI J : Ideal T\nhI : I \u2260 \u22a5\nhJ : Irreducible J\nn : \u2115\nhn : emultiplicity J I \u2264 \u2191n\n\u22a2 \u2191n < \u22a4",["simp","aesop","norm_num"]],["RingTheory/DedekindDomain/Ideal.lean",803,"A : Type u_2\ninst\u271d\u00b9 : CommRing A\ninst\u271d : IsDedekindDomain A\nI J : Ideal A\nthis : NormalizedGCDMonoid (Ideal A) := toNormalizedGCDMonoid (Ideal A)\n\u22a2 I \u2264 I \u2294 J \u2227 J \u2264 I \u2294 J",["simp","aesop","norm_num"]],["RingTheory/DedekindDomain/Ideal.lean",1195,"R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDedekindDomain R\ninst\u271d\u00b2 : DecidableEq (Ideal R)\ninst\u271d\u00b9 : DecidableEq (Associates (Ideal R))\ninst\u271d : (p : Associates (Ideal R)) \u2192 Decidable (Irreducible p)\nI J : Ideal R\nhJ : J.IsPrime\nhJ\u2080 : J \u2260 \u22a5\nhI : Associates.mk I \u2260 0\nhJ' : Irreducible (Associates.mk J)\n\u22a2 \u00ac(Associates.mk J).count (Associates.mk I).factors + 1 \u2264 (Associates.mk J).count (Associates.mk I).factors",["omega","aesop","linarith","norm_num","simp"]],["RingTheory/DedekindDomain/Ideal.lean",193,"case mpr.h\nK : Type u_3\ninst\u271d\u2075 : Field K\nR\u2081 : Type u_4\ninst\u271d\u2074 : CommRing R\u2081\ninst\u271d\u00b3 : IsDomain R\u2081\ninst\u271d\u00b2 : Algebra R\u2081 K\ninst\u271d\u00b9 : IsFractionRing R\u2081 K\nI : FractionalIdeal R\u2081\u2070 K\ninst\u271d : (\u2191I).IsPrincipal\nhg : generator \u2191I \u2260 0\nhI : spanSingleton R\u2081\u2070 (generator \u2191I) = 0\nthis : generator \u2191I = 0\n\u22a2 False",["contradiction","aesop","tauto"]],["RingTheory/DedekindDomain/Ideal.lean",429,"case intro.mk.intro.intro.intro.intro.refine_3.intro\nA : Type u_2\nK : Type u_3\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra A K\ninst\u271d\u00b9 : IsFractionRing A K\ninst\u271d : IsDedekindDomain A\nhNF : \u00acIsField A\nI : Ideal A\nhI0\u271d : I \u2260 \u22a5\nhI1 : I \u2260 \u22a4\nhM : I.IsMaximal\nhI0 : \u22a5 < I\na : A\nhaI : a \u2208 I\nha0 : a \u2260 0\nJ : Ideal A := span {a}\nhJ0 : J \u2260 \u22a5\nhJI : J \u2264 I\nZ : Multiset (PrimeSpectrum A)\nhle : (I ::\u2098 Multiset.map PrimeSpectrum.asIdeal Z).prod \u2264 J\nhnle : \u00ac(Multiset.map PrimeSpectrum.asIdeal Z).prod \u2264 J\nb : A\nhbZ : b \u2208 (Multiset.map PrimeSpectrum.asIdeal Z).prod\nhbJ : b \u2209 J\nhnz_fa : (algebraMap A K) a \u2260 0\nx' : A\nh\u2082_abs : (algebraMap A K) (x' * a) = (algebraMap A K) b\nthis : b \u2208 span {a}\n\u22a2 False",["contradiction","aesop","tauto"]],["MeasureTheory/Integral/IntegralEqImproper.lean",1004,"E : Type u_1\nf f' : \u211d \u2192 E\nm n : E\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : CompleteSpace E\nhderiv : \u2200 (x : \u211d), HasDerivAt f (f' x) x\nhf' : Integrable f' volume\nhbot : Tendsto f atBot (\ud835\udcdd m)\nhtop : Tendsto f atTop (\ud835\udcdd n)\n\u22a2 f 0 - m + (n - f 0) = n - m",["abel","aesop","norm_num","simp"]],["Data/Ordmap/Ordset.lean",1435,"case nil\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLE \u03b1\nx : \u03b1\na\u2081 : WithBot \u03b1\na\u2082 : WithTop \u03b1\nh : Valid' a\u2081 nil a\u2082\nh_mem : x \u2208 nil\n\u22a2 (erase x nil).size = nil.size - 1",["contradiction","aesop","congr","tauto"]],["Data/Ordmap/Ordset.lean",587,"case nil.node.nil.node.refl.refl.hc\n\u03b1 : Type u_1\nx : \u03b1\nhl : nil.Balanced\nsl : nil.Sized\nrs : \u2115\nrx rrx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhr : (nil.node' rx (node 1 nil rrx nil)).Balanced\nsr : (node rs nil rx (node 1 nil rrx nil)).Sized\n\u22a2 0 < ratio * 1\n```\n---\n```lean\ncase nil.node.nil.node.refl.refl.hc\n\u03b1 : Type u_1\nx : \u03b1\nhl : nil.Balanced\nsl : nil.Sized\nrs : \u2115\nrx rrx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhr : (nil.node' rx (node 1 nil rrx nil)).Balanced\nsr : (node rs nil rx (node 1 nil rrx nil)).Sized\n\u22a2 0 + 1 + 1 > 0\n```\n---\n```lean\ncase nil.node.nil.node.refl.refl.hnc\n\u03b1 : Type u_1\nx : \u03b1\nhl : nil.Balanced\nsl : nil.Sized\nrs : \u2115\nrx rrx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhr : (nil.node' rx (node 1 nil rrx nil)).Balanced\nsr : (node rs nil rx (node 1 nil rrx nil)).Sized\n\u22a2 \u00ac0 + (0 + 1 + 1) \u2264 1",["decide","tauto"]],["Data/Ordmap/Ordset.lean",595,"case nil.node.node.nil.refl.refl.hnc\n\u03b1 : Type u_1\nx : \u03b1\nhl : nil.Balanced\nsl : nil.Sized\nrs : \u2115\nrx rlx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhr : ((node 1 nil rlx nil).node' rx nil).Balanced\nsr : (node rs (node 1 nil rlx nil) rx nil).Sized\n\u22a2 \u00ac1 < ratio * 0\n```\n---\n```lean\ncase nil.node.node.nil.refl.refl.hc\n\u03b1 : Type u_1\nx : \u03b1\nhl : nil.Balanced\nsl : nil.Sized\nrs : \u2115\nrx rlx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhr : ((node 1 nil rlx nil).node' rx nil).Balanced\nsr : (node rs (node 1 nil rlx nil) rx nil).Sized\n\u22a2 1 + 1 > 0\n```\n---\n```lean\ncase nil.node.node.nil.refl.refl.hnc\n\u03b1 : Type u_1\nx : \u03b1\nhl : nil.Balanced\nsl : nil.Sized\nrs : \u2115\nrx rlx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhr : ((node 1 nil rlx nil).node' rx nil).Balanced\nsr : (node rs (node 1 nil rlx nil) rx nil).Sized\n\u22a2 \u00ac0 + (1 + 1) \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",614,"case node.nil.nil.node.refl.refl.hnc\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nhr : nil.Balanced\nsr : nil.Sized\nlrx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhl : (nil.node' lx (node 1 nil lrx nil)).Balanced\nsl : (node ls nil lx (node 1 nil lrx nil)).Sized\n\u22a2 \u00ac1 < ratio * 0\n```\n---\n```lean\ncase node.nil.nil.node.refl.refl.hc\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nhr : nil.Balanced\nsr : nil.Sized\nlrx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhl : (nil.node' lx (node 1 nil lrx nil)).Balanced\nsl : (node ls nil lx (node 1 nil lrx nil)).Sized\n\u22a2 0 + 1 + 1 > 0\n```\n---\n```lean\ncase node.nil.nil.node.refl.refl.hnc\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nhr : nil.Balanced\nsr : nil.Sized\nlrx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhl : (nil.node' lx (node 1 nil lrx nil)).Balanced\nsl : (node ls nil lx (node 1 nil lrx nil)).Sized\n\u22a2 \u00ac0 + 1 + 1 \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",622,"case node.nil.node.nil.refl.refl.hc\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nhr : nil.Balanced\nsr : nil.Sized\nllx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhl : ((node 1 nil llx nil).node' lx nil).Balanced\nsl : (node ls (node 1 nil llx nil) lx nil).Sized\n\u22a2 0 < ratio * 1\n```\n---\n```lean\ncase node.nil.node.nil.refl.refl.hc\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nhr : nil.Balanced\nsr : nil.Sized\nllx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhl : ((node 1 nil llx nil).node' lx nil).Balanced\nsl : (node ls (node 1 nil llx nil) lx nil).Sized\n\u22a2 1 + 1 > 0\n```\n---\n```lean\ncase node.nil.node.nil.refl.refl.hnc\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nhr : nil.Balanced\nsr : nil.Sized\nllx : \u03b1\nthis : nil.size = 0 \u2227 nil.size = 0\nhl : ((node 1 nil llx nil).node' lx nil).Balanced\nsl : (node ls (node 1 nil llx nil) lx nil).Sized\n\u22a2 \u00ac1 + 1 \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",637,"\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nll : Ordnode \u03b1\nlx : \u03b1\nlr : Ordnode \u03b1\nhl : (node ls ll lx lr).Balanced\nsl : (node ls ll lx lr).Sized\nrs : \u2115\nrx : \u03b1\nrr : Ordnode \u03b1\nh : delta * ls < rs\nhr : (node rs nil rx rr).Balanced\nsr : (node rs nil rx rr).Sized\nrd : delta \u2264 rr.size\n\u22a2 \u00acdelta \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",639,"\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nll : Ordnode \u03b1\nlx : \u03b1\nlr : Ordnode \u03b1\nhl : (node ls ll lx lr).Balanced\nsl : (node ls ll lx lr).Sized\nrs : \u2115\nrx : \u03b1\nh : delta * ls < rs\nrls : \u2115\nrll : Ordnode \u03b1\nrlx : \u03b1\nrlr : Ordnode \u03b1\nhr : (node rs (node rls rll rlx rlr) rx nil).Balanced\nsr : (node rs (node rls rll rlx rlr) rx nil).Sized\nrd : delta \u2264 (node rls rll rlx rlr).size + nil.size\n\u22a2 \u00acdelta \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",648,"\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nlr : Ordnode \u03b1\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : (node rs rl rx rr).Balanced\nsr : (node rs rl rx rr).Sized\nh : \u00acdelta * ls < rs\nh_1 : delta * rs < ls\nhl : (node ls nil lx lr).Balanced\nsl : (node ls nil lx lr).Sized\nld : delta \u2264 lr.size\n\u22a2 \u00acdelta \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",650,"\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : (node rs rl rx rr).Balanced\nsr : (node rs rl rx rr).Sized\nh : \u00acdelta * ls < rs\nh_1 : delta * rs < ls\nlls : \u2115\nlll : Ordnode \u03b1\nllx : \u03b1\nllr : Ordnode \u03b1\nhl : (node ls (node lls lll llx llr) lx nil).Balanced\nsl : (node ls (node lls lll llx llr) lx nil).Sized\nld : delta \u2264 (node lls lll llx llr).size + nil.size\n\u22a2 \u00acdelta \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",1025,"case pos.zero.succ.refl\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx y : \u03b1\nr : Ordnode \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nhr : Valid' (\u2191y) r o\u2082\ns : \u2115\nml : Ordnode \u03b1\nz : \u03b1\nmr : Ordnode \u03b1\nhm : Valid' (\u2191x) (Ordnode.node s ml z mr) \u2191y\nHm : 0 < (Ordnode.node s ml z mr).size\nl0 : 0 < l.size\nmr\u2081 : ratio * r.size \u2264 ml.size + mr.size + 1\nlr\u2081 : delta * l.size \u2264 ml.size + mr.size + (1 + 1)\nlr\u2082 : 3 * (ml.size + mr.size + 1 + r.size) \u2264 16 * l.size + 9\nmr\u2082 : ml.size + mr.size + 1 \u2264 delta * r.size\nr0 : r.size > 0\nr1 : r.size = 1\nl1 : l.size = 1\n\u22a2 BalancedSz 1 0 \u2227 BalancedSz (0 + 1) 1 \u2227 BalancedSz (1 + 0 + 1) (0 + 1 + 1 + 1)",["decide"]],["Data/Ordmap/Ordset.lean",1026,"case pos.succ.zero.refl\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx y : \u03b1\nr : Ordnode \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nhr : Valid' (\u2191y) r o\u2082\ns : \u2115\nml : Ordnode \u03b1\nz : \u03b1\nmr : Ordnode \u03b1\nhm : Valid' (\u2191x) (Ordnode.node s ml z mr) \u2191y\nHm : 0 < (Ordnode.node s ml z mr).size\nl0 : 0 < l.size\nmr\u2081 : ratio * r.size \u2264 ml.size + mr.size + 1\nlr\u2081 : delta * l.size \u2264 ml.size + mr.size + (1 + 1)\nlr\u2082 : 3 * (ml.size + mr.size + 1 + r.size) \u2264 16 * l.size + 9\nmr\u2082 : ml.size + mr.size + 1 \u2264 delta * r.size\nr0 : r.size > 0\nr1 : r.size = 1\nl1 : l.size = 1\n\u22a2 BalancedSz 1 (0 + 1) \u2227 BalancedSz 0 1 \u2227 BalancedSz (1 + (0 + 1) + 1) (0 + 1 + 1)",["decide"]],["Data/Ordmap/Ordset.lean",1031,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx y : \u03b1\nr : Ordnode \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nhr : Valid' (\u2191y) r o\u2082\ns : \u2115\nml : Ordnode \u03b1\nz : \u03b1\nmr : Ordnode \u03b1\nhm : Valid' (\u2191x) (Ordnode.node s ml z mr) \u2191y\nHm : 0 < (Ordnode.node s ml z mr).size\nl0 : 0 < l.size\nmr\u2081 : ratio * r.size \u2264 ml.size + mr.size + 1\nlr\u2081 : delta * l.size \u2264 ml.size + mr.size + 1 + r.size\nlr\u2082 : 3 * (ml.size + mr.size + 1 + r.size) \u2264 16 * l.size + 9\nmr\u2082 : ml.size + mr.size + 1 \u2264 delta * r.size\nr0 : r.size > 0\nmm : \u00ac0 + 0 \u2264 1\nmm\u2081 : ml.size \u2264 delta * mr.size\nmm\u2082 : mr.size = 0\nml0 : ml.size = 0\n\u22a2 0 + 0 \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",1077,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx : \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : Valid' (\u2191x) (Ordnode.node rs rl rx rr) o\u2082\nH1 : \u00acl.size + (Ordnode.node rs rl rx rr).size \u2264 1\nH2 : delta * l.size \u2264 rl.size + rr.size\nH3 : 2 * (rl.size + rr.size) \u2264 9 * l.size + 3 \u2228 rl.size + rr.size \u2264 2\nH3_0 : l.size = 0 \u2192 rl.size + rr.size \u2264 2\nH3p : l.size > 0 \u2192 2 * (rl.size + rr.size) \u2264 9 * l.size + 3\nablem : \u2200 {a b : \u2115}, 1 \u2264 a \u2192 a + b \u2264 2 \u2192 b \u2264 1\nl0 : l.size > 0\nhb : rl.size + rr.size \u2264 1\n\u22a2 \u00acdelta * Nat.succ 0 \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",1089,"case pos.inl.inl\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx : \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : Valid' (\u2191x) (Ordnode.node rs rl rx rr) o\u2082\nH1 : \u00acl.size + (Ordnode.node rs rl rx rr).size \u2264 1\nH2 : delta * l.size \u2264 rl.size + rr.size\nH3_0 : l.size = 0 \u2192 rl.size + rr.size \u2264 2\nH3p : l.size > 0 \u2192 2 * (rl.size + rr.size) \u2264 9 * l.size + 3\nablem : \u2200 {a b : \u2115}, 1 \u2264 a \u2192 a + b \u2264 2 \u2192 b \u2264 1\nhlp : l.size > 0 \u2192 \u00acrl.size + rr.size \u2264 1\nh : rl.size < ratio * rr.size\nrr0 : rr.size > 0\nl0 : l.size = 0\nH3 : rl.size + rr.size \u2264 2\nthis : BalancedSz 0 rr.size\nrl0 : rl.size = 0\n\u22a2 BalancedSz 0 0 \u2227 BalancedSz (0 + 0 + 1) 1",["decide"]],["Data/Ordmap/Ordset.lean",1093,"case pos.inl.inr\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx : \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : Valid' (\u2191x) (Ordnode.node rs rl rx rr) o\u2082\nH1 : \u00acl.size + (Ordnode.node rs rl rx rr).size \u2264 1\nH2 : delta * l.size \u2264 rl.size + rr.size\nH3_0 : l.size = 0 \u2192 rl.size + rr.size \u2264 2\nH3p : l.size > 0 \u2192 2 * (rl.size + rr.size) \u2264 9 * l.size + 3\nablem : \u2200 {a b : \u2115}, 1 \u2264 a \u2192 a + b \u2264 2 \u2192 b \u2264 1\nhlp : l.size > 0 \u2192 \u00acrl.size + rr.size \u2264 1\nh : rl.size < ratio * rr.size\nrr0 : rr.size > 0\nl0 : l.size = 0\nH3 : rr.size + rl.size \u2264 2\nthis : BalancedSz rl.size rr.size\nrl0 : rl.size > 0\nrr1 : rr.size = 1\n\u22a2 BalancedSz 0 1 \u2227 BalancedSz (0 + 1 + 1) 1",["decide"]],["Data/Ordmap/Ordset.lean",1105,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx : \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : Valid' (\u2191x) (Ordnode.node rs rl rx rr) o\u2082\nH1 : \u00acl.size + (Ordnode.node rs rl rx rr).size \u2264 1\nH2 : delta * l.size \u2264 rl.size + rr.size\nH3 : 2 * (rl.size + rr.size) \u2264 9 * l.size + 3 \u2228 rl.size + rr.size \u2264 2\nH3_0 : l.size = 0 \u2192 rl.size + rr.size \u2264 2\nH3p : l.size > 0 \u2192 2 * (rl.size + rr.size) \u2264 9 * l.size + 3\nablem : \u2200 {a b : \u2115}, 1 \u2264 a \u2192 a + b \u2264 2 \u2192 b \u2264 1\nhlp : l.size > 0 \u2192 \u00acrl.size + rr.size \u2264 1\nh : ratio = 0 \u2228 rr.size = 0\nrl0 : rl.size = 0\n\u22a2 \u00acratio = 0",["decide"]],["Data/Ordmap/Ordset.lean",1108,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx : \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : Valid' (\u2191x) (Ordnode.node rs rl rx rr) o\u2082\nH1 : \u00ac0 + (0 + 0 + 1) \u2264 1\nH2 : delta = 0 \u2228 l.size = 0\nH3 : 2 * (rl.size + rr.size) \u2264 9 * l.size + 3 \u2228 rl.size + rr.size \u2264 2\nH3_0 : l.size = 0 \u2192 rl.size + rr.size \u2264 2\nH3p : l.size > 0 \u2192 2 * (rl.size + rr.size) \u2264 9 * l.size + 3\nablem : \u2200 {a b : \u2115}, 1 \u2264 a \u2192 a + b \u2264 2 \u2192 b \u2264 1\nhlp : l.size > 0 \u2192 \u00acrl.size + rr.size \u2264 1\nrl0 : rl.size = 0\nh : rr.size = 0\n\u22a2 0 + (0 + 0 + 1) \u2264 1",["decide"]],["Data/Ordmap/Ordset.lean",1175,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx : \u03b1\nr : Ordnode \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nhr : Valid' (\u2191x) r o\u2082\nH\u2081 : l.size = 0 \u2192 r.size \u2264 1\nH\u2082 : 1 \u2264 l.size \u2192 1 \u2264 r.size \u2192 r.size \u2264 delta * l.size\nH\u2083 : 2 * l.size \u2264 9 * r.size + 5 \u2228 l.size \u2264 3\nr0 : r.size > 0\nl0 : l.size = 0\n\u22a2 2 * 1 \u2264 9 * 0 + 5",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["MeasureTheory/Function/LpSeminorm/Basic.lean",799,"case hz\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : \u211d\u22650\u221e\n\u03bc : Measure \u03b1\ns : Set \u03b1\n\u03b5 : Type u_7\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\nc : \u03b5\nhs : NullMeasurableSet s \u03bc\nhp : p \u2260 0\nhp_top : p \u2260 \u22a4\nhp_pos : 0 < p.toReal\n\u22a2 0 \u2264 1 / p.toReal",["positivity","aesop","norm_num","simp"]],["MeasureTheory/Function/LpSeminorm/Basic.lean",970,"\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : \u211d\u22650\u221e\n\u03bc : Measure \u03b1\n\u03b5 : Type u_8\ninst\u271d : ENorm \u03b5\nhp : p \u2260 \u22a4\nc : \u211d\u22650\nf : \u03b1 \u2192 \u03b5\n\u22a2 0 \u2264 p.toReal\u207b\u00b9",["positivity","aesop","norm_num","simp"]],["Analysis/InnerProductSpace/Projection.lean",342,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\nu v : E\nhv : v \u2208 K\nthis\u271d : InnerProductSpace \u211d E := rclikeToReal \ud835\udd5c E\nthis : Module \u211d E := RestrictScalars.module \u211d \ud835\udd5c E\nK' : Submodule \u211d E := Submodule.restrictScalars \u211d K\nH : \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016\nA : \u2200 w \u2208 K, re \u27eau - v, w\u27eb_\ud835\udd5c = 0\nw : E\nhw : w \u2208 K\n\u22a2 re (-I * \u27eau - v, w\u27eb_\ud835\udd5c) = im \u27eau - v, w\u27eb_\ud835\udd5c",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/Projection.lean",1010,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d : HasOrthogonalProjection K\nw : E\n\u22a2 \u2191((orthogonalProjection K) w) + \u2191((orthogonalProjection K\u15ee) w) = w",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/Projection.lean",603,"case pos\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nv w : E\nhv : v = 0\n\u22a2 \u2191((orthogonalProjection \u22a5) w) = (\u27ea0, w\u27eb_\ud835\udd5c / \u2191(\u20160\u2016 ^ 2)) \u2022 0",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/Projection.lean",255,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nh\u271d : Convex \u211d K\nu v : F\nhv : v \u2208 K\nthis\u271d : Nonempty \u2191K := Nonempty.intro \u27e8v, hv\u27e9\nh : \u2200 w \u2208 K, \u27eau - v, w - v\u27eb_\u211d \u2264 0\nw : \u2191K\nthis : \u27eau - v, \u2191w - v\u27eb_\u211d \u2264 0\n\u22a2 u - v - (\u2191w - v) = u - \u2191w",["abel","aesop","norm_num","simp"]],["Analysis/InnerProductSpace/Projection.lean",224,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nh : Convex \u211d K\nu v : F\nhv : v \u2208 K\nthis\u271d : Nonempty \u2191K := Nonempty.intro \u27e8v, hv\u27e9\neq : \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016\nw : F\nhw : w \u2208 K\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\np : \u211d := \u27eau - v, w - v\u27eb_\u211d\nq : \u211d := \u2016w - v\u2016 ^ 2\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nthis : \u2200 (\u03b8 : \u211d), 0 < \u03b8 \u2192 \u03b8 \u2264 1 \u2192 2 * p \u2264 \u03b8 * 0\nhq : q = 0\n\u22a2 1 \u2264 1",["norm_num","aesop","linarith","tauto","simp"]],["Analysis/InnerProductSpace/Projection.lean",1317,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nv : Set E\nhv : Orthonormal \ud835\udd5c Subtype.val\nx : E\nhx' : x \u2208 (span \ud835\udd5c v)\u15ee\nhx : x \u2260 0\ne : E := (\u2191\u2016x\u2016)\u207b\u00b9 \u2022 x\nhe : \u2016e\u2016 = 1\nhe' : e \u2208 (span \ud835\udd5c v)\u15ee\nhev : e \u2208 v\nthis\u271d : e = 0\nthis : e \u2260 0\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/BigOperators/Group/Finset/Basic.lean",595,"case neg.hnc\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nb : (x : \u03b1) \u2192 a = x \u2192 \u03b2\nh : a \u2209 s\na\u271d : a \u2208 s\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/BigOperators/Group/Finset/Basic.lean",610,"case neg.hnc\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nx\u271d : \u03b1\na\u271d : x\u271d \u2208 s\nb : (x : \u03b1) \u2192 x = x\u271d \u2192 \u03b2\nh : x\u271d \u2209 s\n\u22a2 False",["contradiction","aesop","tauto"]],["MeasureTheory/Measure/MeasureSpace.lean",766,"\u03b1 : Type u_1\nms : MeasurableSpace \u03b1\nh : ms \u2264 OuterMeasure.caratheodory 0\n\u22a2 OuterMeasure.toMeasure 0 h = 0",["simp","aesop","norm_num"]],["Analysis/NormedSpace/Multilinear/Basic.lean",979,"case H\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u00b3 : Fintype \u03b9'\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2077 : SeminormedAddCommGroup G\ninst\u271d\u2076 : NormedSpace \ud835\udd5c G\ninst\u271d\u2075 : SeminormedAddCommGroup G'\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G'\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u00b9 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\nf : MultilinearMap \ud835\udd5c E (MultilinearMap \ud835\udd5c E' G)\nC : \u211d\nH : \u2200 (m\u2081 : (i : \u03b9) \u2192 E i) (m\u2082 : (i : \u03b9') \u2192 E' i), \u2016(f m\u2081) m\u2082\u2016 \u2264 (C * \u220f i : \u03b9, \u2016m\u2081 i\u2016) * \u220f i : \u03b9', \u2016m\u2082 i\u2016\ninst\u271d : DecidableEq \u03b9\nm : (i : \u03b9) \u2192 E i\ni : \u03b9\nx y : E i\nx\u271d : (i : \u03b9') \u2192 E' i\n\u22a2 ((fun m \u21a6 (f m).mkContinuous (C * \u220f i : \u03b9, \u2016m i\u2016) \u22ef) (update m i (x + y))) x\u271d =\n    ((fun m \u21a6 (f m).mkContinuous (C * \u220f i : \u03b9, \u2016m i\u2016) \u22ef) (update m i x) +\n        (fun m \u21a6 (f m).mkContinuous (C * \u220f i : \u03b9, \u2016m i\u2016) \u22ef) (update m i y))\n      x\u271d",["simp","aesop","norm_num"]],["Analysis/NormedSpace/Multilinear/Basic.lean",226,"case pos\n\ud835\udd5c : Type u\n\u03b9 : Type v\nE : \u03b9 \u2192 Type wE\nG : Type wG\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : MultilinearMap \ud835\udd5c E G\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (s.piecewise m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i \u2208 s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else \u2016m\u2081 j\u2016 \u2294 \u2016m\u2082 j\u2016\nA : (insert i s).piecewise m\u2082 m\u2081 = update (s.piecewise m\u2082 m\u2081) i (m\u2082 i)\nB : s.piecewise m\u2082 m\u2081 = update (s.piecewise m\u2082 m\u2081) i (m\u2081 i)\nj : \u03b9\na\u271d : j \u2208 univ\nh : j = i\n\u22a2 \u2016update (s.piecewise m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) i\u2016 \u2264 if i = i then \u2016m\u2081 i - m\u2082 i\u2016 else \u2016m\u2081 i\u2016 \u2294 \u2016m\u2082 i\u2016",["simp","norm_num"]],["Analysis/NormedSpace/Multilinear/Basic.lean",833,"\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2070 : Fintype \u03b9'\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\ninst\u271d : Fintype \u03b9\nz : G\n\u22a2 (fun f \u21a6 f fun x \u21a6 1)\n      ({ toFun := fun z \u21a6 ContinuousMultilinearMap.mkPiRing \ud835\udd5c \u03b9 z, map_add' := \u22ef, map_smul' := \u22ef }.toFun z) =\n    z",["simp","aesop","norm_num"]],["Analysis/NormedSpace/Multilinear/Basic.lean",240,"case h.e'_3.h.e'_3.h.e'_6.h.e'_6\n\ud835\udd5c : Type u\n\u03b9 : Type v\nE : \u03b9 \u2192 Type wE\nG : Type wG\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : MultilinearMap \ud835\udd5c E G\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\nA :\n  \u2200 (s : Finset \u03b9),\n    \u2016f m\u2081 - f (s.piecewise m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i \u2208 s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else \u2016m\u2081 j\u2016 \u2294 \u2016m\u2082 j\u2016\n\u22a2 m\u2082 = univ.piecewise m\u2082 m\u2081",["simp","aesop","norm_num"]],["Analysis/NormedSpace/Multilinear/Basic.lean",771,"case succ\n\ud835\udd5c : Type u\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nA : Type u_1\ninst\u271d\u00b2 : SeminormedRing A\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c A\ninst\u271d : NormOneClass A\nn\u271d : \u2115\n\u22a2 1 = \u2016(ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c n\u271d.succ A) fun x \u21a6 1\u2016 / \u220f i : Fin n\u271d.succ, \u20161\u2016",["simp","aesop","norm_num"]],["Probability/Independence/Kernel.lean",792,"\u03b1 : Type u_1\n\u03a9 : Type u_2\n\u03b9 : Type u_3\n_m\u03b1 : MeasurableSpace \u03b1\n_m\u03a9 : MeasurableSpace \u03a9\n\u03ba : Kernel \u03b1 \u03a9\n\u03bc : Measure \u03b1\nf : \u03b9 \u2192 Set \u03a9\nh : iIndepSet f \u03ba \u03bc\ns : Finset \u03b9\n\u22a2 \u2200 i \u2208 s, f i \u2208 {f i}",["simp","aesop","tauto","norm_num"]],["Probability/Independence/Kernel.lean",987,"\u03b1 : Type u_1\n\u03a9 : Type u_2\n\u03b9 : Type u_3\n_m\u03b1 : MeasurableSpace \u03b1\n_m\u03a9 : MeasurableSpace \u03a9\n\u03ba : Kernel \u03b1 \u03a9\n\u03bc : Measure \u03b1\n\u03b2 : \u03b9 \u2192 Type u_8\nm : (i : \u03b9) \u2192 MeasurableSpace (\u03b2 i)\nf : (i : \u03b9) \u2192 \u03a9 \u2192 \u03b2 i\nS T : Finset \u03b9\nhST : Disjoint S T\nhf_Indep : iIndepFun f \u03ba \u03bc\nhf_meas : \u2200 (i : \u03b9), Measurable (f i)\nh\u03bc : \u03bc \u2260 0\n\u03b7 : Kernel \u03b1 \u03a9\n\u03b7_eq : \u21d1\u03ba =\u1da0[ae \u03bc] \u21d1\u03b7\nh\u03b7 : IsMarkovKernel \u03b7\n\u03c0S\u03b2 : Set (Set ((i : { x // x \u2208 S }) \u2192 \u03b2 \u2191i)) := univ.pi '' univ.pi fun i \u21a6 {s | MeasurableSet s}\n\u03c0S : Set (Set \u03a9) := {s | \u2203 t \u2208 \u03c0S\u03b2, (fun a i \u21a6 f (\u2191i) a) \u207b\u00b9' t = s}\nh\u03c0S_pi : IsPiSystem \u03c0S\n\u22a2 generateFrom ((preimage fun a i \u21a6 f (\u2191i) a) '' (univ.pi '' univ.pi fun i \u21a6 {s | MeasurableSet s})) = generateFrom \u03c0S",["congr","tauto"]],["Probability/Independence/Kernel.lean",994,"\u03b1 : Type u_1\n\u03a9 : Type u_2\n\u03b9 : Type u_3\n_m\u03b1 : MeasurableSpace \u03b1\n_m\u03a9 : MeasurableSpace \u03a9\n\u03ba : Kernel \u03b1 \u03a9\n\u03bc : Measure \u03b1\n\u03b2 : \u03b9 \u2192 Type u_8\nm : (i : \u03b9) \u2192 MeasurableSpace (\u03b2 i)\nf : (i : \u03b9) \u2192 \u03a9 \u2192 \u03b2 i\nS T : Finset \u03b9\nhST : Disjoint S T\nhf_Indep : iIndepFun f \u03ba \u03bc\nhf_meas : \u2200 (i : \u03b9), Measurable (f i)\nh\u03bc : \u03bc \u2260 0\n\u03b7 : Kernel \u03b1 \u03a9\n\u03b7_eq : \u21d1\u03ba =\u1da0[ae \u03bc] \u21d1\u03b7\nh\u03b7 : IsMarkovKernel \u03b7\n\u03c0S\u03b2 : Set (Set ((i : { x // x \u2208 S }) \u2192 \u03b2 \u2191i)) := univ.pi '' univ.pi fun i \u21a6 {s | MeasurableSet s}\n\u03c0S : Set (Set \u03a9) := {s | \u2203 t \u2208 \u03c0S\u03b2, (fun a i \u21a6 f (\u2191i) a) \u207b\u00b9' t = s}\nh\u03c0S_pi : IsPiSystem \u03c0S\nh\u03c0S_gen : MeasurableSpace.comap (fun a i \u21a6 f (\u2191i) a) MeasurableSpace.pi = generateFrom \u03c0S\n\u03c0T\u03b2 : Set (Set ((i : { x // x \u2208 T }) \u2192 \u03b2 \u2191i)) := univ.pi '' univ.pi fun i \u21a6 {s | MeasurableSet s}\n\u03c0T : Set (Set \u03a9) := {s | \u2203 t \u2208 \u03c0T\u03b2, (fun a i \u21a6 f (\u2191i) a) \u207b\u00b9' t = s}\nh\u03c0T_pi : IsPiSystem \u03c0T\n\u22a2 generateFrom ((preimage fun a i \u21a6 f (\u2191i) a) '' (univ.pi '' univ.pi fun i \u21a6 {s | MeasurableSet s})) = generateFrom \u03c0T",["congr","tauto"]],["Analysis/Analytic/Composition.lean",468,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nq : FormalMultilinearSeries \ud835\udd5c F G\np : FormalMultilinearSeries \ud835\udd5c E F\nhq : 0 < q.radius\nhp : 0 < p.radius\nrq rp : \u211d\u22650\nhrp : rp < 1 \u2227 \u2191rp < p.radius\nhrq : rq < 1 \u2227 \u2191rq < q.radius\nrp_pos : 0 < rp\nrq_pos : 0 < rq\nCq : \u211d\u22650\n_hCq0 : Cq > 0\nhCq : \u2200 (n : \u2115), \u2016q n\u2016\u208a * rq ^ n \u2264 Cq\nCp : \u211d\u22650\nhCp1 : Cp \u2265 1\nhCp : \u2200 (n : \u2115), \u2016p n\u2016\u208a * rp ^ n \u2264 Cp\nr0 : \u211d\u22650 := (4 * Cp)\u207b\u00b9\nr0_pos : 0 < r0\nr : \u211d\u22650 := rp * rq * r0\nr_pos : 0 < r\nn : \u2115\nc : Composition n\nA : \u2016q c.length\u2016\u208a * rq ^ n \u2264 Cq\n\u22a2 \u220f _i : Fin c.length, Cp = Cp ^ c.length",["simp","aesop","norm_num"]],["Analysis/Analytic/Composition.lean",304,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nn : \u2115\np : FormalMultilinearSeries \ud835\udd5c E F\nc : Composition n\nf : ContinuousMultilinearMap \ud835\udd5c (fun i \u21a6 F) G\nv : Fin n \u2192 E\n\u22a2 (\u2016f\u2016 * \u220f i : Fin c.length, \u2016p (c.blocksFun i)\u2016) *\n      \u220f i : Fin c.length, \u220f j : Fin (c.blocksFun i), \u2016(v \u2218 \u21d1(c.embedding i)) j\u2016 =\n    (\u2016f\u2016 * \u220f i : Fin c.length, \u2016p (c.blocksFun i)\u2016) *\n      \u220f a : Fin c.length, \u220f s : Fin (c.blocksFun a), \u2016v (c.blocksFinEquiv \u27e8a, s\u27e9)\u2016",["congr","aesop","tauto","abel"]],["Topology/ContinuousMap/Bounded/Basic.lean",1049,"case h.e'_3.h.e'_4\nF : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\ud835\udd5c : Type u_2\ninst\u271d\u2076 : PseudoMetricSpace \ud835\udd5c\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PseudoMetricSpace \u03b2\ninst\u271d\u00b3 : Zero \ud835\udd5c\ninst\u271d\u00b2 : Zero \u03b2\ninst\u271d\u00b9 : SMul \ud835\udd5c \u03b2\ninst\u271d : IsBoundedSMul \ud835\udd5c \u03b2\nc\u2081 c\u2082 : \ud835\udd5c\nf : \u03b1 \u2192\u1d47 \u03b2\nx : \u03b1\n\u22a2 0 = 0 x",["simp","aesop","congr","tauto","norm_num"]],["Topology/ContinuousMap/Bounded/Basic.lean",71,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b2\ninst\u271d : PseudoMetricSpace \u03b3\nf g : \u03b1 \u2192\u1d47 \u03b2\nx : \u03b1\nC : \u211d\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d\u00b9 : Continuous toFun\u271d\u00b9\nmap_bounded'\u271d\u00b9 :\n  \u2203 C,\n    \u2200 (x y : \u03b1),\n      dist ({ toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun x)\n          ({ toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun y) \u2264\n        C\ntoFun\u271d : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d : Continuous toFun\u271d\nmap_bounded'\u271d :\n  \u2203 C,\n    \u2200 (x y : \u03b1),\n      dist ({ toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }.toFun x)\n          ({ toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }.toFun y) \u2264\n        C\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, map_bounded' := map_bounded'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, map_bounded' := map_bounded'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, map_bounded' := map_bounded'\u271d\u00b9 } =\n    { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, map_bounded' := map_bounded'\u271d }",["congr","aesop"]],["Data/Seq/WSeq.lean",1078,"\u03b1 : Type u\na : \u03b1\nl : List \u03b1\n\u22a2 Seq.map some \u2191(a :: l) = Seq.cons (some a) (Seq.map some \u2191l)",["simp","aesop"]],["Data/Seq/WSeq.lean",728,"case intro.intro.intro.intro.none\n\u03b1 : Type u\ns : WSeq \u03b1\na : \u03b1 \u00d7 WSeq \u03b1\nt : WSeq \u03b1\nht' : none \u2208 s.destruct\nht2 : Option.rec nil Prod.snd none = t\ntd : some a \u2208 Computation.pure none\nthis : some a = none\n\u22a2 \u2203 a', some a' \u2208 s.destruct",["contradiction","aesop","tauto"]],["Analysis/Seminorm.lean",113,"case mk.mk.mk.mk\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\n\u03b9 : Type u_11\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9 : AddGroup E\ninst\u271d : SMul \ud835\udd5c E\ntoFun\u271d\u00b9 : E \u2192 \u211d\nmap_zero'\u271d\u00b9 : toFun\u271d\u00b9 0 = 0\nadd_le'\u271d\u00b9 : \u2200 (r s : E), toFun\u271d\u00b9 (r + s) \u2264 toFun\u271d\u00b9 r + toFun\u271d\u00b9 s\nneg'\u271d\u00b9 : \u2200 (r : E), toFun\u271d\u00b9 (-r) = toFun\u271d\u00b9 r\nsmul'\u271d\u00b9 :\n  \u2200 (a : \ud835\udd5c) (x : E),\n    { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, add_le' := add_le'\u271d\u00b9, neg' := neg'\u271d\u00b9 }.toFun (a \u2022 x) =\n      \u2016a\u2016 * { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, add_le' := add_le'\u271d\u00b9, neg' := neg'\u271d\u00b9 }.toFun x\ntoFun\u271d : E \u2192 \u211d\nmap_zero'\u271d : toFun\u271d 0 = 0\nadd_le'\u271d : \u2200 (r s : E), toFun\u271d (r + s) \u2264 toFun\u271d r + toFun\u271d s\nneg'\u271d : \u2200 (r : E), toFun\u271d (-r) = toFun\u271d r\nsmul'\u271d :\n  \u2200 (a : \ud835\udd5c) (x : E),\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d, add_le' := add_le'\u271d, neg' := neg'\u271d }.toFun (a \u2022 x) =\n      \u2016a\u2016 * { toFun := toFun\u271d, map_zero' := map_zero'\u271d, add_le' := add_le'\u271d, neg' := neg'\u271d }.toFun x\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, add_le' := add_le'\u271d\u00b9, neg' := neg'\u271d\u00b9, smul' := smul'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, map_zero' := map_zero'\u271d, add_le' := add_le'\u271d, neg' := neg'\u271d, smul' := smul'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, add_le' := add_le'\u271d\u00b9, neg' := neg'\u271d\u00b9, smul' := smul'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d, add_le' := add_le'\u271d, neg' := neg'\u271d, smul' := smul'\u271d }",["congr","aesop"]],["Topology/Algebra/Group/Basic.lean",782,"G : Type w\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\nx : G\n\u22a2 map (fun x_1 \u21a6 x_1 * x) (\ud835\udcdd 1) = \ud835\udcdd x",["simp"]],["Order/UpperLower/Basic.lean",1214,"case h\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ns : Set \u03b1\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191(upperClosure s) \u2194 x\u271d \u2208 \u22c3 a \u2208 s, Ici a",["simp","aesop"]],["Order/UpperLower/Basic.lean",733,"\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 LowerSet \u03b1\n\u22a2 a \u2208 \u2a05 i, \u2a05 j, f i j \u2194 \u2200 (i : \u03b9) (j : \u03ba i), a \u2208 f i j",["simp","aesop"]],["Order/UpperLower/Basic.lean",967,"case h.h.a.h\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nx\u271d\u00b9 : LowerSet \u03b1\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191((map (OrderIso.refl \u03b1)) x\u271d\u00b9) \u2194 x\u271d \u2208 \u2191((OrderIso.refl (LowerSet \u03b1)) x\u271d\u00b9)",["simp","aesop"]],["Order/UpperLower/Basic.lean",928,"case h.h.a.h\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nx\u271d\u00b9 : UpperSet \u03b1\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191((map (OrderIso.refl \u03b1)) x\u271d\u00b9) \u2194 x\u271d \u2208 \u2191((OrderIso.refl (UpperSet \u03b1)) x\u271d\u00b9)",["simp","aesop"]],["Order/UpperLower/Basic.lean",557,"\u03b1 : Type u_1\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 UpperSet \u03b1\n\u22a2 \u2191(\u2a06 i, \u2a06 j, f i j) = \u22c2 i, \u22c2 j, \u2191(f i j)",["simp","aesop"]],["Order/UpperLower/Basic.lean",933,"case a.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\ns : UpperSet \u03b1\ng : \u03b2 \u2243o \u03b3\nf : \u03b1 \u2243o \u03b2\nx\u271d : \u03b3\n\u22a2 x\u271d \u2208 \u2191((map g) ((map f) s)) \u2194 x\u271d \u2208 \u2191((map (f.trans g)) s)",["simp","aesop"]],["Order/UpperLower/Basic.lean",1036,"case a.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 \u2191((map f) (Ici a)) \u2194 x\u271d \u2208 \u2191(Ici (f a))",["simp","aesop"]],["Order/UpperLower/Basic.lean",426,"case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\ncarrier\u271d\u00b9 : Set \u03b1\nupper'\u271d\u00b9 : IsUpperSet carrier\u271d\u00b9\ncarrier\u271d : Set \u03b1\nupper'\u271d : IsUpperSet carrier\u271d\nh : { carrier := carrier\u271d\u00b9, upper' := upper'\u271d\u00b9 }.carrier = { carrier := carrier\u271d, upper' := upper'\u271d }.carrier\n\u22a2 { carrier := carrier\u271d\u00b9, upper' := upper'\u271d\u00b9 } = { carrier := carrier\u271d, upper' := upper'\u271d }",["congr","aesop"]],["Order/UpperLower/Basic.lean",452,"case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\ncarrier\u271d\u00b9 : Set \u03b1\nlower'\u271d\u00b9 : IsLowerSet carrier\u271d\u00b9\ncarrier\u271d : Set \u03b1\nlower'\u271d : IsLowerSet carrier\u271d\nh : { carrier := carrier\u271d\u00b9, lower' := lower'\u271d\u00b9 }.carrier = { carrier := carrier\u271d, lower' := lower'\u271d }.carrier\n\u22a2 { carrier := carrier\u271d\u00b9, lower' := lower'\u271d\u00b9 } = { carrier := carrier\u271d, lower' := lower'\u271d }",["congr","aesop"]],["Order/UpperLower/Basic.lean",166,"\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : Set \u03b1\nhs : IsUpperSet s\nht : IsLowerSet t\n\u22a2 \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t",["aesop","tauto"]],["Order/UpperLower/Basic.lean",169,"\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : Set \u03b1\nhs : IsLowerSet s\nht : IsUpperSet t\n\u22a2 \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t",["aesop","tauto"]],["Order/Hom/Lattice.lean",1770,"case h\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b2\ninst\u271d : Lattice \u03b3\nf : LatticeHom \u03b2 \u03b3\ng : LatticeHom \u03b1 \u03b2\na\u271d : WithTop (WithBot \u03b1)\n\u22a2 (f.comp g).withTopWithBot a\u271d = (f.withTopWithBot.comp g.withTopWithBot) a\u271d",["simp","aesop","infer_instance"]],["Order/Hom/Lattice.lean",679,"F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u00b2 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b9 : Min \u03b1\ninst\u271d : SemilatticeInf \u03b2\nP : \u03b2 \u2192 Prop\nPinf : \u2200 \u2983x y : \u03b2\u2984, P x \u2192 P y \u2192 P (x \u2293 y)\nthis : SemilatticeInf { x // P x } := Subtype.semilatticeInf Pinf\n\u22a2 \u2200 (a b : { x // P x }), \u2191(a \u2293 b) = \u2191a \u2293 \u2191b",["simp","aesop"]],["Order/Hom/Lattice.lean",354,"case mk.mk\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Max \u03b1\ninst\u271d\u00b2 : Max \u03b2\ninst\u271d\u00b9 : Max \u03b3\ninst\u271d : Max \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_sup'\u271d\u00b9 : \u2200 (a b : \u03b1), toFun\u271d\u00b9 (a \u2294 b) = toFun\u271d\u00b9 a \u2294 toFun\u271d\u00b9 b\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_sup'\u271d : \u2200 (a b : \u03b1), toFun\u271d (a \u2294 b) = toFun\u271d a \u2294 toFun\u271d b\nh : { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, map_sup' := map_sup'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9 } = { toFun := toFun\u271d, map_sup' := map_sup'\u271d }",["congr","aesop"]],["Order/Hom/Lattice.lean",530,"case mk.mk\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Min \u03b1\ninst\u271d\u00b2 : Min \u03b2\ninst\u271d\u00b9 : Min \u03b3\ninst\u271d : Min \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_inf'\u271d\u00b9 : \u2200 (a b : \u03b1), toFun\u271d\u00b9 (a \u2293 b) = toFun\u271d\u00b9 a \u2293 toFun\u271d\u00b9 b\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_inf'\u271d : \u2200 (a b : \u03b1), toFun\u271d (a \u2293 b) = toFun\u271d a \u2293 toFun\u271d b\nh : { toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, map_inf' := map_inf'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9 } = { toFun := toFun\u271d, map_inf' := map_inf'\u271d }",["congr","aesop"]],["Order/Hom/Lattice.lean",712,"case mk.mk.mk.mk\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : Max \u03b1\ninst\u271d\u2076 : Bot \u03b1\ninst\u271d\u2075 : Max \u03b2\ninst\u271d\u2074 : Bot \u03b2\ninst\u271d\u00b3 : Max \u03b3\ninst\u271d\u00b2 : Bot \u03b3\ninst\u271d\u00b9 : Max \u03b4\ninst\u271d : Bot \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_sup'\u271d\u00b9 : \u2200 (a b : \u03b1), toFun\u271d\u00b9 (a \u2294 b) = toFun\u271d\u00b9 a \u2294 toFun\u271d\u00b9 b\nmap_bot'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9 }.toFun \u22a5 = \u22a5\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_sup'\u271d : \u2200 (a b : \u03b1), toFun\u271d (a \u2294 b) = toFun\u271d a \u2294 toFun\u271d b\nmap_bot'\u271d : { toFun := toFun\u271d, map_sup' := map_sup'\u271d }.toFun \u22a5 = \u22a5\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9, map_bot' := map_bot'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, map_sup' := map_sup'\u271d, map_bot' := map_bot'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9, map_bot' := map_bot'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_sup' := map_sup'\u271d, map_bot' := map_bot'\u271d }",["congr","aesop"]],["Order/Hom/Lattice.lean",863,"case mk.mk.mk.mk\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : Min \u03b1\ninst\u271d\u2076 : Top \u03b1\ninst\u271d\u2075 : Min \u03b2\ninst\u271d\u2074 : Top \u03b2\ninst\u271d\u00b3 : Min \u03b3\ninst\u271d\u00b2 : Top \u03b3\ninst\u271d\u00b9 : Min \u03b4\ninst\u271d : Top \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_inf'\u271d\u00b9 : \u2200 (a b : \u03b1), toFun\u271d\u00b9 (a \u2293 b) = toFun\u271d\u00b9 a \u2293 toFun\u271d\u00b9 b\nmap_top'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9 }.toFun \u22a4 = \u22a4\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_inf'\u271d : \u2200 (a b : \u03b1), toFun\u271d (a \u2293 b) = toFun\u271d a \u2293 toFun\u271d b\nmap_top'\u271d : { toFun := toFun\u271d, map_inf' := map_inf'\u271d }.toFun \u22a4 = \u22a4\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9, map_top' := map_top'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, map_inf' := map_inf'\u271d, map_top' := map_top'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9, map_top' := map_top'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_inf' := map_inf'\u271d, map_top' := map_top'\u271d }",["congr","aesop"]],["Order/Hom/Lattice.lean",1007,"case mk.mk.mk.mk\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : Lattice \u03b3\ninst\u271d : Lattice \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_sup'\u271d\u00b9 : \u2200 (a b : \u03b1), toFun\u271d\u00b9 (a \u2294 b) = toFun\u271d\u00b9 a \u2294 toFun\u271d\u00b9 b\nmap_inf'\u271d\u00b9 :\n  \u2200 (a b : \u03b1),\n    { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9 }.toFun (a \u2293 b) =\n      { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9 }.toFun a \u2293 { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9 }.toFun b\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_sup'\u271d : \u2200 (a b : \u03b1), toFun\u271d (a \u2294 b) = toFun\u271d a \u2294 toFun\u271d b\nmap_inf'\u271d :\n  \u2200 (a b : \u03b1),\n    { toFun := toFun\u271d, map_sup' := map_sup'\u271d }.toFun (a \u2293 b) =\n      { toFun := toFun\u271d, map_sup' := map_sup'\u271d }.toFun a \u2293 { toFun := toFun\u271d, map_sup' := map_sup'\u271d }.toFun b\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, map_sup' := map_sup'\u271d, map_inf' := map_inf'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_sup' := map_sup'\u271d, map_inf' := map_inf'\u271d }",["congr","aesop"]],["Order/Hom/Lattice.lean",1185,"case mk.mk.mk.mk.mk.mk\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : Lattice \u03b1\ninst\u271d\u2076 : Lattice \u03b2\ninst\u271d\u2075 : Lattice \u03b3\ninst\u271d\u2074 : Lattice \u03b4\ninst\u271d\u00b3 : BoundedOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b2\ninst\u271d\u00b9 : BoundedOrder \u03b3\ninst\u271d : BoundedOrder \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_sup'\u271d\u00b9 : \u2200 (a b : \u03b1), toFun\u271d\u00b9 (a \u2294 b) = toFun\u271d\u00b9 a \u2294 toFun\u271d\u00b9 b\nmap_inf'\u271d\u00b9 :\n  \u2200 (a b : \u03b1),\n    { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9 }.toFun (a \u2293 b) =\n      { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9 }.toFun a \u2293 { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9 }.toFun b\nmap_top'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9 }.toFun \u22a4 = \u22a4\nmap_bot'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9 }.toFun \u22a5 = \u22a5\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_sup'\u271d : \u2200 (a b : \u03b1), toFun\u271d (a \u2294 b) = toFun\u271d a \u2294 toFun\u271d b\nmap_inf'\u271d :\n  \u2200 (a b : \u03b1),\n    { toFun := toFun\u271d, map_sup' := map_sup'\u271d }.toFun (a \u2293 b) =\n      { toFun := toFun\u271d, map_sup' := map_sup'\u271d }.toFun a \u2293 { toFun := toFun\u271d, map_sup' := map_sup'\u271d }.toFun b\nmap_top'\u271d : { toFun := toFun\u271d, map_sup' := map_sup'\u271d, map_inf' := map_inf'\u271d }.toFun \u22a4 = \u22a4\nmap_bot'\u271d : { toFun := toFun\u271d, map_sup' := map_sup'\u271d, map_inf' := map_inf'\u271d }.toFun \u22a5 = \u22a5\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9, map_top' := map_top'\u271d\u00b9,\n        map_bot' := map_bot'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d, map_sup' := map_sup'\u271d, map_inf' := map_inf'\u271d, map_top' := map_top'\u271d, map_bot' := map_bot'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_sup' := map_sup'\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9, map_top' := map_top'\u271d\u00b9, map_bot' := map_bot'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_sup' := map_sup'\u271d, map_inf' := map_inf'\u271d, map_top' := map_top'\u271d, map_bot' := map_bot'\u271d }",["congr","aesop"]],["Topology/Compactness/Compact.lean",517,"X : Type u\ninst\u271d : TopologicalSpace X\nb : Set (Set X)\nhb : IsTopologicalBasis b\nU : Set X\nhUc : IsCompact U\nhUo : IsOpen U\n\u22a2 b = range fun i \u21a6 \u2191i",["simp","aesop"]],["Topology/Compactness/Compact.lean",491,"case intro.intro.intro\nX : Type u\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Nonempty \u03b9\nV : \u03b9 \u2192 Set X\nhV : Directed (fun x1 x2 \u21a6 x1 \u2287 x2) V\nhV_cpct : \u2200 (i : \u03b9), IsCompact (V i)\nhV_closed : \u2200 (i : \u03b9), IsClosed (V i)\nU : Set X\nhU : \u2200 x \u2208 \u22c2 i, V i, U \u2208 \ud835\udcdd x\nW : Set X\nhsubW : \u22c2 i, V i \u2286 W\nW_op : IsOpen W\nhWU : W \u2286 U\nH : \u2200 (i : \u03b9), (V i \u2229 W\u1d9c).Nonempty\nthis\u271d : (\u22c2 i, V i \u2229 W\u1d9c).Nonempty\nthis : \u00ac\u22c2 i, V i \u2286 W\n\u22a2 False",["contradiction","aesop","tauto"]],["Topology/Compactness/Compact.lean",489,"case intro.intro.refine_1\nX : Type u\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Nonempty \u03b9\nV : \u03b9 \u2192 Set X\nhV : Directed (fun x1 x2 \u21a6 x1 \u2287 x2) V\nhV_cpct : \u2200 (i : \u03b9), IsCompact (V i)\nhV_closed : \u2200 (i : \u03b9), IsClosed (V i)\nU : Set X\nhU : \u2200 x \u2208 \u22c2 i, V i, U \u2208 \ud835\udcdd x\nW : Set X\nhsubW : \u22c2 i, V i \u2286 W\nW_op : IsOpen W\nhWU : W \u2286 U\nH : \u2200 (i : \u03b9), (V i \u2229 W\u1d9c).Nonempty\ni j k : \u03b9\nhki : V i \u2287 V k\nhkj : V j \u2287 V k\nx : X\n\u22a2 x \u2208 V k \u2192 x \u2209 W \u2192 x \u2208 V i \u2227 x \u2209 W\n```\n---\n```lean\ncase intro.intro.refine_2\nX : Type u\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Nonempty \u03b9\nV : \u03b9 \u2192 Set X\nhV : Directed (fun x1 x2 \u21a6 x1 \u2287 x2) V\nhV_cpct : \u2200 (i : \u03b9), IsCompact (V i)\nhV_closed : \u2200 (i : \u03b9), IsClosed (V i)\nU : Set X\nhU : \u2200 x \u2208 \u22c2 i, V i, U \u2208 \ud835\udcdd x\nW : Set X\nhsubW : \u22c2 i, V i \u2286 W\nW_op : IsOpen W\nhWU : W \u2286 U\nH : \u2200 (i : \u03b9), (V i \u2229 W\u1d9c).Nonempty\ni j k : \u03b9\nhki : V i \u2287 V k\nhkj : V j \u2287 V k\nx : X\n\u22a2 x \u2208 V k \u2192 x \u2209 W \u2192 x \u2208 V j \u2227 x \u2209 W",["tauto","aesop"]],["Topology/Compactness/Compact.lean",566,"X : Type u\ninst\u271d : TopologicalSpace X\nf : Filter X\n\u22a2 (\u2203 i, IsCompact i \u2227 i \u2208 f) \u2194 \u2203 K \u2208 f, IsCompact K",["tauto","aesop"]],["Topology/Compactness/Compact.lean",572,"X : Type u\ninst\u271d : TopologicalSpace X\nf : Filter X\n\u22a2 (\u2203 i, IsCompact i \u2227 i \u2208 f) \u2194 \u2203 K \u2208 f, IsCompact K",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",48,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d : Decidable (a < x \u2227 x < b)\n\u22a2 Decidable (x \u2208 Ioo a b)",["assumption","aesop","congr","tauto"]],["Order/Interval/Set/Basic.lean",50,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d : Decidable (a \u2264 x \u2227 x < b)\n\u22a2 Decidable (x \u2208 Ico a b)",["assumption","aesop","congr","tauto"]],["Order/Interval/Set/Basic.lean",52,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d : Decidable (x < b)\n\u22a2 Decidable (x \u2208 Iio b)",["assumption","aesop","congr","tauto"]],["Order/Interval/Set/Basic.lean",54,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d : Decidable (a \u2264 x \u2227 x \u2264 b)\n\u22a2 Decidable (x \u2208 Icc a b)",["assumption","aesop","congr","tauto"]],["Order/Interval/Set/Basic.lean",56,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d : Decidable (x \u2264 b)\n\u22a2 Decidable (x \u2208 Iic b)",["assumption","aesop","congr","tauto"]],["Order/Interval/Set/Basic.lean",58,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d : Decidable (a < x \u2227 x \u2264 b)\n\u22a2 Decidable (x \u2208 Ioc a b)",["assumption","aesop","congr","tauto"]],["Order/Interval/Set/Basic.lean",60,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d : Decidable (a \u2264 x)\n\u22a2 Decidable (x \u2208 Ici a)",["assumption","aesop","congr","tauto"]],["Order/Interval/Set/Basic.lean",62,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d : Decidable (a < x)\n\u22a2 Decidable (x \u2208 Ioi a)",["assumption","aesop","congr","tauto"]],["Order/Interval/Set/Basic.lean",978,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhc : \u00acc < x\nhxb : x < b\n\u22a2 a < x \u2227 x < b \u2228 c < x \u2194 a < x \u2228 c < x",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1006,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : \u00acc \u2264 x\nhxb : x < b\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1026,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : \u00acc < x\nhxb : x \u2264 b\n\u22a2 a < x \u2227 x \u2264 b \u2228 c < x \u2194 a < x \u2228 c < x",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1061,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : \u00acc \u2264 x\nhxb : x \u2264 b\n\u22a2 a \u2264 x \u2227 x \u2264 b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1096,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nb c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : \u00acc \u2264 x\nhxb : x < b\n\u22a2 x < b \u2228 c \u2264 x \u2227 x < d \u2194 x < b \u2228 x < d",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1117,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nb c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhc : \u00acc < x\nhxb : x \u2264 b\n\u22a2 x \u2264 b \u2228 c < x \u2227 x \u2264 d \u2194 x \u2264 b \u2228 x \u2264 d",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1161,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nb c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : \u00acc \u2264 x\nhxb : x \u2264 b\n\u22a2 x \u2264 b \u2228 c \u2264 x \u2227 x \u2264 d \u2194 x \u2264 b \u2228 x \u2264 d",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1205,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c d : \u03b1\nh\u2081 : c \u2264 b\nh\u2082 : a \u2264 d\nx : \u03b1\nhc : c \u2264 x\nhd : \u00acx < d\nhax : a \u2264 x\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2227 x < d \u2194 (a \u2264 x \u2228 c \u2264 x) \u2227 (x < b \u2228 x < d)",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1207,"case pos\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c d : \u03b1\nh\u2081 : c \u2264 b\nh\u2082 : a \u2264 d\nx : \u03b1\nhc : \u00acc \u2264 x\nhd : x < d\nhxb : x < b\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2227 x < d \u2194 (a \u2264 x \u2228 c \u2264 x) \u2227 (x < b \u2228 x < d)",["tauto"]],["Order/Interval/Set/Basic.lean",1278,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c d : \u03b1\nh\u2081 : c \u2264 b\nh\u2082 : a \u2264 d\nx : \u03b1\nhc : c < x\nhd : \u00acx \u2264 d\nhax : a < x\n\u22a2 a < x \u2227 x \u2264 b \u2228 c < x \u2227 x \u2264 d \u2194 (a < x \u2228 c < x) \u2227 (x \u2264 b \u2228 x \u2264 d)",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1280,"case pos\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c d : \u03b1\nh\u2081 : c \u2264 b\nh\u2082 : a \u2264 d\nx : \u03b1\nhc : \u00acc < x\nhd : x \u2264 d\nhxb : x \u2264 b\n\u22a2 a < x \u2227 x \u2264 b \u2228 c < x \u2227 x \u2264 d \u2194 (a < x \u2228 c < x) \u2227 (x \u2264 b \u2228 x \u2264 d)",["tauto"]],["Order/Interval/Set/Basic.lean",1325,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c d : \u03b1\nh\u2081 : c \u2264 b\nh\u2082 : a \u2264 d\nx : \u03b1\nhc : c \u2264 x\nhd : \u00acx \u2264 d\nhax : a \u2264 x\n\u22a2 a \u2264 x \u2227 x \u2264 b \u2228 c \u2264 x \u2227 x \u2264 d \u2194 (a \u2264 x \u2228 c \u2264 x) \u2227 (x \u2264 b \u2228 x \u2264 d)",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1327,"case pos\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c d : \u03b1\nh\u2081 : c \u2264 b\nh\u2082 : a \u2264 d\nx : \u03b1\nhc : \u00acc \u2264 x\nhd : x \u2264 d\nhxb : x \u2264 b\n\u22a2 a \u2264 x \u2227 x \u2264 b \u2228 c \u2264 x \u2227 x \u2264 d \u2194 (a \u2264 x \u2228 c \u2264 x) \u2227 (x \u2264 b \u2228 x \u2264 d)",["tauto"]],["Order/Interval/Set/Basic.lean",1356,"case neg\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c d : \u03b1\nh\u2081 : c < b\nh\u2082 : a < d\nx : \u03b1\nhc : c < x\nhd : \u00acx < d\nhax : a < x\n\u22a2 a < x \u2227 x < b \u2228 c < x \u2227 x < d \u2194 (a < x \u2228 c < x) \u2227 (x < b \u2228 x < d)",["tauto","aesop"]],["Order/Interval/Set/Basic.lean",1358,"case pos\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c d : \u03b1\nh\u2081 : c < b\nh\u2082 : a < d\nx : \u03b1\nhc : \u00acc < x\nhd : x < d\nhxb : x < b\n\u22a2 a < x \u2227 x < b \u2228 c < x \u2227 x < d \u2194 (a < x \u2228 c < x) \u2227 (x < b \u2228 x < d)",["tauto"]],["Computability/TMToPartrec.lean",810,"case zero'\nk : Cont\nv : List \u2115\ns : Option \u0393'\n\u22a2 { l := some (\u039b'.ret (trCont k)), var := s, stk := elim (trList (0 :: v)) [] [] (trContStack k) } \u2208\n    TM2.step tr { l := some (trNormal Code.zero' (trCont k)), var := s, stk := elim (trList v) [] [] (trContStack k) }",["simp","aesop"]],["Computability/TMToPartrec.lean",769,"case cons.zero\nq\u2081 q\u2082 : \u039b'\ns : Option \u0393'\nc d : List \u0393'\nv : List \u2115\n\u22a2 Nat.rec { l := some q\u2081, var := some \u0393'.cons, stk := elim (trList (0 :: v).tail) [] c d }\n      (fun n x \u21a6 { l := some q\u2082, var := some \u0393'.cons, stk := elim (trList (n :: (0 :: v).tail)) [] c d }) (0 :: v).headI \u2208\n    TM2.step tr { l := some (q\u2081.pred q\u2082), var := s, stk := elim (trList (0 :: v)) [] c d }",["simp","aesop"]],["Computability/TMToPartrec.lean",680,"q : \u039b'\ns : Option \u0393'\nL : List \u2115\nc d : List \u0393'\no : Option \u0393' := List.casesOn L none fun x x \u21a6 some \u0393'.cons\n\u22a2 main \u2260 rev",["decide","aesop","tauto","simp"]],["Computability/TMToPartrec.lean",699,"q : \u039b'\ns : Option \u0393'\nL\u2081 : List \u2115\nL\u2083 : List \u0393'\n\u22a2 stack \u2260 rev",["decide","aesop","tauto","simp"]],["Computability/TMToPartrec.lean",710,"q : \u039b'\ns : Option \u0393'\nL\u2081 : List \u2115\nL\u2083 : List \u0393'\na : \u2115\nL\u2082 : List \u2115\n\u22a2 stack \u2260 rev",["decide"]],["Analysis/Distribution/SchwartzSpace.lean",562,"E : Type u_4\nF : Type u_5\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nc : F\nx : E\n\u22a2 \u2016c\u2016 \u2264 \u2016c\u2016 * (1 + \u2016x\u2016) ^ 0",["simp","aesop","linarith","norm_num"]],["Analysis/Distribution/SchwartzSpace.lean",825,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u00b9\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : NormedSpace \u211d E\ninst\u271d\u00b9\u2070 : NormedAddCommGroup F\ninst\u271d\u2079 : NormedSpace \u211d F\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2077 : NormedAlgebra \u211d \ud835\udd5c\ninst\u271d\u2076 : NormedAddCommGroup D\ninst\u271d\u2075 : NormedSpace \u211d D\ninst\u271d\u2074 : NormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \u211d G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : NormedSpace \ud835\udd5c G\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\ng : D \u2192 F\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nhgrowth : \u2200 N \u2264 n, \u2200 (x : D), \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\nf : \ud835\udce2(D, E)\nx : D\nhxk : 0 \u2264 \u2016x\u2016 ^ k\nhnorm_mul :\n  \u2016iteratedFDeriv \u211d n (fun y \u21a6 ((ContinuousLinearMap.bilinearRestrictScalars \u211d B) (f.toFun y)) (g y)) x\u2016 \u2264\n    \u2016ContinuousLinearMap.bilinearRestrictScalars \u211d B\u2016 *\n      \u2211 i \u2208 Finset.range (n + 1), \u2191(n.choose i) * \u2016iteratedFDeriv \u211d i f.toFun x\u2016 * \u2016iteratedFDeriv \u211d (n - i) g x\u2016\n\u22a2 \u2211 _x \u2208 Finset.range (n + 1), 1 = \u2191n + 1",["simp","aesop","norm_num"]],["Analysis/Distribution/SchwartzSpace.lean",845,"case right.h.h\u2081.h.h.h.hab\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u00b9\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : NormedSpace \u211d E\ninst\u271d\u00b9\u2070 : NormedAddCommGroup F\ninst\u271d\u2079 : NormedSpace \u211d F\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2077 : NormedAlgebra \u211d \ud835\udd5c\ninst\u271d\u2076 : NormedAddCommGroup D\ninst\u271d\u2075 : NormedSpace \u211d D\ninst\u271d\u2074 : NormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \u211d G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : NormedSpace \ud835\udd5c G\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\ng : D \u2192 F\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nf : \ud835\udce2(D, E)\nx : D\nhxk : 0 \u2264 \u2016x\u2016 ^ k\nhnorm_mul :\n  \u2016iteratedFDeriv \u211d n (fun y \u21a6 ((ContinuousLinearMap.bilinearRestrictScalars \u211d B) (f.toFun y)) (g y)) x\u2016 \u2264\n    \u2016ContinuousLinearMap.bilinearRestrictScalars \u211d B\u2016 *\n      \u2211 i \u2208 Finset.range (n + 1), \u2191(n.choose i) * \u2016iteratedFDeriv \u211d i f.toFun x\u2016 * \u2016iteratedFDeriv \u211d (n - i) g x\u2016\nthis : \u2211 _x \u2208 Finset.range (n + 1), 1 = \u2191n + 1\ni : \u2115\nhgrowth : \u2016iteratedFDeriv \u211d (n - i) g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\nhi : i \u2264 (l + k, n).2\n\u22a2 \u2016x\u2016 \u2264 1 + \u2016x\u2016",["simp","aesop","linarith","norm_num"]],["Analysis/Distribution/SchwartzSpace.lean",692,"case h.hx\nD : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup D\ninst\u271d : MeasurableSpace D\n\u03bc : Measure D\nh\u03bc : \u03bc.HasTemperateGrowth\np : \u211d\u22650\nhp : \u2191p \u2260 0\nh_one_add : \u2200 (x : D), 0 < 1 + \u2016x\u2016\nhp_pos : 0 < \u2191p\nl : \u2115\nhl : Integrable (fun x \u21a6 (1 + \u2016x\u2016) ^ (-\u2191l)) \u03bc\nk : \u2115 := \u2308\u2191l / \u2191p\u2309\u208a\nhlk : \u2191l \u2264 \u2191k * \u2191p\nx : D\n\u22a2 1 \u2264 1 + \u2016x\u2016",["simp","aesop","norm_num"]],["Analysis/Distribution/SchwartzSpace.lean",90,"case mk.mk\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\ntoFun\u271d\u00b9 : E \u2192 F\nsmooth'\u271d\u00b9 : ContDiff \u211d \u221e toFun\u271d\u00b9\ndecay'\u271d\u00b9 : \u2200 (k n : \u2115), \u2203 C, \u2200 (x : E), \u2016x\u2016 ^ k * \u2016iteratedFDeriv \u211d n toFun\u271d\u00b9 x\u2016 \u2264 C\ntoFun\u271d : E \u2192 F\nsmooth'\u271d : ContDiff \u211d \u221e toFun\u271d\ndecay'\u271d : \u2200 (k n : \u2115), \u2203 C, \u2200 (x : E), \u2016x\u2016 ^ k * \u2016iteratedFDeriv \u211d n toFun\u271d x\u2016 \u2264 C\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, smooth' := smooth'\u271d\u00b9, decay' := decay'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, smooth' := smooth'\u271d, decay' := decay'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, smooth' := smooth'\u271d\u00b9, decay' := decay'\u271d\u00b9 } =\n    { toFun := toFun\u271d, smooth' := smooth'\u271d, decay' := decay'\u271d }",["congr","aesop"]],["Analysis/Distribution/SchwartzSpace.lean",174,"E : Type u_4\nF : Type u_5\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nk n : \u2115\nf g : \ud835\udce2(E, F)\nx : E\n\u22a2 0 \u2264 \u2016x\u2016 ^ k",["positivity","aesop","norm_num","simp"]],["Analysis/Distribution/SchwartzSpace.lean",225,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \u211d E\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \u211d F\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b3 : SMulCommClass \u211d \ud835\udd5c F\ninst\u271d\u00b2 : NormedField \ud835\udd5c'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c' F\ninst\u271d : SMulCommClass \u211d \ud835\udd5c' F\nc : \ud835\udd5c\nf : \ud835\udce2(E, F)\nk n : \u2115\nx : E\n\u22a2 0 \u2264 \u2016c\u2016",["positivity","aesop","norm_num","simp"]],["Analysis/Distribution/SchwartzSpace.lean",558,"E : Type u_4\nF : Type u_5\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nn : \u2115\nx : E\n\u22a2 0 \u2264 0 * (1 + \u2016x\u2016) ^ 0",["positivity","aesop","linarith","norm_num","simp"]],["Analysis/Distribution/SchwartzSpace.lean",814,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u00b9\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : NormedSpace \u211d E\ninst\u271d\u00b9\u2070 : NormedAddCommGroup F\ninst\u271d\u2079 : NormedSpace \u211d F\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2077 : NormedAlgebra \u211d \ud835\udd5c\ninst\u271d\u2076 : NormedAddCommGroup D\ninst\u271d\u2075 : NormedSpace \u211d D\ninst\u271d\u2074 : NormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \u211d G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : NormedSpace \ud835\udd5c G\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\ng : D \u2192 F\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nhgrowth : \u2200 N \u2264 n, \u2200 (x : D), \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\nf : \ud835\udce2(D, E)\nx : D\n\u22a2 0 \u2264 \u2016x\u2016 ^ k",["positivity","aesop","norm_num","simp"]],["Geometry/Manifold/VectorField/LieBracket.lean",381,"\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nH : Type u_2\ninst\u271d\u2076 : TopologicalSpace H\nE : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : ChartedSpace H M\ns t : Set M\nx : M\nV W : (x : M) \u2192 TangentSpace I x\ninst\u271d\u00b9 : IsManifold I 2 M\ninst\u271d : CompleteSpace E\nst : t \u2208 \ud835\udcdd[s] x\nhs : UniqueMDiffWithinAt I s x\nhV : MDifferentiableWithinAt I I.tangent (fun x \u21a6 { proj := x, snd := V x }) t x\nhW : MDifferentiableWithinAt I I.tangent (fun x \u21a6 { proj := x, snd := W x }) t x\n\u22a2 x = \u2191(extChartAt I x).symm (\u2191(extChartAt I x) x)",["simp","aesop","norm_num"]],["Geometry/Manifold/VectorField/LieBracket.lean",734,"\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\nH : Type u_2\ninst\u271d\u00b9\u00b2 : TopologicalSpace H\nE : Type u_3\ninst\u271d\u00b9\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c E\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u2079 : TopologicalSpace M\ninst\u271d\u2078 : ChartedSpace H M\nH' : Type u_5\ninst\u271d\u2077 : TopologicalSpace H'\nE' : Type u_6\ninst\u271d\u2076 : NormedAddCommGroup E'\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E'\nI' : ModelWithCorners \ud835\udd5c E' H'\nM' : Type u_7\ninst\u271d\u2074 : TopologicalSpace M'\ninst\u271d\u00b3 : ChartedSpace H' M'\ninst\u271d\u00b2 : IsManifold I (minSmoothness \ud835\udd5c 2) M\ninst\u271d\u00b9 : IsManifold I' (minSmoothness \ud835\udd5c 2) M'\ninst\u271d : CompleteSpace E\nn : WithTop \u2115\u221e\nf : M \u2192 M'\nV W : (x : M') \u2192 TangentSpace I' x\nx\u2080 : M\nhf : ContMDiffAt I I' n f x\u2080\nhn : minSmoothness \ud835\udd5c 2 \u2264 n\nhV : MDifferentiableWithinAt I' I'.tangent (fun x \u21a6 { proj := x, snd := V x }) univ (f x\u2080)\nhW : MDifferentiableWithinAt I' I'.tangent (fun x \u21a6 { proj := x, snd := W x }) univ (f x\u2080)\n\u22a2 f \u207b\u00b9' univ \u2208 \ud835\udcdd[univ] x\u2080",["simp","aesop","norm_num"]],["Geometry/Manifold/VectorField/LieBracket.lean",110,"\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nH : Type u_2\ninst\u271d\u2074 : TopologicalSpace H\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\ns : Set M\nx : M\nV W : (x : M) \u2192 TangentSpace I x\nhV : V x = 0\nhW : W x = 0\n\u22a2 \u2191(extChartAt I x).symm (\u2191(extChartAt I x) x) = x",["simp","aesop","norm_num"]],["Geometry/Manifold/VectorField/LieBracket.lean",580,"\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\nH : Type u_2\ninst\u271d\u00b9\u00b2 : TopologicalSpace H\nE : Type u_3\ninst\u271d\u00b9\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c E\nI : ModelWithCorners \ud835\udd5c E H\nM\u271d : Type u_4\ninst\u271d\u2079 : TopologicalSpace M\u271d\ninst\u271d\u2078 : ChartedSpace H M\u271d\nH' : Type u_5\ninst\u271d\u2077 : TopologicalSpace H'\nE' : Type u_6\ninst\u271d\u2076 : NormedAddCommGroup E'\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E'\nI' : ModelWithCorners \ud835\udd5c E' H'\nM'\u271d : Type u_7\ninst\u271d\u2074 : TopologicalSpace M'\u271d\ninst\u271d\u00b3 : ChartedSpace H' M'\u271d\ninst\u271d\u00b2 : IsManifold I 2 M\u271d\ninst\u271d\u00b9 : IsManifold I' 2 M'\u271d\ninst\u271d : CompleteSpace E\nf : M\u271d \u2192 M'\u271d\nV W : (x : M'\u271d) \u2192 TangentSpace I' x\nx\u2080 : M\u271d\ns : Set M\u271d\nt : Set M'\u271d\nhV : MDifferentiableWithinAt I' I'.tangent (fun x \u21a6 { proj := x, snd := V x }) t (f x\u2080)\nhW : MDifferentiableWithinAt I' I'.tangent (fun x \u21a6 { proj := x, snd := W x }) t (f x\u2080)\nhu : UniqueMDiffOn I s\nhf : ContMDiffWithinAt I I' 2 f s x\u2080\nhx\u2080 : x\u2080 \u2208 s\nhst : f \u207b\u00b9' t \u2208 \ud835\udcdd[s] x\u2080\nhsymm :\n  IsSymmSndFDerivWithinAt \ud835\udd5c (\u2191(extChartAt I' (f x\u2080)) \u2218 f \u2218 \u2191(extChartAt I x\u2080).symm)\n    (\u2191(extChartAt I x\u2080).symm \u207b\u00b9' s \u2229 range \u2191I) (\u2191(extChartAt I x\u2080) x\u2080)\nA : \u2191(extChartAt I x\u2080).symm (\u2191(extChartAt I x\u2080) x\u2080) = x\u2080\nM : TangentSpace I x\u2080 \u2243L[\ud835\udd5c] TangentSpace I' (f x\u2080)\nM' : E \u2243L[\ud835\udd5c] E' := M\n\u22a2 CompleteSpace E",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["MeasureTheory/Function/SimpleFunc.lean",205,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\nf g : \u03b1 \u2192\u209b \u03b2\n\u22a2 \u21d1(piecewise univ \u22ef f g) = \u21d1f",["simp","aesop","norm_num"]],["MeasureTheory/Function/SimpleFunc.lean",359,"case H\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192\u209b \u03b2\na\u271d : \u03b1\n\u22a2 (f.bind (const \u03b1)) a\u271d = f a\u271d",["simp","aesop","congr","tauto","norm_num"]],["MeasureTheory/Function/SimpleFunc.lean",134,"\u03b2 : Type u_2\n\u03b1 : Type u_5\ninst\u271d : MeasurableSpace \u03b1\nb : \u03b2\n\u22a2 \u2191(const \u03b1 b).range \u2286 \u2191{b}",["simp","aesop","norm_num"]],["MeasureTheory/Function/SimpleFunc.lean",842,"case refine_2\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\ns : Finset \u211d\u22650\u221e\nhs : \u2200 (x : \u03b1), f x \u2260 0 \u2192 \u03bc (\u21d1f \u207b\u00b9' {f x}) \u2260 0 \u2192 f x \u2208 s\na\u2081\u271d : \u211d\u22650\u221e\nh\u2081\u2081\u271d : a\u2081\u271d \u2208 f.range\nh\u2081\u2082\u271d : a\u2081\u271d * \u03bc (\u21d1f \u207b\u00b9' {a\u2081\u271d}) \u2260 0\na\u2082\u271d : \u211d\u22650\u221e\nh\u2082\u2081\u271d : a\u2082\u271d \u2208 f.range\nh\u2082\u2082\u271d : a\u2082\u271d * \u03bc (\u21d1f \u207b\u00b9' {a\u2082\u271d}) \u2260 0\na\u271d : (fun r x x \u21a6 r) a\u2081\u271d h\u2081\u2081\u271d h\u2081\u2082\u271d = (fun r x x \u21a6 r) a\u2082\u271d h\u2082\u2081\u271d h\u2082\u2082\u271d\n\u22a2 a\u2081\u271d = a\u2082\u271d",["assumption","aesop","congr","gcongr","tauto"]],["MeasureTheory/Function/SimpleFunc.lean",951,"case left.bc\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\ns : \u03b9 \u2192 Set \u03b1\nhd : Directed (fun x1 x2 \u21a6 x1 \u2286 x2) s\n\u03bc : Measure \u03b1\ni j k : \u03b9\nx\u271d : (fun x1 x2 \u21a6 x1 \u2286 x2) (s i) (s k) \u2227 (fun x1 x2 \u21a6 x1 \u2286 x2) (s j) (s k)\nhik : (fun x1 x2 \u21a6 x1 \u2286 x2) (s i) (s k)\nhjk : (fun x1 x2 \u21a6 x1 \u2286 x2) (s j) (s k)\na : \u211d\u22650\u221e\n\u22a2 s i \u2286 s k\n```\n---\n```lean\ncase right.bc\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\ns : \u03b9 \u2192 Set \u03b1\nhd : Directed (fun x1 x2 \u21a6 x1 \u2286 x2) s\n\u03bc : Measure \u03b1\ni j k : \u03b9\nx\u271d : (fun x1 x2 \u21a6 x1 \u2286 x2) (s i) (s k) \u2227 (fun x1 x2 \u21a6 x1 \u2286 x2) (s j) (s k)\nhik : (fun x1 x2 \u21a6 x1 \u2286 x2) (s i) (s k)\nhjk : (fun x1 x2 \u21a6 x1 \u2286 x2) (s j) (s k)\na : \u211d\u22650\u221e\n\u22a2 s j \u2286 s k",["assumption","aesop","congr","gcongr","tauto"]],["MeasureTheory/Measure/Regular.lean",1016,"case h.e'_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : BorelSpace \u03b2\nf : \u03b1 \u2243\u209c \u03b2\nh : (map (\u21d1f) \u03bc).Regular\n\u22a2 \u03bc = map (\u21d1f.symm \u2218 \u21d1f) \u03bc",["simp","aesop","norm_num"]],["MeasureTheory/Integral/IntervalIntegral.lean",290,"case inl\nE : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\nhf : IntervalIntegrable f volume a b\nc : \u211d\nhc : c = 0\n\u22a2 IntervalIntegrable (fun x \u21a6 f (0 * x)) volume (a / 0) (b / 0)",["simp","aesop","norm_num"]],["RingTheory/LaurentSeries.lean",628,"K : Type u_2\ninst\u271d : Field K\nn D : \u2124\nf : K\u2e28X\u2e29\nH : Valued.v f \u2264 \u2191(Multiplicative.ofAdd (-D))\nhnd : n < D\nh_n_ord : HahnSeries.order f \u2264 n\nF : K\u27e6X\u27e7 := f.powerSeriesPart\nhF : F = f.powerSeriesPart\nord_nonpos : HahnSeries.order f \u2264 0\ns : \u2115\nhs : HahnSeries.order f = -\u2191s\nm : \u2115\nhm : n + \u2191s = \u2191m\nd : \u2115\nhd : D + \u2191s = \u2191d\n\u22a2 m < ?m.349465",["linarith","tauto"]],["RingTheory/LaurentSeries.lean",638,"K : Type u_2\ninst\u271d : Field K\nn D : \u2124\nf : K\u2e28X\u2e29\nH : Valued.v f \u2264 \u2191(Multiplicative.ofAdd (-D))\nhnd : n < D\nh_n_ord : HahnSeries.order f \u2264 n\nF : K\u27e6X\u27e7 := f.powerSeriesPart\nhF : F = f.powerSeriesPart\nord_nonpos : 0 < HahnSeries.order f\ns : \u2115\nhs : -HahnSeries.order f = -\u2191s\nm : \u2115\nhm : n - \u2191s = \u2191m\nd : \u2115\nhd : D - \u2191s = \u2191d\n\u22a2 m < ?m.357339",["linarith","tauto"]],["RingTheory/LaurentSeries.lean",1120,"case h\nK : Type u_2\ninst\u271d : Field K\na : adicCompletion (RatFunc K) (idealX K)\n\u03c8 : RatFunc K \u2192 \u2124\u2098\u2080 := \u21d1Valued.v\nh\u03c8 : \u03c8 = \u21d1Valued.v\nthis : \u2200 (s : Set (adicCompletion (RatFunc K) (idealX K))), s \u2208 \ud835\udcdd 0 \u2194 \u2203 \u03b3, {x | Valued.v x < \u2191\u03b3} \u2286 s\nha : \u00aca = 0\n\u03b3 : \u2124\u2098\u2080 := Valued.v a / \u2191(Multiplicative.ofAdd 1)\nh_a\u03b3 : \u03b3 = Valued.v a / \u2191(Multiplicative.ofAdd 1)\n\u03b3_ne_zero : \u03b3 \u2260 0\ny : adicCompletion (RatFunc K) (idealX K)\nb : RatFunc K\ndiff_b_y : \u2191b = y\nval_y : Valued.v y = Valued.v a\n\u22a2 Valued.extension \u2191b = Valued.v \u2191b",["congr","aesop","tauto","norm_num","simp"]],["RingTheory/LaurentSeries.lean",975,"case h.a\nK : Type u_2\ninst\u271d : Field K\nS : Set (RatFunc K \u00d7 RatFunc K)\nT : Set (K\u2e28X\u2e29 \u00d7 K\u2e28X\u2e29)\npre_T : (fun x \u21a6 (\u2191x.1, \u2191x.2)) \u207b\u00b9' T \u2286 S\nR : Set K\u2e28X\u2e29\nhR : R \u2208 nhds 0\npre_R : (fun x \u21a6 x.2 - x.1) \u207b\u00b9' R \u2286 T\nd : (WithZero (Multiplicative \u2124))\u02e3\nhd : {y | Valued.v (y - 0) < \u2191d} \u2286 R\nx\u271d\u00b9 : RatFunc K \u00d7 RatFunc K\nx\u271d : x\u271d\u00b9 \u2208 (fun x \u21a6 x.2 - x.1) \u207b\u00b9' {P | Valued.v P < \u2191d}\n\u22a2 (valuation (RatFunc K) (idealX K)) (x\u271d\u00b9.2 - x\u271d\u00b9.1) < \u2191d",["assumption","aesop","congr","tauto"]],["RingTheory/LaurentSeries.lean",987,"case h.mpr.intro.intro.intro.refine_2.a\nK : Type u_2\ninst\u271d : Field K\nS : Set (RatFunc K \u00d7 RatFunc K)\nw\u271d : Set (RatFunc K)\nhT : w\u271d \u2208 nhds 0\npre_T : (fun x \u21a6 x.2 - x.1) \u207b\u00b9' w\u271d \u2286 S\nd : (WithZero (Multiplicative \u2124))\u02e3\nhd : {y | Valued.v (y - 0) < \u2191d} \u2286 w\u271d\nX : Set K\u2e28X\u2e29 := {f | Valued.v f < \u2191d}\nx\u271d\u00b9 : RatFunc K \u00d7 RatFunc K\nx\u271d : x\u271d\u00b9 \u2208 (fun x \u21a6 (\u2191x.1, \u2191x.2)) \u207b\u00b9' ((fun x \u21a6 x.2 - x.1) \u207b\u00b9' X)\n\u22a2 (valuation K\u2e28X\u2e29 (PowerSeries.idealX K)) (\u2191x\u271d\u00b9.2 - \u2191x\u271d\u00b9.1) < \u2191d",["assumption","aesop","congr","tauto"]],["RingTheory/LaurentSeries.lean",764,"K : Type u_2\ninst\u271d : Field K\n\u2131 : Filter K\u2e28X\u2e29\nh\u2131 : Cauchy \u2131\nentourage : Set (K\u2e28X\u2e29 \u00d7 K\u2e28X\u2e29) := {P | Valued.v (P.2 - P.1) < \u2191(ofAdd 0)}\n\u03b6 : \u2124\u2098\u2080\u02e3 := Units.mk0 \u2191(ofAdd 0) \u22ef\n\u22a2 True",["tauto","ring","decide","aesop","abel","norm_num","simp"]],["Analysis/Normed/Group/Basic.lean",578,"E : Type u_5\ninst\u271d : SeminormedGroup E\nr : \u211d\na : E\n\u22a2 a \u2208 ball 1 r \u2194 a \u2208 {x | \u2016x\u2016 < r}",["simp","aesop","norm_num"]],["MeasureTheory/Decomposition/Lebesgue.lean",256,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\n\u22a2 \u03bc.singularPart 0 = \u03bc.singularPart 0 + withDensity 0 (\u03bc.rnDeriv 0)",["simp","aesop","norm_num"]],["MeasureTheory/Decomposition/Lebesgue.lean",735,"case neg\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nh : \u00ac\u03bc \u27c2\u2098 \u03bd\nf : \u2115 \u2192 Set \u03b1\nhf\u2081 : \u2200 (n : \u2115), MeasurableSet (f n)\nhf\u2082 : \u2200 (n : \u2115) (t : Set \u03b1), MeasurableSet t \u2192 ((1 / (\u2191n + 1)) \u2022 \u03bd) (t \u2229 f n) \u2264 \u03bc (t \u2229 f n)\nhf\u2083 : \u2200 (n : \u2115) (t : Set \u03b1), MeasurableSet t \u2192 \u03bc (t \u2229 (f n)\u1d9c) \u2264 ((1 / (\u2191n + 1)) \u2022 \u03bd) (t \u2229 (f n)\u1d9c)\nA : Set \u03b1 := \u22c2 n, (f n)\u1d9c\nhAmeas : MeasurableSet A\nhA\u2082 : \u2200 (n : \u2115) (t : Set \u03b1), MeasurableSet t \u2192 \u03bc (t \u2229 A) \u2264 ((1 / (\u2191n + 1)) \u2022 \u03bd) (t \u2229 A)\n\u03bcA : \u211d\u22650\nhA\u2083\u271d\u00b9 : \u2200 (n : \u2115), \u2191\u03bcA \u2264 \u2191(1 / (\u2191n + 1)) * \u03bd A\n\u03bdA : \u211d\u22650\nhA\u2083\u271d : \u2200 (n : \u2115), \u2191\u03bcA \u2264 \u2191(1 / (\u2191n + 1)) * \u2191\u03bdA\nhb : \u03bdA = 0\nhA\u2083 : \u03bcA = 0\n\u22a2 \u03bcA = 0",["assumption","aesop","congr","gcongr","tauto"]],["AlgebraicGeometry/AffineScheme.lean",1213,"R S : CommRingCat\nf : R \u27f6 S\np : PrimeSpectrum \u2191S\n\u22a2 (StructureSheaf.stalkIso (\u2191R) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p)).hom \u226b\n      (Arrow.mk\n          (CommRingCat.ofHom\n            (Localization.localRingHom ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p).asIdeal p.asIdeal\n              (CommRingCat.Hom.hom f) \u22ef))).hom =\n    (Arrow.mk\n          ((StructureSheaf.stalkIso (\u2191R) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p)).hom \u226b\n            CommRingCat.ofHom\n                (Localization.localRingHom ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p).asIdeal p.asIdeal\n                  (CommRingCat.Hom.hom f) \u22ef) \u226b\n              (StructureSheaf.stalkIso (\u2191S) p).inv)).hom \u226b\n      (StructureSheaf.stalkIso (\u2191S) p).hom",["simp","aesop","infer_instance","norm_num"]],["AlgebraicGeometry/AffineScheme.lean",653,"case hf.h\nX Y : Scheme\nf : X \u27f6 Y\nU : Y.Opens\nhU : IsAffineOpen U\nh : IsAffineOpen (f \u207b\u00b9\u1d41 U)\nr : \u2191\u0393(Y, U)\nthis\u271d : IsLocalization.Away r \u2191\u0393(Y, Y.basicOpen r)\nthis :\n  IsLocalization.Away ((ConcreteCategory.hom (Scheme.Hom.app f U)) r)\n    \u2191\u0393(X, X.basicOpen ((ConcreteCategory.hom (Scheme.Hom.app f U)) r))\n\u22a2 CommRingCat.Hom.hom (Y.presheaf.map (homOfLE \u22ef).op \u226b Scheme.Hom.app f (Y.basicOpen r)) =\n    (CommRingCat.Hom.hom (X.presheaf.map ((homOfLE \u22ef).op \u226b (eqToHom \u22ef).op))).comp\n      (CommRingCat.Hom.hom (Scheme.Hom.app f U))",["simp","aesop","norm_num"]],["AlgebraicGeometry/AffineScheme.lean",245,"X : Scheme\ninst\u271d : IsAffine X\ni : (Scheme.coverOfIsIso (\ud835\udfd9 X)).J\n\u22a2 IsAffine X",["infer_instance","aesop","congr","tauto","assumption"]],["Topology/MetricSpace/GromovHausdorff.lean",954,"X : \u2115 \u2192 Type\ninst\u271d\u00b3 : (n : \u2115) \u2192 MetricSpace (X n)\ninst\u271d\u00b2 : \u2200 (n : \u2115), CompactSpace (X n)\ninst\u271d\u00b9 : \u2200 (n : \u2115), Nonempty (X n)\nA : Type\ninst\u271d : MetricSpace A\n\u22a2 MetricSpace A",["infer_instance","aesop","congr","tauto","assumption"]],["Topology/MetricSpace/GromovHausdorff.lean",859,"t : Set GHSpace\nC : \u211d\nu : \u2115 \u2192 \u211d\nK : \u2115 \u2192 \u2115\nulim : Tendsto u atTop (\ud835\udcdd 0)\nhdiam : \u2200 p \u2208 t, diam univ \u2264 C\nhcov : \u2200 p \u2208 t, \u2200 (n : \u2115), \u2203 s, #\u2191s \u2264 \u2191(K n) \u2227 univ \u2286 \u22c3 x \u2208 s, ball x (u n)\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\n\u03b5 : \u211d := 1 / 5 * \u03b4\n\u03b5pos : 0 < \u03b5\nn : \u2115\nhn : \u2200 n_1 \u2265 n, dist (u n_1) 0 < \u03b5\nu_le_\u03b5 : u n \u2264 \u03b5\ns : (p : GHSpace) \u2192 Set p.Rep\nN : GHSpace \u2192 \u2115\nhN : \u2200 (p : GHSpace), N p \u2264 K n\nE : (p : GHSpace) \u2192 \u2191(s p) \u2243 Fin (N p)\nhs : \u2200 p \u2208 t, univ \u2286 \u22c3 x \u2208 s p, ball x (u n)\nM : \u2115 := \u230a\u03b5\u207b\u00b9 * (C \u2294 0)\u230b\u208a\nF : GHSpace \u2192 (k : Fin (K n).succ) \u00d7 (Fin \u2191k \u2192 Fin \u2191k \u2192 Fin M.succ) :=\n  fun p \u21a6 \u27e8\u27e8N p, \u22ef\u27e9, fun a b \u21a6 \u27e8M \u2293 \u230a\u03b5\u207b\u00b9 * dist ((E p).symm a) ((E p).symm b)\u230b\u208a, \u22ef\u27e9\u27e9\np : GHSpace\npt : p \u2208 t\nq : GHSpace\nqt : q \u2208 t\nhpq : (fun p \u21a6 F \u2191p) \u27e8p, pt\u27e9 = (fun p \u21a6 F \u2191p) \u27e8q, qt\u27e9\nNpq : N p = N q\n\u03a8 : \u2191(s p) \u2192 \u2191(s q) := fun x \u21a6 (E q).symm (Fin.cast Npq ((E p) x))\n\u03a6 : \u2191(s p) \u2192 q.Rep := fun x \u21a6 \u2191(\u03a8 x)\nx y : \u2191(s p)\nthis : dist (\u03a6 x) (\u03a6 y) = dist (\u03a8 x) (\u03a8 y)\ni : \u2115 := \u2191((E p) x)\nhip : i < N p\nhiq : i < N q\ni' : i = \u2191((E q) (\u03a8 x))\nj : \u2115 := \u2191((E p) y)\nhjp : j < N p\nhjq : j < N q\nj' : j = \u2191((E q) (\u03a8 y))\n\u22a2 \u2191((F p).snd \u27e8i, hip\u27e9 \u27e8j, hjp\u27e9) = \u2191((F p).snd ((E p) x) ((E p) y))",["congr","ring","aesop","linarith","tauto","abel"]],["Data/Num/Lemmas.lean",829,"case pos.succ.one.h\u2080\nn : \u2115\nIH : \u2200 (m : PosNum), \u2191(m >>> n) = \u2191(pos m) >>> n\nhdiv2 : \u2200 (m : \u2115), (m + m).div2 = m\n\u22a2 \u2191(pos one) < 2 ^ (n + 1)",["simp","aesop"]],["Data/Num/Lemmas.lean",1498,"n d : PosNum\n\u22a2 \u2191\u2191(n.div' d) = \u2191(pos n) / \u2191(pos d)",["simp","aesop"]],["Data/Num/Lemmas.lean",1090,"p : PosNum\n\u22a2 \u2191\u2191p.pred'.succ' = \u2191p",["simp","aesop"]],["Data/Num/Lemmas.lean",657,"b : Bool\nn : \u2115\nIH : ofNat' n = \u2191n\n\u22a2 ofNat' (Nat.bit b n) = \u2191(Nat.bit b n)",["tauto","aesop","congr"]],["Data/Num/Lemmas.lean",383,"\u22a2 0 \u2264 1",["decide","tauto"]],["Data/Num/Lemmas.lean",692,"n : PosNum\nh : 1 < n\ne : n.pred' = zero\nthis : 1 \u2264 \u2191zero\n\u22a2 \u00ac1 \u2264 \u2191zero",["decide","aesop","tauto","contradiction","simp"]],["Data/Num/Lemmas.lean",1303,"\u03b1 : Type u_1\n\u22a2 0 \u2264 1",["decide","tauto"]],["Geometry/RingedSpace/OpenImmersion.lean",502,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : PresheafedSpace C\nf : X \u27f6 Z\nhf : IsOpenImmersion f\ng : Y \u27f6 Z\ns : PullbackCone f g\ninst\u271d : IsOpenImmersion g\ne : Set.range \u21d1(ConcreteCategory.hom f.base) = Set.range \u21d1(ConcreteCategory.hom g.base)\n\u22a2 (lift g f \u22ef \u226b lift f g \u22ef) \u226b f = \ud835\udfd9 X \u226b f",["simp","aesop","norm_num"]],["Geometry/RingedSpace/OpenImmersion.lean",388,"case refine_1\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : PresheafedSpace C\nf : X \u27f6 Z\nhf : IsOpenImmersion f\ng : Y \u27f6 Z\ns : PullbackCone f g\n\u22a2 pullback.lift s.fst.base s.snd.base \u22ef \u226b pullback.fst f.base g.base = s.fst.base",["simp","aesop","norm_num"]],["Geometry/RingedSpace/OpenImmersion.lean",584,"case mk\nY : LocallyRingedSpace\ntoSheafedSpace\u271d : SheafedSpace CommRingCat\nisLocalRing\u271d : \u2200 (x : \u2191\u2191toSheafedSpace\u271d.toPresheafedSpace), IsLocalRing \u2191(toSheafedSpace\u271d.presheaf.stalk x)\nf : { toSheafedSpace := toSheafedSpace\u271d, isLocalRing := isLocalRing\u271d } \u27f6 Y\ninst\u271d : LocallyRingedSpace.IsOpenImmersion f\n\u22a2 { toSheafedSpace := toSheafedSpace Y.toSheafedSpace f.toHom, isLocalRing := \u22ef } =\n    { toSheafedSpace := toSheafedSpace\u271d, isLocalRing := isLocalRing\u271d }",["simp","aesop","tauto","norm_num"]],["Geometry/RingedSpace/OpenImmersion.lean",927,"C : Type u\ninst\u271d\u2075 : Category.{v, u} C\ninst\u271d\u2074 : HasLimits C\n\u03b9\u271d : Type v\nF\u271d : Discrete \u03b9\u271d \u2964 SheafedSpace C\ninst\u271d\u00b3 : HasColimit F\u271d\ni\u271d : Discrete \u03b9\u271d\n\u03b9 : Type w\ninst\u271d\u00b2 : Small.{v, w} \u03b9\nF : Discrete \u03b9 \u2964 SheafedSpace C\ninst\u271d\u00b9 : HasColimit F\ni : Discrete \u03b9\ninst\u271d : HasStrictTerminalObjects C\n\u03b9' : Type v\ne : \u03b9 \u2243 \u03b9'\nf : Discrete \u03b9' \u224c Discrete \u03b9 := Discrete.equivalence e.symm\n\u22a2 colimit.\u03b9 F i =\n    (colimit.\u03b9 F i \u226b (HasColimit.isoOfEquivalence f (Iso.refl (f.functor \u22d9 F))).inv) \u226b\n      (HasColimit.isoOfEquivalence f (Iso.refl (f.functor \u22d9 F))).hom",["simp","aesop"]],["Geometry/RingedSpace/OpenImmersion.lean",201,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : PresheafedSpace C\nf : X \u27f6 Y\nH : IsOpenImmersion f\nU : Opens \u2191\u2191Y\n\u22a2 f.c.app (op U) \u226b X.presheaf.map (eqToHom \u22ef) =\n    f.c.app (op U) \u226b ((TopCat.Presheaf.pushforward C f.base).obj X.presheaf).map (homOfLE \u22ef).op",["congr","aesop","tauto"]],["Geometry/RingedSpace/OpenImmersion.lean",212,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : PresheafedSpace C\nf : X \u27f6 Y\nH : IsOpenImmersion f\nU : Opens \u2191\u2191Y\nhU : \u2191U \u2286 Set.range \u21d1(ConcreteCategory.hom f.base)\n\u22a2 f.c.app (op U) \u226b X.presheaf.map (eqToHom \u22ef) =\n    f.c.app (op U) \u226b ((TopCat.Presheaf.pushforward C f.base).obj X.presheaf).map (eqToHom \u22ef).op",["congr","aesop","tauto"]],["Geometry/RingedSpace/OpenImmersion.lean",238,"case h.e'_5.e_8.e_3.h\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d : PresheafedSpace C\nf\u271d : X\u271d \u27f6 Y\u271d\nH : IsOpenImmersion f\u271d\nX : TopCat\nY : PresheafedSpace C\nf : X \u27f6 \u2191Y\nhf : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\nU : Opens \u2191\u2191(Y.restrict hf)\nthis : (Opens.map f).obj (\u22ef.functor.obj U) = U\ne_4\u271d : Y.presheaf.obj (op (\u22ef.functor.obj ((Opens.map f).obj (\u22ef.functor.obj U)))) = Y.presheaf.obj (op (\u22ef.functor.obj U))\n\u22a2 \u22ef.functor.obj ((Opens.map f).obj (\u22ef.functor.obj U)) = \u22ef.functor.obj U",["congr","aesop","tauto"]],["Data/Finsupp/Basic.lean",724,"case h\n\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : AddCommMonoid M\nf g : Option \u03b1 \u2192\u2080 M\na\u271d : \u03b1\n\u22a2 (f + g).some a\u271d = (f.some + g.some) a\u271d",["simp","aesop","tauto"]],["Data/Finsupp/Basic.lean",779,"case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : Zero M\np\u271d : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nf\u271d : \u03b1 \u2192\u2080 M\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1 \u2192\u2080 M\na : \u03b1\nh : p a\n\u22a2 f a \u2260 0 \u2227 True \u2194 f a \u2260 0\n```\n---\n```lean\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : Zero M\np\u271d : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nf\u271d : \u03b1 \u2192\u2080 M\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1 \u2192\u2080 M\na : \u03b1\nh : \u00acp a\n\u22a2 f a \u2260 0 \u2227 False \u2194 0 \u2260 0",["tauto","aesop","simp"]],["Data/Finsupp/Basic.lean",1403,"\u03b9 : Type u_4\nM : Type u_5\n\u03b1s : \u03b9 \u2192 Type u_13\ninst\u271d : Zero M\nl : (i : \u03b9) \u00d7 \u03b1s i \u2192\u2080 M\n\u22a2 \u2200 (a : \u03b9) (b : \u03b1s a), \u27e8a, b\u27e9 \u2208 l.support \u2194 (\u2203 a_1 \u2208 l.support, a_1.fst = a) \u2227 \u27e8a, b\u27e9 \u2208 l.support",["tauto"]],["Algebra/BigOperators/Finprod.lean",654,"\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2205), f i = 1",["simp","aesop"]],["Algebra/BigOperators/Finprod.lean",559,"\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : CommMonoid M\ns : Set \u03b1\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), 1 = 1",["simp","aesop"]],["Algebra/BigOperators/Finprod.lean",349,"\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Finset \u03b1\nh : mulSupport f \u2286 \u2191s\nA : mulSupport (f \u2218 PLift.down) = \u21d1Equiv.plift.symm '' mulSupport f\nthis : mulSupport (f \u2218 PLift.down) \u2286 \u2191(Finset.map Equiv.plift.symm.toEmbedding s)\n\u22a2 \u220f x \u2208 s, f (Equiv.plift.symm x).down = \u220f i \u2208 s, f i",["congr","aesop","tauto"]],["Algebra/BigOperators/Finprod.lean",942,"\u03b1 : Type u_1\nM : Type u_5\ninst\u271d : CommMonoid M\nf : Option \u03b1 \u2192 M\nhf : (mulSupport f).Finite\n\u22a2 none \u2209 range some",["aesop","simp"]],["Algebra/BigOperators/Finprod.lean",1039,"N : Type u_6\ninst\u271d : CommMonoid N\n\u03b1 : Type u_7\n\u03b9 : Type u_8\nf : \u03b9 \u2192 \u03b1 \u2192 N\nhf : (mulSupport f).Finite\na : \u03b1\n\u22a2 (mulSupport fun i \u21a6 f i a) \u2286 mulSupport f",["aesop","tauto"]],["Algebra/Group/Pointwise/Set/Basic.lean",1378,"\u03b1 : Type u_2\ninst\u271d : Group \u03b1\nt : Set \u03b1\na : \u03b1\n\u22a2 (fun x \u21a6 a\u207b\u00b9 * x) '' t = (fun x \u21a6 a * x) \u207b\u00b9' t",["simp","aesop"]],["Topology/MetricSpace/Pseudo/Defs.lean",925,"\u03b1 : Type u\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : \u211d\u22650\n\u22a2 EMetric.ball x \u2191\u03b5 = EMetric.ball x (ENNReal.ofReal \u2191\u03b5)",["simp","aesop","norm_num"]],["Topology/MetricSpace/Pseudo/Defs.lean",415,"\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\nx y z : \u03b1\n\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\ns : Set \u03b1\ninst\u271d\u00b9 : Subsingleton \u03b1\ninst\u271d : NeZero \u03b5\n\u22a2 IsEmpty \u2191\u2205",["infer_instance","aesop","norm_num","simp"]],["Algebra/Lie/Submodule.lean",1303,"case h\nR : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\nm\u271d : \u21a5I\n\u22a2 m\u271d \u2208 I.incl.ker \u2194 m\u271d \u2208 \u22a5",["simp","aesop","norm_num"]],["Algebra/Lie/Submodule.lean",1391,"case a\nR : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\ninst\u271d : LieRingModule L N\nf\u271d : M \u2192\u2097\u2045R,L\u2046 N\nP : LieSubmodule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nh : \u2200 (m : M), f m \u2208 P\nx : L\nm : M\n\u22a2 \u2191({ toFun := \u21d1(LinearMap.codRestrict (\u2191P) (\u2191f) h), map_add' := \u22ef, map_smul' := \u22ef }.toFun \u2045x, m\u2046) =\n    \u2191\u2045x, { toFun := \u21d1(LinearMap.codRestrict (\u2191P) (\u2191f) h), map_add' := \u22ef, map_smul' := \u22ef }.toFun m\u2046",["simp","aesop","norm_num"]],["Algebra/Lie/Submodule.lean",926,"case h\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\nN : LieSubmodule R L M\nm\u271d : M\n\u22a2 m\u271d \u2208 map LieModuleHom.id N \u2194 m\u271d \u2208 N",["simp","aesop","norm_num"]],["Algebra/Lie/Submodule.lean",132,"case mk.mk\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\ntoSubmodule\u271d\u00b9 : Submodule R M\nlie_mem\u271d\u00b9 : \u2200 {x : L} {m : M}, m \u2208 toSubmodule\u271d\u00b9.carrier \u2192 \u2045x, m\u2046 \u2208 toSubmodule\u271d\u00b9.carrier\ntoSubmodule\u271d : Submodule R M\nlie_mem\u271d : \u2200 {x : L} {m : M}, m \u2208 toSubmodule\u271d.carrier \u2192 \u2045x, m\u2046 \u2208 toSubmodule\u271d.carrier\nh : \u2191{ toSubmodule := toSubmodule\u271d\u00b9, lie_mem := lie_mem\u271d\u00b9 } = \u2191{ toSubmodule := toSubmodule\u271d, lie_mem := lie_mem\u271d }\n\u22a2 { toSubmodule := toSubmodule\u271d\u00b9, lie_mem := lie_mem\u271d\u00b9 } = { toSubmodule := toSubmodule\u271d, lie_mem := lie_mem\u271d }",["congr","aesop"]],["Algebra/Lie/Submodule.lean",227,"case h\nR : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nI : LieIdeal R L\nx y : L\nh : x \u2208 I\n\u22a2 x \u2208 I",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Lie/Submodule.lean",798,"R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\nm : M\ns : Set (LieSubmodule R L M)\nhne : s.Nonempty\nhdir : DirectedOn (fun x1 x2 \u21a6 x1 \u2264 x2) s\nhsup\u271d : m \u2208 \u2191(sSup s)\nthis : \u2191(sSup s) = \u22c3 N \u2208 s, \u2191N\nhsup : \u2203 i \u2208 s, m \u2208 i\n\u22a2 ?m.337669",["assumption","congr","tauto"]],["Data/Set/Image.lean",309,"\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 id '' s = s",["simp","aesop"]],["Data/Set/Image.lean",199,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (\u2200 y \u2208 f '' s, p y) \u2194 \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 p (f x)",["simp","aesop"]],["Data/Set/Image.lean",256,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 f '' \u2205 \u2194 x\u271d \u2208 \u2205",["simp","aesop"]],["Data/Set/Image.lean",159,"case h\n\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 p \u207b\u00b9' {True} \u2194 x\u271d \u2208 {a | p a}",["simp","aesop"]],["Data/Set/Image.lean",557,"case pos.h.refine_1\n\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\nt : Set \u03b1\nh : t \u2286 insert a s\nhs : a \u2208 t\n\u22a2 t \u2286 insert a s",["assumption","aesop","congr","gcongr","tauto"]],["LinearAlgebra/TensorProduct/Basic.lean",379,"R : Type u_1\ninst\u271d\u00b2\u00b2 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b2\u00b9 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b2\u2070 : Semiring R''\nA : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\nT : Type u_10\ninst\u271d\u00b9\u2079 : AddCommMonoid M\ninst\u271d\u00b9\u2078 : AddCommMonoid N\ninst\u271d\u00b9\u2077 : AddCommMonoid P\ninst\u271d\u00b9\u2076 : AddCommMonoid Q\ninst\u271d\u00b9\u2075 : AddCommMonoid S\ninst\u271d\u00b9\u2074 : AddCommMonoid T\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : Module R N\ninst\u271d\u00b9\u00b9 : Module R Q\ninst\u271d\u00b9\u2070 : Module R S\ninst\u271d\u2079 : Module R T\ninst\u271d\u2078 : DistribMulAction R' M\ninst\u271d\u2077 : Module R'' M\ninst\u271d\u2076 : SMulCommClass R R' M\ninst\u271d\u2075 : SMulCommClass R R'' M\nR'\u2082 : Type u_11\ninst\u271d\u2074 : Monoid R'\u2082\ninst\u271d\u00b3 : DistribMulAction R'\u2082 M\ninst\u271d\u00b2 : SMulCommClass R R'\u2082 M\ninst\u271d\u00b9 : SMul R'\u2082 R'\ninst\u271d : IsScalarTower R'\u2082 R' M\ns : R'\u2082\nr : R'\nx : M \u2297[R] N\n\u22a2 (s \u2022 r) \u2022 0 = s \u2022 r \u2022 0",["simp","aesop","tauto","abel","norm_num"]],["LinearAlgebra/TensorProduct/Basic.lean",662,"R : Type u_1\ninst\u271d\u00b2\u00b9 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b2\u2070 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u2079 : Semiring R''\nA : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\nT : Type u_10\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : AddCommMonoid N\ninst\u271d\u00b9\u2076 : AddCommMonoid P\ninst\u271d\u00b9\u2075 : AddCommMonoid Q\ninst\u271d\u00b9\u2074 : AddCommMonoid S\ninst\u271d\u00b9\u00b3 : AddCommMonoid T\ninst\u271d\u00b9\u00b2 : Module R M\ninst\u271d\u00b9\u00b9 : Module R N\ninst\u271d\u00b9\u2070 : Module R Q\ninst\u271d\u2079 : Module R S\ninst\u271d\u2078 : Module R T\ninst\u271d\u2077 : DistribMulAction R' M\ninst\u271d\u2076 : Module R'' M\ninst\u271d\u2075 : Module R P\ninst\u271d\u2074 : CommSemiring A\ninst\u271d\u00b3 : Module A M\ninst\u271d\u00b2 : Module A N\ninst\u271d\u00b9 : SMulCommClass R A M\ninst\u271d : CompatibleSMul R A M N\nx\u271d\u00b9 x\u271d : M\n\u22a2 \u2200 (x : N),\n    ((fun m \u21a6\n            let __spread.0 := (mk R M N) m;\n            { toAddHom := __spread.0.toAddHom, map_smul' := \u22ef })\n          (x\u271d\u00b9 + x\u271d))\n        x =\n      ((fun m \u21a6\n              let __spread.0 := (mk R M N) m;\n              { toAddHom := __spread.0.toAddHom, map_smul' := \u22ef })\n            x\u271d\u00b9 +\n          (fun m \u21a6\n              let __spread.0 := (mk R M N) m;\n              { toAddHom := __spread.0.toAddHom, map_smul' := \u22ef })\n            x\u271d)\n        x",["simp","aesop","norm_num"]],["RingTheory/Ideal/Operations.lean",1223,"R : Type u\nM : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 \u2200 (b : Submodule R M), 1 \u2022 b = b",["simp","aesop"]],["RingTheory/Ideal/Operations.lean",341,"R : Type u\ninst\u271d\u00b9 : Semiring R\nI J K L : Ideal R\ninst\u271d : I.IsTwoSided\nm n : \u2115\n\u22a2 \u22a4.IsTwoSided",["infer_instance","tauto"]],["RingTheory/Ideal/Operations.lean",816,"R : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nthis : (I * J).radical \u2264 I.radical \u2293 J.radical\n\u22a2 (I * J).radical \u2264 I.radical \u2293 J.radical",["assumption","aesop","congr","gcongr","tauto"]],["MeasureTheory/Measure/Hausdorff.lean",281,"X : Type u_2\ninst\u271d : EMetricSpace X\nm : Set X \u2192 \u211d\u22650\u221e\ns : Set X\nn : \u2115\n\u22a2 (\u2191n)\u207b\u00b9 \u2208 Ioi 0",["simp","aesop","norm_num"]],["Probability/Process/Stopping.lean",431,"case h\n\u03a9 : Type u_1\n\u03b9 : Type u_3\nm : MeasurableSpace \u03a9\ninst\u271d : LinearOrder \u03b9\nf : Filtration \u03b9 m\n\u03c4 : \u03a9 \u2192 \u03b9\nh\u03c4 : IsStoppingTime f \u03c4\ni : \u03b9\n\u03c9 : \u03a9\n\u22a2 \u03c9 \u2208 {\u03c9 | i < \u03c4 \u03c9} \u2194 \u03c9 \u2208 {\u03c9 | \u03c4 \u03c9 \u2264 i}\u1d9c",["simp","aesop","norm_num"]],["Probability/Process/Stopping.lean",278,"case h.intro.intro.intro\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nf : Filtration \u2115 m\n\u03c4 \u03c0 : \u03a9 \u2192 \u2115\nh\u03c4 : IsStoppingTime f \u03c4\nh\u03c0 : IsStoppingTime f \u03c0\ni : \u2115\n\u03c9 : \u03a9\nhj : \u03c0 \u03c9 \u2264 i\nh : \u03c4 \u03c9 + \u03c0 \u03c9 \u2264 i\n\u22a2 \u03c4 \u03c9 + \u03c0 \u03c9 \u2264 i",["assumption","omega","aesop","congr","linarith","gcongr","tauto"]],["Algebra/Order/Module/Defs.lean",941,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedRing \u03b1\ninst\u271d\u00b2 : LinearOrderedAddCommGroup \u03b2\ninst\u271d\u00b9 : Module \u03b1 \u03b2\ninst\u271d : PosSMulStrictMono \u03b1 \u03b2\na : \u03b1\nb : \u03b2\nthis\u271d : a \u2264 0 \u2228 0 \u2264 a\nthis : b \u2264 0 \u2228 0 \u2264 b\n\u22a2 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0 \u2194 (a \u2264 0 \u2228 0 \u2264 b) \u2227 (b \u2264 0 \u2228 0 \u2264 a)",["tauto","aesop"]],["Data/Matroid/Basic.lean",1053,"\u03b1 : Type u_1\nM : Matroid \u03b1\nI J X : Set \u03b1\nhI : M.IsBasis I X\nhJ : M.Indep J\nhIJ : I \u2286 J\n\u22a2 M.Indep J",["assumption","aesop","congr","tauto"]],["Data/Matroid/Basic.lean",862,"\u03b1 : Type u_1\nM : Matroid \u03b1\nI X : Set \u03b1\n\u22a2 ((M.Indep I \u2227 I \u2286 X) \u2227 \u2200 \u2983t : Set \u03b1\u2984, M.Indep t \u2227 t \u2286 X \u2192 I \u2286 t \u2192 I = t) \u2227 X \u2286 M.E \u2194\n    (M.Indep I \u2227 I \u2286 X \u2227 \u2200 \u2983J : Set \u03b1\u2984, M.Indep J \u2192 I \u2286 J \u2192 J \u2286 X \u2192 I = J) \u2227 X \u2286 M.E",["tauto","aesop"]],["Data/Matroid/Basic.lean",1007,"\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\ne : \u03b1\nhI : M.Indep I\n\u22a2 e \u2209 I \u2192 \u00acM.Indep (insert e I) \u2227 e \u2208 M.E \u2194 \u00acM.Indep (insert e I) \u2227 e \u2208 M.E \u2228 e \u2208 I",["tauto"]],["Order/Basic.lean",476,"case refl.refl\n\u03b1 : Type u_2\nA B : Preorder \u03b1\nle\u271d A_lt : \u03b1 \u2192 \u03b1 \u2192 Prop\nle_refl\u271d\u00b9 : \u2200 (a : \u03b1), a \u2264 a\nle_trans\u271d\u00b9 : \u2200 (a b c : \u03b1), a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c\nA_iff : \u2200 (a b : \u03b1), a < b \u2194 a \u2264 b \u2227 \u00acb \u2264 a\nle_refl\u271d : \u2200 (a : \u03b1), a \u2264 a\nle_trans\u271d : \u2200 (a b c : \u03b1), a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c\nB_iff : \u2200 (a b : \u03b1), a < b \u2194 a \u2264 b \u2227 \u00acb \u2264 a\n\u22a2 mk le_refl\u271d\u00b9 le_trans\u271d\u00b9 A_iff = mk le_refl\u271d le_trans\u271d B_iff",["congr","simp"]],["Order/Basic.lean",484,"case mk.mk.refl\n\u03b1 : Type u_2\ntoPreorder\u271d : Preorder \u03b1\nle_antisymm\u271d\u00b9 le_antisymm\u271d : \u2200 (a b : \u03b1), a \u2264 b \u2192 b \u2264 a \u2192 a = b\n\u22a2 mk le_antisymm\u271d\u00b9 = mk le_antisymm\u271d",["congr","simp"]],["Order/Basic.lean",513,"case refl.refl.refl\n\u03b1 : Type u_2\nA B : LinearOrder \u03b1\nA_le A_lt : \u03b1 \u2192 \u03b1 \u2192 Prop\nle_refl\u271d\u00b9 : \u2200 (a : \u03b1), a \u2264 a\nle_trans\u271d\u00b9 : \u2200 (a b c : \u03b1), a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c\nlt_iff_le_not_le\u271d\u00b9 : \u2200 (a b : \u03b1), a < b \u2194 a \u2264 b \u2227 \u00acb \u2264 a\nle_antisymm\u271d\u00b9 : \u2200 (a b : \u03b1), a \u2264 b \u2192 b \u2264 a \u2192 a = b\nA_min A_max : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nA_compare : \u03b1 \u2192 \u03b1 \u2192 Ordering\nle_total\u271d\u00b9 : \u2200 (a b : \u03b1), a \u2264 b \u2228 b \u2264 a\nA_decidableLE : DecidableLE \u03b1\nA_decidableEq : DecidableEq \u03b1\nA_decidableLT : DecidableLT \u03b1\nA_min_def : \u2200 (a b : \u03b1), a \u2293 b = if a \u2264 b then a else b\nA_max_def : \u2200 (a b : \u03b1), a \u2294 b = if a \u2264 b then b else a\nA_compare_canonical : \u2200 (a b : \u03b1), compare a b = compareOfLessAndEq a b\nB_compare : \u03b1 \u2192 \u03b1 \u2192 Ordering\nle_refl\u271d : \u2200 (a : \u03b1), a \u2264 a\nle_trans\u271d : \u2200 (a b c : \u03b1), a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c\nlt_iff_le_not_le\u271d : \u2200 (a b : \u03b1), a < b \u2194 a \u2264 b \u2227 \u00acb \u2264 a\nle_antisymm\u271d : \u2200 (a b : \u03b1), a \u2264 b \u2192 b \u2264 a \u2192 a = b\nle_total\u271d : \u2200 (a b : \u03b1), a \u2264 b \u2228 b \u2264 a\nB_compare_canonical : \u2200 (a b : \u03b1), compare a b = compareOfLessAndEq a b\nB_min_def : \u2200 (a b : \u03b1), a \u2293 b = if a \u2264 b then a else b\nB_max_def : \u2200 (a b : \u03b1), a \u2294 b = if a \u2264 b then b else a\nthis : A_compare = B_compare\n\u22a2 mk le_total\u271d\u00b9 A_decidableLE A_decidableEq A_decidableLT A_min_def A_max_def A_compare_canonical =\n    mk le_total\u271d A_decidableLE A_decidableEq A_decidableLT B_min_def B_max_def B_compare_canonical",["congr"]],["Order/Basic.lean",972,"case neg\n\u03b1 : Type u_2\n\u03b2 : Type u_3\na b : \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ninj : Injective f\ninst\u271d : Decidable (a < b)\nh : compare (f a) (f b) = compareOfLessAndEq (f a) (f b)\nh\u271d\u00b3 : \u00acf a < f b\nh\u271d\u00b2 : f a = f b\nh\u271d\u00b9 : \u00aca < b\nh\u271d : \u00aca = b\nthis : \u00acf a = f b\n\u22a2 False",["contradiction"]],["Order/Basic.lean",974,"case pos\n\u03b1 : Type u_2\n\u03b2 : Type u_3\na b : \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ninj : Injective f\ninst\u271d : Decidable (a < b)\nh : compare (f a) (f b) = compareOfLessAndEq (f a) (f b)\nh\u271d\u00b3 : \u00acf a < f b\nh\u271d\u00b2 : \u00acf a = f b\nh\u271d\u00b9 : \u00aca < b\nh\u271d : a = b\nthis : f a = f b\n\u22a2 False",["contradiction"]],["LinearAlgebra/QuadraticForm/Basic.lean",787,"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nQ : QuadraticMap R M N\nx : M\n\u22a2 2 \u2022 Q x = (2 \u2022 Q) x",["simp","aesop","congr","tauto","norm_num"]],["LinearAlgebra/QuadraticForm/Basic.lean",168,"case mk.mk\nS : Type u_1\nT : Type u_2\nR : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\nA : Type u_7\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\nQ Q' : QuadraticMap R M N\ntoFun\u271d\u00b9 : M \u2192 N\ntoFun_smul\u271d\u00b9 : \u2200 (a : R) (x : M), toFun\u271d\u00b9 (a \u2022 x) = (a * a) \u2022 toFun\u271d\u00b9 x\nexists_companion'\u271d\u00b9 : \u2203 B, \u2200 (x y : M), toFun\u271d\u00b9 (x + y) = toFun\u271d\u00b9 x + toFun\u271d\u00b9 y + (B x) y\ntoFun\u271d : M \u2192 N\ntoFun_smul\u271d : \u2200 (a : R) (x : M), toFun\u271d (a \u2022 x) = (a * a) \u2022 toFun\u271d x\nexists_companion'\u271d : \u2203 B, \u2200 (x y : M), toFun\u271d (x + y) = toFun\u271d x + toFun\u271d y + (B x) y\nh :\n  { toFun := toFun\u271d\u00b9, toFun_smul := toFun_smul\u271d\u00b9, exists_companion' := exists_companion'\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, toFun_smul := toFun_smul\u271d, exists_companion' := exists_companion'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, toFun_smul := toFun_smul\u271d\u00b9, exists_companion' := exists_companion'\u271d\u00b9 } =\n    { toFun := toFun\u271d, toFun_smul := toFun_smul\u271d, exists_companion' := exists_companion'\u271d }",["congr","aesop"]],["LinearAlgebra/QuadraticForm/Basic.lean",100,"M : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : AddCommGroup N\nf : M \u2192 N\nx y : M\n\u22a2 f (x + y) = f x + f y + (f (x + y) - f x - f y)",["abel","aesop","norm_num","simp"]],["LinearAlgebra/QuadraticForm/Basic.lean",296,"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nQ : QuadraticMap R M N\nx : M\n\u22a2 4 \u2022 Q x = (2 * 2) \u2022 Q x",["norm_num","ring","aesop","congr","tauto","abel","simp"]],["Algebra/Order/Floor.lean",802,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na : \u03b1\nm : \u2115\n\u22a2 a + \u2191m - \u2191\u230aa + \u2191m\u230b = fract a",["simp","aesop","norm_num"]],["Algebra/Order/Floor.lean",956,"case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na : \u03b1\n\u22a2 fract a * \u21910 - fract (a * \u21910) = \u21910",["simp","aesop","norm_num"]],["Algebra/Order/Floor.lean",536,"case mk.mk\n\u03b1 : Type u_4\ninst\u271d : LinearOrderedSemiring \u03b1\nfloor\u271d\u00b9 ceil\u271d\u00b9 : \u03b1 \u2192 \u2115\nfloor_of_neg\u271d\u00b9 : \u2200 {a : \u03b1}, a < 0 \u2192 floor\u271d\u00b9 a = 0\ngc_floor\u271d\u00b9 : \u2200 {a : \u03b1} {n : \u2115}, 0 \u2264 a \u2192 (n \u2264 floor\u271d\u00b9 a \u2194 \u2191n \u2264 a)\ngc_ceil\u271d\u00b9 : GaloisConnection ceil\u271d\u00b9 Nat.cast\nfloor\u271d ceil\u271d : \u03b1 \u2192 \u2115\nfloor_of_neg\u271d : \u2200 {a : \u03b1}, a < 0 \u2192 floor\u271d a = 0\ngc_floor\u271d : \u2200 {a : \u03b1} {n : \u2115}, 0 \u2264 a \u2192 (n \u2264 floor\u271d a \u2194 \u2191n \u2264 a)\ngc_ceil\u271d : GaloisConnection ceil\u271d Nat.cast\nthis\u271d : FloorSemiring.ceil = FloorSemiring.ceil\nthis : FloorSemiring.floor = FloorSemiring.floor\n\u22a2 { floor := floor\u271d\u00b9, ceil := ceil\u271d\u00b9, floor_of_neg := floor_of_neg\u271d\u00b9, gc_floor := gc_floor\u271d\u00b9, gc_ceil := gc_ceil\u271d\u00b9 } =\n    { floor := floor\u271d, ceil := ceil\u271d, floor_of_neg := floor_of_neg\u271d, gc_floor := gc_floor\u271d, gc_ceil := gc_ceil\u271d }",["congr","aesop"]],["Algebra/Order/Floor.lean",1409,"case mk.mk\n\u03b1 : Type u_4\ninst\u271d : LinearOrderedRing \u03b1\nfloor\u271d\u00b9 ceil\u271d\u00b9 : \u03b1 \u2192 \u2124\ngc_coe_floor\u271d\u00b9 : GaloisConnection Int.cast floor\u271d\u00b9\ngc_ceil_coe\u271d\u00b9 : GaloisConnection ceil\u271d\u00b9 Int.cast\nfloor\u271d ceil\u271d : \u03b1 \u2192 \u2124\ngc_coe_floor\u271d : GaloisConnection Int.cast floor\u271d\ngc_ceil_coe\u271d : GaloisConnection ceil\u271d Int.cast\nthis\u271d : FloorRing.floor = FloorRing.floor\nthis : FloorRing.ceil = FloorRing.ceil\n\u22a2 { floor := floor\u271d\u00b9, ceil := ceil\u271d\u00b9, gc_coe_floor := gc_coe_floor\u271d\u00b9, gc_ceil_coe := gc_ceil_coe\u271d\u00b9 } =\n    { floor := floor\u271d, ceil := ceil\u271d, gc_coe_floor := gc_coe_floor\u271d, gc_ceil_coe := gc_ceil_coe\u271d }",["congr","aesop"]],["Algebra/Order/Floor.lean",1203,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na : \u03b1\nha : fract a \u2260 0\nthis : \u2191\u2308a\u2309 = \u2191\u230aa\u230b + 1\n\u22a2 fract a = a + 1 - (a - fract a + 1)",["abel","aesop","norm_num","simp"]],["Algebra/Order/Floor.lean",1212,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na : \u03b1\nha : fract a \u2260 0\n\u22a2 \u2191\u2308a\u2309 = a + 1 - (a + 1 - \u2191\u2308a\u2309)",["abel","aesop","norm_num","simp"]],["Algebra/Order/Floor.lean",512,"case refine_3\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorSemiring \u03b1\na : \u03b1\nha : 1 \u2264 a\n\u22a2 1 \u2264 a",["assumption","aesop","congr","linarith","gcongr","tauto"]],["Algebra/Order/Floor.lean",1258,"case refine_3\nk : Type u_4\ninst\u271d\u00b9 : LinearOrderedField k\ninst\u271d : FloorRing k\na : k\nha : 1 \u2264 a\n\u22a2 1 \u2264 a",["assumption","aesop","congr","linarith","gcongr","tauto"]],["Data/Set/Card.lean",411,"case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : IsEmpty \u03b1\n\u22a2 (f '' \u2205).encard \u2264 \u2205.encard",["simp","aesop"]],["Data/Set/Card.lean",341,"\u03b1 : Type u_1\ns : Set \u03b1\nh : s.encard = 3\n\u22a2 3 \u2260 0",["simp","decide","aesop","tauto"]],["Data/Set/Card.lean",331,"\u03b1 : Type u_1\ns : Set \u03b1\nh : s.encard = 2\n\u22a2 2 \u2260 0",["simp","decide","aesop","tauto"]],["Data/Set/Card.lean",315,"\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 (\u2200 (a b : \u03b1), a \u2208 s \u2192 b \u2208 s \u2192 a = b) \u2194 \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 x = y",["tauto","aesop"]],["Data/Set/Card.lean",1005,"\u03b1 : Type u_1\ns : Set \u03b1\nhs : autoParam s.Finite _auto\u271d\n\u22a2 (\u2200 a \u2208 s, \u2200 b \u2208 s, a = b) \u2194 \u2200 {a b : \u03b1}, a \u2208 s \u2192 b \u2208 s \u2192 a = b",["tauto","aesop"]],["GroupTheory/OrderOfElement.lean",1088,"G : Type u_1\ninst\u271d : LinearOrderedRing G\nh : |(-1)| = 1\n\u22a2 (-1) ^ 2 = 1",["simp","aesop"]],["GroupTheory/OrderOfElement.lean",1162,"case intro.intro.intro\nR : Type u_6\ninst\u271d\u00b9 : Ring R\ninst\u271d : Fintype R\np : \u2115\nhp : Fact (Nat.Prime p)\ni : \u2115\nhc : CharP R (p ^ i)\nhn : card R = p ^ i\nhR : \u2200 i_1 \u2264 i, \u2191p ^ i_1 = 0 \u2192 i_1 = i\nhi : i \u2264 i\nhcpn : p ^ i \u2223 p ^ i\n\u22a2 CharP R (p ^ i)",["assumption","omega","aesop","congr","gcongr","tauto","infer_instance"]],["Topology/Bases.lean",237,"\u03b1 : Type u\nt : TopologicalSpace \u03b1\n\u22a2 \u2200 (a : \u03b1) (u : Set \u03b1), a \u2208 u \u2192 IsOpen u \u2192 \u2203 v \u2208 {U | IsOpen U}, a \u2208 v \u2227 v \u2286 u",["tauto","aesop"]],["MeasureTheory/Measure/Prod.lean",898,"case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b9 : SFinite \u03bd\n\u03c1 : Measure (\u03b1 \u00d7 \u03b2)\ninst\u271d : IsZeroOrProbabilityMeasure \u03c1\nh : \u03c1 = 0\n\u22a2 IsZeroOrProbabilityMeasure 0",["infer_instance","tauto"]],["MeasureTheory/Measure/Prod.lean",966,"case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b9 : SFinite \u03bd\n\u03c1 : Measure (\u03b1 \u00d7 \u03b2)\ninst\u271d : IsZeroOrProbabilityMeasure \u03c1\nh : \u03c1 = 0\n\u22a2 IsZeroOrProbabilityMeasure 0",["infer_instance","tauto"]],["Analysis/Calculus/FDeriv/Measurable.lean",704,"case h.e'_3.h.e'_2.h.a\nF : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\nf : \u211d \u2192 F\ninst\u271d : CompleteSpace F\nthis : IsComplete univ\nx\u271d : \u211d\n\u22a2 DifferentiableWithinAt \u211d f (Ici x\u271d) x\u271d \u2194 DifferentiableWithinAt \u211d f (Ici x\u271d) x\u271d \u2227 derivWithin f (Ici x\u271d) x\u271d \u2208 univ",["simp","aesop","tauto","norm_num"]],["Analysis/Calculus/FDeriv/Measurable.lean",259,"case e_a\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\ne p q e' p' q' : \u2115\nhp : n e \u2264 p\nhq : n e \u2264 q\nhp' : n e' \u2264 p'\nhq' : n e' \u2264 q'\nhe' : e \u2264 e'\nr : \u2115 := n e \u2294 n e'\nI : (1 / 2) ^ e' \u2264 (1 / 2) ^ e\nJ1 : \u2016L e p q - L e p r\u2016 \u2264 4 * \u2016c\u2016 * (1 / 2) ^ e\nJ2 : \u2016L e p r - L e' p' r\u2016 \u2264 4 * \u2016c\u2016 * (1 / 2) ^ e\nJ3 : \u2016L e' p' r - L e' p' q'\u2016 \u2264 4 * \u2016c\u2016 * (1 / 2) ^ e\n\u22a2 L e p q - L e' p' q' = L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')",["abel","aesop","norm_num","simp"]],["Analysis/Calculus/FDeriv/Measurable.lean",590,"case e_a\nF : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\ne p q e' p' q' : \u2115\nhp : n e \u2264 p\nhq : n e \u2264 q\nhp' : n e' \u2264 p'\nhq' : n e' \u2264 q'\nhe' : e \u2264 e'\nr : \u2115 := n e \u2294 n e'\nI : (1 / 2) ^ e' \u2264 (1 / 2) ^ e\nJ1 : \u2016L e p q - L e p r\u2016 \u2264 4 * (1 / 2) ^ e\nJ2 : \u2016L e p r - L e' p' r\u2016 \u2264 4 * (1 / 2) ^ e\nJ3 : \u2016L e' p' r - L e' p' q'\u2016 \u2264 4 * (1 / 2) ^ e\n\u22a2 L e p q - L e' p' q' = L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')",["abel","aesop","norm_num","simp"]],["Analysis/Calculus/FDeriv/Measurable.lean",199,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nx : E\nhx : x \u2208 {x | DifferentiableAt \ud835\udd5c f x \u2227 fderiv \ud835\udd5c f x \u2208 K}\ne : \u2115\n\u22a2 0 < (1 / 2) ^ e",["positivity","aesop","norm_num","simp"]],["Analysis/Calculus/FDeriv/Measurable.lean",206,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nx : E\nhx : x \u2208 {x | DifferentiableAt \ud835\udd5c f x \u2227 fderiv \ud835\udd5c f x \u2208 K}\ne : \u2115\nthis : 0 < (1 / 2) ^ e\nR : \u211d\nR_pos : R > 0\nhR : \u2200 r \u2208 Ioo 0 R, x \u2208 A f (fderiv \ud835\udd5c f x) r ((1 / 2) ^ e)\nn : \u2115\nhn : (1 / 2) ^ n < R\np : \u2115\nhp : p \u2265 n\nq : \u2115\nhq : q \u2265 n\n\u22a2 n \u2264 p\n```\n---\n```lean\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nx : E\nhx : x \u2208 {x | DifferentiableAt \ud835\udd5c f x \u2227 fderiv \ud835\udd5c f x \u2208 K}\ne : \u2115\nthis : 0 < (1 / 2) ^ e\nR : \u211d\nR_pos : R > 0\nhR : \u2200 r \u2208 Ioo 0 R, x \u2208 A f (fderiv \ud835\udd5c f x) r ((1 / 2) ^ e)\nn : \u2115\nhn : (1 / 2) ^ n < R\np : \u2115\nhp : p \u2265 n\nq : \u2115\nhq : q \u2265 n\n\u22a2 n \u2264 q",["assumption","omega","aesop","congr","linarith","gcongr","tauto"]],["Analysis/Calculus/FDeriv/Measurable.lean",539,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nx : \u211d\nhx : x \u2208 {x | DifferentiableWithinAt \u211d f (Ici x) x \u2227 derivWithin f (Ici x) x \u2208 K}\ne : \u2115\nthis : 0 < (1 / 2) ^ e\nR : \u211d\nR_pos : R > 0\nhR : \u2200 r \u2208 Ioo 0 R, x \u2208 A f (derivWithin f (Ici x) x) r ((1 / 2) ^ e)\nn : \u2115\nhn : (1 / 2) ^ n < R\np : \u2115\nhp : p \u2265 n\nq : \u2115\nhq : q \u2265 n\n\u22a2 n \u2264 p\n```\n---\n```lean\nF : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nx : \u211d\nhx : x \u2208 {x | DifferentiableWithinAt \u211d f (Ici x) x \u2227 derivWithin f (Ici x) x \u2208 K}\ne : \u2115\nthis : 0 < (1 / 2) ^ e\nR : \u211d\nR_pos : R > 0\nhR : \u2200 r \u2208 Ioo 0 R, x \u2208 A f (derivWithin f (Ici x) x) r ((1 / 2) ^ e)\nn : \u2115\nhn : (1 / 2) ^ n < R\np : \u2115\nhp : p \u2265 n\nq : \u2115\nhq : q \u2265 n\n\u22a2 n \u2264 q",["assumption","omega","aesop","congr","linarith","gcongr","tauto"]],["Analysis/Calculus/FDeriv/Measurable.lean",608,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / 12\ne' : \u2115\nhe' : e' \u2265 e\n\u22a2 0 < 12",["norm_num","aesop","linarith","positivity","simp"]],["SetTheory/Ordinal/Notation.lean",301,"case inl.intro\no\u2081 e\u2081 : ONote\nn\u2081 : \u2115+\na\u2081 : ONote\nh\u271d\u00b9 : o\u2081 = e\u2081.oadd n\u2081 a\u2081\no\u2082 : ONote\nn\u2082 : \u2115+\na\u2082 : ONote\nh\u2081 : (namedPattern o\u2081 (e\u2081.oadd n\u2081 a\u2081) h\u271d\u00b9).NF\nh\u271d : o\u2082 = e\u2081.oadd n\u2082 a\u2082\nh\u2082 : (namedPattern o\u2082 (e\u2081.oadd n\u2082 a\u2082) h\u271d).NF\nleft\u271d : \u2191n\u2081 < \u2191n\u2082\nright\u271d : Ordering.lt = Ordering.gt\n\u22a2 (Ordering.eq.then (Ordering.gt.then (a\u2081.cmp a\u2082))).Compares (namedPattern o\u2081 (e\u2081.oadd n\u2081 a\u2081) h\u271d\u00b9)\n    (namedPattern o\u2082 (e\u2081.oadd n\u2082 a\u2082) h\u271d)",["contradiction","aesop","tauto"]],["SetTheory/Ordinal/Notation.lean",305,"case inr.intro.inr.intro\no\u2081 e\u2081 : ONote\nn\u2081 : \u2115+\na\u2081 : ONote\nh\u271d\u00b9 : o\u2081 = e\u2081.oadd n\u2081 a\u2081\no\u2082 : ONote\nn\u2082 : \u2115+\na\u2082 : ONote\nh\u2081 : (namedPattern o\u2081 (e\u2081.oadd n\u2081 a\u2081) h\u271d\u00b9).NF\nh\u271d : o\u2082 = e\u2081.oadd n\u2082 a\u2082\nh\u2082 : (namedPattern o\u2082 (e\u2081.oadd n\u2082 a\u2082) h\u271d).NF\nleft\u271d\u00b9 : \u2191n\u2082 \u2264 \u2191n\u2081\nleft\u271d : \u00ac\u2191n\u2082 < \u2191n\u2081\nright\u271d : Ordering.eq = Ordering.gt\n\u22a2 (Ordering.eq.then (Ordering.gt.then (a\u2081.cmp a\u2082))).Compares (namedPattern o\u2081 (e\u2081.oadd n\u2081 a\u2081) h\u271d\u00b9)\n    (namedPattern o\u2082 (e\u2081.oadd n\u2082 a\u2082) h\u271d)",["contradiction"]],["SetTheory/Ordinal/Notation.lean",307,"case eq.inl.intro\no\u2081 e\u2081 : ONote\nn\u2081 : \u2115+\na\u2081 : ONote\nh\u271d\u00b9 : o\u2081 = e\u2081.oadd n\u2081 a\u2081\no\u2082 : ONote\nn\u2082 : \u2115+\na\u2082 : ONote\nh\u2081 : (namedPattern o\u2081 (e\u2081.oadd n\u2081 a\u2081) h\u271d\u00b9).NF\nh\u271d : o\u2082 = e\u2081.oadd n\u2082 a\u2082\nh\u2082 : (namedPattern o\u2082 (e\u2081.oadd n\u2082 a\u2082) h\u271d).NF\nleft\u271d : \u2191n\u2081 < \u2191n\u2082\nright\u271d : Ordering.lt = Ordering.eq\n\u22a2 (Ordering.eq.then (Ordering.eq.then (a\u2081.cmp a\u2082))).Compares (namedPattern o\u2081 (e\u2081.oadd n\u2081 a\u2081) h\u271d\u00b9)\n    (namedPattern o\u2082 (e\u2081.oadd n\u2082 a\u2082) h\u271d)",["contradiction"]],["SetTheory/Ordinal/Notation.lean",311,"case eq.inr.intro.inl.intro\no\u2081 e\u2081 : ONote\nn\u2081 : \u2115+\na\u2081 : ONote\nh\u271d\u00b9 : o\u2081 = e\u2081.oadd n\u2081 a\u2081\no\u2082 : ONote\nn\u2082 : \u2115+\na\u2082 : ONote\nh\u2081 : (namedPattern o\u2081 (e\u2081.oadd n\u2081 a\u2081) h\u271d\u00b9).NF\nh\u271d : o\u2082 = e\u2081.oadd n\u2082 a\u2082\nh\u2082 : (namedPattern o\u2082 (e\u2081.oadd n\u2082 a\u2082) h\u271d).NF\nnhl : \u2191n\u2082 \u2264 \u2191n\u2081\nleft\u271d : \u2191n\u2082 < \u2191n\u2081\nright\u271d : Ordering.gt = Ordering.eq\n\u22a2 (Ordering.eq.then (Ordering.eq.then (a\u2081.cmp a\u2082))).Compares (namedPattern o\u2081 (e\u2081.oadd n\u2081 a\u2081) h\u271d\u00b9)\n    (namedPattern o\u2082 (e\u2081.oadd n\u2082 a\u2082) h\u271d)",["contradiction"]],["SetTheory/Ordinal/Notation.lean",756,"case pos\no\u2081 o\u2082 : ONote\ninst\u271d\u00b9 : o\u2081.NF\ninst\u271d : o\u2082.NF\nb' : ONote\nk : \u2115\ne\u2082 : o\u2082.split' = (b', k)\nthis : b'.NF\nna : zero.NF\nm : \u2115\ne\u2081 : o\u2081.split = (zero, m + 1)\nh\u271d : m = 0\n\u22a2 NF 1",["decide","infer_instance"]],["MeasureTheory/Constructions/Polish/Basic.lean",907,"\u03b3 : Type u_3\ns : Set \u03b3\nt\u03b3 : TopologicalSpace \u03b3\ninst\u271d\u00b9 : PolishSpace \u03b3\ninst\u271d : BorelSpace \u03b3\nthis\u271d : MeasurableSpace \u03b3 := borel \u03b3\nt' : TopologicalSpace \u03b3\nt't : t' \u2264 t\u03b3\nt'_polish : PolishSpace \u03b3\nleft\u271d : IsClosed s\ns_open : IsOpen s\n\u22a2 PolishSpace \u03b3",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["NumberTheory/ArithmeticFunction.lean",271,"case h\nR : Type u_1\ninst\u271d : Semiring R\nf g : ArithmeticFunction \u2115\nn : \u2115\n\u22a2 \u2191(f * g) n = (\u2191f * \u2191g) n",["simp","aesop","norm_num"]],["NumberTheory/ArithmeticFunction.lean",881,"\u22a2 \u03a9 0 = 0",["simp","aesop","norm_num"]],["NumberTheory/ArithmeticFunction.lean",221,"case h\nR : Type u_1\ninst\u271d : AddMonoidWithOne R\nx\u271d : \u2115\n\u22a2 (NatCast.natCast 0) x\u271d = 0 x\u271d",["simp","aesop","norm_num"]],["Combinatorics/SimpleGraph/Path.lean",615,"case pos.a\nV : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v u\u271d v\u271d w\u271d : V\nh\u271d\u00b9 : G.Adj u\u271d v\u271d\np\u271d : G.Walk v\u271d w\u271d\nih : p\u271d.bypass.support \u2286 p\u271d.support\nh\u271d : u\u271d \u2208 p\u271d.bypass.support\n\u22a2 p\u271d.bypass.support \u2286 p\u271d.support",["assumption","aesop","congr","gcongr","tauto"]],["Combinatorics/SimpleGraph/Path.lean",618,"case neg.s\nV : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v u\u271d v\u271d w\u271d : V\nh\u271d\u00b9 : G.Adj u\u271d v\u271d\np\u271d : G.Walk v\u271d w\u271d\nih : p\u271d.bypass.support \u2286 p\u271d.support\nh\u271d : u\u271d \u2209 p\u271d.bypass.support\n\u22a2 p\u271d.bypass.support \u2286 p\u271d.support",["assumption"]],["Combinatorics/SimpleGraph/Path.lean",246,"V : Type u\nG : SimpleGraph V\nv : V\np : G.Walk v v\nv\u271d\u00b2 : V\nh\u271d\u00b2 : G.Adj v v\u271d\u00b2\nv\u271d\u00b9 : V\nh\u271d\u00b9 : G.Adj v\u271d\u00b2 v\u271d\u00b9\nv\u271d : V\nh\u271d : G.Adj v\u271d\u00b9 v\u271d\np\u271d : G.Walk v\u271d v\nhp\u271d : (cons h\u271d\u00b2 (cons h\u271d\u00b9 (cons h\u271d p\u271d))).IsCycle\nhp : (cons h\u271d\u00b2 (cons h\u271d\u00b9 (cons h\u271d p\u271d))).IsTrail\nhp' : cons h\u271d\u00b2 (cons h\u271d\u00b9 (cons h\u271d p\u271d)) \u2260 nil\nsupport_nodup\u271d : (cons h\u271d\u00b2 (cons h\u271d\u00b9 (cons h\u271d p\u271d))).support.tail.Nodup\n\u22a2 3 \u2264 p\u271d.length + 1 + 1 + 1",["omega","aesop","simp"]],["Combinatorics/SimpleGraph/Path.lean",324,"V : Type u\nG : SimpleGraph V\nu w : V\ni : \u2115\np : G.Walk u w\nhp : p.IsPath\nhi\u271d : i \u2264 p.length\nh : p.getVert i = u\nhi : \u00aci = 0\n\u22a2 0 \u2264 p.length",["omega","aesop","simp"]],["Combinatorics/SimpleGraph/Path.lean",354,"case cons.intro.intro\nV : Type u\nG : SimpleGraph V\nu v u\u271d v\u271d w\u271d : V\nh : G.Adj u\u271d v\u271d\nq : G.Walk v\u271d w\u271d\nih : Set.InjOn q.getVert {i | i \u2264 q.length} \u2192 q.IsPath\nhinj : Set.InjOn (cons h q).getVert {i | i \u2264 (cons h q).length}\nh' : u\u271d \u2208 q.support\nn : \u2115\nhn : q.getVert n = u\u271d\nhnl : n \u2264 q.length\nthis : n + 1 = 0\n\u22a2 False",["omega","aesop","tauto","contradiction"]],["Combinatorics/SimpleGraph/Path.lean",581,"V : Type u\nG : SimpleGraph V\ninst\u271d : DecidableEq V\nu v u\u271d v\u271d w\u271d : V\nh\u271d\u00b9 : G.Adj u\u271d v\u271d\np\u271d : G.Walk v\u271d w\u271d\nih : p\u271d.bypass.length \u2264 p\u271d.length\nh\u271d : u\u271d \u2208 p\u271d.bypass.support\n\u22a2 p\u271d.bypass.length \u2264 p\u271d.length + 1",["omega","tauto"]],["Combinatorics/SimpleGraph/Path.lean",259,"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk v u\nh : G.Adj u v\nthis : p.support.Nodup \u2192 p.edges.Nodup\n\u22a2 (s(u, v) \u2209 p.edges \u2227 p.edges.Nodup) \u2227 cons h p \u2260 nil \u2227 p.support.Nodup \u2194 p.support.Nodup \u2227 s(u, v) \u2209 p.edges",["tauto","aesop"]],["Analysis/MeanInequalities.lean",752,"\u03b9 : Type u\ns : Finset \u03b9\np : \u211d\nhp : 1 \u2264 p\nw f : \u03b9 \u2192 \u211d\nhw : \u2200 (i : \u03b9), 0 \u2264 w i\nhf : \u2200 (i : \u03b9), 0 \u2264 f i\ni : \u03b9\nx\u271d : i \u2208 s\nthis : 0 \u2264 w i\n\u22a2 0 \u2264 w i",["positivity","aesop","congr","linarith","gcongr","tauto","assumption"]],["Analysis/MeanInequalities.lean",312,"w\u2081 w\u2082 p\u2081 p\u2082 : \u211d\nhw\u2081 : 0 \u2264 w\u2081\nhw\u2082 : 0 \u2264 w\u2082\nhp\u2081 : 0 \u2264 p\u2081\nhp\u2082 : 0 \u2264 p\u2082\nhw : w\u2081 + w\u2082 = 1\n\u22a2 \u2191(\u27e8w\u2081, hw\u2081\u27e9 + \u27e8w\u2082, hw\u2082\u27e9) = \u21911",["assumption","aesop","tauto"]],["Analysis/MeanInequalities.lean",327,"w\u2081 w\u2082 w\u2083 w\u2084 p\u2081 p\u2082 p\u2083 p\u2084 : \u211d\nhw\u2081 : 0 \u2264 w\u2081\nhw\u2082 : 0 \u2264 w\u2082\nhw\u2083 : 0 \u2264 w\u2083\nhw\u2084 : 0 \u2264 w\u2084\nhp\u2081 : 0 \u2264 p\u2081\nhp\u2082 : 0 \u2264 p\u2082\nhp\u2083 : 0 \u2264 p\u2083\nhp\u2084 : 0 \u2264 p\u2084\nhw : w\u2081 + w\u2082 + w\u2083 + w\u2084 = 1\n\u22a2 \u2191(\u27e8w\u2081, hw\u2081\u27e9 + \u27e8w\u2082, hw\u2082\u27e9 + \u27e8w\u2083, hw\u2083\u27e9 + \u27e8w\u2084, hw\u2084\u27e9) = \u21911",["assumption","aesop","tauto"]],["Analysis/MeanInequalities.lean",359,"case h1.hx.hi\n\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 \u211d\nhs : s.Nonempty\nhw : \u2200 i \u2208 s, 0 < w i\nhw' : \u2211 i \u2208 s, w i = 1\nhz : \u2200 i \u2208 s, 0 < z i\np_pos : 0 < \u220f i \u2208 s, (z i)\u207b\u00b9 ^ w i\ns_pos : 0 < \u2211 i \u2208 s, w i * (z i)\u207b\u00b9\nthis : (\u2211 i \u2208 s, w i * (z i)\u207b\u00b9)\u207b\u00b9 \u2264 (\u220f i \u2208 s, (z i)\u207b\u00b9 ^ w i)\u207b\u00b9\np_pos\u2082 : 0 < (\u220f i \u2208 s, z i ^ w i)\u207b\u00b9\ni\u271d : \u03b9\na\u271d : i\u271d \u2208 s\n\u22a2 i\u271d \u2208 s",["assumption","aesop","congr","gcongr","tauto"]],["Data/DFinsupp/Defs.lean",925,"case pos\n\u03b9 : Type u\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192 \u03b2\u2082 i\nhf : \u2200 (i : \u03b9), f i 0 = 0\ni : \u03b9\nb : \u03b2\u2081 i\n\u22a2 (mapRange f hf (single i b)) i = (single i (f i b)) i",["simp","aesop"]],["Data/DFinsupp/Defs.lean",1028,"case h\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\n\u22a2 i \u2208 (-f).support \u2194 i \u2208 f.support",["simp","aesop"]],["Data/Matroid/Closure.lean",163,"\u03b1 : Type u_2\nM : Matroid \u03b1\nX : Set \u03b1\n\u22a2 \u2200 t' \u2208 {F | M.IsFlat F \u2227 X \u2229 M.E \u2286 F}, X \u2229 M.E \u2286 t'",["simp","aesop"]],["Data/Matroid/Closure.lean",518,"\u03b1 : Type u_2\nM : Matroid \u03b1\nI J : Set \u03b1\nh : M.Indep (I \u222a J)\n\u22a2 \u2200 (i : Bool), M.closure (bif i then I else J) = bif i then M.closure I else M.closure J",["simp"]],["Data/Matroid/Closure.lean",369,"\u03b1 : Type u_2\nM : Matroid \u03b1\nI : Set \u03b1\nx : \u03b1\nhI : M.Indep I\nthis : I \u2286 M.E\n\u22a2 \u00acM.Indep (insert x I) \u2227 x \u2208 M.E \u2228 x \u2208 I \u2194 x \u2208 M.E \u2227 (\u00acM.Indep (insert x I) \u2228 x \u2208 I)",["aesop","tauto"]],["Data/Matroid/Closure.lean",383,"\u03b1 : Type u_2\nM : Matroid \u03b1\ne : \u03b1\nI : Set \u03b1\nhI : M.Indep I\nhe : autoParam (e \u2208 M.E) _auto\u271d\n\u22a2 \u00ac(\u00acM.Indep (insert e I) \u2228 e \u2208 I) \u2194 M.Indep (insert e I) \u2227 e \u2209 I",["tauto","aesop","simp"]],["Data/Matroid/Closure.lean",900,"case neg\n\u03b1 : Type u_2\nM : Matroid \u03b1\nX R I : Set \u03b1\nhI : (M \u21be R).IsBasis' I X\nhI' : M.IsBasis' I (X \u2229 R)\nhIR : I \u2286 R\ne : \u03b1\nhe : \u00acM.Indep (insert e I)\n\u22a2 e \u2208 R \u2227 (M.Indep (insert e I) \u2227 insert e I \u2286 R \u2192 e \u2208 I) \u2194\n    (e \u2208 M.E \u2227 (M.Indep (insert e I) \u2192 e \u2208 I)) \u2227 e \u2208 R \u2228 e \u2208 R \u2227 e \u2209 M.E",["tauto"]],["Data/Nat/Init.lean",352,"\u22a2 0 < 0 * 0 \u2194 1 < 0",["simp","omega","decide"]],["Data/Nat/Init.lean",552,"a : \u2115\n\u22a2 a ^ 0 = 0 \u2194 a = 0 \u2227 0 \u2260 0",["simp"]],["Data/Nat/Init.lean",855,"P : \u2115 \u2192 \u2115 \u2192 Prop\nha : \u2200 (a : \u2115), P (a + 1) (a + 1)\nhb : \u2200 (b : \u2115), P 0 (b + 1)\nhd : \u2200 (a b : \u2115), a < b \u2192 P (a + 1) b \u2192 P a (b + 1) \u2192 P (a + 1) (b + 1)\na b : \u2115\nh : a + 1 < b + 1\n\u22a2 a + (b + 1) < a + 1 + (b + 1)",["simp","omega"]],["Data/Nat/Init.lean",79,"n : \u2115\n\u22a2 n.succ.succ \u2260 1",["simp","omega"]],["Data/Nat/Init.lean",117,"n : \u2115\n\u22a2 1 < n + 2 \u2194 n + 2 \u2260 0 \u2227 n + 2 \u2260 1",["omega","simp"]],["Data/Nat/Init.lean",201,"a b : \u2115\n\u22a2 a + b = a \u2194 b = 0",["omega","simp"]],["Data/Nat/Init.lean",202,"a b : \u2115\n\u22a2 a + b = b \u2194 a = 0",["omega","simp"]],["Data/Nat/Init.lean",213,"m n : \u2115\n\u22a2 m + n = 0 \u2194 m = 0 \u2227 n = 0",["omega","simp"]],["Data/Nat/Init.lean",115,"\u22a2 1 < 0 \u2194 0 \u2260 0 \u2227 0 \u2260 1",["decide","omega","simp"]],["Data/Nat/Init.lean",116,"\u22a2 1 < 1 \u2194 1 \u2260 0 \u2227 1 \u2260 1",["decide"]],["Data/Nat/Init.lean",502,"m n\u271d n : \u2115\na\u271d : m / (n + 2) = m\n\u22a2 0 < 2",["decide","omega","simp"]],["Data/Nat/Init.lean",575,"n : \u2115\n\u22a2 1 < 2",["decide","omega","simp"]],["Data/Nat/Init.lean",919,"a n : \u2115\nhp : 1 < a.succ\nhk : 1 < n.succ\nh : a.succ ^ n.succ \u2223 a.succ\nthis\u271d\u2074 : a.succ * a.succ ^ n \u2223 a.succ * 1\nthis\u271d\u00b3 : a.succ ^ n \u2223 1\nhe : a.succ ^ n = 1\nthis\u271d\u00b2 : n < a.succ ^ n\nthis\u271d\u00b9 : n < 1\nthis\u271d : n = 0\nthis : 1 < 1\n\u22a2 \u00ac1 < 1",["decide","omega","contradiction","simp"]],["Order/Atoms.lean",243,"\u03b1 : Type u_2\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 a \u22d6 b \u2194 IsAtom \u27e8b, h\u27e9",["simp","aesop"]],["Order/Atoms.lean",667,"\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : PartialOrder \u03b1\u271d\ninst\u271d\u2074 : BoundedOrder \u03b1\u271d\ninst\u271d\u00b3 : IsSimpleOrder \u03b1\u271d\n\u03b1 : Type u_4\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : BoundedOrder \u03b1\ninst\u271d : IsSimpleOrder \u03b1\n\u22a2 IsSimpleOrder \u03b1",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["Order/Atoms.lean",420,"\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : PartialOrder \u03b1\u271d\n\u03b1 : Type u_4\na b : \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : IsStronglyAtomic \u03b1\ns : Set \u03b1\ninst\u271d : s.OrdConnected\n\u22a2 s.OrdConnected",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["Order/Atoms.lean",423,"\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\u271d\n\u03b1 : Type u_4\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : IsStronglyCoatomic \u03b1\ns : Set \u03b1\nh : s.OrdConnected\n\u22a2 s.OrdConnected",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["Order/Atoms.lean",1116,"p : Prop\n\u22a2 \u00acp \u2192 \u2200 (b : Prop), (p \u2192 b) \u2192 b \u2192 \u00acp \u2192 b",["tauto","aesop"]],["CategoryTheory/Limits/Shapes/Equalizers.lean",1122,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : IsSplitEpi f\n\u22a2 \ud835\udfd9 X \u226b f = (f \u226b section_ f) \u226b f",["simp","aesop"]],["CategoryTheory/Limits/Shapes/Equalizers.lean",658,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\nc : Cofork f g\n\u22a2 c.\u03c0 \u226b \ud835\udfd9 c.pt = c.\u03c0",["simp","aesop"]],["CategoryTheory/Limits/Shapes/Equalizers.lean",594,"case one\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\ns t : Fork f g\nk : s.pt \u27f6 t.pt\nw : k \u226b t.\u03b9 = s.\u03b9\n\u22a2 (k \u226b t.\u03b9) \u226b f = s.\u03b9 \u226b f",["congr","aesop","tauto"]],["CategoryTheory/Limits/Shapes/Equalizers.lean",316,"case zero.one.right\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\nP : C\n\u03b9 : P \u27f6 X\nw : \u03b9 \u226b f = \u03b9 \u226b g\n\u22a2 \u03b9 \u226b f = \u03b9 \u226b g",["assumption","aesop","congr","gcongr","tauto"]],["CategoryTheory/Limits/Shapes/Equalizers.lean",433,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\nt : Fork f g\nlift : (s : Fork f g) \u2192 s.pt \u27f6 t.pt\nfac : \u2200 (s : Fork f g), lift s \u226b t.\u03b9 = s.\u03b9\nuniq : \u2200 (s : Fork f g) (m : s.pt \u27f6 t.pt), m \u226b t.\u03b9 = s.\u03b9 \u2192 m = lift s\ns : Cone (parallelPair f g)\nm : s.pt \u27f6 t.pt\nj : \u2200 (j : WalkingParallelPair), m \u226b t.\u03c0.app j = s.\u03c0.app j\n\u22a2 m = lift s",["aesop","tauto"]],["CategoryTheory/Limits/Shapes/Equalizers.lean",451,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\nt : Cofork f g\ndesc : (s : Cofork f g) \u2192 t.pt \u27f6 s.pt\nfac : \u2200 (s : Cofork f g), t.\u03c0 \u226b desc s = s.\u03c0\nuniq : \u2200 (s : Cofork f g) (m : t.pt \u27f6 s.pt), t.\u03c0 \u226b m = s.\u03c0 \u2192 m = desc s\n\u22a2 \u2200 (s : Cocone (parallelPair f g)) (m : t.pt \u27f6 s.pt),\n    (\u2200 (j : WalkingParallelPair), t.\u03b9.app j \u226b m = s.\u03b9.app j) \u2192 m = desc s",["aesop","tauto"]],["CategoryTheory/Limits/Shapes/Equalizers.lean",640,"case mk.mk.mk\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\npt\u271d\u00b9 : C\n\u03c0\u271d\u00b9 : (Functor.const WalkingParallelPair).obj pt\u271d\u00b9 \u27f6 parallelPair f g\npt\u271d : C\n\u03c0\u271d : (Functor.const WalkingParallelPair).obj pt\u271d \u27f6 parallelPair f g\nhom\u271d : { pt := pt\u271d\u00b9, \u03c0 := \u03c0\u271d\u00b9 }.pt \u27f6 { pt := pt\u271d, \u03c0 := \u03c0\u271d }.pt\nw\u271d : \u2200 (j : WalkingParallelPair), hom\u271d \u226b { pt := pt\u271d, \u03c0 := \u03c0\u271d }.\u03c0.app j = { pt := pt\u271d\u00b9, \u03c0 := \u03c0\u271d\u00b9 }.\u03c0.app j\n\u22a2 { hom := hom\u271d, w := w\u271d }.hom \u226b \u03b9 { pt := pt\u271d, \u03c0 := \u03c0\u271d } = \u03b9 { pt := pt\u271d\u00b9, \u03c0 := \u03c0\u271d\u00b9 }",["aesop","tauto"]],["CategoryTheory/Limits/Shapes/Equalizers.lean",644,"case mk.mk.mk\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nf g : X \u27f6 Y\npt\u271d\u00b9 : C\n\u03b9\u271d\u00b9 : parallelPair f g \u27f6 (Functor.const WalkingParallelPair).obj pt\u271d\u00b9\npt\u271d : C\n\u03b9\u271d : parallelPair f g \u27f6 (Functor.const WalkingParallelPair).obj pt\u271d\nhom\u271d : { pt := pt\u271d\u00b9, \u03b9 := \u03b9\u271d\u00b9 }.pt \u27f6 { pt := pt\u271d, \u03b9 := \u03b9\u271d }.pt\nw\u271d : \u2200 (j : WalkingParallelPair), { pt := pt\u271d\u00b9, \u03b9 := \u03b9\u271d\u00b9 }.\u03b9.app j \u226b hom\u271d = { pt := pt\u271d, \u03b9 := \u03b9\u271d }.\u03b9.app j\n\u22a2 Cofork.\u03c0 { pt := pt\u271d\u00b9, \u03b9 := \u03b9\u271d\u00b9 } \u226b { hom := hom\u271d, w := w\u271d }.hom = Cofork.\u03c0 { pt := pt\u271d, \u03b9 := \u03b9\u271d }",["aesop","tauto"]],["Analysis/Normed/Lp/lpSpace.lean",122,"case inl.hf\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u22a2 {i | 0 i \u2260 0}.Finite",["simp","aesop","norm_num"]],["Analysis/Normed/Lp/lpSpace.lean",186,"\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\np q : \u211d\u22650\u221e\nf : (i : \u03b1) \u2192 E i\nhfq : Mem\u2113p f q\nhpq : q \u2264 p\nhq : 0 < q.toReal\nleft\u271d : 0 < p.toReal\nhpq' : q.toReal \u2264 p.toReal\nhf' : Summable fun i \u21a6 \u2016f i\u2016 ^ q.toReal\n\u22a2 0 < 1",["norm_num","aesop","linarith","positivity","simp"]],["Analysis/Normed/Lp/lpSpace.lean",420,"case inl.h.h\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nf : \u21a5(lp E 0)\nh : \u2016f\u2016 = 0\ni : \u03b1\nthis\u271d : {i | \u00ac\u2191f i = 0} = \u2205\nthis : (\u00ac\u2191f i = 0) = False\n\u22a2 \u2191f i = \u21910 i",["tauto"]],["Analysis/Calculus/ContDiff/FaaDiBruno.lean",917,"\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nm : \u2115\nq : FormalMultilinearSeries \ud835\udd5c F G\np : FormalMultilinearSeries \ud835\udd5c E F\nc : OrderedFinpartition m\ne : E\nv : Fin m \u2192 E\nj : Fin c.length\n\u22a2 update c.partSize j (c.partSize j + 1) j = c.partSize j + 1",["simp","aesop","norm_num"]],["Analysis/Calculus/ContDiff/FaaDiBruno.lean",924,"case h.H.h.e_6.h.h.inr\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nm : \u2115\nq : FormalMultilinearSeries \ud835\udd5c F G\np : FormalMultilinearSeries \ud835\udd5c E F\nc : OrderedFinpartition m\ni : Fin c.length\ne : E\nv : Fin m \u2192 E\nj : Fin c.length\nhij : j \u2260 i\n\u22a2 \u2200 (i_1 : \u2115) (him : i_1 < update c.partSize i (c.partSize i + 1) j) (hin : i_1 < c.partSize j),\n    (cons e v \u2218 succ \u2218 c.emb j \u2218 Fin.cast \u22ef) \u27e8i_1, him\u27e9 = (v \u2218 c.emb j) \u27e8i_1, hin\u27e9",["simp","aesop","tauto","norm_num"]],["Analysis/Calculus/ContDiff/FaaDiBruno.lean",319,"n : \u2115\nc : OrderedFinpartition n\n\u22a2 Nonempty (Fin 1)",["infer_instance","tauto"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",990,"R : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u00b3 : OrderedCommRing R\ninst\u271d\u00b9\u00b2 : StarRing R\ninst\u271d\u00b9\u00b9 : MetricSpace R\ninst\u271d\u00b9\u2070 : IsTopologicalRing R\ninst\u271d\u2079 : ContinuousStar R\ninst\u271d\u2078 : ContinuousSqrt R\ninst\u271d\u2077 : StarOrderedRing R\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : Ring A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : StarOrderedRing A\ninst\u271d\u00b9 : Algebra R A\ninstCFC : ContinuousFunctionalCalculus R p\ninst\u271d : NonnegSpectrumClass R A\nf g : R \u2192 R\na : A\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto\u271d\nhg : autoParam (ContinuousOn g (spectrum R a)) _auto\u271d\nha : autoParam (p a) _auto\u271d\n\u22a2 (\u2200 (a_1 : \u2191(spectrum R a)),\n      { toFun := (spectrum R a).restrict f, continuous_toFun := \u22ef } a_1 \u2264\n        { toFun := (spectrum R a).restrict g, continuous_toFun := \u22ef } a_1) \u2194\n    \u2200 x \u2208 spectrum R a, f x \u2264 g x",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",487,"case h\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : StarRing R\ninst\u271d\u2076 : MetricSpace R\ninst\u271d\u2075 : IsTopologicalSemiring R\ninst\u271d\u2074 : ContinuousStar R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : Algebra R A\ninstCFC : ContinuousFunctionalCalculus R p\n\u03b9 : Type u_3\nf : \u03b9 \u2192 R \u2192 R\na : A\ns : Finset \u03b9\nhf : autoParam (\u2200 i \u2208 s, ContinuousOn (f i) (spectrum R a)) _auto\u271d\nha : p a\nx\u271d : R\n\u22a2 s.sum f x\u271d = \u2211 i \u2208 s, f i x\u271d",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",383,"R : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : StarRing R\ninst\u271d\u2076 : MetricSpace R\ninst\u271d\u2075 : IsTopologicalSemiring R\ninst\u271d\u2074 : ContinuousStar R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : Algebra R A\ninstCFC : ContinuousFunctionalCalculus R p\nr : R\na : A\nha : autoParam (p a) _auto\u271d\n\u22a2 (cfcHom ha) { toFun := (spectrum R a).restrict fun x \u21a6 r, continuous_toFun := \u22ef } =\n    (cfcHom ha) ((algebraMap R C(\u2191(spectrum R a), R)) r)",["congr","aesop","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",452,"case pos\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : StarRing R\ninst\u271d\u2076 : MetricSpace R\ninst\u271d\u2075 : IsTopologicalSemiring R\ninst\u271d\u2074 : ContinuousStar R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : Algebra R A\ninstCFC : ContinuousFunctionalCalculus R p\nf g : R \u2192 R\na : A\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto\u271d\nhg : autoParam (ContinuousOn g (spectrum R a)) _auto\u271d\nha : p a\n\u22a2 (cfcHom ha) { toFun := (spectrum R a).restrict fun x \u21a6 f x * g x, continuous_toFun := \u22ef } =\n    (cfcHom ha)\n      ({ toFun := (spectrum R a).restrict f, continuous_toFun := \u22ef } *\n        { toFun := (spectrum R a).restrict g, continuous_toFun := \u22ef })",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",459,"R : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : StarRing R\ninst\u271d\u2076 : MetricSpace R\ninst\u271d\u2075 : IsTopologicalSemiring R\ninst\u271d\u2074 : ContinuousStar R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : Algebra R A\ninstCFC : ContinuousFunctionalCalculus R p\nf : R \u2192 R\nn : \u2115\na : A\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto\u271d\nha : autoParam (p a) _auto\u271d\n\u22a2 (cfcHom ha) { toFun := (spectrum R a).restrict fun x \u21a6 f x ^ n, continuous_toFun := \u22ef } =\n    (cfcHom ha) ({ toFun := (spectrum R a).restrict f, continuous_toFun := \u22ef } ^ n)",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",466,"case pos\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : StarRing R\ninst\u271d\u2076 : MetricSpace R\ninst\u271d\u2075 : IsTopologicalSemiring R\ninst\u271d\u2074 : ContinuousStar R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : Algebra R A\ninstCFC : ContinuousFunctionalCalculus R p\na : A\nf g : R \u2192 R\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto\u271d\nhg : autoParam (ContinuousOn g (spectrum R a)) _auto\u271d\nha : p a\n\u22a2 (cfcHom ha) { toFun := (spectrum R a).restrict fun x \u21a6 f x + g x, continuous_toFun := \u22ef } =\n    (cfcHom ha)\n      ({ toFun := (spectrum R a).restrict f, continuous_toFun := \u22ef } +\n        { toFun := (spectrum R a).restrict g, continuous_toFun := \u22ef })",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",512,"case pos\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u00b3 : CommSemiring R\ninst\u271d\u00b9\u00b2 : StarRing R\ninst\u271d\u00b9\u00b9 : MetricSpace R\ninst\u271d\u00b9\u2070 : IsTopologicalSemiring R\ninst\u271d\u2079 : ContinuousStar R\ninst\u271d\u2078 : TopologicalSpace A\ninst\u271d\u2077 : Ring A\ninst\u271d\u2076 : StarRing A\ninst\u271d\u2075 : Algebra R A\ninstCFC : ContinuousFunctionalCalculus R p\nS : Type u_3\ninst\u271d\u2074 : SMul S R\ninst\u271d\u00b3 : ContinuousConstSMul S R\ninst\u271d\u00b2 : SMulZeroClass S A\ninst\u271d\u00b9 : IsScalarTower S R A\ninst\u271d : IsScalarTower S R (R \u2192 R)\ns : S\nf : R \u2192 R\na : A\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto\u271d\nha : p a\n\u22a2 (cfcHom ha) { toFun := (spectrum R a).restrict ((s \u2022 1) \u2022 f), continuous_toFun := \u22ef } =\n    (cfcHom ha) ((s \u2022 1) \u2022 { toFun := (spectrum R a).restrict f, continuous_toFun := \u22ef })",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",524,"case pos.intro\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : StarRing R\ninst\u271d\u2076 : MetricSpace R\ninst\u271d\u2075 : IsTopologicalSemiring R\ninst\u271d\u2074 : ContinuousStar R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : Algebra R A\ninstCFC : ContinuousFunctionalCalculus R p\nf : R \u2192 R\na : A\nha : p a\nhf : ContinuousOn f (spectrum R a)\n\u22a2 (cfcHom ha) { toFun := (spectrum R a).restrict fun x \u21a6 star (f x), continuous_toFun := \u22ef } =\n    (cfcHom ha) (star { toFun := (spectrum R a).restrict f, continuous_toFun := \u22ef })",["congr","aesop","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",843,"case pos\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : StarRing R\ninst\u271d\u2077 : MetricSpace R\ninst\u271d\u2076 : IsTopologicalRing R\ninst\u271d\u2075 : ContinuousStar R\ninst\u271d\u2074 : TopologicalSpace A\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : ContinuousFunctionalCalculus R p\nf g : R \u2192 R\na : A\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto\u271d\nhg : autoParam (ContinuousOn g (spectrum R a)) _auto\u271d\nha : p a\n\u22a2 (cfcHom ha) { toFun := (spectrum R a).restrict fun x \u21a6 f x - g x, continuous_toFun := \u22ef } =\n    (cfcHom ha)\n      ({ toFun := (spectrum R a).restrict f, continuous_toFun := \u22ef } -\n        { toFun := (spectrum R a).restrict g, continuous_toFun := \u22ef })",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",850,"case pos.intro\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : StarRing R\ninst\u271d\u2077 : MetricSpace R\ninst\u271d\u2076 : IsTopologicalRing R\ninst\u271d\u2075 : ContinuousStar R\ninst\u271d\u2074 : TopologicalSpace A\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : ContinuousFunctionalCalculus R p\nf : R \u2192 R\na : A\nha : p a\nhf : ContinuousOn f (spectrum R a)\n\u22a2 (cfcHom ha) { toFun := (spectrum R a).restrict fun x \u21a6 -f x, continuous_toFun := \u22ef } =\n    (cfcHom ha) (-{ toFun := (spectrum R a).restrict f, continuous_toFun := \u22ef })",["congr","tauto","abel"]],["NumberTheory/NumberField/Embeddings.lean",1099,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u03b6 : K\nk : \u2115\nhk : 2 < k\nh\u03b6 : IsPrimitiveRoot \u03b6 k\nx\u271d : { w // w.IsReal }\nw : NumberField.InfinitePlace K\nhwreal : NumberField.ComplexEmbedding.IsReal w.embedding\nf : K \u2192+* \u2102 := w.embedding\nh\u03b6' : IsPrimitiveRoot (f \u03b6) k\n\u22a2 (NumberField.ComplexEmbedding.conjugate f) \u03b6 = f \u03b6",["congr","tauto"]],["MeasureTheory/Function/UniformIntegrable.lean",580,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\np : \u211d\u22650\u221e\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nhf : \u2200 (n : \u2115), MemLp (f n) p \u03bc\nhg : MemLp g p \u03bc\nhfg : Tendsto (fun n \u21a6 eLpNorm (f n - g) p \u03bc) atTop (\ud835\udcdd 0)\nn : \u2115\n\u22a2 f n = ((fun x \u21a6 g) + fun n \u21a6 f n - g) n",["simp","aesop","norm_num"]],["MeasureTheory/Function/UniformIntegrable.lean",493,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup \u03b2\np : \u211d\u22650\u221e\ninst\u271d : IsFiniteMeasure \u03bc\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\nhf : \u2200 (n : \u2115), StronglyMeasurable (f n)\nhg : StronglyMeasurable g\nhg' : MemLp g p \u03bc\nhui : UnifIntegrable f p \u03bc\nhfg : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n \u21a6 f n x) atTop (\ud835\udcdd (g x))\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 > 0\nh : \u03b5 < \u22a4\nh\u03bc : \u00ac\u03bc = 0\nh\u03b5' : 0 < \u03b5.toReal / 3\n\u22a2 0 \u2264 1 / p.toReal",["positivity","aesop","norm_num","simp"]],["MeasureTheory/Function/UniformIntegrable.lean",457,"case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup \u03b2\np : \u211d\u22650\u221e\ninst\u271d : Finite \u03b9\nhp_one : 1 \u2264 p\nhp_top : p \u2260 \u22a4\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : \u2200 (i : \u03b9), MemLp (f i) p \u03bc\nn : \u2115\nhn : Nonempty (\u03b9 \u2243 Fin n)\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\ng : Fin n \u2192 \u03b1 \u2192 \u03b2 := f \u2218 \u21d1hn.some.symm\nhg : \u2200 (i : Fin n), MemLp (g i) p \u03bc\n\u03b4 : \u211d\nh\u03b4pos : 0 < \u03b4\ni : \u03b9\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2264 ENNReal.ofReal \u03b4\nh\u03b4 : eLpNorm (s.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5\n\u22a2 eLpNorm (s.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5",["assumption","aesop","congr","gcongr","tauto"]],["MeasureTheory/Function/UniformIntegrable.lean",389,"case intro.intro.ha\u2080\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\np : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u03b2\nhp_one : 1 \u2264 p\nhp_top : p \u2260 \u22a4\nhf : MemLp f p \u03bc\nhmeas : StronglyMeasurable f\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u03b4 : \u211d\nh\u03b4pos : 0 < \u03b4\nh\u03b4 : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s \u2264 ENNReal.ofReal \u03b4 \u2192 eLpNorm (s.indicator f) p \u03bc \u2264 2 * ENNReal.ofReal (\u03b5 / 2)\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2264 ENNReal.ofReal \u03b4\n\u22a2 2 \u2260 0\n```\n---\n```lean\ncase intro.intro.ha\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\np : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u03b2\nhp_one : 1 \u2264 p\nhp_top : p \u2260 \u22a4\nhf : MemLp f p \u03bc\nhmeas : StronglyMeasurable f\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u03b4 : \u211d\nh\u03b4pos : 0 < \u03b4\nh\u03b4 : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s \u2264 ENNReal.ofReal \u03b4 \u2192 eLpNorm (s.indicator f) p \u03bc \u2264 2 * ENNReal.ofReal (\u03b5 / 2)\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2264 ENNReal.ofReal \u03b4\n\u22a2 2 \u2260 \u22a4",["norm_num","aesop","simp"]],["MeasureTheory/Function/UniformIntegrable.lean",492,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup \u03b2\np : \u211d\u22650\u221e\ninst\u271d : IsFiniteMeasure \u03bc\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\nhf : \u2200 (n : \u2115), StronglyMeasurable (f n)\nhg : StronglyMeasurable g\nhg' : MemLp g p \u03bc\nhui : UnifIntegrable f p \u03bc\nhfg : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n \u21a6 f n x) atTop (\ud835\udcdd (g x))\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 > 0\nh : \u03b5 < \u22a4\nh\u03bc : \u00ac\u03bc = 0\n\u22a2 0 < 3",["norm_num","aesop","linarith","positivity","simp"]],["MeasureTheory/Function/UniformIntegrable.lean",630,"case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\np : \u211d\u22650\u221e\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : \u2200 (i : \u03b9), StronglyMeasurable (f i)\nh : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 C, 0 < C \u2227 \u2200 (i : \u03b9), eLpNorm ({x | C \u2264 \u2016f i x\u2016\u208a}.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5\nhpzero : p \u2260 0\nh\u03bc : \u00ac\u03bc univ = 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nC : \u211d\u22650\nhCpos : 0 < C\nhC : \u2200 (i : \u03b9), eLpNorm ({x | C \u2264 \u2016f i x\u2016\u208a}.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal (\u03b5 / 2)\ni : \u03b9\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2264 ENNReal.ofReal ((\u03b5 / (2 * \u2191C)) ^ p.toReal)\nh\u03bcs' : \u03bc s = 0\n\u22a2 0 \u2264 ENNReal.ofReal \u03b5",["norm_num","aesop","positivity","simp"]],["Data/Set/Basic.lean",252,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 IsRefl (Set \u03b1) fun x1 x2 \u21a6 x1 \u2264 x2",["infer_instance","tauto"]],["Data/Set/Basic.lean",1421,"\u03b1 : Type u\ns t : Set \u03b1\na b : \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : Decidable (p a)\n\u22a2 Decidable (a \u2208 {a | p a})",["assumption","omega","aesop","congr","tauto","infer_instance"]],["Data/Set/Basic.lean",195,"\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\np : \u03b1 \u2192 \u03b2 \u2192 Prop\n\u22a2 (\u2200 a \u2208 s, \u2200 (b : \u03b2), p a b) \u2194 \u2200 (b : \u03b2), \u2200 a \u2208 s, p a b",["tauto","aesop"]],["Data/Set/Basic.lean",1342,"case h\n\u03b1 : Type u\nt s\u2081 s\u2082 s\u2081' s\u2082' : Set \u03b1\nx : \u03b1\n\u22a2 (x \u2208 s\u2081 \u2227 x \u2208 s\u2082) \u2227 x \u2208 t \u2228 (x \u2208 s\u2081' \u2227 x \u2208 s\u2082') \u2227 x \u2209 t \u2194\n    (x \u2208 s\u2081 \u2227 x \u2208 t \u2228 x \u2208 s\u2081' \u2227 x \u2209 t) \u2227 (x \u2208 s\u2082 \u2227 x \u2208 t \u2228 x \u2208 s\u2082' \u2227 x \u2209 t)",["tauto","aesop"]],["Analysis/SpecialFunctions/Pow/Real.lean",211,"x : \u211d\nhx : 0 \u2264 x\ny z : \u211d\nH : 0 = x\nh : y + z = 0\n\u22a2 1 * 1 = 1",["simp","ring","aesop","linarith","norm_num"]],["Analysis/SpecialFunctions/Pow/Real.lean",982,"case inl\nx : \u211d\nh : 0 \u2264 x\n\u22a2 x = x ^ (1 / 2 * \u21912)",["norm_num","aesop","simp"]],["Analysis/SpecialFunctions/Pow/Real.lean",87,"x : \u211d\nhx : x < 0\ny : \u211d\nthis : Complex.log \u2191x * \u2191y = \u2191(log (-x) * y) + \u2191(y * \u03c0) * Complex.I\n\u22a2 rexp (log x * y) * cos (y * \u03c0) + ((\u2191(rexp (log x * y) * sin (y * \u03c0))).re * 0 - 0 * Complex.I.im) =\n    rexp (log x * y) * cos (y * \u03c0)",["ring","aesop","linarith","norm_num","simp"]],["Data/List/Basic.lean",1251,"\u03b1 : Type u\nl : List \u03b1\ni : Fin l.attach.length\n\u22a2 \u2191(l.attach.get i) = l.get \u27e8\u2191i, \u22ef\u27e9",["simp","omega","aesop"]],["Data/List/Basic.lean",989,"case nil\n\u03b1 : Type u\n\u03b2 : Type v\nm : Type v \u2192 Type w\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nf : \u03b2 \u2192 \u03b1 \u2192 m \u03b2\nb : \u03b2\nmb\u271d : m \u03b2\n\u22a2 (do\n      let b \u2190 mb\u271d\n      foldlM f b []) =\n    foldl\n      (fun mb a \u21a6 do\n        let b \u2190 mb\n        f b a)\n      mb\u271d []",["simp","aesop"]],["Data/List/Basic.lean",345,"case h\n\u03b1 : Type u\na b : \u03b1\nl : List \u03b1\nx : \u03b1\nhx : x \u2208 (b :: l).getLast?\nw\u271d : b :: l \u2260 []\nh\u2082 : x = (b :: l).getLast w\u271d\n\u22a2 x = (a :: b :: l).getLast \u22ef",["assumption","aesop","congr","tauto"]],["Data/List/Basic.lean",353,"\u03b1 : Type u\nx y : \u03b1\nx\u271d : x \u2208 [].getLast?\n\u22a2 x \u2208 [y].getLast?",["contradiction","aesop","tauto"]],["Data/List/Basic.lean",379,"\u03b1 : Type u\nl\u2081 : List \u03b1\nhl\u2082 : [] \u2260 []\n\u22a2 (l\u2081 ++ []).getLast? = [].getLast?",["contradiction","aesop","tauto"]],["Data/List/Basic.lean",444,"\u03b1 : Type u\na : \u03b1\nh : a \u2208 [].head?\n\u22a2 a :: [].tail = []",["contradiction","aesop","tauto"]],["Data/List/Basic.lean",450,"\u03b1 : Type u\ninst\u271d : Inhabited \u03b1\nh : [] \u2260 []\n\u22a2 [].head! \u2208 [].head?",["contradiction","aesop","tauto"]],["Order/Hom/Basic.lean",180,"F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b3 : LE \u03b1\ninst\u271d\u00b2 : LE \u03b2\ninst\u271d\u00b9 : EquivLike F \u03b1 \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na b : \u03b2\n\u22a2 EquivLike.inv f b \u2264 EquivLike.inv f a \u2194 b \u2264 a",["simp","aesop"]],["Order/Hom/Basic.lean",216,"case mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b3\ninst\u271d : Preorder \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmonotone'\u271d\u00b9 : Monotone toFun\u271d\u00b9\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmonotone'\u271d : Monotone toFun\u271d\nh : { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, monotone' := monotone'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 } = { toFun := toFun\u271d, monotone' := monotone'\u271d }",["congr","aesop"]],["Order/Hom/Basic.lean",741,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : LE \u03b2\ninst\u271d : LE \u03b3\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\ninvFun\u271d\u00b9 : \u03b2 \u2192 \u03b1\nleft_inv\u271d\u00b9 : Function.LeftInverse invFun\u271d\u00b9 toFun\u271d\u00b9\nright_inv\u271d\u00b9 : Function.RightInverse invFun\u271d\u00b9 toFun\u271d\u00b9\nmap_rel_iff'\u271d\u00b9 :\n  \u2200 {a b : \u03b1},\n    { toFun := toFun\u271d\u00b9, invFun := invFun\u271d\u00b9, left_inv := left_inv\u271d\u00b9, right_inv := right_inv\u271d\u00b9 } a \u2264\n        { toFun := toFun\u271d\u00b9, invFun := invFun\u271d\u00b9, left_inv := left_inv\u271d\u00b9, right_inv := right_inv\u271d\u00b9 } b \u2194\n      a \u2264 b\ntoFun\u271d : \u03b1 \u2192 \u03b2\ninvFun\u271d : \u03b2 \u2192 \u03b1\nleft_inv\u271d : Function.LeftInverse invFun\u271d toFun\u271d\nright_inv\u271d : Function.RightInverse invFun\u271d toFun\u271d\nmap_rel_iff'\u271d :\n  \u2200 {a b : \u03b1},\n    { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d } a \u2264\n        { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d } b \u2194\n      a \u2264 b\nh\u2081 :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d\u00b9, invFun := invFun\u271d\u00b9, left_inv := left_inv\u271d\u00b9, right_inv := right_inv\u271d\u00b9,\n        map_rel_iff' := map_rel_iff'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d,\n        map_rel_iff' := map_rel_iff'\u271d }\nh\u2082 :\n  (fun f \u21a6 f.invFun)\n      { toFun := toFun\u271d\u00b9, invFun := invFun\u271d\u00b9, left_inv := left_inv\u271d\u00b9, right_inv := right_inv\u271d\u00b9,\n        map_rel_iff' := map_rel_iff'\u271d\u00b9 } =\n    (fun f \u21a6 f.invFun)\n      { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d,\n        map_rel_iff' := map_rel_iff'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, invFun := invFun\u271d\u00b9, left_inv := left_inv\u271d\u00b9, right_inv := right_inv\u271d\u00b9,\n      map_rel_iff' := map_rel_iff'\u271d\u00b9 } =\n    { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d, map_rel_iff' := map_rel_iff'\u271d }",["congr","aesop"]],["Analysis/Calculus/ContDiff/FTaylorSeries.lean",370,"\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ns : Set E\nf : E \u2192 F\nn : WithTop \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u22a2 \u221e \u2264 \u221e + 1",["simp","decide","aesop","norm_num"]],["Analysis/Calculus/ContDiff/FTaylorSeries.lean",847,"case zero.h.H\n\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nx\u271d : Fin 0 \u2192 E\n\u22a2 (iteratedFDerivWithin \ud835\udd5c 0 f univ x) x\u271d = (iteratedFDeriv \ud835\udd5c 0 f x) x\u271d",["simp","aesop","tauto","abel","norm_num"]],["Analysis/Calculus/ContDiff/FTaylorSeries.lean",369,"\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ns : Set E\nf : E \u2192 F\nn : WithTop \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u22a2 \u221e \u2264 \u03c9 + 1",["simp","decide","aesop","tauto","norm_num"]],["MeasureTheory/Constructions/BorelSpace/Order.lean",530,"case hf\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Iic x)\n\u22a2 \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Iic x)",["assumption","aesop","congr","tauto"]],["MeasureTheory/Constructions/BorelSpace/Order.lean",535,"case hf\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Ici x)\n\u22a2 \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Ici x)",["assumption","aesop","congr","tauto"]],["Data/Fin/Tuple/Basic.lean",172,"case pos\nn : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\nj : Fin (n + 1)\nh : j = 0\n\u22a2 cons (q 0) (tail q) 0 = q 0",["simp","aesop","tauto"]],["Data/Fin/Tuple/Basic.lean",655,"case neg\nn : \u2115\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\ng : \u03b1 \u2192 \u03b2\nq : Fin n \u2192 \u03b1\ny : \u03b1\nj : Fin (n + 1)\nh : \u00ac\u2191j < n\n\u22a2 (g \u2218 snoc q y) (last n) = snoc (g \u2218 q) (g y) (last n)",["simp","aesop"]],["Data/Fin/Tuple/Basic.lean",554,"n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u_1\nx : \u03b1 (last n)\np : (i : Fin n) \u2192 \u03b1 i.castSucc\ni : Fin n\ny : \u03b1 i.castSucc\nj : Fin (n + 1)\nh : \u2191j < n\nh' : j = i.castSucc\nC1 : \u03b1 i.castSucc = \u03b1 j\n\u22a2 update (snoc p x) j (cast C1 y) j = cast C1 y",["simp","aesop"]],["Data/Fin/Tuple/Basic.lean",188,"m n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Sort u\nx : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d i.succ\ni : Fin n\ny : \u03b1\u271d i.succ\nz : \u03b1\u271d 0\n\u03b1 : Fin (n + 1) \u2192 Type u_1\nf : (i : Fin (n + 1)) \u2192 \u03b1 i\n\u22a2 (fun f \u21a6 cons f.1 f.2) ((fun f \u21a6 (f 0, tail f)) f) = f",["simp","aesop"]],["Data/Fin/Tuple/Basic.lean",997,"m n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Sort u_1\n\u03b2 : Sort u_2\n\u03b1 : Fin (n + 1) \u2192 Type u\np : Fin (n + 1)\nf : (i : Fin (n + 1)) \u2192 \u03b1 i\n\u22a2 (fun f \u21a6 p.insertNth f.1 f.2) ((fun f \u21a6 (f p, p.removeNth f)) f) = f",["simp","aesop"]],["Data/Fin/Tuple/Basic.lean",201,"n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Sort u\nP : ((i : Fin n.succ) \u2192 \u03b1 i) \u2192 Sort v\nh : (x\u2080 : \u03b1 0) \u2192 (x : (i : Fin n) \u2192 \u03b1 i.succ) \u2192 P (cons x\u2080 x)\nx\u2080 : \u03b1 0\nx : (i : Fin n) \u2192 \u03b1 i.succ\n\u22a2 h (cons x\u2080 x 0) (tail (cons x\u2080 x)) = h x\u2080 x",["congr","aesop","tauto"]],["Data/Fin/Tuple/Basic.lean",706,"case neg\nm n : \u2115\n\u03b1 : Sort u_2\nas : Fin n \u2192 \u03b1\nbs : Fin m \u2192 \u03b1\nb : \u03b1\ni : \u2115\nisLt : i < n + (m + 1)\nlt_n : i < n\nlt_add : \u00aci < n + m\nthis : i < n + m\n\u22a2 as \u27e8i, \u22ef\u27e9 = b",["contradiction","omega","aesop","tauto"]],["Data/Fin/Tuple/Basic.lean",710,"case pos\nm n : \u2115\n\u03b1 : Sort u_2\nas : Fin n \u2192 \u03b1\nbs : Fin m \u2192 \u03b1\nb : \u03b1\ni : \u2115\nisLt : i < n + (m + 1)\nlt_n : \u00aci < n\nsub_lt : \u00aci - n < m\nlt_add : i < n + m\nthis : i - n < m\n\u22a2 b = bs \u27e8i - n, \u22ef\u27e9",["contradiction"]],["Geometry/Euclidean/Angle/Oriented/Basic.lean",509,"case h.e'_2\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhn : x \u2260 y\nh : \u2016x\u2016 = \u2016y\u2016\nhy : y \u2260 0\nhx : x \u2260 0\n\u22a2 o.oangle (-y) (-x) + o.oangle x (x - y) + o.oangle (y - x) y =\n    o.oangle (-y) (-x) + o.oangle x (-(y - x)) + o.oangle (y - x) (- -y)",["simp","aesop","norm_num"]],["Geometry/Euclidean/Angle/Oriented/Basic.lean",76,"case h.e'_2.h.h.e'_1.hx\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\ne_1\u271d : Real.Angle = (\u211d \u29f8 AddSubgroup.zmultiples (2 * \u03c0))\n\u22a2 0 \u2264 \u2016x\u2016 ^ 2",["positivity","aesop","norm_num","simp"]],["LinearAlgebra/Dual/Lemmas.lean",400,"case h\nK : Type u\nV : Type v\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nW : Subspace K V\nx\u271d : V\n\u22a2 (\u2200 \u03c6 \u2208 dualAnnihilator W, \u03c6 x\u271d = 0) \u2194 x\u271d \u2208 comap (Dual.eval K V) (dualAnnihilator W).dualAnnihilator",["simp","aesop","norm_num"]],["Analysis/Fourier/FourierTransformDeriv.lean",414,"case hab\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : NormedSpace \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup W\ninst\u271d : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\nK : WithTop \u2115\u221e\nC : \u211d\nhf : ContDiff \u211d K f\nn k : \u2115\nhk : \u2191k \u2264 K\nv : V\nhv : \u2200 i \u2264 k, \u2200 j \u2264 n, \u2016v\u2016 ^ j * \u2016iteratedFDeriv \u211d i f v\u2016 \u2264 C\nT : ContinuousMultilinearMap \u211d (fun i \u21a6 W \u2192L[\u211d] \u211d) (ContinuousMultilinearMap \u211d (fun i \u21a6 W) \u211d) :=\n  (ContinuousMultilinearMap.mkPiAlgebra \u211d (Fin n) \u211d).compContinuousLinearMapLRight\nI\u2081 : \u2200 (m : \u2115), \u2016iteratedFDeriv \u211d m \u21d1T fun x \u21a6 L v\u2016 \u2264 \u2191(n.descFactorial m) * 1 * (\u2016L\u2016 * \u2016v\u2016) ^ (n - m)\nI\u2082 :\n  \u2200 (m : \u2115),\n    \u2016iteratedFDeriv \u211d m (\u21d1T \u2218 \u21d1(ContinuousLinearMap.pi fun x \u21a6 L)) v\u2016 \u2264\n      \u2191(n.descFactorial m) * 1 * (\u2016L\u2016 * \u2016v\u2016) ^ (n - m) * \u2016L\u2016 ^ m\nI\u2083 :\n  \u2200 (m : \u2115),\n    \u2016iteratedFDeriv \u211d m (\u21d1T \u2218 \u21d1(ContinuousLinearMap.pi fun x \u21a6 L)) v\u2016 \u2264 \u2191(n.descFactorial m) * \u2016L\u2016 ^ n * \u2016v\u2016 ^ (n - m)\nA : ContDiff \u211d K fun y \u21a6 T fun x \u21a6 L y\ni : \u2115\nhi : i \u2208 Finset.range (k + 1)\n\u22a2 n \u2264 n + 1",["omega","aesop","linarith","tauto","norm_num","simp"]],["Analysis/Fourier/FourierTransformDeriv.lean",416,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : NormedSpace \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup W\ninst\u271d : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\nK : WithTop \u2115\u221e\nC : \u211d\nhf : ContDiff \u211d K f\nn k : \u2115\nhk : \u2191k \u2264 K\nv : V\nhv : \u2200 i \u2264 k, \u2200 j \u2264 n, \u2016v\u2016 ^ j * \u2016iteratedFDeriv \u211d i f v\u2016 \u2264 C\nT : ContinuousMultilinearMap \u211d (fun i \u21a6 W \u2192L[\u211d] \u211d) (ContinuousMultilinearMap \u211d (fun i \u21a6 W) \u211d) :=\n  (ContinuousMultilinearMap.mkPiAlgebra \u211d (Fin n) \u211d).compContinuousLinearMapLRight\nI\u2081 : \u2200 (m : \u2115), \u2016iteratedFDeriv \u211d m \u21d1T fun x \u21a6 L v\u2016 \u2264 \u2191(n.descFactorial m) * 1 * (\u2016L\u2016 * \u2016v\u2016) ^ (n - m)\nI\u2082 :\n  \u2200 (m : \u2115),\n    \u2016iteratedFDeriv \u211d m (\u21d1T \u2218 \u21d1(ContinuousLinearMap.pi fun x \u21a6 L)) v\u2016 \u2264\n      \u2191(n.descFactorial m) * 1 * (\u2016L\u2016 * \u2016v\u2016) ^ (n - m) * \u2016L\u2016 ^ m\nI\u2083 :\n  \u2200 (m : \u2115),\n    \u2016iteratedFDeriv \u211d m (\u21d1T \u2218 \u21d1(ContinuousLinearMap.pi fun x \u21a6 L)) v\u2016 \u2264 \u2191(n.descFactorial m) * \u2016L\u2016 ^ n * \u2016v\u2016 ^ (n - m)\nA : ContDiff \u211d K fun y \u21a6 T fun x \u21a6 L y\ni : \u2115\nhi : i \u2208 Finset.range (k + 1)\n\u22a2 n - i \u2264 n",["omega","aesop","norm_num","simp"]],["Probability/StrongLaw.lean",776,"case e_a\n\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d\u2075 : IsProbabilityMeasure \u03bc\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : CompleteSpace E\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : BorelSpace E\nX : \u2115 \u2192 \u03a9 \u2192 E\nhint : Integrable (X 0) \u03bc\nh' : StronglyMeasurable (X 0)\nhindep : Pairwise ((fun x1 x2 \u21a6 IndepFun x1 x2 \u03bc) on X)\nhident : \u2200 (i : \u2115), IdentDistrib (X i) (X 0) \u03bc \u03bc\ns : Set E := Set.range (X 0) \u222a {0}\nzero_s : 0 \u2208 s\nthis\u271d\u00b9 : SeparableSpace \u2191s\nthis\u271d : Nonempty \u2191s\n\u03c6 : \u2115 \u2192 SimpleFunc E E := SimpleFunc.nearestPt fun k \u21a6 Nat.casesOn k 0 (Subtype.val \u2218 denseSeq \u2191s)\nY : \u2115 \u2192 \u2115 \u2192 \u03a9 \u2192 E := fun k i \u21a6 \u21d1(\u03c6 k) \u2218 X i\nA : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, \u2200 (k : \u2115), Tendsto (fun n \u21a6 (\u2191n)\u207b\u00b9 \u2022 \u2211 i \u2208 Finset.range n, Y k i \u03c9) atTop (\ud835\udcdd (\u222b (x : \u03a9), Y k 0 x \u2202\u03bc))\nB :\n  \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc,\n    \u2200 (k : \u2115),\n      Tendsto (fun n \u21a6 (\u2211 i \u2208 Finset.range n, \u2016(X i - Y k i) \u03c9\u2016) / \u2191n) atTop\n        (\ud835\udcdd (\u222b (x : \u03a9), (fun \u03c9 \u21a6 \u2016(X 0 - Y k 0) \u03c9\u2016) x \u2202\u03bc))\n\u03c9 : \u03a9\nh\u03c9 : \u2200 (k : \u2115), Tendsto (fun n \u21a6 (\u2191n)\u207b\u00b9 \u2022 \u2211 i \u2208 Finset.range n, Y k i \u03c9) atTop (\ud835\udcdd (\u222b (x : \u03a9), Y k 0 x \u2202\u03bc))\nh'\u03c9 :\n  \u2200 (k : \u2115), Tendsto (fun n \u21a6 (\u2211 i \u2208 Finset.range n, \u2016(X i - Y k i) \u03c9\u2016) / \u2191n) atTop (\ud835\udcdd (\u222b (x : \u03a9), \u2016(X 0 - Y k 0) x\u2016 \u2202\u03bc))\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : \u03b4 + \u03b4 + \u03b4 < \u03b5\nk : \u2115\nhk : \u222b (\u03c9 : \u03a9), \u2016(X 0 - Y k 0) \u03c9\u2016 \u2202\u03bc < \u03b4\nthis : \u2016\u222b (x : \u03a9), Y k 0 x \u2202\u03bc - \u222b (x : \u03a9), X 0 x \u2202\u03bc\u2016 < \u03b4\nI : \u2200\u1da0 (n : \u2115) in atTop, (\u2211 i \u2208 Finset.range n, \u2016(X i - Y k i) \u03c9\u2016) / \u2191n < \u03b4\nJ : \u2200\u1da0 (n : \u2115) in atTop, \u2016(\u2191n)\u207b\u00b9 \u2022 \u2211 i \u2208 Finset.range n, Y k i \u03c9 - \u222b (x : \u03a9), Y k 0 x \u2202\u03bc\u2016 < \u03b4\nn : \u2115\nhn : (\u2211 i \u2208 Finset.range n, \u2016(X i - Y k i) \u03c9\u2016) / \u2191n < \u03b4\nh'n : \u2016(\u2191n)\u207b\u00b9 \u2022 \u2211 i \u2208 Finset.range n, Y k i \u03c9 - \u222b (x : \u03a9), Y k 0 x \u2202\u03bc\u2016 < \u03b4\n\u22a2 (\u2191n)\u207b\u00b9 \u2022 \u2211 i \u2208 Finset.range n, X i \u03c9 - \u222b (x : \u03a9), X 0 x \u2202\u03bc =\n    (\u2191n)\u207b\u00b9 \u2022 \u2211 i \u2208 Finset.range n, X i \u03c9 - (\u2191n)\u207b\u00b9 \u2022 \u2211 x \u2208 Finset.range n, Y k x \u03c9 +\n        ((\u2191n)\u207b\u00b9 \u2022 \u2211 x \u2208 Finset.range n, Y k x \u03c9 - \u222b (x : \u03a9), Y k 0 x \u2202\u03bc) +\n      (\u222b (x : \u03a9), Y k 0 x \u2202\u03bc - \u222b (x : \u03a9), X 0 x \u2202\u03bc)",["abel","aesop","norm_num","simp"]],["Order/Lattice.lean",556,"\u03b1 : Type u\ninst\u271d : Lattice \u03b1\na b : \u03b1\n\u22a2 a \u2294 a \u2293 b = a",["simp"]],["Order/Lattice.lean",199,"\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na b : \u03b1\n\u22a2 a \u2294 b \u2294 b = a \u2294 b",["simp"]],["Order/Lattice.lean",390,"\u03b1 : Type u\ninst\u271d : SemilatticeInf \u03b1\na b : \u03b1\n\u22a2 a \u2293 b \u2293 b = a \u2293 b",["simp"]],["Order/Lattice.lean",373,"\u03b1 : Type u\ninst\u271d : SemilatticeInf \u03b1\na : \u03b1\n\u22a2 a \u2293 a = a",["simp"]],["Order/Lattice.lean",181,"\u03b1 : Type u\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 a \u2294 a = a",["simp"]],["Order/Lattice.lean",566,"case mk.mk.refl.refl\n\u03b1 : Type u_1\ntoSemilatticeSup\u271d : SemilatticeSup \u03b1\ninf\u271d : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninf_le_left\u271d\u00b9 : \u2200 (a b : \u03b1), inf\u271d a b \u2264 a\ninf_le_right\u271d\u00b9 : \u2200 (a b : \u03b1), inf\u271d a b \u2264 b\nle_inf\u271d\u00b9 : \u2200 (a b c : \u03b1), a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 inf\u271d b c\ninf_le_left\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 a\ninf_le_right\u271d : \u2200 (a b : \u03b1), inf\u271d a b \u2264 b\nle_inf\u271d : \u2200 (a b c : \u03b1), a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 inf\u271d b c\nH : \u2200 (x y : \u03b1), x \u2264 y \u2194 x \u2264 y\n\u22a2 mk inf\u271d inf_le_left\u271d\u00b9 inf_le_right\u271d\u00b9 le_inf\u271d\u00b9 = mk inf\u271d inf_le_left\u271d inf_le_right\u271d le_inf\u271d",["congr","simp"]],["CategoryTheory/Preadditive/Biproducts.lean",281,"case pos\nC : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : Preadditive C\n\u03b2 \u03b3 : Type\ninst\u271d\u00b2 : Finite \u03b2\n\u03b5 : \u03b2 \u2243 \u03b3\nf : \u03b3 \u2192 C\ninst\u271d\u00b9 : HasBiproduct f\ninst\u271d : HasBiproduct (f \u2218 \u21d1\u03b5)\nb' : \u03b2\n\u22a2 \u03b9 (f \u2218 \u21d1\u03b5) b' \u226b ((desc fun b \u21a6 \u03b9 f (\u03b5 b)) \u226b lift fun b \u21a6 \u03c0 f (\u03b5 b)) \u226b \u03c0 (f \u2218 \u21d1\u03b5) b' =\n    \u03b9 (f \u2218 \u21d1\u03b5) b' \u226b \ud835\udfd9 (\u2a01 f \u2218 \u21d1\u03b5) \u226b \u03c0 (f \u2218 \u21d1\u03b5) b'",["simp","aesop"]],["CategoryTheory/Preadditive/Biproducts.lean",360,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nX Y : C\nt : Cone (pair X Y)\nht : IsLimit t\n\u22a2 ((BinaryBicone.ofLimitCone ht).fst \u226b (BinaryBicone.ofLimitCone ht).inl +\n        (BinaryBicone.ofLimitCone ht).snd \u226b (BinaryBicone.ofLimitCone ht).inr) \u226b\n      BinaryFan.snd t =\n    \ud835\udfd9 (BinaryBicone.ofLimitCone ht).pt \u226b BinaryFan.snd t",["simp","aesop","norm_num"]],["CategoryTheory/Preadditive/Biproducts.lean",624,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Preadditive C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasBinaryBiproduct Y Y\n\u22a2 f + g = lift f g \u226b desc (\ud835\udfd9 Y) (\ud835\udfd9 Y)",["simp"]],["CategoryTheory/Preadditive/Biproducts.lean",567,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Preadditive C\nX\u271d Y\u271d : C\ninst\u271d : HasBinaryBiproduct X\u271d Y\u271d\nX Y : C\nb : BinaryBicone X Y\nhb : IsColimit b.inlCokernelCofork\nT\u271d : C\nf : X \u27f6 T\u271d\ng : Y \u27f6 T\u271d\n\u22a2 BinaryCofan.inl b.toCocone \u226b (fun {T} f g \u21a6 b.fst \u226b f + b.snd \u226b g) f g = f",["simp","aesop","norm_num"]],["CategoryTheory/Preadditive/Biproducts.lean",620,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Preadditive C\nX Y : C\nf g : X \u27f6 Y\ninst\u271d : HasBinaryBiproduct X X\n\u22a2 f + g = lift (\ud835\udfd9 X) (\ud835\udfd9 X) \u226b desc f g",["simp"]],["Analysis/Complex/PhragmenLindelof.lean",84,"case h.h.h\u2082.hx\nE : Type u_1\ninst\u271d : NormedAddCommGroup E\na : \u211d\nf g : \u2102 \u2192 E\nl : Filter \u2102\nhBf : \u2203 c < a, \u2203 B, f =O[cobounded \u2102 \u2293 l] fun z \u21a6 expR (B * \u2016z\u2016 ^ c)\nhBg : \u2203 c < a, \u2203 B, g =O[cobounded \u2102 \u2293 l] fun z \u21a6 expR (B * \u2016z\u2016 ^ c)\nc\u2081\u271d c\u2082\u271d B\u2081\u271d B\u2082\u271d : \u211d\nhc : c\u2081\u271d \u2264 c\u2082\u271d\nhB\u2080 : 0 \u2264 B\u2082\u271d\nhB : B\u2081\u271d \u2264 B\u2082\u271d\nz : \u2102\nhz : 1 \u2264 \u2016z\u2016\n\u22a2 1 \u2264 \u2016z\u2016",["assumption","aesop","congr","linarith","gcongr","tauto"]],["Analysis/InnerProductSpace/PiL2.lean",420,"case h.e'_2.a\n\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b3 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : Fintype \u03b9\nb : OrthonormalBasis \u03b9 \ud835\udd5c E\nx y : E\nthis : \u2211 x_1 : \u03b9, ((innerSL \ud835\udd5c) x) (b.repr y x_1 \u2022 b x_1) = ((innerSL \ud835\udd5c) x) y\nx\u271d : \u03b9\na\u271d : x\u271d \u2208 Finset.univ\n\u22a2 inner (b x\u271d) y * inner x (b x\u271d) = inner (b x\u271d) y \u2022 ((innerSL \ud835\udd5c) x) (b x\u271d)",["simp","aesop","congr","tauto","abel","norm_num"]],["Analysis/InnerProductSpace/PiL2.lean",332,"case ofRepr.ofRepr\n\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b3 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : Fintype \u03b9\nrepr\u271d\u00b9 repr\u271d : E \u2243\u2097\u1d62[\ud835\udd5c] EuclideanSpace \ud835\udd5c \u03b9\nh : { repr := repr\u271d\u00b9 }.repr = { repr := repr\u271d }.repr\n\u22a2 { repr := repr\u271d\u00b9 } = { repr := repr\u271d }",["congr","aesop","tauto"]],["Analysis/InnerProductSpace/PiL2.lean",708,"case h.e'_2\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u2075 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9'\na : OrthonormalBasis \u03b9' \ud835\udd5c E\nb : OrthonormalBasis \u03b9 \ud835\udd5c E\ni j : \u03b9\n\u22a2 \u2211 x : \u03b9', (starRingEnd \ud835\udd5c) (a.toBasis.toMatrix (\u21d1b) x i) * a.toBasis.toMatrix (\u21d1b) x j =\n    \u2211 x : \u03b9', (starRingEnd \ud835\udd5c) (a.repr (b i) x) * a.repr (b j) x",["congr","aesop","tauto","abel"]],["MeasureTheory/VectorMeasure/Basic.lean",284,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nM : Type u_3\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : IsTopologicalAddGroup M\nv w : VectorMeasure \u03b1 M\n\u22a2 (\u2191v - \u2191w) \u2205 = 0",["simp","aesop","norm_num"]],["MeasureTheory/VectorMeasure/Basic.lean",518,"case h\n\u03b1 : Type u_1\ninst\u271d\u2074 : MeasurableSpace \u03b1\nM : Type u_3\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : TopologicalSpace M\nN : Type u_4\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : TopologicalSpace N\nf : M \u2192+ N\nhf : Continuous \u21d1f\ni\u271d : Set \u03b1\na\u271d : MeasurableSet i\u271d\n\u22a2 \u2191(mapRange 0 f hf) i\u271d = \u21910 i\u271d",["simp","aesop","norm_num"]],["MeasureTheory/VectorMeasure/Basic.lean",563,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm inst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : TopologicalSpace M\nv\u271d v : VectorMeasure \u03b1 M\ni : Set \u03b1\nhi : MeasurableSet i\n\u22a2 (fun s \u21a6 if MeasurableSet s then \u2191v (s \u2229 i) else 0) \u2205 = 0",["simp","aesop","norm_num"]],["MeasureTheory/VectorMeasure/Basic.lean",552,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm inst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : MeasurableSpace \u03b2\nM : Type u_3\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : TopologicalSpace M\nv : VectorMeasure \u03b1 M\nN : Type u_4\ninst\u271d\u2078 : AddCommMonoid N\ninst\u271d\u2077 : TopologicalSpace N\nR : Type u_5\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : ContinuousAdd M\ninst\u271d\u00b2 : ContinuousAdd N\ninst\u271d\u00b9 : ContinuousConstSMul R M\ninst\u271d : ContinuousConstSMul R N\nf : M \u2192\u2097[R] N\nhf : Continuous \u21d1f\nm\u271d : R\nx\u271d : VectorMeasure \u03b1 M\ni\u271d : Set \u03b1\na\u271d : MeasurableSet i\u271d\n\u22a2 \u2191({ toFun := fun v \u21a6 v.mapRange f.toAddMonoidHom hf, map_add' := \u22ef }.toFun (m\u271d \u2022 x\u271d)) i\u271d =\n    \u2191((RingHom.id R) m\u271d \u2022 { toFun := fun v \u21a6 v.mapRange f.toAddMonoidHom hf, map_add' := \u22ef }.toFun x\u271d) i\u271d",["simp","aesop","norm_num"]],["MeasureTheory/VectorMeasure/Basic.lean",96,"case mk.mk\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : TopologicalSpace M\nmeasureOf'\u271d\u00b9 : Set \u03b1 \u2192 M\nempty'\u271d\u00b9 : measureOf'\u271d\u00b9 \u2205 = 0\nnot_measurable'\u271d\u00b9 : \u2200 \u2983i : Set \u03b1\u2984, \u00acMeasurableSet i \u2192 measureOf'\u271d\u00b9 i = 0\nm_iUnion'\u271d\u00b9 :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984,\n    (\u2200 (i : \u2115), MeasurableSet (f i)) \u2192\n      Pairwise (Disjoint on f) \u2192 HasSum (fun i \u21a6 measureOf'\u271d\u00b9 (f i)) (measureOf'\u271d\u00b9 (\u22c3 i, f i))\nmeasureOf'\u271d : Set \u03b1 \u2192 M\nempty'\u271d : measureOf'\u271d \u2205 = 0\nnot_measurable'\u271d : \u2200 \u2983i : Set \u03b1\u2984, \u00acMeasurableSet i \u2192 measureOf'\u271d i = 0\nm_iUnion'\u271d :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984,\n    (\u2200 (i : \u2115), MeasurableSet (f i)) \u2192\n      Pairwise (Disjoint on f) \u2192 HasSum (fun i \u21a6 measureOf'\u271d (f i)) (measureOf'\u271d (\u22c3 i, f i))\nh :\n  \u2191{ measureOf' := measureOf'\u271d\u00b9, empty' := empty'\u271d\u00b9, not_measurable' := not_measurable'\u271d\u00b9, m_iUnion' := m_iUnion'\u271d\u00b9 } =\n    \u2191{ measureOf' := measureOf'\u271d, empty' := empty'\u271d, not_measurable' := not_measurable'\u271d, m_iUnion' := m_iUnion'\u271d }\n\u22a2 { measureOf' := measureOf'\u271d\u00b9, empty' := empty'\u271d\u00b9, not_measurable' := not_measurable'\u271d\u00b9, m_iUnion' := m_iUnion'\u271d\u00b9 } =\n    { measureOf' := measureOf'\u271d, empty' := empty'\u271d, not_measurable' := not_measurable'\u271d, m_iUnion' := m_iUnion'\u271d }",["congr","aesop"]],["MeasureTheory/VectorMeasure/Basic.lean",346,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nh : \u03bc = \u03bd\n\u22a2 \u03bc.toSignedMeasure = \u03bd.toSignedMeasure",["congr","aesop"]],["Data/ZMod/Basic.lean",726,"a n : \u2115\n\u22a2 \u2191(a % n) = \u2191(a % n + n * (a / n))",["simp","aesop"]],["Data/ZMod/Basic.lean",994,"case pos.refl\nn : \u2115\ninst\u271d : NeZero n\na : ZMod n\nh : val 0 \u2264 a.val\n\u22a2 (a - 0).val = a.val - val 0",["simp","aesop"]],["Data/ZMod/Basic.lean",256,"case pos\nn : \u2115\na b : Fin (n + 1)\nh : n + 1 \u2264 \u2191a + \u2191b\n\u22a2 \u2191(\u2191a + \u2191b) - \u2191(n + 1) = cast a + cast b - \u2191(n + 1)",["congr","aesop","tauto"]],["MeasureTheory/Measure/Restrict.lean",514,"\u03b1 : Type u_2\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1d50 (x : \u03b1) \u2202\u03bc.restrict (\u22c3 i, s i), p x) \u2194 \u2200 (i : \u03b9), \u2200\u1d50 (x : \u03b1) \u2202\u03bc.restrict (s i), p x",["simp","aesop","norm_num"]],["MeasureTheory/Measure/Restrict.lean",392,"case H\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nm0 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\ns : Set \u03b1\n\u03bd : Measure \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : QuasiMeasurePreserving f \u03bc \u03bd\nt : Set \u03b2\nhmaps : MapsTo f s t\nu : Set \u03b2\nhum : MeasurableSet u\nhu : \u03bd (u \u2229 t) = 0\n\u22a2 s \u2286 f \u207b\u00b9' t",["assumption","aesop","congr","tauto"]],["Computability/PartrecCode.lean",481,"cf cg : Code\na k : \u2115\n\u22a2 Nat.rec (cf.eval (a, k.succ).1)\n      (fun y IH \u21a6 do\n        let i \u2190 IH\n        cg.eval (Nat.pair (a, k.succ).1 (Nat.pair y i)))\n      (a, k.succ).2 =\n    (unpaired\n          (fun a n \u21a6\n            Nat.rec (cf.eval a)\n              (fun y IH \u21a6 do\n                let i \u2190 IH\n                cg.eval (Nat.pair a (Nat.pair y i)))\n              n)\n          (Nat.pair a k)).bind\n      fun ih \u21a6 cg.eval (Nat.pair a (Nat.pair k ih))",["simp","aesop"]],["GroupTheory/Perm/Cycle/Basic.lean",428,"\u03b1 : Type u_4\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\nhf : f.IsCycle\nx : \u03b1\nhx : f x \u2260 x\nhffx : f (f x) \u2260 x\ny : \u03b1\nhy : (swap x (f x) * f) y \u2260 y\ni : \u2124\nhi : (f ^ i) x = y\n\u22a2 (f ^ (i - 1)) (f x) = (f ^ (i - 1) * f ^ 1) x",["simp","aesop","congr","tauto","norm_num"]],["GroupTheory/Perm/Cycle/Basic.lean",905,"case h.e'_3.h\n\u03b1 : Type u_2\ns : Set \u03b1\nhs : s.Countable\nhs' : s.Infinite\nthis\u271d : Countable \u2191s\nthis : Infinite \u2191s\nf : \u2124 \u2243 \u2191s\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 s \u2194 x\u271d \u2208 Subtype.val '' (\u21d1f.symm \u207b\u00b9' {x | (Equiv.addRight 1) x \u2260 x})",["simp","aesop","norm_num"]],["GroupTheory/Perm/Cycle/Basic.lean",881,"case h.e'_3\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 \u2191s = {a | a \u2208 s.toList}",["simp","aesop","norm_num"]],["GroupTheory/Perm/Cycle/Basic.lean",779,"case inr\n\u03b1 : Type u_2\nf : Perm \u03b1\na : \u03b1\ns : Finset \u03b1\nhf : f.IsCycleOn \u2191s\nha : a \u2208 s\nn : \u2115\nhs : s.Nontrivial\nh : \u2200 (x : { x // x \u2208 s }), \u00acf \u2191x = \u2191x\nthis : orderOf (f.subtypePerm \u22ef) = #s\n\u22a2 (f ^ n) a = a \u2194 \u27e8(f ^ n) \u2191\u27e8a, ha\u27e9, \u22ef\u27e9 = \u27e8a, ha\u27e9",["simp","aesop","norm_num"]],["GroupTheory/Perm/Cycle/Basic.lean",1094,"\u03b1 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nhg : g.IsCycle\nn : \u2124\nx : \u03b1\nhx : g x \u2260 x\nq : \u2124 := n / \u2191(#g.support)\nr : \u2124 := n % \u2191(#g.support)\n\u22a2 0 < 2",["norm_num","omega","decide","aesop","tauto","infer_instance","simp"]],["GroupTheory/Perm/Cycle/Basic.lean",569,"case pos\n\u03b2 : Type u_3\ninst\u271d : Finite \u03b2\nf : Perm \u03b2\nhf : f.IsCycle\nn : \u2115\nval\u271d : Fintype \u03b2\nx : \u03b2\nhx : (f ^ n) x \u2260 x\nhx' : (f ^ n) x = x\nh : (f ^ n).support = f.support\n\u22a2 f ^ n = 1",["contradiction","aesop","tauto"]],["GroupTheory/Perm/Cycle/Basic.lean",608,"case neg\n\u03b2 : Type u_3\ninst\u271d : Finite \u03b2\nf : Perm \u03b2\nhf : f.IsCycle\nval\u271d : Fintype \u03b2\nx : \u03b2\nhx : f x \u2260 x\na b : \u2115\nhx' : (f ^ a) x = (f ^ b) x\nhab : a \u2264 b\nhfa : f x = x\nh : f ((f ^ a) x) = (f ^ a) (f x)\n\u22a2 \u2203 x, f x \u2260 x \u2227 (f ^ (b - a)) x = x",["contradiction","aesop","tauto"]],["GroupTheory/Perm/Cycle/Basic.lean",417,"case intro.inl\n\u03b1 : Type u_4\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\nhf : f.IsCycle\nx : \u03b1\nhfx : f x \u2260 x\nhffx : f (f x) = x\ny z : \u03b1\nhz : f z \u2260 z \u2227 \u2200 \u2983y : \u03b1\u2984, f y \u2260 y \u2192 f.SameCycle z y\ni : \u2124\nhi : (f ^ i) z = x\nhfyx : \u00acy = f x\nhy : \u00acf y = y\nj : \u2124\nhyx : \u00acx = x\nhj : (f ^ (j - i)) x = y\nhji : (f ^ (j - i)) x = x\n\u22a2 False",["tauto","aesop","contradiction"]],["GroupTheory/Perm/Cycle/Basic.lean",419,"case intro.inr\n\u03b1 : Type u_4\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\nhf : f.IsCycle\nx : \u03b1\nhfx : f x \u2260 x\nhffx : f (f x) = x\ny z : \u03b1\nhz : f z \u2260 z \u2227 \u2200 \u2983y : \u03b1\u2984, f y \u2260 y \u2192 f.SameCycle z y\ni : \u2124\nhi : (f ^ i) z = x\nhyx : \u00acy = x\nhy : \u00acf y = y\nj : \u2124\nhfyx : \u00acf x = f x\nhj : (f ^ (j - i)) x = y\nhji : (f ^ (j - i)) x = f x\n\u22a2 False",["tauto"]],["Combinatorics/SimpleGraph/Subgraph.lean",403,"\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b : V\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 G.Subgraph\n\u22a2 (\u2200 G' \u2208 Set.range fun i \u21a6 f i, G'.Adj a b) \u2194 \u2200 (i : \u03b9), (f i).Adj a b",["simp","aesop"]],["Combinatorics/SimpleGraph/Subgraph.lean",957,"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n\u22a2 G.singletonSubgraph v \u2264 G.subgraphOfAdj h",["simp","aesop"]],["Combinatorics/SimpleGraph/Subgraph.lean",919,"case h\nV : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G \u2192g G'\nv w : V\nhvw : G.Adj v w\n\u22a2 (v = v \u2227 w = w \u2228 v = w \u2227 w = v) \u2227 f v = f v \u2227 f w = f w",["simp","aesop","tauto"]],["Combinatorics/SimpleGraph/Subgraph.lean",545,"case h.h\nV : Type u\nG : SimpleGraph V\ns : Set G.Subgraph\nx\u271d y\u271d : V\n\u22a2 s(x\u271d, y\u271d) \u2208 (sInf s).edgeSet \u2194 s(x\u271d, y\u271d) \u2208 (\u22c2 G' \u2208 s, G'.edgeSet) \u2229 G.edgeSet",["simp","aesop"]],["Combinatorics/SimpleGraph/Subgraph.lean",538,"case h.h\nV : Type u\nG : SimpleGraph V\ns : Set G.Subgraph\nx\u271d y\u271d : V\n\u22a2 s(x\u271d, y\u271d) \u2208 (sSup s).edgeSet \u2194 s(x\u271d, y\u271d) \u2208 \u22c3 G' \u2208 s, G'.edgeSet",["simp","aesop"]],["Combinatorics/SimpleGraph/Subgraph.lean",777,"V : Type u\nG : SimpleGraph V\ninst\u271d\u00b9 : Fintype V\nG' : G.Subgraph\ninst\u271d : Fintype \u2191G'.verts\nh : G'.IsSpanning\n\u22a2 Finset.univ.card = Fintype.card V",["congr","aesop","tauto","simp"]],["Combinatorics/SimpleGraph/Subgraph.lean",1241,"V : Type u\nG G' : SimpleGraph V\nu : Set V\nh : G \u2264 G'\nv w : \u2191(\u22a4.deleteVerts u).verts\nhvw : (\u22a4.deleteVerts u).coe.Adj v w\n\u22a2 (\u22a4.deleteVerts u).coe.Adj v w",["aesop","omega","tauto","infer_instance"]],["LinearAlgebra/Eigenspace/Basic.lean",885,"case h\nR : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf\u2081 f\u2082 : End R M\n\u03bc\u2081 \u03bc\u2082 : R\nh : Commute f\u2081 f\u2082\n\u22a2 Commute f\u2081 f\u2082",["assumption","aesop","congr","gcongr","tauto"]],["LinearAlgebra/Eigenspace/Basic.lean",805,"case hk\nK : Type v\nV : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nf : End K V\n\u03bc : K\n\u22a2 finrank K V \u2264 finrank K V + finrank K V",["omega","aesop","linarith","norm_num","simp"]],["LinearAlgebra/Eigenspace/Basic.lean",642,"R : Type v\nM : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : End R M\n\u03bc\u2081 \u03bc\u2082 : R\nh\u03bc : \u03bc\u2081 \u2260 \u03bc\u2082\nk\u271d l\u271d : \u2115\u221e\nk : \u2115\nproperty\u271d\u00b9 : \u2191k \u2264 k\u271d\nl : \u2115\nproperty\u271d : \u2191l \u2264 l\u271d\na\u271d : Nontrivial M\nthis\u271d : IsReduced R\np : Submodule R M := (f.genEigenspace \u03bc\u2081) \u2191k \u2293 (f.genEigenspace \u03bc\u2082) \u2191l\nhp : Nontrivial \u21a5p\nf\u2081 : End R \u21a5p := LinearMap.restrict (f - (algebraMap R (End R M)) \u03bc\u2081) \u22ef\nf\u2082 : End R \u21a5p := LinearMap.restrict (f - (algebraMap R (End R M)) \u03bc\u2082) \u22ef\nthis : \u03bc\u2081 = \u03bc\u2082\nhf\u2081\u2082 : f\u2082 - f\u2081 = (algebraMap R (End R \u21a5p)) (\u03bc\u2081 - \u03bc\u2082)\n\u22a2 False",["contradiction","aesop","tauto"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",950,"case h.e'_5.h.e'_3\n\u22a2 1 = sin (\u03c0 / 2)",["simp","aesop","norm_num"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",955,"case h.e'_5.h.e'_3\n\u22a2 0 = cos (\u03c0 / 2)",["simp","aesop","norm_num"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",620,"x : \u211d\n\u22a2 x.sqrtTwoAddSeries 0 = x",["simp","aesop","congr","tauto","abel","norm_num"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",834,"c : \u211d := cos (\u03c0 / 5)\nthis : 4 * (c * c) + -2 * c + -1 = 0\nhd : discrim 4 (-2) (-1) = 2 * \u221a5 * (2 * \u221a5)\nh : c = (- -2 - 2 * \u221a5) / (2 * 4)\n\u22a2 0 < 2 * 4",["positivity","aesop","linarith","norm_num","simp"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",852,"\u22a2 \u221a2 / 2 > 0",["positivity","aesop","norm_num","simp"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",211,"\u22a2 2 * 0 ^ 2 - 1 = -1",["norm_num","ring","aesop","linarith","simp"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",602,"\u22a2 -1 < 1",["norm_num","aesop","linarith","simp"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",606,"\u22a2 -1 < 1",["norm_num","aesop","linarith","simp"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",635,"\u22a2 sqrtTwoAddSeries 0 0 < 2",["norm_num","aesop","positivity","simp"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",976,"\u22a2 -1 < 0",["norm_num","aesop","linarith","simp"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",866,"\u22a2 \u221a3 / 2 / (1 / 2) = \u221a3",["ring","aesop","linarith","simp"]],["LinearAlgebra/Matrix/ToLin.lean",1032,"case a.h\n\u03b9 : Type u_1\ninst\u271d\u2078 : Fintype \u03b9\ninst\u271d\u2077 : DecidableEq \u03b9\nR : Type u_2\ninst\u271d\u2076 : CommSemiring R\nA : Type u_3\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\nM : Type u_4\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module A M\ninst\u271d : IsScalarTower R A M\nf g : Module.End A (\u03b9 \u2192 M)\ni\u271d j\u271d : \u03b9\nx\u271d : M\n\u22a2 ({ toFun := fun f i j \u21a6 { toFun := fun x \u21a6 f (Pi.single j x) i, map_add' := \u22ef, map_smul' := \u22ef },\n            invFun := fun m \u21a6 { toFun := fun x i \u21a6 \u2211 j : \u03b9, (m i j) (x j), map_add' := \u22ef, map_smul' := \u22ef }, left_inv := \u22ef,\n            right_inv := \u22ef }.toFun\n        (f + g) i\u271d j\u271d)\n      x\u271d =\n    (({ toFun := fun f i j \u21a6 { toFun := fun x \u21a6 f (Pi.single j x) i, map_add' := \u22ef, map_smul' := \u22ef },\n                invFun := fun m \u21a6 { toFun := fun x i \u21a6 \u2211 j : \u03b9, (m i j) (x j), map_add' := \u22ef, map_smul' := \u22ef },\n                left_inv := \u22ef, right_inv := \u22ef }.toFun\n            f +\n          { toFun := fun f i j \u21a6 { toFun := fun x \u21a6 f (Pi.single j x) i, map_add' := \u22ef, map_smul' := \u22ef },\n                invFun := fun m \u21a6 { toFun := fun x i \u21a6 \u2211 j : \u03b9, (m i j) (x j), map_add' := \u22ef, map_smul' := \u22ef },\n                left_inv := \u22ef, right_inv := \u22ef }.toFun\n            g)\n        i\u271d j\u271d)\n      x\u271d",["simp","aesop","congr","tauto","abel","norm_num"]],["LinearAlgebra/Matrix/ToLin.lean",533,"case h\u2081\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Finite m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\ni : m\nj : n\nhj : j \u2209 Finset.univ\nthis : j \u2208 Finset.univ\n\u22a2 (if j = j then 1 else 0) \u2022 v\u2081 j = 0",["contradiction","aesop","tauto"]],["LinearAlgebra/Matrix/ToLin.lean",629,"case h\u2081\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\na\u271d : i \u2209 Finset.univ\nthis : i \u2208 Finset.univ\n\u22a2 M j i * (Finsupp.single i 1) i = 0",["contradiction","aesop","tauto"]],["CategoryTheory/Limits/Shapes/Biproducts.lean",640,"case pos\nJ : Type w\nK : Type u_1\nC : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroMorphisms C\nf : J \u2192 C\ng : K \u2192 C\ne : J \u2243 K\nw : (j : J) \u2192 g (e j) \u2245 f j\ninst\u271d\u00b9 : HasBiproduct f\ninst\u271d : HasBiproduct g\nj : J\n\u22a2 \u03b9 f j \u226b (desc fun j \u21a6 (w j).inv \u226b \u03b9 g (e j)) \u226b \u03c0 g (e j) =\n    \u03b9 f j \u226b (lift fun k \u21a6 \u03c0 f (e.symm k) \u226b (w (e.symm k)).inv \u226b eqToHom \u22ef) \u226b \u03c0 g (e j)",["simp","aesop"]],["CategoryTheory/Limits/Shapes/Biproducts.lean",457,"case refl\nJ : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasZeroMorphisms C\nf : J \u2192 C\ninst\u271d : HasBiproduct f\nj : J\n\u22a2 \u03c0 f j \u226b eqToHom \u22ef = \u03c0 f j",["simp","aesop"]],["CategoryTheory/Limits/Shapes/Biproducts.lean",262,"J : Type w\nC : Type uC\ninst\u271d\u00b3 : Category.{uC', uC} C\ninst\u271d\u00b2 : HasZeroMorphisms C\nD : Type uD\ninst\u271d\u00b9 : Category.{uD', uD} D\ninst\u271d : HasZeroMorphisms D\nF : J \u2192 C\nK : Type w'\nf : J \u2192 C\nc : Bicone f\ng : K \u2243 J\n\u22a2 \u2200 (j : Discrete K),\n    (c.whisker g).toCone.\u03c0.app j =\n      (Iso.refl (c.whisker g).toCone.pt).hom \u226b\n        ((Cones.postcompose (Discrete.functorComp f \u21d1g).inv).obj\n                (Cone.whisker (Discrete.functor (Discrete.mk \u2218 \u21d1g)) c.toCone)).\u03c0.app\n          j",["simp","aesop"]],["CategoryTheory/Limits/Shapes/Biproducts.lean",103,"case mk.mk\nJ : Type w\nC : Type uC\ninst\u271d\u00b9 : Category.{uC', uC} C\ninst\u271d : HasZeroMorphisms C\nF : J \u2192 C\nc c' : Bicone F\nhom\u271d\u00b9 : c.pt \u27f6 c'.pt\nw\u03c0\u271d\u00b9 : \u2200 (j : J), hom\u271d\u00b9 \u226b c'.\u03c0 j = c.\u03c0 j\nw\u03b9\u271d\u00b9 : \u2200 (j : J), c.\u03b9 j \u226b hom\u271d\u00b9 = c'.\u03b9 j\nhom\u271d : c.pt \u27f6 c'.pt\nw\u03c0\u271d : \u2200 (j : J), hom\u271d \u226b c'.\u03c0 j = c.\u03c0 j\nw\u03b9\u271d : \u2200 (j : J), c.\u03b9 j \u226b hom\u271d = c'.\u03b9 j\nw : { hom := hom\u271d\u00b9, w\u03c0 := w\u03c0\u271d\u00b9, w\u03b9 := w\u03b9\u271d\u00b9 }.hom = { hom := hom\u271d, w\u03c0 := w\u03c0\u271d, w\u03b9 := w\u03b9\u271d }.hom\n\u22a2 { hom := hom\u271d\u00b9, w\u03c0 := w\u03c0\u271d\u00b9, w\u03b9 := w\u03b9\u271d\u00b9 } = { hom := hom\u271d, w\u03c0 := w\u03c0\u271d, w\u03b9 := w\u03b9\u271d }",["congr","aesop"]],["Geometry/Euclidean/Circumcenter.lean",211,"V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\n\u03b9 : Type u_3\nhne : Nonempty \u03b9\ninst\u271d : Finite \u03b9\np : \u03b9 \u2192 P\nha : AffineIndependent \u211d p\nval\u271d : Fintype \u03b9\nm : \u2115\nhm :\n  \u2200 {\u03b9 : Type u_3} [hne : Nonempty \u03b9] [inst : Finite \u03b9] {p : \u03b9 \u2192 P},\n    AffineIndependent \u211d p \u2192\n      \u2200 (val : Fintype \u03b9),\n        Fintype.card \u03b9 = m + 1 \u2192\n          \u2203! cs, cs.center \u2208 affineSpan \u211d (Set.range p) \u2227 Set.range p \u2286 Metric.sphere cs.center cs.radius\nhn : Fintype.card \u03b9 = m + 1 + 1\ni : \u03b9\n\u03b92 : Type (max 0 u_3) := { x // x \u2260 i }\n\u22a2 m + 1 + 1 - 1 = m + 1",["simp","omega","aesop","congr","tauto","norm_num"]],["Geometry/Euclidean/Circumcenter.lean",590,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nn : \u2115\ns : Simplex \u211d P n\nfs : Finset (Fin (n + 1))\n\u22a2 \u2211 x : Fin (n + 1),\n        (if x \u2208 \u2191fs then Function.const (Fin (n + 1)) (\u2191(#fs))\u207b\u00b9 x else 0) \u2022 (s.points x -\u1d65 Classical.choice \u22ef) +\u1d65\n      Classical.choice \u22ef =\n    \u2211 x : Fin (n + 1), (if x \u2208 fs then (\u2191(#fs))\u207b\u00b9 else 0) \u2022 (s.points x -\u1d65 Classical.choice \u22ef) +\u1d65 Classical.choice \u22ef",["congr","aesop","tauto","norm_num","simp"]],["Topology/Algebra/Module/LinearMap.lean",469,"case h\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b9\u2074 : Semiring R\u2081\ninst\u271d\u00b9\u00b3 : Semiring R\u2082\ninst\u271d\u00b9\u00b2 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2081\nM\u2082 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommMonoid M\u2083\ninst\u271d\u2075 : Module R\u2081 M\u2081\ninst\u271d\u2074 : Module R\u2082 M\u2082\ninst\u271d\u00b3 : Module R\u2083 M\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\n\u03b9 : Type u_9\ns : Finset \u03b9\ninst\u271d\u00b9 : ContinuousAdd M\u2082\ninst\u271d : ContinuousAdd M\u2083\ng : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083\nf : \u03b9 \u2192 M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nx\u271d : M\u2081\n\u22a2 (g.comp (\u2211 i \u2208 s, f i)) x\u271d = (\u2211 i \u2208 s, g.comp (f i)) x\u271d",["simp","aesop","norm_num"]],["Topology/Algebra/Module/LinearMap.lean",770,"case h\nR : Type u_1\ninst\u271d\u00b9\u2074 : Ring R\nR\u2082 : Type u_2\ninst\u271d\u00b9\u00b3 : Ring R\u2082\nR\u2083 : Type u_3\ninst\u271d\u00b9\u00b2 : Ring R\u2083\nM : Type u_4\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : AddCommGroup M\nM\u2082 : Type u_5\ninst\u271d\u2079 : TopologicalSpace M\u2082\ninst\u271d\u2078 : AddCommGroup M\u2082\nM\u2083 : Type u_6\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : AddCommGroup M\u2083\nM\u2084 : Type u_7\ninst\u271d\u2075 : TopologicalSpace M\u2084\ninst\u271d\u2074 : AddCommGroup M\u2084\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\ninst\u271d\u00b9 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d : IsTopologicalAddGroup M\u2082\nf : M \u2192SL[\u03c3\u2081\u2082] M\u2082\nx\u271d : M\n\u22a2 ((fun x1 x2 \u21a6 x1 \u2022 x2) 0 f) x\u271d = 0 x\u271d",["simp","aesop","norm_num"]],["Topology/Algebra/Module/LinearMap.lean",463,"case h\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b9\u00b3 : Semiring R\u2081\ninst\u271d\u00b9\u00b2 : Semiring R\u2082\ninst\u271d\u00b9\u00b9 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\nM\u2081 : Type u_4\ninst\u271d\u00b9\u2070 : TopologicalSpace M\u2081\ninst\u271d\u2079 : AddCommMonoid M\u2081\nM\u2082 : Type u_6\ninst\u271d\u2078 : TopologicalSpace M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u2076 : TopologicalSpace M\u2083\ninst\u271d\u2075 : AddCommMonoid M\u2083\ninst\u271d\u2074 : Module R\u2081 M\u2081\ninst\u271d\u00b3 : Module R\u2082 M\u2082\ninst\u271d\u00b2 : Module R\u2083 M\u2083\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d : ContinuousAdd M\u2083\ng\u2081 g\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083\nf : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nx\u271d : M\u2081\n\u22a2 ((g\u2081 + g\u2082).comp f) x\u271d = (g\u2081.comp f + g\u2082.comp f) x\u271d",["simp","aesop","congr","tauto","abel","norm_num"]],["Topology/Algebra/Module/LinearMap.lean",85,"case mk.mk\nR\u2081 : Type u_1\nR\u2082 : Type u_2\ninst\u271d\u2077 : Semiring R\u2081\ninst\u271d\u2076 : Semiring R\u2082\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\nM\u2081 : Type u_4\ninst\u271d\u2075 : TopologicalSpace M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2081\nM\u2082 : Type u_6\ninst\u271d\u00b3 : TopologicalSpace M\u2082\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R\u2081 M\u2081\ninst\u271d : Module R\u2082 M\u2082\ntoLinearMap\u271d\u00b9 : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ncont\u271d\u00b9 : Continuous toLinearMap\u271d\u00b9.toFun\ntoLinearMap\u271d : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ncont\u271d : Continuous toLinearMap\u271d.toFun\nH : \u2191{ toLinearMap := toLinearMap\u271d\u00b9, cont := cont\u271d\u00b9 } = \u2191{ toLinearMap := toLinearMap\u271d, cont := cont\u271d }\n\u22a2 { toLinearMap := toLinearMap\u271d\u00b9, cont := cont\u271d\u00b9 } = { toLinearMap := toLinearMap\u271d, cont := cont\u271d }",["congr","aesop"]],["MeasureTheory/Measure/Lebesgue/EqHaar.lean",299,"case inl\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : BorelSpace E\ninst\u271d\u00b9 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nf : E \u2192\u2097[\u211d] E\ns : Set E\nhf : LinearMap.det f \u2260 0\ng : E \u2243L[\u211d] E := (f.equivOfDetNeZero hf).toContinuousLinearEquiv\n\u22a2 ENNReal.ofReal |LinearMap.det \u2191\u2191g.symm.symm| * \u03bc s = ENNReal.ofReal |LinearMap.det f| * \u03bc s",["congr","aesop","tauto","abel"]],["Combinatorics/SimpleGraph/Walk.lean",655,"V : Type u\nG : SimpleGraph V\nu v : V\nd : G.Dart\np : G.Walk u v\n\u22a2 d \u2208 p.reverse.darts \u2194 d.symm \u2208 p.darts",["simp","aesop"]],["Combinatorics/SimpleGraph/Walk.lean",767,"case h\nV : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\n\u22a2 some (p.getVert 0) = some (p.getVert (p.support.length - 1))",["aesop","simp"]],["RingTheory/Ideal/Maps.lean",1107,"case h\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : FaithfulSMul R A\nx\u271d : R\n\u22a2 x\u271d \u2208 RingHom.ker (algebraMap R A) \u2194 x\u271d \u2208 \u22a5",["simp","omega","aesop","tauto","infer_instance","norm_num"]],["RingTheory/Ideal/Maps.lean",617,"case refine_2.intro.intro\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\nf : R \u2192+* S\nq : Ideal S\nhq : q.IsPrime\ninst\u271d : (comap f q).IsPrime\n\u22a2 comap f (map f (comap f q)) = comap f q",["simp","aesop","norm_num"]],["RingTheory/Ideal/Maps.lean",954,"case h.e'_5\nR : Type u_1\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : FunLike F R S\nrc : RingHomClass F R S\nf : F\nhf : Function.Surjective \u21d1f\nI : Ideal R\nH : I.IsPrime\nhk : RingHom.ker f \u2264 I\nx y : S\na : R\nha : f a = x\nb : R\nhb : f b = y\nc : R\nhc : c \u2208 I\nhc' : f (c - a * b) = 0\n\u22a2 a * b = c - (c - a * b)",["abel","aesop","norm_num","simp"]],["Algebra/Quaternion.lean",391,"S : Type u_1\nT : Type u_2\nR : Type u_3\nc\u2081 c\u2082 c\u2083 r x y : R\na b : \u210d[R,c\u2081,c\u2082,c\u2083]\ninst\u271d : AddCommGroupWithOne R\n\u22a2 NatCast.natCast 0 = 0",["simp","aesop","norm_num"]],["Algebra/Quaternion.lean",574,"R : Type u_3\nc\u2081 c\u2082 c\u2083 : R\ninst\u271d\u00b9 : CommRing R\ninst\u271d : StrongRankCondition R\n\u22a2 \u21914 = 4",["norm_num","ring","aesop","congr","tauto","abel","simp"]],["Algebra/Quaternion.lean",905,"R : Type u_3\ninst\u271d : CommRing R\na b : \u210d[R]\n\u22a2 a.re * b.imK + a.imI * b.imJ + 0 * a.imI * b.imK - a.imJ * b.imI + a.imK * b.re =\n    a.re * b.imK + a.imI * b.imJ - a.imJ * b.imI + a.imK * b.re",["ring","aesop","norm_num","simp"]],["Algebra/Quaternion.lean",1265,"R : Type u_1\ninst\u271d : Infinite R\n\u22a2 1 \u2264 4",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["Topology/Algebra/Module/Equiv.lean",684,"R : Type u_3\ninst\u271d\u2074 : Semiring R\nM : Type u_4\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : ContinuousNeg M\nx : M\n\u22a2 (neg R) x = -x",["simp","aesop","congr","tauto","norm_num"]],["Topology/Algebra/Module/Equiv.lean",1052,"case pos.intro.h\nR : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\ninst\u271d\u2076 : TopologicalSpace M\ninst\u271d\u2075 : TopologicalSpace M\u2082\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup M\u2082\ninst\u271d : Module R M\u2082\ne : M \u2243L[R] M\u2082\nf : M \u2192L[R] M\u2082\ne' : M \u2243L[R] M\u2082\nhe' : \u2191e' = f\nx\u271d : M\u2082\n\u22a2 (\u2191e').inverse x\u271d = ((Ring.inverse \u2191(e'.trans e.symm)).comp \u2191e.symm) x\u271d",["simp","aesop","norm_num"]],["Topology/Algebra/Module/Equiv.lean",716,"R\u271d : Type u_1\nM\u271d : Type u_2\ninst\u271d\u00b9\u2076 : Ring R\u271d\ninst\u271d\u00b9\u2075 : TopologicalSpace R\u271d\ninst\u271d\u00b9\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b9\u00b3 : AddCommGroup M\u271d\ninst\u271d\u00b9\u00b2 : ContinuousAdd M\u271d\ninst\u271d\u00b9\u00b9 : Module R\u271d M\u271d\ninst\u271d\u00b9\u2070 : ContinuousSMul R\u271d M\u271d\nR : Type u_3\ninst\u271d\u2079 : Ring R\nR\u2082 : Type u_4\ninst\u271d\u2078 : Ring R\u2082\nM : Type u_5\ninst\u271d\u2077 : TopologicalSpace M\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\nM\u2082 : Type u_6\ninst\u271d\u2074 : TopologicalSpace M\u2082\ninst\u271d\u00b3 : AddCommGroup M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nf : (M \u2192L[R] M)\u02e3\n\u22a2 \u2200 (m : R) (x : M),\n    { toFun := \u21d1\u2191f, map_add' := \u22ef }.toFun (m \u2022 x) = (RingHom.id R) m \u2022 { toFun := \u21d1\u2191f, map_add' := \u22ef }.toFun x",["simp","aesop","norm_num"]],["Topology/Algebra/Module/Equiv.lean",978,"case mp.intro\nR : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nM\u2083 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\ninst\u271d\u2078 : TopologicalSpace M\u2082\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : AddCommMonoid M\u2083\ninst\u271d : Module R M\u2083\ne : M\u2082 \u2243L[R] M\u2083\nf : M \u2192L[R] M\u2082\nA : M \u2243L[R] M\u2083\nhA : \u2191A = (\u2191e).comp f\nthis : f = (\u2191e.symm).comp ((\u2191e).comp f)\n\u22a2 ((\u2191e.symm).comp \u2191A).IsInvertible",["simp","norm_num"]],["Topology/Algebra/Module/Equiv.lean",776,"R\u271d : Type u_1\nM\u271d : Type u_2\ninst\u271d\u00b9\u2078 : Ring R\u271d\ninst\u271d\u00b9\u2077 : TopologicalSpace R\u271d\ninst\u271d\u00b9\u2076 : TopologicalSpace M\u271d\ninst\u271d\u00b9\u2075 : AddCommGroup M\u271d\ninst\u271d\u00b9\u2074 : ContinuousAdd M\u271d\ninst\u271d\u00b9\u00b3 : Module R\u271d M\u271d\ninst\u271d\u00b9\u00b2 : ContinuousSMul R\u271d M\u271d\nR : Type u_3\ninst\u271d\u00b9\u00b9 : Ring R\nR\u2082 : Type u_4\ninst\u271d\u00b9\u2070 : Ring R\u2082\nM : Type u_5\ninst\u271d\u2079 : TopologicalSpace M\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : Module R M\nM\u2082 : Type u_6\ninst\u271d\u2076 : TopologicalSpace M\u2082\ninst\u271d\u2075 : AddCommGroup M\u2082\ninst\u271d\u2074 : Module R\u2082 M\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b3 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : ContinuousMul R\nu : R\u02e3\n\u22a2 \u2191((fun e \u21a6 { val := e 1, inv := e.symm 1, val_inv := \u22ef, inv_val := \u22ef })\n        ((fun u \u21a6 equivOfInverse (ContinuousLinearMap.smulRight 1 \u2191u) (ContinuousLinearMap.smulRight 1 \u2191u\u207b\u00b9) \u22ef \u22ef) u)) =\n    \u2191u",["simp","aesop","norm_num"]],["Topology/Algebra/Module/Equiv.lean",980,"case mpr.intro\nR : Type u_3\nM\u271d : Type u_4\nM\u2082 : Type u_5\nM\u2083 : Type u_6\ninst\u271d\u2079 : TopologicalSpace M\u271d\ninst\u271d\u2078 : TopologicalSpace M\u2082\ninst\u271d\u2077 : TopologicalSpace M\u2083\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\u271d\ninst\u271d\u2074 : Module R M\u271d\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : AddCommMonoid M\u2083\ninst\u271d : Module R M\u2083\ne : M\u2082 \u2243L[R] M\u2083\nM : M\u271d \u2243L[R] M\u2082\n\u22a2 ((\u2191e).comp \u2191M).IsInvertible",["simp","aesop","norm_num"]],["Geometry/Euclidean/Angle/Oriented/Affine.lean",665,"V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\nhd2 : Fact (finrank \u211d V = 2)\ninst\u271d : Oriented \u211d V (Fin 2)\np\u2081 p\u2082 p\u2083 p\u2084 p\u2085 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2083p\u2084 : p\u2083 \u2260 p\u2084\nhc : Collinear \u211d {p\u2081, p\u2082, p\u2083, p\u2084}\nhr : SameRay \u211d (p\u2082 -\u1d65 p\u2081) (p\u2084 -\u1d65 p\u2083)\nhc\u2085\u2081\u2082 : \u00acCollinear \u211d {p\u2085, p\u2081, p\u2082}\ns : Set (P \u00d7 P \u00d7 P) := (fun x \u21a6 (\u2191x.1, p\u2085, x.2 +\u1d65 \u2191x.1)) '' Set.univ \u00d7\u02e2 {v | SameRay \u211d (p\u2082 -\u1d65 p\u2081) v \u2227 v \u2260 0}\nhco : IsConnected s\nhf : ContinuousOn (fun p \u21a6 \u2221 p.1 p.2.1 p.2.2) s\nhsp : \u2200 p \u2208 s, \u2221 p.1 p.2.1 p.2.2 \u2260 0 \u2227 \u2221 p.1 p.2.1 p.2.2 \u2260 \u2191\u03c0\nhp\u2081p\u2082s : (p\u2081, p\u2085, p\u2082) \u2208 s\n\u22a2 \u2191(\u27e8p\u2083, \u22ef\u27e9, p\u2084 -\u1d65 p\u2083).1 = p\u2083 \u2227 True \u2227 (\u27e8p\u2083, \u22ef\u27e9, p\u2084 -\u1d65 p\u2083).2 +\u1d65 \u2191(\u27e8p\u2083, \u22ef\u27e9, p\u2084 -\u1d65 p\u2083).1 = p\u2084",["simp","aesop","norm_num"]],["MeasureTheory/Function/SimpleFuncDenseLp.lean",156,"\u03b2 : Type u_2\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : NormedAddCommGroup E\np : \u211d\u22650\u221e\ninst\u271d\u00b9 : BorelSpace E\nf : \u03b2 \u2192 E\nhp_ne_top : p \u2260 \u22a4\n\u03bc : Measure \u03b2\nfmeas : Measurable f\ninst\u271d : SeparableSpace \u2191(Set.range f \u222a {0})\nhf : eLpNorm f p \u03bc < \u22a4\nx : \u03b2\n\u22a2 f x \u2208 Set.range f \u222a {0}",["simp","aesop","tauto","norm_num"]],["MeasureTheory/Function/SimpleFuncDenseLp.lean",143,"case h.e'_4\n\u03b2 : Type u_2\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : NormedAddCommGroup E\np : \u211d\u22650\u221e\ninst\u271d\u00b9 : BorelSpace E\nf : \u03b2 \u2192 E\n\u03bc : Measure \u03b2\nfmeas : Measurable f\nhf : MemLp f p \u03bc\ns : Set E\ny\u2080 : E\nh\u2080 : y\u2080 \u2208 s\ninst\u271d : SeparableSpace \u2191s\nhi\u2080 : MemLp (fun x \u21a6 y\u2080) p \u03bc\nn : \u2115\nhf' : MemLp (fun x \u21a6 \u2016f x - y\u2080\u2016) p \u03bc\nx : \u03b2\n\u22a2 0 \u2264 \u2016f x - y\u2080\u2016 + \u2016f x - y\u2080\u2016",["positivity","aesop","norm_num","simp"]],["SetTheory/Game/Basic.lean",503,"x y : PGame\n\u22a2 \u27e6-x * -y\u27e7 = \u27e6x * y\u27e7",["simp","aesop","norm_num"]],["SetTheory/Game/Basic.lean",417,"case mk.mk\n\u03b1\u271d\u00b9 \u03b2\u271d\u00b9 : Type u\na\u271d\u00b3 : \u03b1\u271d\u00b9 \u2192 PGame\na\u271d\u00b2 : \u03b2\u271d\u00b9 \u2192 PGame\n\u03b1\u271d \u03b2\u271d : Type u\na\u271d\u00b9 : \u03b1\u271d \u2192 PGame\na\u271d : \u03b2\u271d \u2192 PGame\ninst\u271d :\n  IsEmpty\n    ((mk \u03b1\u271d\u00b9 \u03b2\u271d\u00b9 a\u271d\u00b3 a\u271d\u00b2).LeftMoves \u00d7 (mk \u03b1\u271d \u03b2\u271d a\u271d\u00b9 a\u271d).LeftMoves \u2295\n      (mk \u03b1\u271d\u00b9 \u03b2\u271d\u00b9 a\u271d\u00b3 a\u271d\u00b2).RightMoves \u00d7 (mk \u03b1\u271d \u03b2\u271d a\u271d\u00b9 a\u271d).RightMoves)\n\u22a2 IsEmpty (mk \u03b1\u271d\u00b9 \u03b2\u271d\u00b9 a\u271d\u00b3 a\u271d\u00b2 * mk \u03b1\u271d \u03b2\u271d a\u271d\u00b9 a\u271d).LeftMoves",["assumption","congr","tauto"]],["SetTheory/Game/Basic.lean",424,"case mk.mk\n\u03b1\u271d\u00b9 \u03b2\u271d\u00b9 : Type u\na\u271d\u00b3 : \u03b1\u271d\u00b9 \u2192 PGame\na\u271d\u00b2 : \u03b2\u271d\u00b9 \u2192 PGame\n\u03b1\u271d \u03b2\u271d : Type u\na\u271d\u00b9 : \u03b1\u271d \u2192 PGame\na\u271d : \u03b2\u271d \u2192 PGame\ninst\u271d :\n  IsEmpty\n    ((mk \u03b1\u271d\u00b9 \u03b2\u271d\u00b9 a\u271d\u00b3 a\u271d\u00b2).LeftMoves \u00d7 (mk \u03b1\u271d \u03b2\u271d a\u271d\u00b9 a\u271d).RightMoves \u2295\n      (mk \u03b1\u271d\u00b9 \u03b2\u271d\u00b9 a\u271d\u00b3 a\u271d\u00b2).RightMoves \u00d7 (mk \u03b1\u271d \u03b2\u271d a\u271d\u00b9 a\u271d).LeftMoves)\n\u22a2 IsEmpty (mk \u03b1\u271d\u00b9 \u03b2\u271d\u00b9 a\u271d\u00b3 a\u271d\u00b2 * mk \u03b1\u271d \u03b2\u271d a\u271d\u00b9 a\u271d).RightMoves",["assumption","congr","tauto"]],["LinearAlgebra/AffineSpace/AffineSubspace/Defs.lean",158,"case mk.mk\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ncarrier\u271d\u00b9 : Set P\nsmul_vsub_vadd_mem\u271d\u00b9 :\n  \u2200 (c : k) {p\u2081 p\u2082 p\u2083 : P}, p\u2081 \u2208 carrier\u271d\u00b9 \u2192 p\u2082 \u2208 carrier\u271d\u00b9 \u2192 p\u2083 \u2208 carrier\u271d\u00b9 \u2192 c \u2022 (p\u2081 -\u1d65 p\u2082) +\u1d65 p\u2083 \u2208 carrier\u271d\u00b9\ncarrier\u271d : Set P\nsmul_vsub_vadd_mem\u271d :\n  \u2200 (c : k) {p\u2081 p\u2082 p\u2083 : P}, p\u2081 \u2208 carrier\u271d \u2192 p\u2082 \u2208 carrier\u271d \u2192 p\u2083 \u2208 carrier\u271d \u2192 c \u2022 (p\u2081 -\u1d65 p\u2082) +\u1d65 p\u2083 \u2208 carrier\u271d\nx\u271d :\n  { carrier := carrier\u271d\u00b9, smul_vsub_vadd_mem := smul_vsub_vadd_mem\u271d\u00b9 }.carrier =\n    { carrier := carrier\u271d, smul_vsub_vadd_mem := smul_vsub_vadd_mem\u271d }.carrier\n\u22a2 { carrier := carrier\u271d\u00b9, smul_vsub_vadd_mem := smul_vsub_vadd_mem\u271d\u00b9 } =\n    { carrier := carrier\u271d, smul_vsub_vadd_mem := smul_vsub_vadd_mem\u271d }",["congr","aesop"]],["LinearAlgebra/AffineSpace/AffineSubspace/Defs.lean",445,"case h\nk : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\ns : Set V\nx\u271d : V\n\u22a2 (\u2203 x \u2208 vectorSpan k s, \u2203 y \u2208 s, x + y = x\u271d) \u2194 \u2203 p\u2081 \u2208 s, \u2203 v \u2208 vectorSpan k s, x\u271d = v + p\u2081",["aesop","tauto"]],["Logic/Function/Basic.lean",578,"case pos\n\u03b9 : Sort u_1\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Sort u_2\n\u03b2 : \u03b9 \u2192 Sort u_3\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\ng : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nv : \u03b1 i\n\u22a2 f i (update g i v i) = update (fun k \u21a6 f k (g k)) i (f i v) i",["simp"]],["Logic/Function/Basic.lean",644,"\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ne' : \u03b2 \u2192 \u03b3\nb : \u03b2\ninst\u271d : Decidable (\u2203 a, f a = b)\n\u22a2 (if h : \u2203 a, f a = b then g (Classical.choose h) else e' b) = if h : \u2203 a, f a = b then g (Classical.choose h) else e' b",["congr"]],["Logic/Function/Basic.lean",265,"\u03b1 : Type u\nf : \u03b1 \u2192 Type (max u v)\nhf : Surjective f\nT : Type (max u v) := Sigma f\nU : \u03b1\nhU : f U = Set T\ng : Set T \u2192 T := fun s \u21a6 \u27e8U, cast \u22ef s\u27e9\ns t : Set T\nh : g s = g t\nthis : s = t\n\u22a2 s = t",["assumption","congr"]],["RingTheory/Ideal/Quotient/Operations.lean",1013,"case refine_4.intro.intro\nR : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\nn : \u2115\ny : R\nhy : y \u2208 I ^ n\nhx : (Quotient.mk (I ^ (n + 1))) y \u2208 map (Quotient.mk (I ^ (n + 1))) (I ^ n)\n\u22a2 (fun c \u21a6 \u27e8((I \u2022 \u22a4).mapQ (I ^ (n + 1)) (Submodule.subtype (I ^ n)) \u22ef) c, \u22ef\u27e9) (Submodule.Quotient.mk \u27e8y, hy\u27e9) =\n    \u27e8(Quotient.mk (I ^ (n + 1))) y, hx\u27e9",["simp","aesop","congr","tauto","abel","norm_num"]],["RingTheory/Ideal/Quotient/Operations.lean",934,"case h\nR : Type u\nA : Type u_1\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nI J : Ideal A\na\u271d : (A \u29f8 J) \u29f8 map (Quotient.mk\u2090 R J) I\n\u22a2 (AlgEquiv.ofRingEquiv \u22ef).symm a\u271d = (AlgEquiv.ofRingEquiv \u22ef) a\u271d",["congr","aesop","tauto","abel"]],["Data/Seq/Seq.lean",1186,"case h.e'_2.h.e'_4\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b1' : Type u'\ns\u2081 : Seq \u03b1\ns\u2082 : Seq \u03b2\nf : \u03b1 \u2192 \u03b1'\n\u22a2 s\u2082 = map id s\u2082",["simp","aesop"]],["Data/Seq/Seq.lean",1118,"case e_s\n\u03b1 : Type u\n\u03b2 : Type v\ninit : \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nx : \u03b1\ns : Seq \u03b1\n\u22a2 (match (init, cons x s).2.destruct with\n    | none => none\n    | some (x_1, s_1) => some (f (init, cons x s).1 x_1, f (init, cons x s).1 x_1, s_1)) =\n    some (f init x, f init x, s)",["simp","aesop","congr","tauto"]],["Data/Seq/Seq.lean",1170,"case h.e'_2.h.e'_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b1' : Type u'\ns\u2081 : Seq \u03b1\ns\u2082 : Seq \u03b2\nf : \u03b1 \u2192 \u03b1'\ng : \u03b1' \u2192 \u03b2 \u2192 \u03b3\n\u22a2 s\u2082 = map id s\u2082",["simp","aesop"]],["Data/Seq/Seq.lean",738,"case refine_1.h.a\n\u03b1 : Type u\ns : Seq \u03b1\nh : s.TerminatedAt 0\nn : \u2115\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 none \u2194 a\u271d \u2208 nil.get? n",["simp","aesop","tauto"]],["Data/Seq/Seq.lean",1134,"case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Seq \u03b1\nn\u271d : \u2115\n\u22a2 (zipWith f s nil).get? n\u271d = nil.get? n\u271d",["simp","aesop"]],["Data/Seq/Seq.lean",271,"case mpr\n\u03b1 : Type u\nx x' : \u03b1\ns s' : Seq \u03b1\nleft\u271d : x = x'\nright\u271d : s = s'\n\u22a2 cons x s = cons x' s'",["congr","aesop"]],["Data/Seq/Seq.lean",1103,"case h.succ\n\u03b1 : Type u\ns : Seq \u03b1\nx : \u03b1\nn\u271d : \u2115\n\u22a2 Option.map (Prod.mk (n\u271d + 1)) (s.get? n\u271d) = Option.map (Prod.map Nat.succ id \u2218 Prod.mk n\u271d) (s.get? n\u271d)",["congr","aesop","tauto"]],["Data/Seq/Seq.lean",520,"case none\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b1 \u2192 \u03b2\ns : Stream' (Option \u03b1)\nal : s.IsSeq\nn : \u2115\ne : s n = none\na\u271d : Option.map f none = none\n\u22a2 Option.map f none = none",["assumption","aesop","congr","gcongr","tauto","simp"]],["Data/Seq/Seq.lean",332,"case zero.some.some.mk\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b2 \u2192 Option (\u03b1 \u00d7 \u03b2)\nb\u271d b : \u03b2\na : \u03b1\nb' : \u03b2\nh\u2081 : f b = some (a, b')\nh :\n  (match some (a, b') with\n      | none => (none, none)\n      | some (a, b') => (some a, some b')).1 =\n    none\n\u22a2 (match\n        (match some (a, b') with\n          | none => (none, none)\n          | some (a, b') => (some a, some b')).2 with\n      | none => (none, none)\n      | some b =>\n        match f b with\n        | none => (none, none)\n        | some (a, b') => (some a, some b')).1 =\n    none",["contradiction","aesop","tauto"]],["Analysis/LocallyConvex/WithSeminorms.lean",690,"\ud835\udd5c : Type u_1\nE : Type u_5\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2074 : Nonempty \u03b9\ninst\u271d\u00b3 : Nonempty \u03b9'\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nq : SeminormFamily \ud835\udd5c E \u03b9'\nhpq : Seminorm.IsBounded p q LinearMap.id\nhqp : Seminorm.IsBounded q p LinearMap.id\n\u22a2 Seminorm.IsBounded p q LinearMap.id\n```\n---\n```lean\n\ud835\udd5c : Type u_1\nE : Type u_5\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2074 : Nonempty \u03b9\ninst\u271d\u00b3 : Nonempty \u03b9'\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nq : SeminormFamily \ud835\udd5c E \u03b9'\nhpq : Seminorm.IsBounded p q LinearMap.id\nhqp : Seminorm.IsBounded q p LinearMap.id\n\u22a2 Seminorm.IsBounded q p LinearMap.id",["assumption","aesop","congr","gcongr","tauto"]],["Analysis/Normed/Lp/PiLp.lean",888,"p : \u211d\u22650\u221e\n\u03b9 : Type u_2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9 : Fintype \u03b9\n\u03b2 : Type u_5\ninst\u271d : SeminormedAddCommGroup \u03b2\nhp : p \u2260 \u22a4\nb : \u03b2\n\u22a2 \u2191(\u2191(Fintype.card \u03b9) ^ (1 / p).toReal * \u2016b\u2016\u208a) = \u2191\u2191(Fintype.card \u03b9) ^ (1 / p).toReal * \u2016b\u2016",["simp","aesop","congr","tauto","abel","norm_num"]],["Analysis/Normed/Lp/PiLp.lean",897,"p : \u211d\u22650\u221e\n\u03b9 : Type u_2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b2 : Fintype \u03b9\n\u03b2 : Type u_5\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b2\ninst\u271d : Nonempty \u03b9\nb : \u03b2\n\u22a2 \u2191(\u2191(Fintype.card \u03b9) ^ (1 / p).toReal * \u2016b\u2016\u208a) = \u2191\u2191(Fintype.card \u03b9) ^ (1 / p).toReal * \u2016b\u2016",["simp","aesop","congr","tauto","abel","norm_num"]],["NumberTheory/RamificationInertia/Basic.lean",629,"R : Type u\ninst\u271d\u2075 : CommRing R\nS : Type v\ninst\u271d\u2074 : CommRing S\np : Ideal R\nP : Ideal S\ninst\u271d\u00b3 : Algebra R S\nhfp : NeZero e\ninst\u271d\u00b2 : IsDedekindDomain S\ninst\u271d\u00b9 : p.IsMaximal\ninst\u271d : P.IsPrime\nhP0 : P \u2260 \u22a5\ni : \u2115\nhi : i \u2264 e\nQ : \u2115 \u2192 Prop := fun i \u21a6 Module.rank (R \u29f8 p) \u21a5(map (Quotient.mk (P ^ e)) (P ^ i)) = (e - i) \u2022 Module.rank (R \u29f8 p) (S \u29f8 P)\nj : \u2115\nlt_e : j < e\n_le_j : i \u2264 j\nih : Q (j + 1)\n\u22a2 P \u2260 \u22a5",["assumption","aesop","congr","tauto"]],["NumberTheory/RamificationInertia/Basic.lean",591,"R : Type u\ninst\u271d\u00b3 : CommRing R\nS : Type v\ninst\u271d\u00b2 : CommRing S\np : Ideal R\nP : Ideal S\ninst\u271d\u00b9 : Algebra R S\nhfp : NeZero e\ninst\u271d : IsDedekindDomain S\nhP0 : P \u2260 \u22a5\nhP : P.IsPrime\ni : \u2115\nhi : i < e\na : S\na_mem : a \u2208 P ^ i\na_not_mem : 0 \u2209 P ^ (i + 1)\nb\u271d : \u21a5(map (Quotient.mk (P ^ e)) (P ^ i)) \u29f8 LinearMap.range (p.powQuotSuccInclusion P i)\nval\u271d : S \u29f8 P ^ e\nx : S\nhx\u271d : Quot.mk (\u21d1(Submodule.quotientRel (P ^ e))) x \u2208 map (Quotient.mk (P ^ e)) (P ^ i)\nhx : x \u2208 P ^ i\nPe_le_Pi : P ^ e \u2264 P ^ i\nthis\u271d : DecidableEq (Ideal S) := Classical.decEq (Ideal S)\nha : span {a} = \u22a5\nthis : 0 \u2208 P ^ (i + 1)\n\u22a2 False",["contradiction","aesop","tauto"]],["Analysis/Normed/Algebra/Spectrum.lean",631,"\ud835\udd5c : Type u_3\nA : Type u_4\nSA : Type u_5\ninst\u271d\u2075 : NormedRing A\ninst\u271d\u2074 : CompleteSpace A\ninst\u271d\u00b3 : SetLike SA A\ninst\u271d\u00b2 : SubringClass SA A\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : NormedAlgebra \ud835\udd5c A\ninstSMulMem : SMulMemClass SA \ud835\udd5c A\nS : SA\nhS : IsClosed \u2191S\nx : \u21a5S\nthis : CompleteSpace \u21a5S\n\u03bc : \ud835\udd5c\nh : IsUnit ((algebraMap \ud835\udd5c A) \u03bc - \u2191x)\nh\u03bc\u2081 : ClusterPt \u03bc (\ud835\udcdf (\u03c3 \ud835\udd5c x)\u1d9c)\nh\u03bc\u2082 : \u03bc \u2209 (\u03c3 \ud835\udd5c x)\u1d9c\n\u22a2 \ud835\udcdd \u03bc \u2293 \ud835\udcdf (\u03c3 \ud835\udd5c x)\u1d9c \u2264 \ud835\udcdd \u03bc",["simp","ring","omega","decide","aesop","congr","linarith","positivity","gcongr","tauto","infer_instance","assumption","abel","norm_num","contradiction","fun_prop"]],["Analysis/Normed/Algebra/Spectrum.lean",607,"case refine_1.a\n\ud835\udd5c : Type u_3\nA : Type u_4\nSA : Type u_5\ninst\u271d\u2075 : NormedRing A\ninst\u271d\u2074 : CompleteSpace A\ninst\u271d\u00b3 : SetLike SA A\ninst\u271d\u00b2 : SubringClass SA A\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : NormedAlgebra \ud835\udd5c A\ninstSMulMem : SMulMemClass SA \ud835\udd5c A\nS : SA\nhS : IsClosed \u2191S\nl : Filter \u21a5S\na : \u21a5S\nha : IsUnit \u2191a\nhla : l \u2264 \ud835\udcdd a\nhl : \u2200\u1da0 (x : \u21a5S) in l, IsUnit x\nhl' : l.NeBot\nhla\u2082 : Tendsto Ring.inverse (map (\u21d1(val S)) l) (\ud835\udcdd \u2191ha.unit\u207b\u00b9)\nmem : \u2191ha.unit\u207b\u00b9 \u2208 S\n\u22a2 \u2191(a * \u27e8\u2191ha.unit\u207b\u00b9, mem\u27e9) = \u21911\n```\n---\n```lean\ncase refine_2.a\n\ud835\udd5c : Type u_3\nA : Type u_4\nSA : Type u_5\ninst\u271d\u2075 : NormedRing A\ninst\u271d\u2074 : CompleteSpace A\ninst\u271d\u00b3 : SetLike SA A\ninst\u271d\u00b2 : SubringClass SA A\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : NormedAlgebra \ud835\udd5c A\ninstSMulMem : SMulMemClass SA \ud835\udd5c A\nS : SA\nhS : IsClosed \u2191S\nl : Filter \u21a5S\na : \u21a5S\nha : IsUnit \u2191a\nhla : l \u2264 \ud835\udcdd a\nhl : \u2200\u1da0 (x : \u21a5S) in l, IsUnit x\nhl' : l.NeBot\nhla\u2082 : Tendsto Ring.inverse (map (\u21d1(val S)) l) (\ud835\udcdd \u2191ha.unit\u207b\u00b9)\nmem : \u2191ha.unit\u207b\u00b9 \u2208 S\n\u22a2 \u2191(\u27e8\u2191ha.unit\u207b\u00b9, mem\u27e9 * a) = \u21911",["simp","aesop","norm_num"]],["Analysis/Normed/Algebra/Spectrum.lean",748,"case refine_1.intro.intro\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u2102 A\na : A\nh : SpectrumRestricts a \u21d1Complex.reCLM\nx : \u211d\nhx : (algebraMap \u211d \u2102) x \u2208 spectrum \u2102 a\n\u22a2 (algebraMap \u211d \u2102) x = \u2191((algebraMap \u211d \u2102) x).re",["simp","aesop","congr","tauto","abel","norm_num"]],["Analysis/Normed/Algebra/Spectrum.lean",786,"case refine_1.intro.intro.intro.intro\nA : Type u_3\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u211d A\na : A\nt : \u211d\u22650\nht : spectralRadius \u211d a \u2264 \u2191t\nthis : spectrum \u211d a \u2286 Set.Icc (-\u2191t) \u2191t\nh : \u2200 x \u2208 spectrum \u211d a, 0 \u2264 x\ny : \u211d\u22650\nhy : \u2191y \u2208 spectrum \u211d a\nhx : \u2191t - \u2191y \u2208 {\u2191t} - spectrum \u211d a\nhty : -\u2191t \u2264 \u2191y\nhyt : \u2191y \u2264 \u2191t\n\u22a2 \u2191\u2016\u2191(t - y)\u2016\u208a \u2264 \u2191t",["simp","norm_num"]],["Analysis/Normed/Algebra/Spectrum.lean",210,"case h.e'_3.hn\n\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedRing A\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c A\ninst\u271d : CompleteSpace A\na : A\nn : \u2115\nk : \ud835\udd5c\nhk : k \u2208 \u03c3 a\npow_mem : k ^ (n + 1) \u2208 \u03c3 (a ^ (n + 1))\nnnnorm_pow_le : \u2191(\u2016k\u2016\u208a ^ (n + 1)) \u2264 \u2191\u2016a ^ (n + 1)\u2016\u208a * \u2191\u20161\u2016\u208a\nhn : 0 < \u2191(n + 1)\n\u22a2 n + 1 \u2260 0",["positivity","omega","aesop","linarith","tauto","norm_num","simp"]],["Analysis/Normed/Algebra/Spectrum.lean",133,"\ud835\udd5c : Type u_1\nA\u271d : Type u_2\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : NormedRing A\u271d\ninst\u271d\u2074 : NormedAlgebra \ud835\udd5c A\u271d\ninst\u271d\u00b3 : CompleteSpace A\u271d\nA : Type u_3\ninst\u271d\u00b2 : NormedRing A\ninst\u271d\u00b9 : NormedAlgebra \u211d A\na : A\ninst\u271d : IsCompact (spectrum \u211d a)\n\u22a2 IsCompact (spectrum \u211d a)",["assumption","aesop","congr","gcongr","tauto"]],["Analysis/Normed/Algebra/Spectrum.lean",154,"\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : NormedRing A\ninst\u271d\u00b9\u00b9 : NormedAlgebra \ud835\udd5c A\ninst\u271d\u00b9\u2070 : CompleteSpace A\nB : Type u_3\ninst\u271d\u2079 : NonUnitalNormedRing B\ninst\u271d\u2078 : NormedSpace \ud835\udd5c B\ninst\u271d\u2077 : CompleteSpace B\ninst\u271d\u2076 : IsScalarTower \ud835\udd5c B B\ninst\u271d\u2075 : SMulCommClass \ud835\udd5c B B\ninst\u271d\u2074 : ProperSpace \ud835\udd5c\ninst\u271d\u00b3 : NormedSpace \u211d B\ninst\u271d\u00b2 : IsScalarTower \u211d B B\ninst\u271d\u00b9 : SMulCommClass \u211d B B\na : B\ninst\u271d : IsCompact (quasispectrum \u211d a)\n\u22a2 IsCompact (quasispectrum \u211d a)",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Group/Hom/Defs.lean",439,"\u03b9 : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b3 : FunLike F G H\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : DivisionMonoid H\ninst\u271d : MonoidHomClass F G H\nf : F\ng h : \u03b9 \u2192 G\n\u22a2 \u21d1f \u2218 (g * h\u207b\u00b9) = \u21d1f \u2218 g * (\u21d1f \u2218 h)\u207b\u00b9",["simp"]],["Algebra/Group/Hom/Defs.lean",1025,"\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : DivisionMonoid \u03b2\nf : \u03b1 \u2192* \u03b2\ng h : \u03b1\n\u22a2 f (g * h\u207b\u00b9) = f g * (f h)\u207b\u00b9",["simp","infer_instance"]],["Algebra/Group/Hom/Defs.lean",221,"\u03b9 : Type u_1\nM : Type u_4\nN : Type u_5\nF : Type u_9\ninst\u271d\u00b3 : One M\ninst\u271d\u00b2 : One N\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : OneHomClass F M N\nf : F\n\u22a2 \u21d1f \u2218 1 = 1",["simp"]],["Algebra/Group/Hom/Defs.lean",189,"case mk.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ntoFun\u271d\u00b9 : M \u2192 N\nmap_one'\u271d\u00b9 : toFun\u271d\u00b9 1 = 1\ntoFun\u271d : M \u2192 N\nmap_one'\u271d : toFun\u271d 1 = 1\nh : { toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, map_one' := map_one'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9 } = { toFun := toFun\u271d, map_one' := map_one'\u271d }",["congr"]],["Algebra/Group/Hom/Defs.lean",299,"case mk.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b9 : Mul M\ninst\u271d : Mul N\ntoFun\u271d\u00b9 : M \u2192 N\nmap_mul'\u271d\u00b9 : \u2200 (x y : M), toFun\u271d\u00b9 (x * y) = toFun\u271d\u00b9 x * toFun\u271d\u00b9 y\ntoFun\u271d : M \u2192 N\nmap_mul'\u271d : \u2200 (x y : M), toFun\u271d (x * y) = toFun\u271d x * toFun\u271d y\nh : { toFun := toFun\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, map_mul' := map_mul'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 } = { toFun := toFun\u271d, map_mul' := map_mul'\u271d }",["congr"]],["Algebra/Polynomial/Basic.lean",1018,"case ofFinsupp\nR : Type u\ninst\u271d\u00b9 : Semiring R\nn : \u2115\na : R\ninst\u271d : Decidable (a = 0)\ntoFinsupp\u271d : R[\u2115]\n\u22a2 (if a = 0 then toFinsupp\u271d.support.erase n else insert n toFinsupp\u271d.support) =\n    if a = 0 then toFinsupp\u271d.support.erase n else insert n toFinsupp\u271d.support",["congr","aesop","simp"]],["AlgebraicGeometry/EllipticCurve/Affine.lean",563,"case pos\nF : Type u\ninst\u271d : Field F\nW : Affine F\nx\u2081 y\u2081 y\u2082 : F\nh\u2081 : W.Nonsingular x\u2081 y\u2081\nh\u2082 : W.Nonsingular x\u2081 y\u2082\nhxy : \u00ac(x\u2081 = x\u2081 \u2227 y\u2081 = W.negY x\u2081 y\u2082)\nhx\u2081 : \u00acW.addX x\u2081 x\u2081 (W.slope x\u2081 x\u2081 y\u2081 y\u2082) = x\u2081\nhx\u2082 : W.addX x\u2081 x\u2081 (W.slope x\u2081 x\u2081 y\u2081 y\u2082) = x\u2081\n\u22a2 W.Nonsingular (W.addX x\u2081 x\u2081 (W.slope x\u2081 x\u2081 y\u2081 y\u2082)) (W.negAddY x\u2081 x\u2081 y\u2081 (W.slope x\u2081 x\u2081 y\u2081 y\u2082))",["contradiction","aesop","tauto"]],["Topology/MetricSpace/PiNat.lean",634,"E : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 TopologicalSpace (E n)\ninst\u271d : \u2200 (n : \u2115), DiscreteTopology (E n)\ns : Set ((n : \u2115) \u2192 E n)\nhs : IsClosed s\nhne : s.Nonempty\nf : ((n : \u2115) \u2192 E n) \u2192 (n : \u2115) \u2192 E n := fun x \u21a6 if x \u2208 s then x else \u22ef.some\nfs : \u2200 x \u2208 s, f x = x\nx y : (n : \u2115) \u2192 E n\nhxy : x \u2260 y\nI2 : cylinder x (firstDiff x y) = cylinder y (firstDiff x y)\nxs : x \u2209 s\nys : y \u2209 s\nAx : (s \u2229 cylinder x (longestPrefix x s)).Nonempty\nfx : f x = Ax.some\nAy : (s \u2229 cylinder y (longestPrefix y s)).Nonempty\nhfxfy : Ax.some \u2260 Ay.some\nfy : f y = Ay.some\nH : longestPrefix x s < firstDiff x y \u2228 longestPrefix y s < firstDiff x y\nthis : cylinder x (longestPrefix x s) = cylinder y (longestPrefix y s)\n\u22a2 Ax.some = Ay.some",["congr","aesop"]],["Topology/MetricSpace/PiNat.lean",682,"\u03b1 : Type u_2\ninst\u271d\u00b3 : MetricSpace \u03b1\ninst\u271d\u00b2 : CompleteSpace \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\ninst\u271d : Nonempty \u03b1\nthis : MetricSpace (\u2115 \u2192 \u2115) := metricSpaceNatNat\n\u22a2 0 < 1 / 2",["norm_num","aesop","linarith","positivity","simp"]],["Analysis/InnerProductSpace/Basic.lean",430,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nx y : E\nh : \u2016x\u2016 = 0\n\u22a2 0 \u2264 \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016",["positivity","aesop","norm_num","simp"]],["Analysis/InnerProductSpace/Basic.lean",501,"F : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx y : F\n\u22a2 2 = 0 \u2228 re \u27eax, y\u27eb_\u211d = 0 \u2194 \u27eax, y\u27eb_\u211d = 0",["norm_num","aesop","simp"]],["Analysis/InnerProductSpace/Basic.lean",527,"F : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx y : F\n\u22a2 2 = 0 \u2228 re \u27eax, y\u27eb_\u211d = 0 \u2194 \u27eax, y\u27eb_\u211d = 0",["norm_num","aesop","simp"]],["Analysis/InnerProductSpace/Basic.lean",462,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nx y : E\n\u22a2 re \u27eax, y\u27eb_\ud835\udd5c = (\u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 - (\u2016x\u2016 * \u2016x\u2016 - 2 * re \u27eax, y\u27eb_\ud835\udd5c + \u2016y\u2016 * \u2016y\u2016)) / 2",["ring","aesop","linarith","norm_num","simp"]],["ModelTheory/Semantics.lean",470,"case refine_2\nL : Language\nM : Type w\ninst\u271d\u00b9 : L.Structure M\n\u03b1 : Type u'\ninst\u271d : Nonempty M\nn : \u2115\n\u03c6 : L.BoundedFormula \u03b1 n\nv : \u03b1 \u2192 M\nxs : Fin n \u2192 M\ninhabited_h : Inhabited M\nh : \u03c6.Realize v xs\na : M\ni : Fin n\n\u22a2 xs i = (snoc xs a \u2218 castSucc) i",["simp","aesop"]],["ModelTheory/Semantics.lean",437,"L : Language\nM : Type w\ninst\u271d\u00b9 : L.Structure M\n\u03b1 : Type u'\ninst\u271d : DecidableEq \u03b1\nn : \u2115\n\u03c6 : L.BoundedFormula \u03b1 n\ns : Set \u03b1\nh : \u2191\u03c6.freeVarFinset \u2286 s\nv : \u03b1 \u2192 M\nxs : Fin n \u2192 M\n\u22a2 \u2200 (a : { x // x \u2208 \u03c6.freeVarFinset }), (v \u2218 Subtype.val) (Set.inclusion h a) = v \u2191a",["simp","aesop","tauto"]],["ModelTheory/Semantics.lean",292,"L : Language\nM : Type w\ninst\u271d : L.Structure M\n\u03b1 : Type u'\nl : \u2115\n\u03c6 \u03c8 : L.BoundedFormula \u03b1 l\nv : \u03b1 \u2192 M\nxs : Fin l \u2192 M\n\u22a2 (\u223c\u03c6 \u27f9 \u03c8).Realize v xs \u2194 \u03c6.Realize v xs \u2228 \u03c8.Realize v xs",["tauto"]],["Analysis/SpecificLimits/Normed.lean",691,"case h.e'_5.h.e'_3\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nb : \u211d\nf : \u2115 \u2192 \u211d\nz : \u2115 \u2192 E\nhfa : Antitone f\nhf0 : Tendsto f atTop (\ud835\udcdd 0)\nhzb : \u2200 (n : \u2115), \u2016\u2211 i \u2208 Finset.range n, z i\u2016 \u2264 b\nhfa' : Monotone fun n \u21a6 -f n\n\u22a2 0 = -0",["norm_num","ring","aesop","linarith","abel","simp"]],["Analysis/SpecificLimits/Normed.lean",439,"R : Type u_2\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nk\u271d : \u2115\nr : R\nhr : \u2016r\u2016 < 1\nk : \u2115\nhk : \u2200 m < k, Summable fun n \u21a6 \u2191n ^ m * r ^ n\nP : \u2115[X] := (ascPochhammer \u2115 k).comp (X + C 1)\nn : \u2115\nmP : P.Monic\ndP : P.natDegree = k\n\u22a2 n + 1 + k - 1 = n + k",["omega","aesop","norm_num","simp"]],["Analysis/SpecificLimits/Normed.lean",745,"E : Type u_2\ninst\u271d\u00b2 : OrderedRing E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : OrderClosedTopology E\nl : E\nf : \u2115 \u2192 E\nhfl : Tendsto (fun n \u21a6 \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (\ud835\udcdd l)\nhfm : Monotone f\nk n : \u2115\n\u22a2 2 * n \u2264 2 * n + 1",["omega","aesop","linarith","tauto","norm_num","simp"]],["Analysis/SpecificLimits/Normed.lean",760,"E : Type u_2\ninst\u271d\u00b2 : OrderedRing E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : OrderClosedTopology E\nl : E\nf : \u2115 \u2192 E\nhfl : Tendsto (fun n \u21a6 \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (\ud835\udcdd l)\nhfm : Monotone f\nk n : \u2115\n\u22a2 2 * n + 1 \u2264 2 * n + 1 + 1",["omega","aesop","linarith","tauto","norm_num","simp"]],["Analysis/SpecificLimits/Normed.lean",774,"E : Type u_2\ninst\u271d\u00b2 : OrderedRing E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : OrderClosedTopology E\nl : E\nf : \u2115 \u2192 E\nhfl : Tendsto (fun n \u21a6 \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (\ud835\udcdd l)\nhfa : Antitone f\nk n : \u2115\n\u22a2 2 * n \u2264 2 * n + 1",["omega","aesop","linarith","tauto","norm_num","simp"]],["Analysis/SpecificLimits/Normed.lean",788,"E : Type u_2\ninst\u271d\u00b2 : OrderedRing E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : OrderClosedTopology E\nl : E\nf : \u2115 \u2192 E\nhfl : Tendsto (fun n \u21a6 \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (\ud835\udcdd l)\nhfa : Antitone f\nk n : \u2115\n\u22a2 2 * n + 1 \u2264 2 * n + 2",["omega","aesop","linarith","tauto","norm_num","simp"]],["CategoryTheory/Limits/Shapes/BinaryBiproducts.lean",309,"J : Type w\nC : Type uC\ninst\u271d\u00b3 : Category.{uC', uC} C\ninst\u271d\u00b2 : HasZeroMorphisms C\nD : Type uD\ninst\u271d\u00b9 : Category.{uD', uD} D\ninst\u271d : HasZeroMorphisms D\nX Y : C\nb : Bicone (pairFunction X Y)\nx\u271d : b.toBinaryBicone.IsBilimit\nh : IsLimit b.toBinaryBicone.toCone\nh' : IsColimit b.toBinaryBicone.toCocone\n\u22a2 { isLimit := b.toBinaryBiconeIsLimit.symm (b.toBinaryBiconeIsLimit h),\n      isColimit := b.toBinaryBiconeIsColimit.symm (b.toBinaryBiconeIsColimit h') } =\n    { isLimit := h, isColimit := h' }",["simp","aesop"]],["CategoryTheory/Limits/Shapes/BinaryBiproducts.lean",301,"J : Type w\nC : Type uC\ninst\u271d\u00b3 : Category.{uC', uC} C\ninst\u271d\u00b2 : HasZeroMorphisms C\nD : Type uD\ninst\u271d\u00b9 : Category.{uD', uD} D\ninst\u271d : HasZeroMorphisms D\nX Y : C\nb : BinaryBicone X Y\nx\u271d : b.IsBilimit\nh : IsLimit b.toCone\nh' : IsColimit b.toCocone\n\u22a2 { isLimit := b.toBiconeIsLimit (b.toBiconeIsLimit.symm h),\n      isColimit := b.toBiconeIsColimit (b.toBiconeIsColimit.symm h') } =\n    { isLimit := h, isColimit := h' }",["simp","aesop"]],["CategoryTheory/Limits/Shapes/BinaryBiproducts.lean",561,"case h\u2080.h\u2080\nC : Type uC\ninst\u271d\u00b3 : Category.{uC', uC} C\ninst\u271d\u00b2 : HasZeroMorphisms C\nW X Y Z : C\ninst\u271d\u00b9 : HasBinaryBiproduct W X\ninst\u271d : HasBinaryBiproduct Y Z\nf : W \u27f6 Y\ng : X \u27f6 Z\n\u22a2 inl \u226b fst \u226b f = f \u226b inl \u226b fst",["simp","aesop"]],["CategoryTheory/Limits/Shapes/BinaryBiproducts.lean",999,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasBinaryBiproducts C\nW X Y Z : C\nf : W \u27f6 Y\ng : X \u27f6 Z\ninst\u271d : IsIso (biprod.map f g)\n\u22a2 IsIso ((biprod.braiding X W).hom \u226b biprod.map f g \u226b (biprod.braiding Y Z).hom)",["infer_instance","omega","tauto"]],["CategoryTheory/Limits/Shapes/BinaryBiproducts.lean",95,"case mk.mk\nC : Type uC\ninst\u271d\u00b9 : Category.{uC', uC} C\ninst\u271d : HasZeroMorphisms C\nP Q : C\nc c' : BinaryBicone P Q\nhom\u271d\u00b9 : c.pt \u27f6 c'.pt\nwfst\u271d\u00b9 : hom\u271d\u00b9 \u226b c'.fst = c.fst\nwsnd\u271d\u00b9 : hom\u271d\u00b9 \u226b c'.snd = c.snd\nwinl\u271d\u00b9 : c.inl \u226b hom\u271d\u00b9 = c'.inl\nwinr\u271d\u00b9 : c.inr \u226b hom\u271d\u00b9 = c'.inr\nhom\u271d : c.pt \u27f6 c'.pt\nwfst\u271d : hom\u271d \u226b c'.fst = c.fst\nwsnd\u271d : hom\u271d \u226b c'.snd = c.snd\nwinl\u271d : c.inl \u226b hom\u271d = c'.inl\nwinr\u271d : c.inr \u226b hom\u271d = c'.inr\nw :\n  { hom := hom\u271d\u00b9, wfst := wfst\u271d\u00b9, wsnd := wsnd\u271d\u00b9, winl := winl\u271d\u00b9, winr := winr\u271d\u00b9 }.hom =\n    { hom := hom\u271d, wfst := wfst\u271d, wsnd := wsnd\u271d, winl := winl\u271d, winr := winr\u271d }.hom\n\u22a2 { hom := hom\u271d\u00b9, wfst := wfst\u271d\u00b9, wsnd := wsnd\u271d\u00b9, winl := winl\u271d\u00b9, winr := winr\u271d\u00b9 } =\n    { hom := hom\u271d, wfst := wfst\u271d, wsnd := wsnd\u271d, winl := winl\u271d, winr := winr\u271d }",["congr","aesop"]],["Algebra/Lie/Nilpotent.lean",428,"L : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : Nontrivial M\n\u22a2 IsTrivial L M \u2227 lowerCentralSeries \u2124 L M 0 \u2260 \u22a5 \u2194 IsTrivial L M",["simp","aesop","norm_num"]],["Algebra/Lie/Nilpotent.lean",559,"case succ\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\nN\u2081 N\u2082 : LieSubmodule R L M\ninst\u271d : LieModule R L M\nh : N\u2081 \u2264 N\u2082\nk : \u2115\nih : ucs k N\u2081 \u2264 ucs k N\u2082\n\u22a2 (ucs k N\u2081).normalizer \u2264 (ucs k N\u2082).normalizer",["gcongr","tauto"]],["Algebra/Lie/Nilpotent.lean",241,"case succ.h\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\nk : \u2115\nM\u2082 : Type w\u2081\ninst\u271d\u2074 : AddCommGroup M\u2082\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : LieRingModule L M\u2082\ninst\u271d\u00b9 : LieModule R L M\u2082\ninst\u271d : LieModule R L M\nf : M \u2192\u2097\u2045R,L\u2046 M\u2082\nhf : Function.Surjective \u21d1f\nn\u271d : \u2115\na\u271d : lowerCentralSeries R L M\u2082 n\u271d \u2264 LieSubmodule.map f (lowerCentralSeries R L M n\u271d)\n\u22a2 lowerCentralSeries R L M\u2082 n\u271d \u2264 LieSubmodule.map f (lowerCentralSeries R L M n\u271d)",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Lie/Nilpotent.lean",717,"R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : LieAlgebra R L\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieModule R L M\nM\u2081 M\u2082 : LieSubmodule R L M\nh\u2081 : M\u2081 \u2264 M\u2082\ninst\u271d : IsNilpotent L \u21a5M\u2082\nf : L \u2192\u2097\u2045R\u2046 L := LieHom.id\ng : \u21a5M\u2081 \u2192\u2097[R] \u21a5M\u2082 := Submodule.inclusion h\u2081\n\u22a2 \u2200 (x : L) (m : \u21a5M\u2081), \u2045f x, g m\u2046 = g \u2045x, m\u2046",["aesop","tauto"]],["Algebra/Lie/Nilpotent.lean",931,"R : Type u_1\nL : Type u_2\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\nI : LieIdeal R L\nM : Type u_3\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\nk : \u2115\ninst\u271d : LieModule.IsNilpotent L \u21a5I\nf : \u21a5I \u2192\u2097\u2045R\u2046 L := I.incl\ng : \u21a5I \u2192\u2097\u2045R\u2046 \u21a5I := LieHom.id\n\u22a2 \u2200 (x m : \u21a5I), \u2045f x, g m\u2046 = g \u2045x, m\u2046",["aesop","tauto"]],["Algebra/Lie/Nilpotent.lean",463,"case zero\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : LieAlgebra R L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieModule R L M\ninst\u271d\u00b9 : Nontrivial M\ninst\u271d : IsNilpotent L M\nh : \u00acNontrivial M\n\u22a2 (match 0 with\n    | 0 => \u22a5\n    | k.succ => lowerCentralSeries R L M k) \u2260\n    \u22a5",["contradiction","aesop","tauto"]],["Algebra/Lie/Nilpotent.lean",473,"R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : IsNilpotent L M\nh : \u00acIsTrivial L M\ncontra : \u00ac1 < nilpotencyLength L M\nthis : IsTrivial L M\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/Lie/Nilpotent.lean",334,"R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : LieAlgebra R L\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieModule R L M\ninst\u271d : IsNilpotent L M\nx : L\nthis : \u2203 k, \u2200 (x : L), (toEnd R L M) x ^ k = 0\n\u22a2 \u2203 k, (toEnd R L M) x ^ k = 0",["tauto","aesop"]],["Order/ConditionallyCompleteLattice/Basic.lean",141,"case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : CompleteLattice \u03b1\ns\u271d : Set \u03b1\na\u271d\u00b2 : \u03b1\na\u271d\u00b9 : BddAbove s\u271d\na\u271d : a\u271d\u00b2 \u2208 s\u271d\n\u22a2 a\u271d\u00b2 \u2208 s\u271d",["assumption","aesop","congr","gcongr","tauto"]],["Order/ConditionallyCompleteLattice/Basic.lean",142,"case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : CompleteLattice \u03b1\ns\u271d : Set \u03b1\na\u271d\u00b2 : \u03b1\na\u271d\u00b9 : s\u271d.Nonempty\na\u271d : a\u271d\u00b2 \u2208 upperBounds s\u271d\n\u22a2 \u2200 b \u2208 s\u271d, b \u2264 a\u271d\u00b2",["assumption"]],["Order/ConditionallyCompleteLattice/Basic.lean",143,"case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : CompleteLattice \u03b1\ns\u271d : Set \u03b1\na\u271d\u00b2 : \u03b1\na\u271d\u00b9 : BddBelow s\u271d\na\u271d : a\u271d\u00b2 \u2208 s\u271d\n\u22a2 a\u271d\u00b2 \u2208 s\u271d",["assumption"]],["Order/ConditionallyCompleteLattice/Basic.lean",144,"case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : CompleteLattice \u03b1\ns\u271d : Set \u03b1\na\u271d\u00b2 : \u03b1\na\u271d\u00b9 : s\u271d.Nonempty\na\u271d : a\u271d\u00b2 \u2208 lowerBounds s\u271d\n\u22a2 \u2200 b \u2208 s\u271d, a\u271d\u00b2 \u2264 b",["assumption"]],["NumberTheory/Padics/PadicNumbers.lean",390,"p : \u2115\nhp : Fact (Nat.Prime p)\na : PadicSeq p\n\u22a2 \u2200 (k : \u2115), padicNorm p (\u2191(-a) k) = padicNorm p (\u2191a k)",["simp","aesop","norm_num"]],["NumberTheory/Padics/PadicNumbers.lean",457,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 Add \u211a_[p]",["infer_instance","tauto"]],["NumberTheory/Padics/PadicNumbers.lean",459,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 Mul \u211a_[p]",["infer_instance","tauto"]],["NumberTheory/Padics/PadicNumbers.lean",461,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 Sub \u211a_[p]",["infer_instance","tauto"]],["NumberTheory/Padics/PadicNumbers.lean",463,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 Neg \u211a_[p]",["infer_instance","tauto"]],["NumberTheory/Padics/PadicNumbers.lean",465,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 Div \u211a_[p]",["infer_instance","tauto"]],["NumberTheory/Padics/PadicNumbers.lean",642,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nf : CauSeq \u211a_[p] \u21d1padicNormE\n\u03b5 : \u211a\nh\u03b5 : \u03b5 > 0\n\u22a2 0 < 3",["norm_num","decide","aesop","congr","linarith","positivity","tauto","simp"]],["GroupTheory/CoprodI.lean",636,"case append.h\n\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\ni j i\u271d j\u271d k\u271d l\u271d : \u03b9\n_w\u2081\u271d : NeWord M i\u271d j\u271d\n_hne\u271d : j\u271d \u2260 k\u271d\n_w\u2082\u271d : NeWord M k\u271d l\u271d\n_w\u2081_ih\u271d : _w\u2081\u271d.toList \u2260 []\n_w\u2082_ih\u271d : _w\u2082\u271d.toList \u2260 []\n\u22a2 _w\u2081\u271d.toList \u2260 []",["assumption","aesop","congr","tauto"]],["GroupTheory/CoprodI.lean",656,"\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\ni j i\u271d j\u271d k\u271d l\u271d : \u03b9\n_w\u2081\u271d : NeWord M i\u271d j\u271d\n_hne\u271d : j\u271d \u2260 k\u271d\n_w\u2082\u271d : NeWord M k\u271d l\u271d\n_w\u2081_ih\u271d : \u27e8i\u271d, _w\u2081\u271d.head\u27e9 \u2208 _w\u2081\u271d.toList.head?\n_w\u2082_ih\u271d : \u27e8k\u271d, _w\u2082\u271d.head\u27e9 \u2208 _w\u2082\u271d.toList.head?\n\u22a2 \u27e8i\u271d, (_w\u2081\u271d.append _hne\u271d _w\u2082\u271d).head\u27e9 \u2208 _w\u2081\u271d.toList.head?",["assumption","aesop","congr","tauto"]],["GroupTheory/CoprodI.lean",664,"\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\ni j i\u271d j\u271d k\u271d l\u271d : \u03b9\n_w\u2081\u271d : NeWord M i\u271d j\u271d\n_hne\u271d : j\u271d \u2260 k\u271d\n_w\u2082\u271d : NeWord M k\u271d l\u271d\n_w\u2081_ih\u271d : \u27e8j\u271d, _w\u2081\u271d.last\u27e9 \u2208 _w\u2081\u271d.toList.getLast?\n_w\u2082_ih\u271d : \u27e8l\u271d, _w\u2082\u271d.last\u27e9 \u2208 _w\u2082\u271d.toList.getLast?\n\u22a2 \u27e8l\u271d, (_w\u2081\u271d.append _hne\u271d _w\u2082\u271d).last\u27e9 \u2208 _w\u2082\u271d.toList.getLast?",["assumption","aesop","congr","tauto"]],["GroupTheory/CoprodI.lean",684,"case append\n\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Monoid (M i)\nN : Type u_3\ninst\u271d : Monoid N\ni j i\u271d j\u271d k\u271d l\u271d : \u03b9\n_w\u2081\u271d : NeWord M i\u271d j\u271d\n_hne\u271d : j\u271d \u2260 k\u271d\n_w\u2082\u271d : NeWord M k\u271d l\u271d\n_w\u2081_ih\u271d : List.Chain' (fun l l' \u21a6 l.fst \u2260 l'.fst) _w\u2081\u271d.toList\n_w\u2082_ih\u271d : List.Chain' (fun l l' \u21a6 l.fst \u2260 l'.fst) _w\u2082\u271d.toList\n\u22a2 \u27e8j\u271d, _w\u2081\u271d.last\u27e9.fst \u2260 \u27e8k\u271d, _w\u2082\u271d.head\u27e9.fst",["assumption","aesop","congr","tauto"]],["AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean",358,"case e_a\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u2115 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\nf : A\nm : \u2115\nf_deg : f \u2208 \ud835\udc9c m\nq : \u2191\u2191(Spec A\u2070_ f).toPresheafedSpace\na b : A\nha : a \u2208 carrier f_deg q\nhb : b \u2208 carrier f_deg q\ni j : \u2115\nh2 : \u00acm + m < j\nh1 : \u00acj \u2264 m\nl : A\u2070_ f := HomogeneousLocalization.mk { deg := m * i, num := \u27e8(proj \ud835\udc9c i) a ^ m, \u22ef\u27e9, den := \u27e8f ^ i, \u22ef\u27e9, den_mem := \u22ef }\n\u22a2 \u2191m = \u2191j - \u2191m + (\u2191m + \u2191m - \u2191j)",["abel","ring","omega","aesop","linarith","norm_num","simp"]],["Data/Seq/Computation.lean",262,"case right\n\u03b1 : Type u\nR : Computation \u03b1 \u2192 Computation \u03b1 \u2192 Prop\nbisim : IsBisimulation R\ns\u2081 s\u2082 : Computation \u03b1\nr\u271d : R s\u2081 s\u2082\nt\u2081 t\u2082 : Stream' (Option \u03b1)\ne : \u2203 s s', \u2191s = t\u2081 \u2227 \u2191s' = t\u2082 \u2227 R s s'\ns s' : Computation \u03b1\nr' a' : \u03b1\nr : R (pure a') (pure a')\nh : r' = a'\n\u22a2 R (pure a') (pure a')",["assumption","aesop","congr","gcongr","tauto"]],["Data/Seq/Computation.lean",341,"\u03b1 : Type u\na : \u03b1\nx\u271d : a \u2208 empty \u03b1\nn : \u2115\nh : (fun b \u21a6 some a = b) ((\u2191(empty \u03b1)).get n)\n\u22a2 False",["contradiction","tauto"]],["Data/Seq/Computation.lean",509,"case intro.intro\n\u03b1 : Type u\na\u271d : \u03b1\ns a : Computation \u03b1\nh : a.think.Results a\u271d 0\nn : \u2115\nleft\u271d : a.Results a\u271d n\nright\u271d : 0 = n + 1\n\u22a2 a.think = (pure a\u271d).thinkN 0",["contradiction","omega","aesop","tauto"]],["Data/Seq/Computation.lean",511,"\u03b1 : Type u\na\u271d : \u03b1\nn : \u2115\nIH : \u2200 {s : Computation \u03b1}, s.Results a\u271d n \u2192 s = (pure a\u271d).thinkN n\ns : Computation \u03b1\na : \u03b1\nh : (pure a).Results a\u271d (n + 1)\nthis : n + 1 = 0\n\u22a2 pure a = (pure a\u271d).thinkN (n + 1)",["contradiction"]],["Data/Seq/Computation.lean",692,"\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 Computation \u03b2\nb : \u03b2\ns e : Computation \u03b1\nh : (e.think.bind f).Results b 0\nthis : (e.think.bind f).head = ((pure b).thinkN 0).head\n\u22a2 \u2203 a m n, e.think.Results a m \u2227 (f a).Results b n \u2227 0 = n + m",["contradiction","tauto"]],["Analysis/SpecialFunctions/Trigonometric/Deriv.lean",642,"x : \u211d\n\u22a2 sinh x \u2264 x \u2194 sinh x - x \u2264 sinh 0 - 0",["simp","aesop","norm_num"]],["Order/KrullDimension.lean",971,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 \u2200 (x : \u03b1), height \u2191(Equiv.withTopSubtypeNe.symm x) + 1 = height x + 1",["simp","omega","aesop","infer_instance"]],["Order/KrullDimension.lean",628,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : InfiniteDimensionalOrder \u03b1\nm\u271d : WithBot \u2115\u221e\nhm\u271d : \u2200 (i : LTSeries \u03b1), \u2191i.length \u2264 m\u271d\nm : \u2115\nhm : \u2200 (i : LTSeries \u03b1), \u2191i.length \u2264 some (some m)\n\u22a2 m < \u2191(LTSeries.withLength \u03b1 (m + 1)).length",["simp","aesop"]],["Order/KrullDimension.lean",884,"case neg.a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na : \u03b1\nf : \u2115 \u2192 \u2191(Set.Ioi a)\nhstrictmono : StrictMono f\nm i : \u2115\nhi : i < m\nhzero : \u00aci = 0\n\u22a2 i < i + 1",["omega","aesop","tauto","simp"]],["Order/CompleteBooleanAlgebra.lean",268,"\u03b1 : Type u\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\nminAx : MinimalAxioms \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 \u03b1\nx\u271d : CompleteLattice \u03b1 := minAx.toCompleteLattice\ng : ((i : \u03b9) \u2192 \u03ba i) \u2192 \u03b9\nh : (a : \u03b9) \u2192 \u03ba a\nhh : \u2200 (a : \u03b9) (f : (i : \u03b9) \u2192 \u03ba i) (h_1 : a = g f), h_1 \u25b8 h a \u2260 f (g f)\nthis : \u22ef \u25b8 h (g h) \u2260 h (g h)\n\u22a2 False",["contradiction","aesop","tauto"]],["LinearAlgebra/PiTensorProduct.lean",613,"case H.H\n\u03b9 : Type u_1\n\u03b9\u2082 : Type u_2\n\u03b9\u2083 : Type u_3\nR : Type u_4\ninst\u271d\u00b9\u00b9 : CommSemiring R\nR\u2081 : Type u_5\nR\u2082 : Type u_6\ns : \u03b9 \u2192 Type u_7\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 AddCommMonoid (s i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 Module R (s i)\nM : Type u_8\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nE : Type u_9\ninst\u271d\u2076 : AddCommMonoid E\ninst\u271d\u2075 : Module R E\nF : Type u_10\ninst\u271d\u2074 : AddCommMonoid F\nt : \u03b9 \u2192 Type u_11\nt' : \u03b9 \u2192 Type u_12\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (t i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (t i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (t' i)\ninst\u271d : (i : \u03b9) \u2192 Module R (t' i)\ng : (i : \u03b9) \u2192 t i \u2192\u2097[R] t' i\nf\u271d : (i : \u03b9) \u2192 s i \u2192\u2097[R] t i\nf : (i : \u03b9) \u2192 s i \u2243\u2097[R] t i\nx\u271d : (i : \u03b9) \u2192 s i\n\u22a2 (((map fun i \u21a6 \u2191(f i).symm) \u2218\u2097 map fun i \u21a6 \u2191(f i)).compMultilinearMap (tprod R)) x\u271d =\n    (LinearMap.id.compMultilinearMap (tprod R)) x\u271d",["simp","aesop","norm_num"]],["LinearAlgebra/PiTensorProduct.lean",600,"case H.H\n\u03b9 : Type u_1\nR : Type u_4\ninst\u271d\u2074 : CommSemiring R\ns : \u03b9 \u2192 Type u_7\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (s i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (s i)\nt : \u03b9 \u2192 Type u_11\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (t i)\ninst\u271d : (i : \u03b9) \u2192 Module R (t i)\nf : (i : \u03b9) \u2192 s i \u2192\u2097[R] t i\nx\u271d : (i : \u03b9) \u2192 s i\n\u22a2 ((piTensorHomMap ((tprod R) f)).compMultilinearMap (tprod R)) x\u271d = ((map f).compMultilinearMap (tprod R)) x\u271d",["simp","aesop","norm_num"]],["LinearAlgebra/PiTensorProduct.lean",737,"case a.H.H\n\u03b9 : Type u_1\n\u03b9\u2082 : Type u_2\n\u03b9\u2083 : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : CommSemiring R\ns : \u03b9 \u2192 Type u_7\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (s i)\ninst\u271d : (i : \u03b9) \u2192 Module R (s i)\ne : \u03b9 \u2243 \u03b9\u2082\ne' : \u03b9\u2082 \u2243 \u03b9\u2083\nf : (i : \u03b9) \u2192 s i\n\u22a2 ((tprod R) fun i \u21a6 f (e.symm (e'.symm i))) =\n    ((domDomCongrLinearEquiv' R R s (\u2a02[R] (i : \u03b9\u2083), s ((e.trans e').symm i)) (e.trans e')).symm (tprod R)) f",["congr","aesop","tauto","abel"]],["LinearAlgebra/PiTensorProduct.lean",760,"case a.H.H\n\u03b9 : Type u_1\nR : Type u_4\ninst\u271d\u00b2 : CommSemiring R\ns : \u03b9 \u2192 Type u_7\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (s i)\ninst\u271d : (i : \u03b9) \u2192 Module R (s i)\nx\u271d : (i : \u03b9) \u2192 s i\n\u22a2 { toFun := \u21d1(tprod R) \u2218 \u21d1(Equiv.piCongrLeft' s (Equiv.refl \u03b9)), map_update_add' := \u22ef, map_update_smul' := \u22ef } x\u271d =\n    (tprod R) x\u271d",["congr","aesop","tauto","abel"]],["LinearAlgebra/PiTensorProduct.lean",803,"case refine_1.e_a.h.e_6.h\n\u03b9 : Type u_1\n\u03b9\u2082 : Type u_2\n\u03b9\u2083 : Type u_3\nR : Type u_4\ninst\u271d\u00b9\u2070 : CommSemiring R\nR\u2081 : Type u_5\nR\u2082 : Type u_6\ns : \u03b9 \u2192 Type u_7\ninst\u271d\u2079 : (i : \u03b9) \u2192 AddCommMonoid (s i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 Module R (s i)\nM : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\nE : Type u_9\ninst\u271d\u2075 : AddCommMonoid E\ninst\u271d\u2074 : Module R E\nF : Type u_10\ninst\u271d\u00b3 : AddCommMonoid F\nt : \u03b9 \u2192 Type u_11\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (t i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (t i)\ninst\u271d : IsEmpty \u03b9\nx\u271d : \u2a02[R] (i : \u03b9), s i\nx : R\ny : (i : \u03b9) \u2192 s i\n\u22a2 isEmptyElim = y",["aesop","norm_num","simp"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",726,"F : Type u_3\ninst\u271d\u2078 : NormedAddCommGroup F\ninst\u271d\u2077 : NormedSpace \u211d F\nE : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\ninst\u271d\u2074 : MeasurableSpace E\ninst\u271d\u00b3 : BorelSpace E\ninst\u271d\u00b2 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : FiniteDimensional \u211d F\nu : E \u2192 F\ns : Set E\nhu : ContDiff \u211d 1 u\nh2u : support u \u2286 s\np : \u211d\u22650\nhp : 1 \u2264 p\nh2p : p < \u2191(finrank \u211d E)\nhs : Bornology.IsBounded s\n\u22a2 0 \u2264 (\u2191(finrank \u211d E))\u207b\u00b9",["positivity","aesop","norm_num","simp"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",128,"case h.e'_7.h.e'_5.h.e'_6.h.e'_6.h.e'_5\n\u03b9 : Type u_1\nA : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b9) \u2192 MeasurableSpace (A i)\n\u03bc : (i : \u03b9) \u2192 Measure (A i)\ninst\u271d\u00b9 : DecidableEq \u03b9\np : \u211d\ninst\u271d : \u2200 (i : \u03b9), SigmaFinite (\u03bc i)\nhp\u2080 : 0 \u2264 p\ns : Finset \u03b9\nhp : \u2191(#s) * p \u2264 1\ni : \u03b9\nhi : i \u2209 s\nf : ((i : \u03b9) \u2192 A i) \u2192 \u211d\u22650\u221e\nhf : Measurable f\n\u22a2 \u2191(#s) + 1 - 1 = \u2191(#s)",["ring","aesop","linarith","abel","norm_num","simp"]],["Topology/Order/IntermediateValue.lean",665,"\u03b1 : Type u\ninst\u271d\u2076 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : DenselyOrdered \u03b1\n\u03b4 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b4\ninst\u271d\u00b9 : TopologicalSpace \u03b4\ninst\u271d : OrderClosedTopology \u03b4\na b : \u03b1\nf : \u03b1 \u2192 \u03b4\nhab : a \u2264 b\nhfab : f a \u2264 f b\nhf_c : ContinuousOn f (Icc a b)\nhf_i : InjOn f (Icc a b)\nthis : Fact (a \u2264 b)\ng : \u2191(Icc a b) \u2192 \u03b4 := (Icc a b).restrict f\n\u22a2 g \u22a5 \u2264 g \u22a4",["aesop","congr","tauto","assumption"]],["NumberTheory/PellMatiyasevic.lean",215,"a : \u2115\na1 : 1 < a\nn : \u2115\nh : Pell.d a1 = n * n\nthis\u271d : n * n + 1 = a * a\nna : n < a\nthis : 1 + n * 2 + n ^ 2 \u2264 1 + n ^ 2\n\u22a2 1 + n * 2 + n ^ 2 \u2264 1 + n ^ 2",["assumption","omega","aesop","congr","linarith","gcongr","tauto"]],["NumberTheory/PellMatiyasevic.lean",304,"a : \u2115\na1 : 1 < a\nx y : \u2115\nhp\u271d : x * x - Pell.d a1 * y * y = 1\nhp : 0 = 1\n\u22a2 1 \u2264 { re := \u21910, im := \u2191y }",["contradiction","omega","aesop","linarith","tauto"]],["GroupTheory/Sylow.lean",62,"case mk.mk\np : \u2115\nG : Type u_1\ninst\u271d : Group G\ntoSubgroup\u271d\u00b9 : Subgroup G\nisPGroup'\u271d\u00b9 : IsPGroup p \u21a5toSubgroup\u271d\u00b9\nis_maximal'\u271d\u00b9 : \u2200 {Q : Subgroup G}, IsPGroup p \u21a5Q \u2192 toSubgroup\u271d\u00b9 \u2264 Q \u2192 Q = toSubgroup\u271d\u00b9\ntoSubgroup\u271d : Subgroup G\nisPGroup'\u271d : IsPGroup p \u21a5toSubgroup\u271d\nis_maximal'\u271d : \u2200 {Q : Subgroup G}, IsPGroup p \u21a5Q \u2192 toSubgroup\u271d \u2264 Q \u2192 Q = toSubgroup\u271d\nh :\n  \u2191{ toSubgroup := toSubgroup\u271d\u00b9, isPGroup' := isPGroup'\u271d\u00b9, is_maximal' := is_maximal'\u271d\u00b9 } =\n    \u2191{ toSubgroup := toSubgroup\u271d, isPGroup' := isPGroup'\u271d, is_maximal' := is_maximal'\u271d }\n\u22a2 { toSubgroup := toSubgroup\u271d\u00b9, isPGroup' := isPGroup'\u271d\u00b9, is_maximal' := is_maximal'\u271d\u00b9 } =\n    { toSubgroup := toSubgroup\u271d, isPGroup' := isPGroup'\u271d, is_maximal' := is_maximal'\u271d }",["congr"]],["GroupTheory/Perm/Cycle/Factors.lean",283,"\u03b1 : Type u_2\nf : Perm \u03b1\nx : \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\n\u22a2 (f.cycleOf x).support = \u2205 \u2194 x \u2209 f.support",["simp","aesop","norm_num"]],["GroupTheory/Perm/Cycle/Factors.lean",573,"case neg\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nhx : x \u2208 f.support\ny : \u03b1\nhy : y \u2260 y\nH : \u00acf.SameCycle x y\n\u22a2 y = f y",["contradiction","aesop","tauto"]],["GroupTheory/Perm/Cycle/Factors.lean",845,"case neg\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng f\u271d \u03c3 \u03c4 : Perm \u03b1\nhd : \u03c3.Disjoint \u03c4\na\u271d : \u03c3.IsCycle\nh\u03c3 : \u2200 {f : Perm \u03b1}, f \u2208 \u03c3.cycleFactorsFinset \u2192 (\u03c3 * f\u207b\u00b9).cycleFactorsFinset = \u03c3.cycleFactorsFinset \\ {f}\nh\u03c4 : \u2200 {f : Perm \u03b1}, f \u2208 \u03c4.cycleFactorsFinset \u2192 (\u03c4 * f\u207b\u00b9).cycleFactorsFinset = \u03c4.cycleFactorsFinset \\ {f}\nf : Perm \u03b1\nhf : f.IsCycle \u2227 \u2200 a \u2208 f.support, f a = \u03c3 a\nx : \u03b1\nhx : f x = x\nhfx : \u00acf x = x\n\u22a2 \u03c3 (f\u207b\u00b9 x) = x",["contradiction","aesop","tauto"]],["GroupTheory/Perm/Cycle/Factors.lean",860,"case neg\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng f\u271d \u03c3 \u03c4 : Perm \u03b1\nhd : \u03c3.Disjoint \u03c4\na\u271d : \u03c3.IsCycle\nh\u03c3 : \u2200 {f : Perm \u03b1}, f \u2208 \u03c3.cycleFactorsFinset \u2192 (\u03c3 * f\u207b\u00b9).cycleFactorsFinset = \u03c3.cycleFactorsFinset \\ {f}\nh\u03c4 : \u2200 {f : Perm \u03b1}, f \u2208 \u03c4.cycleFactorsFinset \u2192 (\u03c4 * f\u207b\u00b9).cycleFactorsFinset = \u03c4.cycleFactorsFinset \\ {f}\nf : Perm \u03b1\nhf : f.IsCycle \u2227 \u2200 a \u2208 f.support, f a = \u03c4 a\nx : \u03b1\nhx : f x = x\nhfx : \u00acf x = x\n\u22a2 \u03c4 (f\u207b\u00b9 x) = x",["contradiction"]],["GroupTheory/Perm/Cycle/Factors.lean",673,"case intro.intro.intro.intro\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : _root_.Disjoint f.support g.support\nx : Perm \u03b1\nhf : \u2200 (a : \u03b1), x a \u2260 a \u2192 x a = f a\na : \u03b1\nha : x a \u2260 a\nhg : \u2200 (a : \u03b1), x a \u2260 a \u2192 x a = g a\nthis : a \u2208 \u22a5\n\u22a2 False",["tauto","aesop","contradiction"]],["Geometry/Manifold/PartitionOfUnity.lean",135,"case mk.mk\n\u03b9 : Type u\u03b9\nE : Type uE\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\nF : Type uF\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \u211d F\nH : Type uH\ninst\u271d\u00b2 : TopologicalSpace H\nI : ModelWithCorners \u211d E H\nM : Type uM\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\ns\u271d : Set M\nf : SmoothPartitionOfUnity \u03b9 I M s\u271d\nn : \u2115\u221e\ns : Set M\ntoFun\u271d\u00b9 : \u03b9 \u2192 C^\u221e\u27eeI, M; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef\nlocallyFinite'\u271d\u00b9 : LocallyFinite fun i \u21a6 support \u21d1(toFun\u271d\u00b9 i)\nnonneg'\u271d\u00b9 : \u2200 (i : \u03b9) (x : M), 0 \u2264 (toFun\u271d\u00b9 i) x\nsum_eq_one'\u271d\u00b9 : \u2200 x \u2208 s, \u2211\u1da0 (i : \u03b9), (toFun\u271d\u00b9 i) x = 1\nsum_le_one'\u271d\u00b9 : \u2200 (x : M), \u2211\u1da0 (i : \u03b9), (toFun\u271d\u00b9 i) x \u2264 1\ntoFun\u271d : \u03b9 \u2192 C^\u221e\u27eeI, M; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef\nlocallyFinite'\u271d : LocallyFinite fun i \u21a6 support \u21d1(toFun\u271d i)\nnonneg'\u271d : \u2200 (i : \u03b9) (x : M), 0 \u2264 (toFun\u271d i) x\nsum_eq_one'\u271d : \u2200 x \u2208 s, \u2211\u1da0 (i : \u03b9), (toFun\u271d i) x = 1\nsum_le_one'\u271d : \u2200 (x : M), \u2211\u1da0 (i : \u03b9), (toFun\u271d i) x \u2264 1\nh :\n  { toFun := toFun\u271d\u00b9, locallyFinite' := locallyFinite'\u271d\u00b9, nonneg' := nonneg'\u271d\u00b9, sum_eq_one' := sum_eq_one'\u271d\u00b9,\n        sum_le_one' := sum_le_one'\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, locallyFinite' := locallyFinite'\u271d, nonneg' := nonneg'\u271d, sum_eq_one' := sum_eq_one'\u271d,\n        sum_le_one' := sum_le_one'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, locallyFinite' := locallyFinite'\u271d\u00b9, nonneg' := nonneg'\u271d\u00b9, sum_eq_one' := sum_eq_one'\u271d\u00b9,\n      sum_le_one' := sum_le_one'\u271d\u00b9 } =\n    { toFun := toFun\u271d, locallyFinite' := locallyFinite'\u271d, nonneg' := nonneg'\u271d, sum_eq_one' := sum_eq_one'\u271d,\n      sum_le_one' := sum_le_one'\u271d }",["congr","aesop"]],["LinearAlgebra/SesquilinearForm.lean",843,"R : Type u_1\nM : Type u_5\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nB : LinearMap.BilinForm R M\nx y : M\n\u22a2 (B x) x * ((B x) y * (B x) y) - (B x) x * ((B x) y * (B y) x) -\n      ((B x) x * ((B x) y * (B x) y) - (B x) x * ((B x) x * (B y) y)) =\n    (B x) x * ((B x) x * (B y) y) - (B x) x * ((B x) y * (B y) x)",["abel","ring","aesop","norm_num","simp"]],["Logic/Equiv/PartialEquiv.lean",796,"case hs.h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b7 : Type u_5\n\u03b5 : Type u_6\ne : PartialEquiv \u03b1 \u03b2\nf : PartialEquiv \u03b2 \u03b3\ne' : PartialEquiv \u03b4 \u03b7\nf' : PartialEquiv \u03b7 \u03b5\nx : \u03b1\ny : \u03b4\n\u22a2 (x \u2208 e.source \u2227 y \u2208 e'.source) \u2227 \u2191e x \u2208 f.source \u2227 \u2191e' y \u2208 f'.source \u2194\n    (x \u2208 e.source \u2227 \u2191e x \u2208 f.source) \u2227 y \u2208 e'.source \u2227 \u2191e' y \u2208 f'.source",["tauto","aesop"]],["NumberTheory/LSeries/HurwitzZetaEven.lean",165,"a t : \u211d\nht : 0 < t\nn : \u2124\n\u22a2 cexp (-(\u2191\u03c0 * \u2191n * \u2191a * \u2191t * 2) + (-(\u2191\u03c0 * \u2191n ^ 2 * \u2191t) - \u2191\u03c0 * \u2191a ^ 2 * \u2191t)) =\n    cexp (\u2191\u03c0 * \u2191n * \u2191a * \u2191t * I ^ 2 * 2 + (\u2191\u03c0 * \u2191n ^ 2 * \u2191t * I ^ 2 - \u2191\u03c0 * \u2191a ^ 2 * \u2191t))",["simp","aesop","norm_num"]],["NumberTheory/LSeries/HurwitzZetaEven.lean",653,"case h.e'_11.h\na b : UnitAddCircle\nx\u271d : \u2102\n\u22a2 hurwitzZetaEven a x\u271d - hurwitzZetaEven b x\u271d =\n    hurwitzZetaEven a x\u271d - 1 / (x\u271d - 1) / x\u271d.Gamma\u211d - (hurwitzZetaEven b x\u271d - 1 / (x\u271d - 1) / x\u271d.Gamma\u211d)",["abel","ring","aesop","norm_num","simp"]],["Algebra/Order/ToIntervalMod.lean",339,"\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nm : \u2124\n\u22a2 b + m \u2022 p - (toIcoDiv hp a b \u2022 p + m \u2022 p) = b - toIcoDiv hp a b \u2022 p",["abel","aesop","norm_num","simp"]],["Algebra/Order/ToIntervalMod.lean",349,"\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nm : \u2124\n\u22a2 b + m \u2022 p - (toIocDiv hp a b \u2022 p + m \u2022 p) = b - toIocDiv hp a b \u2022 p",["abel","aesop","norm_num","simp"]],["Algebra/Order/ToIntervalMod.lean",742,"case inr\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\nx\u2081 x\u2082 x\u2083 : \u03b1\nh\u271d : toIcoMod hp x\u2081 x\u2082 \u2264 toIocMod hp x\u2081 x\u2083\nx\u2082' : \u03b1 := toIcoMod hp x\u2081 x\u2082\nx\u2083' : \u03b1 := toIcoMod hp x\u2082' x\u2083\nh : x\u2082' \u2264 toIocMod hp x\u2081 x\u2083'\nh\u2082\u2081 : x\u2082' < x\u2081 + p\nh\u2083\u2082 : x\u2083' - p < x\u2082'\nh\u2081\u2083 : x\u2081 + p < x\u2083'\nhIoc\u2081\u2083 : toIocMod hp x\u2081 x\u2083' = x\u2083' - p\nnot_h\u2083\u2082 : \u00acx\u2083' - p < x\u2082'\n\u22a2 x\u2083' \u2264 toIocMod hp x\u2082' x\u2081",["contradiction","aesop","tauto"]],["Data/Set/Finite/Basic.lean",158,"\u03b1 : Type u\ninst\u271d\u00b9 : Fintype \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nh : {x | p x}.Finite\n\u22a2 h.toFinset = Finset.filter p Finset.univ",["simp","aesop"]],["Data/Set/Finite/Basic.lean",280,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\na : \u03b1\n\u22a2 \u2200 (x : \u03b1), x \u2208 {a} \u2194 x \u2208 {a}",["simp","aesop"]],["Data/Set/Finite/Basic.lean",246,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Fintype \u2191s\ninst\u271d : DecidablePred p\n\u22a2 \u2200 (x : \u03b1), x \u2208 Finset.filter p s.toFinset \u2194 x \u2208 {a | a \u2208 s \u2227 p a}",["simp","aesop"]],["Data/Set/Finite/Basic.lean",372,"case h\n\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\nx : \u03b1\n\u22a2 x \u2208 \u22ef.toFinset \u2194 x \u2208 s.toFinset",["simp","aesop"]],["Data/Set/Finite/Basic.lean",215,"case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b2\nf : \u03b2 \u2192 \u03b1\nh : (range f).Finite\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 h.toFinset \u2194 a\u271d \u2208 Finset.image f Finset.univ",["simp","aesop"]],["Data/Set/Finite/Basic.lean",168,"case h\n\u03b1 : Type u\ns t : Set \u03b1\ninst\u271d : DecidableEq \u03b1\nhs : s.Finite\nht : t.Finite\nh : (s \u2229 t).Finite\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 h.toFinset \u2194 a\u271d \u2208 hs.toFinset \u2229 ht.toFinset",["simp","aesop"]],["Data/Set/Finite/Basic.lean",250,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t : Set \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u2191s\ninst\u271d : Fintype \u2191t\n\u22a2 \u2200 (x : \u03b1), x \u2208 s.toFinset \u2229 t.toFinset \u2194 x \u2208 s \u2229 t",["simp","aesop"]],["Data/Set/Finite/Basic.lean",330,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\nn : \u2115\n\u22a2 \u2200 (x : \u2115), x \u2208 Finset.range n \u2194 x \u2208 {i | i < n}",["simp","aesop"]],["Data/Set/Finite/Basic.lean",200,"\u03b1 : Type u\nh : \u2205.Finite\n\u22a2 h.toFinset = \u2205",["simp","aesop"]],["Data/Set/Finite/Basic.lean",611,"\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Set \u03b2 \u2192 Prop\n\u22a2 (\u2203 s_1, (\u2203 s', \u2191s' \u2286 s \u2227 Finset.image f s' = s_1) \u2227 p \u2191s_1) \u2194 \u2203 s_1, \u2191s_1 \u2286 s \u2227 p (f '' \u2191s_1)",["aesop","simp"]],["CategoryTheory/Limits/Shapes/Types.lean",65,"\u03b2 : Type v\nf : \u03b2 \u2192 Type v\nP : Type v\ns : (b : \u03b2) \u2192 P \u27f6 f b\nb : \u03b2\nx : P\n\u22a2 Pi.\u03c0 f b (Pi.lift s x) = s b x",["simp","aesop"]],["CategoryTheory/Limits/Shapes/Types.lean",638,"case intro\nX Y S : Type v\nf : X \u27f6 S\ng : Y \u27f6 S\nc : PullbackCone f g\nhc : IsLimit c\nx : c.pt\n\u22a2 c.fst ((equivPullbackObj hc).symm ((equivPullbackObj hc) x)) = (\u2191((equivPullbackObj hc) x)).1",["simp","aesop"]],["CategoryTheory/Limits/Shapes/Types.lean",991,"case intro\nJ : MulticospanShape\nI : MulticospanIndex J (Type u)\nc : Multifork I\nhc : IsLimit c\ni : J.L\nx : c.pt\n\u22a2 c.\u03b9 i ((sectionsEquiv hc) ((sectionsEquiv hc).symm x)) = ((sectionsEquiv hc).symm x).val i",["simp","aesop"]],["CategoryTheory/Limits/Shapes/Types.lean",527,"X Y Z : Type u\nf g : X \u27f6 Y\n\u03c0 : Y \u27f6 Z\ne : f \u226b \u03c0 = g \u226b \u03c0\nh : IsColimit (Cofork.of\u03c0 \u03c0 e)\nU : Set Y\nH : f \u207b\u00b9' U = g \u207b\u00b9' U\nlem : \u2200 (x y : Y), Function.Coequalizer.Rel f g x y \u2192 (x \u2208 U \u2194 y \u2208 U)\n\u22a2 \u2200 (x : Y), x \u2208 U \u2194 x \u2208 U",["tauto","aesop","simp"]],["CategoryTheory/Limits/Shapes/Types.lean",528,"X Y Z : Type u\nf g : X \u27f6 Y\n\u03c0 : Y \u27f6 Z\ne : f \u226b \u03c0 = g \u226b \u03c0\nh : IsColimit (Cofork.of\u03c0 \u03c0 e)\nU : Set Y\nH : f \u207b\u00b9' U = g \u207b\u00b9' U\nlem : \u2200 (x y : Y), Function.Coequalizer.Rel f g x y \u2192 (x \u2208 U \u2194 y \u2208 U)\n\u22a2 \u2200 {x y : Y}, (x \u2208 U \u2194 y \u2208 U) \u2192 (y \u2208 U \u2194 x \u2208 U)",["tauto"]],["CategoryTheory/Limits/Shapes/Types.lean",529,"X Y Z : Type u\nf g : X \u27f6 Y\n\u03c0 : Y \u27f6 Z\ne : f \u226b \u03c0 = g \u226b \u03c0\nh : IsColimit (Cofork.of\u03c0 \u03c0 e)\nU : Set Y\nH : f \u207b\u00b9' U = g \u207b\u00b9' U\nlem : \u2200 (x y : Y), Function.Coequalizer.Rel f g x y \u2192 (x \u2208 U \u2194 y \u2208 U)\n\u22a2 \u2200 {x y z : Y}, (x \u2208 U \u2194 y \u2208 U) \u2192 (y \u2208 U \u2194 z \u2208 U) \u2192 (x \u2208 U \u2194 z \u2208 U)",["tauto"]],["MeasureTheory/Measure/LevyProkhorovMetric.lean",276,"\u03a9 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03a9\ninst\u271d\u00b2 : PseudoEMetricSpace \u03a9\ninst\u271d\u00b9 : OpensMeasurableSpace \u03a9\ninst\u271d : BorelSpace \u03a9\n\u03bc \u03bd : LevyProkhorov (ProbabilityMeasure \u03a9)\nh : dist \u03bc \u03bd = 0\n\u22a2 \u2191((LevyProkhorov.equiv (ProbabilityMeasure \u03a9)) \u03bc) univ = \u2191((LevyProkhorov.equiv (ProbabilityMeasure \u03a9)) \u03bd) univ",["simp","aesop","norm_num"]],["Data/Matroid/Circuit.lean",647,"\u03b1 : Type u_1\nM : Matroid \u03b1\ninst\u271d : M\u2736.RankPos\n\u22a2 M\u2736.RankPos",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["Data/Matroid/Circuit.lean",720,"case inr.inl\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nhB : M.IsBase B\ne f : \u03b1\nhe : e \u2208 {f}\nhne : e \u2260 f\nhB' : M\u2736.IsBase (M\u2736.E \\ B)\nhfE : f \u2209 M.E\n\u22a2 f \u2208 M.fundCircuit e B",["contradiction","aesop","tauto"]],["Data/Matroid/Circuit.lean",723,"case inr.inr.inl\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\nhB : M.IsBase B\ne f : \u03b1\nhe : e \u2208 {f}\nhne : e \u2260 f\nhB' : M\u2736.IsBase (M\u2736.E \\ B)\nhfE : f \u2208 M.E\nhfB : f \u2209 B\n\u22a2 f \u2208 M.fundCircuit e B",["contradiction"]],["Logic/Equiv/Defs.lean",293,"\u03b1 : Sort u\n\u03b2 : Sort v\ne : \u03b1 \u2243 \u03b2\n\u22a2 \u2200 (x : \u03b2), (e.symm.trans e) x = (Equiv.refl \u03b2) x",["simp"]],["Logic/Equiv/Defs.lean",665,"\u03b1 : Sort u\n\u03b2\u271d : Sort v\n\u03b3 : Sort w\n\u03b1\u2081 : Type u_1\n\u03b1\u2082 : Type u_2\n\u03b2 : \u03b1\u2082 \u2192 Type ?u.33910\ne : \u03b1\u2081 \u2243 \u03b1\u2082\nx\u271d : (a : \u03b1\u2081) \u00d7 \u03b2 (e a)\na : \u03b1\u2081\nb : \u03b2 (e a)\n\u22a2 (fun a \u21a6 \u27e8e.symm a.fst, \u22ef \u25b8 a.snd\u27e9) ((fun a \u21a6 \u27e8e a.fst, a.snd\u27e9) \u27e8a, b\u27e9) = \u27e8a, b\u27e9",["simp"]],["Logic/Equiv/Defs.lean",95,"case mk.mk\n\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\ninvFun\u271d\u00b9 : \u03b2 \u2192 \u03b1\nleft_inv\u271d\u00b9 : LeftInverse invFun\u271d\u00b9 toFun\u271d\u00b9\nright_inv\u271d\u00b9 : RightInverse invFun\u271d\u00b9 toFun\u271d\u00b9\ntoFun\u271d : \u03b1 \u2192 \u03b2\ninvFun\u271d : \u03b2 \u2192 \u03b1\nleft_inv\u271d : LeftInverse invFun\u271d toFun\u271d\nright_inv\u271d : RightInverse invFun\u271d toFun\u271d\nh\u2081 :\n  { toFun := toFun\u271d\u00b9, invFun := invFun\u271d\u00b9, left_inv := left_inv\u271d\u00b9, right_inv := right_inv\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d }.toFun\nh\u2082 :\n  { toFun := toFun\u271d\u00b9, invFun := invFun\u271d\u00b9, left_inv := left_inv\u271d\u00b9, right_inv := right_inv\u271d\u00b9 }.invFun =\n    { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d }.invFun\n\u22a2 { toFun := toFun\u271d\u00b9, invFun := invFun\u271d\u00b9, left_inv := left_inv\u271d\u00b9, right_inv := right_inv\u271d\u00b9 } =\n    { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d }",["congr"]],["NumberTheory/FLT/Three.lean",276,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nx : \ud835\udcde K\nhx : S'.a ^ 3 - 1 = \u03bb ^ 4 * x\ny : \ud835\udcde K\nhy : S'.b ^ 3 + 1 = \u03bb ^ 4 * y\n\u22a2 \u2191S'.u\u207b\u00b9 * (S'.a ^ 3 - 1 + (S'.b ^ 3 + 1)) = \u2191S'.u\u207b\u00b9 * (S'.a ^ 3 + S'.b ^ 3)\n```\n---\n```lean\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nx : \ud835\udcde K\nhx : S'.a ^ 3 + 1 = \u03bb ^ 4 * x\ny : \ud835\udcde K\nhy : S'.b ^ 3 - 1 = \u03bb ^ 4 * y\n\u22a2 \u2191S'.u\u207b\u00b9 * (S'.a ^ 3 + 1 + (S'.b ^ 3 - 1)) = \u2191S'.u\u207b\u00b9 * (S'.a ^ 3 + S'.b ^ 3)",["ring","abel","norm_num","simp"]],["NumberTheory/FLT/Three.lean",56,"\u22a2 \u2200 {n : ZMod 9}, (castHom \u22ef (ZMod 3)) n \u2260 0 \u2192 n ^ 3 = 1 \u2228 n ^ 3 = 8",["decide"]],["NumberTheory/FLT/Three.lean",104,"a b c : \u2124\nha : a \u2260 0\nh3a : 3 \u2223 a\nHgcd : {a, b, c}.gcd id = 1\nH : \u2200 (a b c : \u2124), c \u2260 0 \u2192 \u00ac3 \u2223 a \u2192 \u00ac3 \u2223 b \u2192 3 \u2223 c \u2192 IsCoprime a b \u2192 a ^ 3 + b ^ 3 \u2260 c ^ 3\nHF : a ^ 3 + b ^ 3 + c ^ 3 = 0\n\u22a2 \u00ac3 \u2223 1",["decide","omega","aesop","tauto","norm_num","simp"]],["GroupTheory/Congruence/Defs.lean",373,"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Mul N\ninst\u271d : Mul P\nc : Con M\n\u22a2 \u2200 {w x y z : M}, __src\u271d w x \u2192 __src\u271d y z \u2192 __src\u271d (w * y) (x * z)",["tauto","aesop","simp"]],["GroupTheory/SpecificGroups/Cyclic.lean",702,"\u03b1 : Type u_1\ninst\u271d : Group \u03b1\np : \u2115\nhp : Nat.Prime p\nh\u03b1 : Nat.card \u03b1 = p ^ 2\nthis\u271d : Finite \u03b1\nthis : Nontrivial \u03b1\nh_cyc : \u00acIsCyclic \u03b1\ng : \u03b1\nhg : g \u2260 1\na : \u2115\nha : 0 < 3\nha' : p ^ 0 = orderOf g\n\u22a2 orderOf g = 1",["aesop","linarith","tauto"]],["GroupTheory/SpecificGroups/Cyclic.lean",506,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nhn : \u2200 (n : \u2115), 0 < n \u2192 #(filter (fun a \u21a6 a ^ n = 1) univ) \u2264 n\nd : \u2115\nhd : d \u2223 Fintype.card \u03b1\nc : \u2115 := Fintype.card \u03b1\nhc0 : 0 < c\nh0 : filter (fun a \u21a6 orderOf a = d) univ = \u2205\nm : \u2115\nhm : m \u2260 d \u2227 m \u2223 c \u2227 c \u2260 0\n\u22a2 m \u2223 c",["tauto","omega","aesop"]],["Order/SuccPred/Limit.lean",331,"case intro.intro.intro\n\u03b1 : Type u_1\na : \u03b1\ninst\u271d : LinearOrder \u03b1\ns : Set \u03b1\nhs : IsLUB s a\nha : a \u2209 s\nb : \u03b1\nhb : b \u22d6 a\nhc : a \u2208 s\nhbc : b < a\nhca : a \u2264 a\n\u22a2 False",["contradiction","aesop","tauto"]],["Order/SuccPred/Limit.lean",232,"\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\nthis : a \u2208 range succ \u2228 IsSuccPrelimit a\n\u22a2 IsMin a \u2228 a \u2208 range succ \u2228 \u00acIsMin a \u2227 IsSuccPrelimit a",["tauto"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/NonUnital.lean",350,"case pos\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : Nontrivial R\ninst\u271d\u2079 : StarRing R\ninst\u271d\u2078 : MetricSpace R\ninst\u271d\u2077 : IsTopologicalSemiring R\ninst\u271d\u2076 : ContinuousStar R\ninst\u271d\u2075 : NonUnitalRing A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\ninstCFC\u2099 : NonUnitalContinuousFunctionalCalculus R p\nf g : R \u2192 R\na : A\nhf : autoParam (ContinuousOn f (\u03c3\u2099 R a)) _auto\u271d\nhf0 : autoParam (f 0 = 0) _auto\u271d\nhg : autoParam (ContinuousOn g (\u03c3\u2099 R a)) _auto\u271d\nhg0 : autoParam (g 0 = 0) _auto\u271d\nha : p a\n\u22a2 (cfc\u2099Hom ha) { toFun := (\u03c3\u2099 R a).restrict fun x \u21a6 f x * g x, continuous_toFun := \u22ef, map_zero' := \u22ef } =\n    (cfc\u2099Hom ha)\n      ({ toFun := (\u03c3\u2099 R a).restrict f, continuous_toFun := \u22ef, map_zero' := \u22ef } *\n        { toFun := (\u03c3\u2099 R a).restrict g, continuous_toFun := \u22ef, map_zero' := \u22ef })",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/NonUnital.lean",358,"case pos\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : Nontrivial R\ninst\u271d\u2079 : StarRing R\ninst\u271d\u2078 : MetricSpace R\ninst\u271d\u2077 : IsTopologicalSemiring R\ninst\u271d\u2076 : ContinuousStar R\ninst\u271d\u2075 : NonUnitalRing A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\ninstCFC\u2099 : NonUnitalContinuousFunctionalCalculus R p\nf g : R \u2192 R\na : A\nhf : autoParam (ContinuousOn f (\u03c3\u2099 R a)) _auto\u271d\nhf0 : autoParam (f 0 = 0) _auto\u271d\nhg : autoParam (ContinuousOn g (\u03c3\u2099 R a)) _auto\u271d\nhg0 : autoParam (g 0 = 0) _auto\u271d\nha : p a\n\u22a2 (cfc\u2099Hom ha) { toFun := (\u03c3\u2099 R a).restrict fun x \u21a6 f x + g x, continuous_toFun := \u22ef, map_zero' := \u22ef } =\n    (cfc\u2099Hom ha)\n      ({ toFun := (\u03c3\u2099 R a).restrict f, continuous_toFun := \u22ef, map_zero' := \u22ef } +\n        { toFun := (\u03c3\u2099 R a).restrict g, continuous_toFun := \u22ef, map_zero' := \u22ef })",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/NonUnital.lean",394,"case pos\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u2076 : CommSemiring R\ninst\u271d\u00b9\u2075 : Nontrivial R\ninst\u271d\u00b9\u2074 : StarRing R\ninst\u271d\u00b9\u00b3 : MetricSpace R\ninst\u271d\u00b9\u00b2 : IsTopologicalSemiring R\ninst\u271d\u00b9\u00b9 : ContinuousStar R\ninst\u271d\u00b9\u2070 : NonUnitalRing A\ninst\u271d\u2079 : StarRing A\ninst\u271d\u2078 : TopologicalSpace A\ninst\u271d\u2077 : Module R A\ninst\u271d\u2076 : IsScalarTower R A A\ninst\u271d\u2075 : SMulCommClass R A A\ninstCFC\u2099 : NonUnitalContinuousFunctionalCalculus R p\nS : Type u_3\ninst\u271d\u2074 : SMulZeroClass S R\ninst\u271d\u00b3 : ContinuousConstSMul S R\ninst\u271d\u00b2 : SMulZeroClass S A\ninst\u271d\u00b9 : IsScalarTower S R A\ninst\u271d : IsScalarTower S R (R \u2192 R)\ns : S\nf : R \u2192 R\na : A\nhf : autoParam (ContinuousOn f (\u03c3\u2099 R a)) _auto\u271d\nh0 : autoParam (f 0 = 0) _auto\u271d\nha : p a\n\u22a2 (cfc\u2099Hom ha) { toFun := (\u03c3\u2099 R a).restrict ((s \u2022 1) \u2022 f), continuous_toFun := \u22ef, map_zero' := \u22ef } =\n    (cfc\u2099Hom ha) ((s \u2022 1) \u2022 { toFun := (\u03c3\u2099 R a).restrict f, continuous_toFun := \u22ef, map_zero' := \u22ef })",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/NonUnital.lean",406,"case pos.intro.intro\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : Nontrivial R\ninst\u271d\u2079 : StarRing R\ninst\u271d\u2078 : MetricSpace R\ninst\u271d\u2077 : IsTopologicalSemiring R\ninst\u271d\u2076 : ContinuousStar R\ninst\u271d\u2075 : NonUnitalRing A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\ninstCFC\u2099 : NonUnitalContinuousFunctionalCalculus R p\nf : R \u2192 R\na : A\nha : p a\nhf : ContinuousOn f (\u03c3\u2099 R a)\nh0 : f 0 = 0\n\u22a2 (cfc\u2099Hom ha) { toFun := (\u03c3\u2099 R a).restrict fun x \u21a6 star (f x), continuous_toFun := \u22ef, map_zero' := \u22ef } =\n    (cfc\u2099Hom ha) (star { toFun := (\u03c3\u2099 R a).restrict f, continuous_toFun := \u22ef, map_zero' := \u22ef })",["congr","aesop","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/NonUnital.lean",535,"case pos\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : Nontrivial R\ninst\u271d\u00b9\u2070 : StarRing R\ninst\u271d\u2079 : MetricSpace R\ninst\u271d\u2078 : IsTopologicalRing R\ninst\u271d\u2077 : ContinuousStar R\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : NonUnitalRing A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : Module R A\ninst\u271d\u00b2 : IsScalarTower R A A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : NonUnitalContinuousFunctionalCalculus R p\nf g : R \u2192 R\na : A\nhf : autoParam (ContinuousOn f (\u03c3\u2099 R a)) _auto\u271d\nhf0 : autoParam (f 0 = 0) _auto\u271d\nhg : autoParam (ContinuousOn g (\u03c3\u2099 R a)) _auto\u271d\nhg0 : autoParam (g 0 = 0) _auto\u271d\nha : p a\n\u22a2 (cfc\u2099Hom ha) { toFun := (\u03c3\u2099 R a).restrict fun x \u21a6 f x - g x, continuous_toFun := \u22ef, map_zero' := \u22ef } =\n    (cfc\u2099Hom ha)\n      ({ toFun := (\u03c3\u2099 R a).restrict f, continuous_toFun := \u22ef, map_zero' := \u22ef } -\n        { toFun := (\u03c3\u2099 R a).restrict g, continuous_toFun := \u22ef, map_zero' := \u22ef })",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/NonUnital.lean",542,"case pos.intro.intro\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : Nontrivial R\ninst\u271d\u00b9\u2070 : StarRing R\ninst\u271d\u2079 : MetricSpace R\ninst\u271d\u2078 : IsTopologicalRing R\ninst\u271d\u2077 : ContinuousStar R\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : NonUnitalRing A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : Module R A\ninst\u271d\u00b2 : IsScalarTower R A A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : NonUnitalContinuousFunctionalCalculus R p\nf : R \u2192 R\na : A\nha : p a\nhf : ContinuousOn f (\u03c3\u2099 R a)\nh0 : f 0 = 0\n\u22a2 (cfc\u2099Hom ha) { toFun := (\u03c3\u2099 R a).restrict fun x \u21a6 -f x, continuous_toFun := \u22ef, map_zero' := \u22ef } =\n    (cfc\u2099Hom ha) (-{ toFun := (\u03c3\u2099 R a).restrict f, continuous_toFun := \u22ef, map_zero' := \u22ef })",["congr","tauto","abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/NonUnital.lean",812,"case pos\nR : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u00b9 : Semifield R\ninst\u271d\u00b9\u2070 : StarRing R\ninst\u271d\u2079 : MetricSpace R\ninst\u271d\u2078 : IsTopologicalSemiring R\ninst\u271d\u2077 : ContinuousStar R\ninst\u271d\u2076 : Ring A\ninst\u271d\u2075 : StarRing A\ninst\u271d\u2074 : TopologicalSpace A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : ContinuousFunctionalCalculus R p\ninst\u271d\u00b9 : CompleteSpace R\ninst\u271d : ContinuousMapZero.UniqueHom R A\nf : R \u2192 R\na : A\nhf : autoParam (ContinuousOn f (\u03c3\u2099 R a)) _auto\u271d\nhf0 : autoParam (f 0 = 0) _auto\u271d\nha : p a\nhf' : ContinuousOn f (spectrum R a)\n\u22a2 (cfcHom ha)\n      ((\u2191{ toFun := (\u03c3\u2099 R a).restrict f, continuous_toFun := \u22ef, map_zero' := \u22ef }).comp\n        { toFun := Set.inclusion \u22ef, continuous_toFun := \u22ef }) =\n    (cfcHom ha) { toFun := (spectrum R a).restrict f, continuous_toFun := \u22ef }",["congr","aesop","tauto","abel"]],["Algebra/Lie/Basic.lean",276,"R : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nt : R\nx\u271d y z : L\nm n : M\nx : L\nf : M \u2192\u2097[R] R\n\u22a2 \u2200 (m : R) (x_1 : M),\n    { toFun := fun m \u21a6 -f \u2045x, m\u2046, map_add' := \u22ef }.toFun (m \u2022 x_1) =\n      (RingHom.id R) m \u2022 { toFun := fun m \u21a6 -f \u2045x, m\u2046, map_add' := \u22ef }.toFun x_1",["simp","aesop","norm_num"]],["Algebra/Lie/Basic.lean",851,"R : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\nP : Type w\u2082\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : AddCommGroup P\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : Module R P\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieRingModule L P\nn : \u2115\nf : M \u2192\u2097\u2045R,L\u2046 N\n\u22a2 \u2200 {x : L} {m : M}, __src\u271d.toFun \u2045x, m\u2046 = \u2045x, __src\u271d.toFun m\u2046",["simp","aesop","norm_num"]],["Algebra/Lie/Basic.lean",129,"case mk.mk\nL : Type u_1\ninst\u271d : LieRing L\ntoModule\u271d\u00b9 : Module \u211a L\nh\u2081 : \u2200 (t : \u211a) (x y : L), \u2045x, t \u2022 y\u2046 = t \u2022 \u2045x, y\u2046\ntoModule\u271d : Module \u211a L\nh\u2082 : \u2200 (t : \u211a) (x y : L), \u2045x, t \u2022 y\u2046 = t \u2022 \u2045x, y\u2046\nheq : toModule = toModule\n\u22a2 mk h\u2081 = mk h\u2082",["congr","aesop"]],["Algebra/Lie/Basic.lean",413,"case mk.mk.mk.mk.mk.mk\nR : Type u\nL\u2081 : Type v\nL\u2082 : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\u2081\ninst\u271d\u00b2 : LieAlgebra R L\u2081\ninst\u271d\u00b9 : LieRing L\u2082\ninst\u271d : LieAlgebra R L\u2082\nf : L\u2081 \u2192 L\u2082\nmap_add'\u271d\u00b9 : \u2200 (x y : L\u2081), f (x + y) = f x + f y\nmap_smul'\u271d\u00b9 :\n  \u2200 (m : R) (x : L\u2081),\n    { toFun := f, map_add' := map_add'\u271d\u00b9 }.toFun (m \u2022 x) =\n      (RingHom.id R) m \u2022 { toFun := f, map_add' := map_add'\u271d\u00b9 }.toFun x\nmap_lie'\u271d\u00b9 :\n  \u2200 {x y : L\u2081},\n    { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun \u2045x, y\u2046 =\n      \u2045{ toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun x,\n        { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun y\u2046\ng : L\u2081 \u2192 L\u2082\nmap_add'\u271d : \u2200 (x y : L\u2081), g (x + y) = g x + g y\nmap_smul'\u271d :\n  \u2200 (m : R) (x : L\u2081),\n    { toFun := g, map_add' := map_add'\u271d }.toFun (m \u2022 x) = (RingHom.id R) m \u2022 { toFun := g, map_add' := map_add'\u271d }.toFun x\nmap_lie'\u271d :\n  \u2200 {x y : L\u2081},\n    { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun \u2045x, y\u2046 =\n      \u2045{ toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun x,\n        { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun y\u2046\nh :\n  \u21d1{ toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_lie' := map_lie'\u271d\u00b9 } =\n    \u21d1{ toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d, map_lie' := map_lie'\u271d }\n\u22a2 { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_lie' := map_lie'\u271d\u00b9 } =\n    { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d, map_lie' := map_lie'\u271d }",["congr","aesop"]],["Algebra/Lie/Basic.lean",767,"case mk.mk.mk.mk.mk.mk\nR : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieRingModule L N\nf : M \u2192 N\nmap_add'\u271d\u00b9 : \u2200 (x y : M), f (x + y) = f x + f y\nmap_smul'\u271d\u00b9 :\n  \u2200 (m : R) (x : M),\n    { toFun := f, map_add' := map_add'\u271d\u00b9 }.toFun (m \u2022 x) =\n      (RingHom.id R) m \u2022 { toFun := f, map_add' := map_add'\u271d\u00b9 }.toFun x\nmap_lie'\u271d\u00b9 :\n  \u2200 {x : L} {m : M},\n    { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun \u2045x, m\u2046 =\n      \u2045x, { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun m\u2046\ng : M \u2192 N\nmap_add'\u271d : \u2200 (x y : M), g (x + y) = g x + g y\nmap_smul'\u271d :\n  \u2200 (m : R) (x : M),\n    { toFun := g, map_add' := map_add'\u271d }.toFun (m \u2022 x) = (RingHom.id R) m \u2022 { toFun := g, map_add' := map_add'\u271d }.toFun x\nmap_lie'\u271d :\n  \u2200 {x : L} {m : M},\n    { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun \u2045x, m\u2046 =\n      \u2045x, { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun m\u2046\nh :\n  \u21d1{ toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_lie' := map_lie'\u271d\u00b9 } =\n    \u21d1{ toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d, map_lie' := map_lie'\u271d }\n\u22a2 { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_lie' := map_lie'\u271d\u00b9 } =\n    { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d, map_lie' := map_lie'\u271d }",["congr","aesop"]],["Analysis/SpecialFunctions/Integrals.lean",188,"case inr\na b : \u211d\nr : \u2102\nh : -1 < r.re\nthis\u271d : \u2200 (c : \u211d), 0 \u2264 c \u2192 IntervalIntegrable (fun x \u21a6 \u2191x ^ r) volume 0 c\nc : \u211d\nhc : c \u2264 0\nm : IntegrableOn (fun x \u21a6 Complex.exp (\u2191\u03c0 * Complex.I * r) * \u2191x ^ r) (Set.Ioc 0 (-c)) volume\nx : \u211d\nhx : x \u2208 Set.Ioc 0 (-c)\nthis : -x \u2264 0\n\u22a2 \u2191x ^ r * Complex.exp (\u2191\u03c0 * Complex.I * r) = (-\u2191(-x)) ^ r * Complex.exp (\u2191\u03c0 * Complex.I * r)",["simp","aesop","norm_num"]],["Analysis/SpecialFunctions/Integrals.lean",371,"case neg.hderiv.refine_2\na b : \u211d\nr : \u2102\nhab : \u00ac0 \u2209 [[a, b]]\nh : -1 < r.re\nc x : \u211d\nhx : x \u2208 Set.Ioo (0 \u2293 c) (0 \u2294 c)\nhr : r = -1\n\u22a2 -1 + 1 = 0",["ring","aesop","abel","norm_num","simp"]],["Analysis/SpecialFunctions/Integrals.lean",679,"case intro.inl.refine_1\nk n : \u2115\nx\u271d : n \u2208 Finset.range k\n\u22a2 0 < 2 * n + 1\n```\n---\n```lean\ncase intro.inl.refine_2\nk n : \u2115\nx\u271d : n \u2208 Finset.range k\n\u22a2 0 < 2 * n + 2\n```\n---\n```lean\ncase intro.inr.refine_1\nk n : \u2115\nx\u271d : n \u2208 Finset.range k\n\u22a2 0 < 2 * n + 2\n```\n---\n```lean\ncase intro.inr.refine_2\nk n : \u2115\nx\u271d : n \u2208 Finset.range k\n\u22a2 0 < 2 * n + 3",["omega","aesop","linarith","positivity","norm_num","simp"]],["Analysis/SpecialFunctions/Integrals.lean",357,"a b : \u211d\nr : \u2102\nh : -1 < r.re \u2228 r \u2260 -1 \u2227 0 \u2209 [[a, b]]\nhr : r + 1 \u2260 0\nhab : \u00ac0 \u2209 [[a, b]]\n\u22a2 -1 < r.re",["tauto","aesop"]],["Topology/Compactness/Lindelof.lean",270,"X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nf : Filter X\nhf : f.NeBot\nhfs : CountableInterFilter f\nfsub : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\nt : Set \u2191s\nht : t.Countable\nh : s \u2286 \u22c3 i \u2208 t, U i\nuinf : \u22c3 i \u2208 t, U i \u2208 f.sets\nuninf\u271d : (\u22c3 i \u2208 t, U i)\u1d9c \u2208 f\nuninf : \u22c3 i \u2208 t, U i \u2209 f\n\u22a2 False",["contradiction","aesop","tauto"]],["Topology/Compactness/Lindelof.lean",174,"case left\nX : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nU : X \u2192 Set X\nhU : \u2200 x \u2208 s, U x \u2208 \ud835\udcdd x\nt : Set \u2191s\nhtc : t.Countable\nhtsub : s \u2286 \u22c3 x \u2208 t, U \u2191x\nx\u271d : X\n\u22a2 \u2200 (x : x\u271d \u2208 s), \u27e8x\u271d, \u22ef\u27e9 \u2208 t \u2192 x\u271d \u2208 s",["tauto","aesop"]],["Topology/Compactness/Lindelof.lean",511,"X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\n\u22a2 IsLindelof s",["tauto"]],["Topology/UniformSpace/Defs.lean",189,"\u03b1 : Type ua\nr : Set (\u03b1 \u00d7 \u03b1)\nx\u271d : \u03b1 \u00d7 \u03b1\na b : \u03b1\n\u22a2 (a, b) \u2208 idRel \u25cb r \u2194 (a, b) \u2208 r",["simp","aesop"]],["Topology/UniformSpace/Defs.lean",367,"case mk.mk\n\u03b1 : Type ua\ntoTopologicalSpace\u271d\u00b9 : TopologicalSpace \u03b1\nuniformity\u271d\u00b9 : Filter (\u03b1 \u00d7 \u03b1)\nsymm\u271d\u00b9 : Tendsto Prod.swap uniformity\u271d\u00b9 uniformity\u271d\u00b9\ncomp\u271d\u00b9 : (uniformity\u271d\u00b9.lift' fun s \u21a6 s \u25cb s) \u2264 uniformity\u271d\u00b9\nnhds_eq_comap_uniformity\u271d\u00b9 : \u2200 (x : \u03b1), \ud835\udcdd x = comap (Prod.mk x) uniformity\u271d\u00b9\ntoTopologicalSpace\u271d : TopologicalSpace \u03b1\nuniformity\u271d : Filter (\u03b1 \u00d7 \u03b1)\nsymm\u271d : Tendsto Prod.swap uniformity\u271d uniformity\u271d\ncomp\u271d : (uniformity\u271d.lift' fun s \u21a6 s \u25cb s) \u2264 uniformity\u271d\nnhds_eq_comap_uniformity\u271d : \u2200 (x : \u03b1), \ud835\udcdd x = comap (Prod.mk x) uniformity\u271d\nh : \ud835\udce4 \u03b1 = \ud835\udce4 \u03b1\nthis : toTopologicalSpace = toTopologicalSpace\n\u22a2 mk uniformity\u271d\u00b9 symm\u271d\u00b9 comp\u271d\u00b9 nhds_eq_comap_uniformity\u271d\u00b9 = mk uniformity\u271d symm\u271d comp\u271d nhds_eq_comap_uniformity\u271d",["congr","aesop"]],["Topology/UniformSpace/Defs.lean",192,"case h.mk\n\u03b1 : Type ua\nr s t : Set (\u03b1 \u00d7 \u03b1)\na b : \u03b1\n\u22a2 (\u2203 z, (\u2203 z_1, (a, z_1) \u2208 r \u2227 (z_1, z) \u2208 s) \u2227 (z, b) \u2208 t) \u2194 \u2203 z, (a, z) \u2208 r \u2227 \u2203 z_1, (z, z_1) \u2208 s \u2227 (z_1, b) \u2208 t",["tauto","aesop"]],["Geometry/Euclidean/MongePoint.lean",360,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nn : \u2115\ns : Simplex \u211d P (n + 1)\ni : Fin (n + 2)\nh :\n  finrank \u211d \u21a5(vectorSpan \u211d (s.points '' \u2191(univ.erase i))) +\n      finrank \u211d \u21a5((vectorSpan \u211d (s.points '' \u2191(univ.erase i)))\u15ee \u2293 vectorSpan \u211d (Set.range s.points)) =\n    finrank \u211d \u21a5(vectorSpan \u211d (Set.range s.points))\n\u22a2 #univ - 1 = n + 1",["simp","aesop","norm_num"]],["Geometry/Euclidean/MongePoint.lean",426,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nt : Triangle \u211d P\n\u22a2 (\u2191(2 + 1) / \u2191(2 - 1)) \u2022 (centroid \u211d univ t.points -\u1d65 circumcenter t) +\u1d65 circumcenter t =\n    3 \u2022 (centroid \u211d univ t.points -\u1d65 circumcenter t) +\u1d65 circumcenter t",["norm_num","ring","aesop","simp"]],["RingTheory/Multiplicity.lean",347,"case mp.right.hm\n\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nn : \u2115\nh : emultiplicity a b = \u2191n\n\u22a2 n < n + 1",["simp","omega","aesop","tauto"]],["RingTheory/Multiplicity.lean",670,"case hsucc\n\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\np a b : \u03b1\nh : \u2191(multiplicity p b) < emultiplicity p a\nthis : FiniteMultiplicity p b\n\u22a2 multiplicity p b < multiplicity p b + 1",["simp","omega","aesop","tauto"]],["RingTheory/Multiplicity.lean",685,"\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\np a b : \u03b1\nh : emultiplicity p b < emultiplicity p a\n\u22a2 emultiplicity p b < emultiplicity p a",["assumption","aesop","congr","gcongr","tauto"]],["RingTheory/Multiplicity.lean",689,"\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\np a b : \u03b1\nh : multiplicity p b < multiplicity p a\nhfin : FiniteMultiplicity p b\n\u22a2 multiplicity p b < multiplicity p a",["assumption","omega","aesop","congr","gcongr","tauto"]],["RingTheory/Multiplicity.lean",511,"a b\u271d : \u2115\nhb : \u00acb\u271d = 0\nb : \u2115\nh : \u2200 (n : \u2115), (b + 2) ^ n \u2223 b\u271d\nha : b + 2 \u2260 0\nha1 : b + 2 \u2260 1\nx\u271d : 1 \u2265 b + 2\n\u22a2 False",["omega","ring","aesop","linarith","positivity","tauto","abel","norm_num","contradiction","fun_prop"]],["Combinatorics/Enumerative/Composition.lean",514,"case h\nn : \u2115\nh : 0 < n\ni : Fin n\n\u22a2 \u2191(((single n h).embedding 0) i) = \u2191i",["simp","aesop"]],["Combinatorics/Enumerative/Composition.lean",750,"case h.mp.inl\nn\u271d\u00b9 n\u271d : \u2115\ns : Finset (Fin (n\u271d - 1))\ni : Fin (n\u271d - 1)\nthis : \u2191i + 1 \u2260 n\u271d\nn : \u2191i + 1 = n\u271d\n\u22a2 i \u2208 s",["contradiction","omega","aesop","tauto"]],["Algebra/Order/Ring/Unbundled/Basic.lean",440,"case h.e'_1.h.e'_3\n\u03b1 : Type u\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\nb c : \u03b1\ninst\u271d : PosMulStrictMono \u03b1\nh : 0 < c\n\u22a2 0 = c * 0",["simp","aesop"]],["Algebra/Order/Ring/Unbundled/Basic.lean",587,"\u03b1 : Type u\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : ExistsAddOfLE \u03b1\ninst\u271d\u00b3 : MulPosStrictMono \u03b1\ninst\u271d\u00b2 : PosMulStrictMono \u03b1\ninst\u271d\u00b9 : AddLeftMono \u03b1\ninst\u271d : AddLeftReflectLE \u03b1\na b c : \u03b1\nor_a : 0 \u2264 a \u2228 a \u2264 0\nor_b : 0 \u2264 b \u2228 b \u2264 0\nor_c : 0 \u2264 c \u2228 c \u2264 0\n\u22a2 (0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0) \u2228 (0 \u2264 b \u2227 0 \u2264 c \u2228 b \u2264 0 \u2227 c \u2264 0) \u2228 0 \u2264 c \u2227 0 \u2264 a \u2228 c \u2264 0 \u2227 a \u2264 0",["aesop","tauto"]],["Algebra/Order/Ring/Unbundled/Basic.lean",596,"\u03b1 : Type u\ninst\u271d\u2076 : Semiring \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\na b : \u03b1\ninst\u271d\u2074 : ExistsAddOfLE \u03b1\ninst\u271d\u00b3 : PosMulStrictMono \u03b1\ninst\u271d\u00b2 : MulPosStrictMono \u03b1\ninst\u271d\u00b9 : AddLeftMono \u03b1\ninst\u271d : AddLeftReflectLE \u03b1\nthis\u271d : a \u2264 0 \u2228 0 \u2264 a\nthis : b \u2264 0 \u2228 0 \u2264 b\n\u22a2 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0 \u2194 (a \u2264 0 \u2228 0 \u2264 b) \u2227 (b \u2264 0 \u2228 0 \u2264 a)",["tauto","aesop"]],["LinearAlgebra/AffineSpace/FiniteDimensional.lean",393,"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u22a2 Module.rank k \u21a5\u22a5 \u2264 1",["simp","aesop","norm_num"]],["LinearAlgebra/AffineSpace/FiniteDimensional.lean",495,"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\np : Fin 3 \u2192 P\n\u22a2 \u2200 {i\u2081 i\u2082 i\u2083 : Fin 3}, i\u2081 \u2260 i\u2082 \u2192 i\u2081 \u2260 i\u2083 \u2192 i\u2082 \u2260 i\u2083 \u2192 Finset.univ = {i\u2081, i\u2082, i\u2083}",["decide"]],["Algebra/Module/Torsion.lean",100,"case refine_2\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : NoZeroSMulDivisors R M\nm : M\nh : m \u2260 0\nr : R\nhr : r = 0 \u2228 m = 0\n\u22a2 r = 0",["tauto","aesop"]],["Algebra/Group/Subgroup/Basic.lean",421,"case h\nG : Type u_1\ninst\u271d : Group G\nH : Subgroup G\n\u22a2 True \u2227 \u00acH = \u22a4 \u2192 True \u2227 \u00acH = H.normalizer \u2194 H.normalizer = H \u2192 H = \u22a4",["tauto"]],["FieldTheory/IntermediateField/Adjoin/Basic.lean",37,"F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u03b9 : Type u_3\ni : \u03b9 \u2192 E\nx : E\n\u22a2 (\u2203 a a_1, (MvPolynomial.aeval i) a / (MvPolynomial.aeval i) a_1 = x) \u2194\n    \u2203 r s, x = (MvPolynomial.aeval i) r / (MvPolynomial.aeval i) s",["tauto","aesop"]],["FieldTheory/IntermediateField/Adjoin/Basic.lean",49,"F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u03b1 x : E\n\u22a2 (\u2203 a a_1, (aeval \u03b1) a / (aeval \u03b1) a_1 = x) \u2194 \u2203 r s, x = (aeval \u03b1) r / (aeval \u03b1) s",["tauto","aesop"]],["Probability/Kernel/IonescuTulcea/Traj.lean",402,"case hfg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nA : \u2115 \u2192 Set ((n : \u2115) \u2192 X n)\nA_mem : \u2200 (n : \u2115), A n \u2208 measurableCylinders X\nA_anti : Antitone A\nA_inter : \u22c2 n, A n = \u2205\np : \u2115\nx\u2080 : (i : { x // x \u2208 Iic p }) \u2192 X \u2191i\nx\u271d : \u2200 (n : \u2115), Nonempty (X n)\na : \u2115 \u2192 \u2115\nS : (n : \u2115) \u2192 Set ((i : { x // x \u2208 Iic (a n) }) \u2192 X \u2191i)\nmS : \u2200 (n : \u2115), MeasurableSet (S n)\nA_eq : \u2200 (n : \u2115), A n = cylinder (Iic (a n)) (S n)\n\u03c7 : \u2115 \u2192 ((n : \u2115) \u2192 X n) \u2192 \u211d\u22650\u221e := fun n \u21a6 (A n).indicator 1\nm\u03c7 : \u2200 (n : \u2115), Measurable (\u03c7 n)\n\u03c7_dep : \u2200 (n : \u2115), DependsOn (\u03c7 n) \u2191(Iic (a n))\nlma_const :\n  \u2200 (x y : (i : \u2115) \u2192 X i) (n : \u2115),\n    lmarginalPartialTraj \u03ba p (a n) (\u03c7 n) (updateFinset x (Iic p) x\u2080) =\n      lmarginalPartialTraj \u03ba p (a n) (\u03c7 n) (updateFinset y (Iic p) x\u2080)\n\u03c7_anti : Antitone \u03c7\nlma_inv : \u2200 (k M n : \u2115), a n \u2264 M \u2192 lmarginalPartialTraj \u03ba k M (\u03c7 n) = lmarginalPartialTraj \u03ba k (a n) (\u03c7 n)\nanti_lma : \u2200 (k : \u2115) (x : (n : \u2115) \u2192 X n), Antitone fun n \u21a6 lmarginalPartialTraj \u03ba k (a n) (\u03c7 n) x\nl : \u2115 \u2192 ((n : \u2115) \u2192 X n) \u2192 \u211d\u22650\u221e\nhl : \u2200 (k : \u2115) (x : (n : \u2115) \u2192 X n), Tendsto (fun n \u21a6 lmarginalPartialTraj \u03ba k (a n) (\u03c7 n) x) atTop (\ud835\udcdd (l k x))\nl_const : \u2200 (x y : (i : \u2115) \u2192 X i), l p (updateFinset x (Iic p) x\u2080) = l p (updateFinset y (Iic p) x\u2080)\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u2200 (x : (i : \u2115) \u2192 X i), l p (updateFinset x (Iic p) x\u2080) = \u03b5\nhpos : \u2200 (x : (i : \u2115) \u2192 X i) (n : \u2115), \u03b5 \u2264 lmarginalPartialTraj \u03ba p (a n) (\u03c7 n) (updateFinset x (Iic p) x\u2080)\nn : \u2115\nx : (n : \u2115) \u2192 X n\n\u22a2 \u2200 a \u2208 A n, 1 a \u2264 1",["simp","aesop","norm_num"]],["Data/Nat/Digits.lean",215,"b : \u2115\nh : 1 < b\nd : \u2115\nL : List \u2115\nih : (\u2200 l \u2208 L, l < b) \u2192 (\u2200 (h : L \u2260 []), L.getLast h \u2260 0) \u2192 b.digits (ofDigits b L) = L\nw\u2081 : \u2200 l \u2208 d :: L, l < b\nw\u2082 : \u2200 (h : d :: L \u2260 []), (d :: L).getLast h \u2260 0\n\u22a2 d :: L \u2260 []",["simp","aesop","tauto"]],["Data/Nat/Digits.lean",621,"case nil\n\u03b1 : Type u_1\ninst\u271d : CommRing \u03b1\na b k : \u03b1\nh : k \u2223 a - b\n\u22a2 k \u2223 0 - 0",["simp","aesop","norm_num"]],["Data/Nat/Digits.lean",385,"b n : \u2115\nIH : \u2200 m < n + 1, \u2200 {d : \u2115}, d \u2208 (b + 2).digits m \u2192 d < b + 2\n\u22a2 b + 2 > 0",["linarith","omega","aesop","positivity","norm_num","simp"]],["Data/Nat/Digits.lean",813,"e n : \u2115\ne0 : 0 < e\nhe : n + 1 < 10 ^ e\nhterm : n.succ / 10 = 0\n\u22a2 (if True then [((n + 1) % 10).digitChar]\n      else\n        if True then [(0 % 10).digitChar, ((n + 1) % 10).digitChar]\n        else toDigitsCore 10 n (0 / 10) [(0 % 10).digitChar, ((n + 1) % 10).digitChar]).length \u2264\n    e",["assumption","aesop","congr","tauto"]],["Data/Nat/Digits.lean",77,"n b : \u2115\n\u22a2 2 \u2264 b + 2",["norm_num","omega","aesop","linarith","simp"]],["Data/Nat/Digits.lean",888,"",["norm_num","ring","omega","decide","aesop","congr","linarith","positivity","gcongr","tauto","infer_instance","assumption","abel","contradiction","simp","fun_prop"]],["Data/Nat/Digits.lean",113,"n\u271d : \u2115\nh : 1 < 0\n\u22a2 \u00ac1 < 0",["decide","omega","aesop","linarith","tauto","norm_num","contradiction","simp"]],["Data/Nat/Digits.lean",114,"n\u271d : \u2115\nh : 1 < 1\n\u22a2 \u00ac1 < 1",["decide"]],["Data/Set/Prod.lean",864,"case h.e'_5\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (i : \u03b9) \u2192 \u03b1 i\nhi : i \u2208 s\nhf : \u2200 j \u2208 s, j \u2260 i \u2192 f j \u2208 t j\nx : \u03b1 i\nh : x \u2208 update f i \u207b\u00b9' s.pi t\n\u22a2 x = update f i x i",["simp","aesop"]],["Data/Set/Prod.lean",857,"case h\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ni : \u03b9\ninst\u271d : DecidableEq \u03b9\ns : Set (\u03b1 i)\nx\u271d : (x : \u03b9) \u2192 \u03b1 x\n\u22a2 x\u271d \u2208 eval i \u207b\u00b9' s \u2194 x\u271d \u2208 {i}.pi (update (fun x \u21a6 univ) i s)",["simp","aesop"]],["Data/Set/Prod.lean",104,"case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nb : \u03b2\nc : \u03b1\nd : \u03b2\n\u22a2 (c, d) \u2208 {a} \u00d7\u02e2 {b} \u2194 (c, d) \u2208 {(a, b)}",["simp","aesop"]],["Data/Set/Prod.lean",588,"\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 (x.1 \u2208 s \u2227 x.1 \u2208 t) \u2227 (x.2 \u2208 s \u2227 x.2 \u2208 t) \u2227 x.1 \u2260 x.2 \u2194 (x.1 \u2208 s \u2227 x.2 \u2208 s \u2227 x.1 \u2260 x.2) \u2227 x.1 \u2208 t \u2227 x.2 \u2208 t \u2227 x.1 \u2260 x.2",["tauto","aesop"]],["Algebra/Lie/Weights/Basic.lean",532,"case h\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : LieRing L\ninst\u271d\u2079 : LieAlgebra R L\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : LieRingModule L M\ninst\u271d\u2075 : LieModule R L M\ninst\u271d\u2074 : LieRing.IsNilpotent L\nM\u2082 : Type u_5\ninst\u271d\u00b3 : AddCommGroup M\u2082\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : LieRingModule L M\u2082\ninst\u271d : LieModule R L M\u2082\n\u03c7 : L \u2192 R\nf : M \u2192\u2097\u2045R,L\u2046 M\u2082\nhf : Injective \u21d1f\nm : M\nhm : \u2200 (x : L), \u2203 k, (((toEnd R L M\u2082) x - \u03c7 x \u2022 1) ^ k) (f m) = 0\nx : L\nx\u271d : M\n\u22a2 (((toEnd R L M\u2082) x - \u03c7 x \u2022 1) \u2218\u2097 \u2191f) x\u271d = (\u2191f \u2218\u2097 ((toEnd R L M) x - \u03c7 x \u2022 1)) x\u271d",["simp","aesop","norm_num"]],["Algebra/Polynomial/Div.lean",529,"case isFalse\nR : Type u\ninst\u271d\u00b9 : Ring R\ninst\u271d : DecidableEq R\np : R[X]\na : R\nh : \u00acp = 0\n\u22a2 Nat.find \u22ef = Nat.find \u22ef",["congr"]],["Algebra/Polynomial/Div.lean",463,"case pos.h\nR : Type u\ninst\u271d : Ring R\np : R[X]\na : R\nn : \u2115\nh : p.natDegree \u2264 n\na\u271d : Nontrivial R\nhp : p.natDegree = 0\n\u22a2 0 < 1",["norm_num","omega","decide","aesop","linarith","positivity","tauto","simp"]],["Algebra/Polynomial/Div.lean",488,"R : Type u\ninst\u271d : Ring R\np : R[X]\na : R\nh0 : p \u2260 0\nthis : Nontrivial R\n\u22a2 0 < 1",["decide","aesop","positivity","norm_num","simp"]],["Algebra/Polynomial/Div.lean",651,"R : Type u\ninst\u271d : CommRing R\np : R[X]\na : R\nhp : p \u2260 0\nthis\u271d : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - C a) ^ rootMultiplicity a p = (X - C a) * q\nthis : (X - C a) ^ (multiplicity (X - C a) p + 1) * q = p\n\u22a2 0 < 1",["decide","aesop","positivity","norm_num","simp"]],["Topology/FiberBundle/Trivialization.lean",765,"B : Type u_1\nF : Type u_2\nE : B \u2192 Type u_3\nZ : Type u_4\ninst\u271d\u00b3 : TopologicalSpace B\ninst\u271d\u00b2 : TopologicalSpace F\nproj : Z \u2192 B\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace (TotalSpace F E)\ne : Trivialization F proj\nx : Z\ne' : Trivialization F TotalSpace.proj\nb\u271d : B\ny : E b\u271d\nT\u271d : Trivialization F proj\nz : Z\nb : B\nT : Trivialization F proj\n\u22a2 \u2200 (x : \u2191T.source \u00d7 \u2191T.baseSet), \u2191x.1 \u2208 T.source",["simp","aesop","norm_num"]],["Topology/FiberBundle/Trivialization.lean",279,"case mk.mk\nB : Type u_1\nF : Type u_2\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace B\ninst\u271d\u00b9 : TopologicalSpace F\nproj : Z \u2192 B\ninst\u271d : TopologicalSpace Z\ntoPartialHomeomorph\u271d\u00b9 : PartialHomeomorph Z (B \u00d7 F)\nbaseSet\u271d\u00b9 : Set B\nopen_baseSet\u271d\u00b9 : IsOpen baseSet\u271d\u00b9\nsource_eq\u271d\u00b9 : toPartialHomeomorph\u271d\u00b9.source = proj \u207b\u00b9' baseSet\u271d\u00b9\ntarget_eq\u271d\u00b9 : toPartialHomeomorph\u271d\u00b9.target = baseSet\u271d\u00b9 \u00d7\u02e2 univ\nproj_toFun\u271d\u00b9 : \u2200 p \u2208 toPartialHomeomorph\u271d\u00b9.source, (\u2191toPartialHomeomorph\u271d\u00b9 p).1 = proj p\ntoPartialHomeomorph\u271d : PartialHomeomorph Z (B \u00d7 F)\nbaseSet\u271d : Set B\nopen_baseSet\u271d : IsOpen baseSet\u271d\nsource_eq\u271d : toPartialHomeomorph\u271d.source = proj \u207b\u00b9' baseSet\u271d\ntarget_eq\u271d : toPartialHomeomorph\u271d.target = baseSet\u271d \u00d7\u02e2 univ\nproj_toFun\u271d : \u2200 p \u2208 toPartialHomeomorph\u271d.source, (\u2191toPartialHomeomorph\u271d p).1 = proj p\nh\u2081 :\n  { toPartialHomeomorph := toPartialHomeomorph\u271d\u00b9, baseSet := baseSet\u271d\u00b9, open_baseSet := open_baseSet\u271d\u00b9,\n        source_eq := source_eq\u271d\u00b9, target_eq := target_eq\u271d\u00b9, proj_toFun := proj_toFun\u271d\u00b9 }.toPartialHomeomorph =\n    { toPartialHomeomorph := toPartialHomeomorph\u271d, baseSet := baseSet\u271d, open_baseSet := open_baseSet\u271d,\n        source_eq := source_eq\u271d, target_eq := target_eq\u271d, proj_toFun := proj_toFun\u271d }.toPartialHomeomorph\nh\u2082 :\n  { toPartialHomeomorph := toPartialHomeomorph\u271d\u00b9, baseSet := baseSet\u271d\u00b9, open_baseSet := open_baseSet\u271d\u00b9,\n        source_eq := source_eq\u271d\u00b9, target_eq := target_eq\u271d\u00b9, proj_toFun := proj_toFun\u271d\u00b9 }.baseSet =\n    { toPartialHomeomorph := toPartialHomeomorph\u271d, baseSet := baseSet\u271d, open_baseSet := open_baseSet\u271d,\n        source_eq := source_eq\u271d, target_eq := target_eq\u271d, proj_toFun := proj_toFun\u271d }.baseSet\n\u22a2 { toPartialHomeomorph := toPartialHomeomorph\u271d\u00b9, baseSet := baseSet\u271d\u00b9, open_baseSet := open_baseSet\u271d\u00b9,\n      source_eq := source_eq\u271d\u00b9, target_eq := target_eq\u271d\u00b9, proj_toFun := proj_toFun\u271d\u00b9 } =\n    { toPartialHomeomorph := toPartialHomeomorph\u271d, baseSet := baseSet\u271d, open_baseSet := open_baseSet\u271d,\n      source_eq := source_eq\u271d, target_eq := target_eq\u271d, proj_toFun := proj_toFun\u271d }",["congr","aesop"]],["Geometry/Manifold/LocalInvariantProperties.lean",490,"H : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\nG : StructureGroupoid H\nx : M\nQ : (H \u2192 H) \u2192 Set H \u2192 H \u2192 Prop\ninst\u271d : HasGroupoid M G\nhG : G.LocalInvariantProp G Q\nhQ : \u2200 (y : H), Q id univ y\n\u22a2 \u2191(chartAt H x) x \u2208 (chartAt H x).target",["simp","aesop","norm_num"]],["MeasureTheory/Integral/DominatedConvergence.lean",637,"E : Type u_1\nX : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : TopologicalSpace X\n\u03bc : Measure \u211d\ninst\u271d\u00b9 : NoAtoms \u03bc\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : X \u2192 \u211d \u2192 E\nhf : Continuous (Function.uncurry f)\na\u2080 b\u2080 : \u211d\n\u22a2 Continuous fun x \u21a6 \u222b (t : \u211d) in a\u2080..b\u2080, f x t \u2202\u03bc",["fun_prop","omega","aesop","tauto","infer_instance"]],["MeasureTheory/Integral/DominatedConvergence.lean",575,"case e_a\nE : Type u_1\nX : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : TopologicalSpace X\n\u03bc : Measure \u211d\ninst\u271d\u00b9 : NoAtoms \u03bc\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : X \u2192 \u211d \u2192 E\na\u2080 : \u211d\nhf : Continuous (Function.uncurry f)\nq : X\nb\u2080 \u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\na : \u211d\na_lt : a < a\u2080 \u2227 a < b\u2080\nb : \u211d\nlt_b : a\u2080 < b \u2227 b\u2080 < b\nthis\u271d : IsCompact ({q} \u00d7\u02e2 Icc a b)\nM : \u211d\nhM : M \u2208 upperBounds ((fun x \u21a6 \u2016Function.uncurry f x\u2016) '' {q} \u00d7\u02e2 Icc a b)\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : \u03b4 < 1\nh'\u03b4 : Icc (b\u2080 - \u03b4) (b\u2080 + \u03b4) \u2286 Icc a b\nh''\u03b4 : (M + 1) * (\u03bc (Icc (b\u2080 - \u03b4) (b\u2080 + \u03b4))).toReal + \u03b4 * (\u03bc (Icc a b)).toReal < \u03b5\nv : Set X\nv_mem : v \u2208 \ud835\udcdd[univ] q\nthis : v \u00d7\u02e2 Ioo (b\u2080 - \u03b4) (b\u2080 + \u03b4) \u2208 \ud835\udcdd (q, b\u2080)\np : X\ns : \u211d\nhp : p \u2208 v\nhs : s \u2208 Ioo (b\u2080 - \u03b4) (b\u2080 + \u03b4)\nhv : \u2200 p \u2208 v, \u2200 x \u2208 Icc a b, \u2016f p x - f q x\u2016 < \u03b4\nJ : \u2200 (r : X) (u v : \u211d), IntervalIntegrable (f r) \u03bc u v\n\u22a2 \u222b (t : \u211d) in a\u2080..s, f p t \u2202\u03bc - \u222b (t : \u211d) in a\u2080..b\u2080, f q t \u2202\u03bc =\n    \u222b (t : \u211d) in a\u2080..s, f p t \u2202\u03bc - \u222b (t : \u211d) in a\u2080..b\u2080, f p t \u2202\u03bc +\n      (\u222b (t : \u211d) in a\u2080..b\u2080, f p t \u2202\u03bc - \u222b (t : \u211d) in a\u2080..b\u2080, f q t \u2202\u03bc)",["abel","aesop","norm_num","simp"]],["MeasureTheory/Integral/DominatedConvergence.lean",608,"case e_a\nE : Type u_1\nX : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : TopologicalSpace X\n\u03bc : Measure \u211d\ninst\u271d\u00b9 : NoAtoms \u03bc\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : X \u2192 \u211d \u2192 E\na\u2080 : \u211d\nhf : Continuous (Function.uncurry f)\nq : X\nb\u2080 \u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\na : \u211d\na_lt : a < a\u2080 \u2227 a < b\u2080\nb : \u211d\nlt_b : a\u2080 < b \u2227 b\u2080 < b\nthis\u271d : IsCompact ({q} \u00d7\u02e2 Icc a b)\nM : \u211d\nhM : M \u2208 upperBounds ((fun x \u21a6 \u2016Function.uncurry f x\u2016) '' {q} \u00d7\u02e2 Icc a b)\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : \u03b4 < 1\nh'\u03b4 : Icc (b\u2080 - \u03b4) (b\u2080 + \u03b4) \u2286 Icc a b\nh''\u03b4 : (M + 1) * (\u03bc (Icc (b\u2080 - \u03b4) (b\u2080 + \u03b4))).toReal + \u03b4 * (\u03bc (Icc a b)).toReal < \u03b5\nv : Set X\nv_mem : v \u2208 \ud835\udcdd[univ] q\nthis : v \u00d7\u02e2 Ioo (b\u2080 - \u03b4) (b\u2080 + \u03b4) \u2208 \ud835\udcdd (q, b\u2080)\np : X\ns : \u211d\nhp : p \u2208 v\nhs : s \u2208 Ioo (b\u2080 - \u03b4) (b\u2080 + \u03b4)\nhv : \u2200 p \u2208 v, \u2200 x \u2208 Icc a b, \u2016f p x - f q x\u2016 < \u03b4\nJ : \u2200 (r : X) (u v : \u211d), IntervalIntegrable (f r) \u03bc u v\nx : \u211d\nhx : x \u2208 Icc (b\u2080 - \u03b4) (b\u2080 + \u03b4)\n\u22a2 f p x = f q x + (f p x - f q x)",["abel","aesop","norm_num","simp"]],["LinearAlgebra/FreeModule/PID.lean",185,"case pos\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : IsPrincipalIdealRing R\ninst\u271d\u00b2 : Finite \u03b9\nO : Type u_4\ninst\u271d\u00b9 : AddCommGroup O\ninst\u271d : Module R O\nM N : Submodule R O\nb'M : Basis \u03b9 R \u21a5M\nN_bot : N \u2260 \u22a5\nN_le_M : N \u2264 M\nthis\u271d : \u2203 \u03d5, \u2200 (\u03c8 : \u21a5M \u2192\u2097[R] R), \u00ac\u03d5.submoduleImage N < \u03c8.submoduleImage N\n\u03d5 : \u21a5M \u2192\u2097[R] R := this\u271d.choose\n\u03d5_max : \u2200 (\u03c8 : \u21a5M \u2192\u2097[R] R), \u00acthis\u271d.choose.submoduleImage N < \u03c8.submoduleImage N\na : R := generator (\u03d5.submoduleImage N)\na_mem : a \u2208 \u03d5.submoduleImage N\na_zero : a = 0\nthis : N = \u22a5\n\u22a2 \u2203 y \u2208 M,\n    \u2203 a,\n      a \u2022 y \u2208 N \u2227\n        \u2203 M' \u2264 M,\n          \u2203 N' \u2264 N,\n            N' \u2264 M' \u2227\n              (\u2200 (c : R), \u2200 z \u2208 M', c \u2022 y + z = 0 \u2192 c = 0) \u2227\n                (\u2200 (c : R), \u2200 z \u2208 N', c \u2022 a \u2022 y + z = 0 \u2192 c = 0) \u2227\n                  \u2200 (n' : \u2115) (bN' : Basis (Fin n') R \u21a5N'),\n                    \u2203 bN,\n                      \u2200 (m' : \u2115) (hn'm' : n' \u2264 m') (bM' : Basis (Fin m') R \u21a5M'),\n                        \u2203 (hnm : n' + 1 \u2264 m' + 1),\n                          \u2203 bM,\n                            \u2200 (as : Fin n' \u2192 R),\n                              (\u2200 (i : Fin n'), \u2191(bN' i) = as i \u2022 \u2191(bM' (Fin.castLE hn'm' i))) \u2192\n                                \u2203 as', \u2200 (i : Fin (n' + 1)), \u2191(bN i) = as' i \u2022 \u2191(bM (Fin.castLE hnm i))",["contradiction","aesop","tauto"]],["Algebra/Homology/ShortComplex/Exact.lean",874,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Abelian C\nS\u2081 S\u2082 : ShortComplex C\n\u03c6 : S\u2081 \u27f6 S\u2082\nhg\u2081 : S\u2081.g = 0\nhf\u2082 : S\u2082.f = 0\nhg\u2082 : S\u2082.g = 0\nthis : Mono \u03c6.\u03c4\u2082.op \u2194 Epi \u03c6.\u03c4\u2082\n\u22a2 (mk (opMap \u03c6).\u03c4\u2082 S\u2081.op.g \u22ef).unop.Exact \u2227 Mono (opMap \u03c6).\u03c4\u2082 \u2194 (mk S\u2081.f \u03c6.\u03c4\u2082 \u22ef).Exact \u2227 Epi \u03c6.\u03c4\u2082",["tauto"]],["Combinatorics/SimpleGraph/Clique.lean",67,"\u03b1 : Type u_1\nG : SimpleGraph \u03b1\na : \u03b1\n\u22a2 G.IsClique {a}",["simp","aesop"]],["Combinatorics/SimpleGraph/Clique.lean",336,"\u03b1 : Type u_1\nn : \u2115\nh : 2 \u2264 n\nt : Finset \u03b1\nht : \u22a5.IsNClique n t\nthis : 2 \u2264 1\n\u22a2 False",["contradiction","omega","aesop","tauto"]],["AlgebraicTopology/SimplexCategory/Basic.lean",828,"case hf\nx : SimplexCategory\ni : x \u27f6 x\ninst\u271d : Mono i\n\u22a2 Mono i",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["AlgebraicTopology/SimplexCategory/Basic.lean",838,"case hf\nx : SimplexCategory\ni : x \u27f6 x\ninst\u271d : Epi i\n\u22a2 Epi i",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["AlgebraicTopology/SimplexCategory/Basic.lean",847,"n : \u2115\n\u03b8 : \u298bn + 1\u298c \u27f6 \u298bn\u298c\ninst\u271d : Epi \u03b8\ni : Fin (n + 1)\n\u03b8' : \u298bn\u298c \u27f6 \u298bn\u298c\nh : \u03b8 = \u03c3 i \u226b \u03b8'\n\u22a2 Epi \u03b8",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["AlgebraicTopology/SimplexCategory/Basic.lean",858,"n : \u2115\n\u03b8 : \u298bn\u298c \u27f6 \u298bn + 1\u298c\ninst\u271d : Mono \u03b8\ni : Fin (n + 2)\n\u03b8' : \u298bn\u298c \u27f6 \u298bn\u298c\nh : \u03b8 = \u03b8' \u226b \u03b4 i\n\u22a2 Mono \u03b8",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["Analysis/Normed/Module/FiniteDimension.lean",95,"\ud835\udd5c : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nP\u2081 : Type u_4\nP\u2082 : Type u_5\ninst\u271d\u00b9\u00b9 : NormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NormedAddCommGroup V\u2081\ninst\u271d\u2079 : SeminormedAddCommGroup V\u2082\ninst\u271d\u2078 : NormedSpace \ud835\udd5c V\u2081\ninst\u271d\u2077 : NormedSpace \ud835\udd5c V\u2082\ninst\u271d\u2076 : MetricSpace P\u2081\ninst\u271d\u2075 : PseudoMetricSpace P\u2082\ninst\u271d\u2074 : NormedAddTorsor V\u2081 P\u2081\ninst\u271d\u00b3 : NormedAddTorsor V\u2082 P\u2082\ninst\u271d\u00b2 : FiniteDimensional \ud835\udd5c V\u2081\ninst\u271d\u00b9 : FiniteDimensional \ud835\udd5c V\u2082\ninst\u271d : Inhabited P\u2081\nli : P\u2081 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082\nh : finrank \ud835\udd5c V\u2081 = finrank \ud835\udd5c V\u2082\np : P\u2081\n\u22a2 li p = (li.linearIsometry.toLinearIsometryEquiv h) (p -\u1d65 default) +\u1d65 li default",["simp","aesop","norm_num"]],["Analysis/Normed/Module/FiniteDimension.lean",406,"\ud835\udd5c : Type u\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : CompleteSpace \ud835\udd5c\nh : \u00acFiniteDimensional \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\n\u22a2 \u2016c\u2016 < \u2016c\u2016 + 1",["linarith","aesop","norm_num","simp"]],["CategoryTheory/Limits/Cones.lean",277,"case mk.mk\nJ : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} J\nC : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} C\nF : J \u2964 C\nc c' : Cone F\nhom\u271d\u00b9 : c.pt \u27f6 c'.pt\nw\u271d\u00b9 : \u2200 (j : J), hom\u271d\u00b9 \u226b c'.\u03c0.app j = c.\u03c0.app j\nhom\u271d : c.pt \u27f6 c'.pt\nw\u271d : \u2200 (j : J), hom\u271d \u226b c'.\u03c0.app j = c.\u03c0.app j\nw : { hom := hom\u271d\u00b9, w := w\u271d\u00b9 }.hom = { hom := hom\u271d, w := w\u271d }.hom\n\u22a2 { hom := hom\u271d\u00b9, w := w\u271d\u00b9 } = { hom := hom\u271d, w := w\u271d }",["congr","aesop"]],["CategoryTheory/Limits/Cones.lean",482,"case mk.mk\nJ : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} J\nC : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} C\nF : J \u2964 C\nc c' : Cocone F\nhom\u271d\u00b9 : c.pt \u27f6 c'.pt\nw\u271d\u00b9 : \u2200 (j : J), c.\u03b9.app j \u226b hom\u271d\u00b9 = c'.\u03b9.app j\nhom\u271d : c.pt \u27f6 c'.pt\nw\u271d : \u2200 (j : J), c.\u03b9.app j \u226b hom\u271d = c'.\u03b9.app j\nw : { hom := hom\u271d\u00b9, w := w\u271d\u00b9 }.hom = { hom := hom\u271d, w := w\u271d }.hom\n\u22a2 { hom := hom\u271d\u00b9, w := w\u271d\u00b9 } = { hom := hom\u271d, w := w\u271d }",["congr","aesop"]],["RingTheory/Valuation/Basic.lean",589,"R : Type u_3\n\u0393\u2080 : Type u_4\ninst\u271d\u00b9 : CommRing R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\na s : R\nh : s \u2208 v.supp\naux : \u2200 (a s : R), v s = 0 \u2192 v (a + s) \u2264 v a\n\u22a2 v a = v (a + s + -s)",["simp","ring","aesop","norm_num"]],["RingTheory/Valuation/Basic.lean",284,"R : Type u_3\n\u0393\u2080 : Type u_4\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx\u271d y\u271d x y : R\nh : v x \u2260 v y\nh' : v (x + y) < v x\nvyx : v y < v x\n\u22a2 v x = v (x + y - y)",["simp","aesop","norm_num"]],["RingTheory/Valuation/Basic.lean",116,"case mk.mk.mk\nK : Type u_1\nF : Type u_2\nR : Type u_3\ninst\u271d\u2074 : DivisionRing K\n\u0393\u2080 : Type u_4\n\u0393'\u2080 : Type u_5\n\u0393''\u2080 : Type u_6\ninst\u271d\u00b3 : LinearOrderedCommMonoidWithZero \u0393''\u2080\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrderedCommMonoidWithZero \u0393\u2080\ninst\u271d : LinearOrderedCommMonoidWithZero \u0393'\u2080\ng : Valuation R \u0393\u2080\ntoFun\u271d : R \u2192 \u0393\u2080\nmap_zero'\u271d : toFun\u271d 0 = 0\nmap_one'\u271d : { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun 1 = 1\nmap_mul'\u271d :\n  \u2200 (x y : R),\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun (x * y) =\n      { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun x * { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun y\nmap_add_le_max'\u271d :\n  \u2200 (x y : R),\n    (\u2191{ toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d }).toFun (x + y) \u2264\n      (\u2191{ toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d }).toFun x \u2294\n        (\u2191{ toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d }).toFun y\nh :\n  (fun f \u21a6 (\u2191f.toMonoidWithZeroHom).toFun)\n      { toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d,\n        map_add_le_max' := map_add_le_max'\u271d } =\n    (fun f \u21a6 (\u2191f.toMonoidWithZeroHom).toFun) g\n\u22a2 { toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d,\n      map_add_le_max' := map_add_le_max'\u271d } =\n    g",["congr","aesop"]],["Analysis/Analytic/Inverse.lean",404,"n : \u2115\np : \u2115 \u2192 \u211d\nhp : \u2200 (k : \u2115), 0 \u2264 p k\nr a : \u211d\nhr : 0 \u2264 r\nha : 0 \u2264 a\nk : \u2115\nblocksFun : Fin k \u2192 \u2115\nH : \u27e8k, blocksFun\u27e9 \u2208 compPartialSumSource 2 (n + 1) n\n\u22a2 (compChangeOfVariables 2 (n + 1) n \u27e8k, blocksFun\u27e9 H).snd.length = k",["simp","aesop","norm_num"]],["Analysis/Analytic/Inverse.lean",285,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nh : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm \u2191i\n\u22a2 p.leftInv i x = (p.leftInv i x).comp (id \ud835\udd5c F ((p 0) 0))",["simp"]],["Analysis/Analytic/Inverse.lean",127,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nh : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm \u2191i\nn\u271d n : \u2115\nv : Fin (n + 2) \u2192 E\nA : univ = {c | c.length < n + 2}.toFinset \u222a {Composition.ones (n + 2)}\nB : Disjoint {c | c.length < n + 2}.toFinset {Composition.ones (n + 2)}\nj : \u2115\nhj1 : j < (Composition.ones (n + 2)).length\nhj2 : j < n + 2\nk : \u2115\nx\u271d\u00b9 x\u271d : k < 1\n\u22a2 v (Fin.castLE \u22ef \u27e8j, hj1\u27e9) = v \u27e8j, hj2\u27e9",["congr","tauto","abel","norm_num","simp"]],["Analysis/Analytic/Inverse.lean",233,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nn : \u2115\nv : Fin (n + 2) \u2192 F\n\u22a2 0 < n + 2",["norm_num","omega","aesop","linarith","positivity","simp"]],["Analysis/Analytic/Inverse.lean",257,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nh : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm \u2191i\nn\u271d n : \u2115\nv : Fin (n + 2) \u2192 F\n\u22a2 0 < n + 2",["norm_num","omega","aesop","linarith","positivity","simp"]],["Analysis/Analytic/Inverse.lean",274,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nn\u271d n : \u2115\nhn : 2 \u2264 n + 2\nv : Fin (n + 2) \u2192 F\n\u22a2 0 < n + 2",["norm_num","omega","aesop","linarith","positivity","simp"]],["Analysis/Analytic/Inverse.lean",547,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nhp : 0 < p.radius\nC r : \u211d\nCpos : 0 < C\nrpos : 0 < r\nple : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\na : \u211d\napos : 0 < a\nha1 : 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a \u2264 1\nha2 : r * (I + 1) * a \u2264 1 / 2\nS : \u2115 \u2192 \u211d := fun n \u21a6 \u2211 k \u2208 Ico 1 n, a ^ k * \u2016p.rightInv i x k\u2016\nIRec : \u2200 (n : \u2115), 1 \u2264 n \u2192 S n \u2264 (I + 1) * a\na' : NNReal := \u27e8a, \u22ef\u27e9\nn : \u2115\nhn : 1 \u2264 n\n\u22a2 1 \u2264 n + 1",["norm_num","omega","aesop","linarith","tauto","simp"]],["Algebra/Star/Subalgebra.lean",326,"R : Type u_2\nA : Type u_3\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\nS : Subalgebra R A\nx : A\n\u22a2 star x \u2208 star S \u2194 x \u2208 S",["simp","aesop","norm_num"]],["Algebra/Star/Subalgebra.lean",599,"case h\nR : Type u_2\nA : Type u_3\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\nx\u271d : A\n\u22a2 x\u271d \u2208 \u22a4.toSubalgebra \u2194 x\u271d \u2208 \u22a4",["simp","aesop","tauto","norm_num"]],["RingTheory/AdjoinRoot.lean",470,"case h\u2081\nR : Type u\nS : Type v\nK : Type w\ninst\u271d : CommRing R\ng : R[X]\nhg : g.Monic\ni : Fin g.natDegree\na\u271d : i \u2209 Finset.univ\nthis : i \u2208 Finset.univ\n\u22a2 (monomial \u2191i) (Pi.single i 1 i) = 0",["contradiction","aesop","tauto"]],["Data/Matroid/Map.lean",400,"case mpr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nM : Matroid \u03b1\nhf : InjOn f M.E\nD\u2080 : Set \u03b1\nhD\u2080 : \u00acM.Indep D\u2080\nhD\u2080E : D\u2080 \u2286 M.E\nhI : M.Indep D\u2080\n\u22a2 False",["contradiction","aesop","tauto"]],["ModelTheory/Substructures.lean",902,"L : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst\u271d\u00b2 : L.Structure M\ninst\u271d\u00b9 : L.Structure N\ninst\u271d : L.Structure P\nS : L.Substructure M\nf\u271d : M \u21aa[L] N\ns : L.Substructure M\nn : \u2115\nf : L.Functions n\nx : Fin n \u2192 \u21a5s\n\u22a2 { toFun := \u21d1(codRestrict (Substructure.map f\u271d.toHom s) (f\u271d.domRestrict s) \u22ef), invFun := fun n \u21a6 \u27e8Classical.choose \u22ef, \u22ef\u27e9,\n          left_inv := \u22ef, right_inv := \u22ef }.toFun\n      (funMap f x) =\n    funMap f\n      ({ toFun := \u21d1(codRestrict (Substructure.map f\u271d.toHom s) (f\u271d.domRestrict s) \u22ef),\n            invFun := fun n \u21a6 \u27e8Classical.choose \u22ef, \u22ef\u27e9, left_inv := \u22ef, right_inv := \u22ef }.toFun \u2218\n        x)",["simp","aesop"]],["ModelTheory/Substructures.lean",923,"L : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst\u271d\u00b2 : L.Structure M\ninst\u271d\u00b9 : L.Structure N\ninst\u271d : L.Structure P\nS : L.Substructure M\nf : M \u21aa[L] N\nn : \u2115\nR : L.Relations n\nx : Fin n \u2192 M\n\u22a2 RelMap R\n      ({ toFun := \u21d1(codRestrict f.toHom.range f \u22ef), invFun := fun n \u21a6 Classical.choose \u22ef, left_inv := \u22ef,\n            right_inv := \u22ef }.toFun \u2218\n        x) \u2194\n    RelMap R x",["simp","aesop"]],["ModelTheory/Substructures.lean",660,"L : Language\nM : Type w\ninst\u271d : L.Structure M\n\u03b1 : Type u_3\nn : \u2115\n\u03c6 : L.BoundedFormula \u03b1 n\nv : \u03b1 \u2192 \u21a5\u22a4\nxs : Fin n \u2192 \u21a5\u22a4\n\u22a2 \u03c6.Realize (\u21d1topEquiv \u2218 v) (\u21d1topEquiv \u2218 xs) \u2194 \u03c6.Realize (Subtype.val \u2218 v) (Subtype.val \u2218 xs)",["simp","aesop","tauto"]],["ModelTheory/Substructures.lean",647,"L : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst\u271d\u00b2 : L.Structure M\ninst\u271d\u00b9 : L.Structure N\ninst\u271d : L.Structure P\nS : L.Substructure M\ns : Set M\nm : \u21a5\u22a4\n\u22a2 (fun m \u21a6 \u27e8m, \u22ef\u27e9) (\u22a4.subtype m) = m",["simp","aesop","congr","tauto"]],["Analysis/SpecificLimits/Basic.lean",316,"case ha\nn i : \u2115\n\u22a2 0 \u2264 1 / 2",["norm_num","aesop","linarith","positivity","simp"]],["Analysis/SpecificLimits/Basic.lean",98,"m : \u2115\nhm : 0 < m\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, 0 \u2264 (fun n \u21a6 \u2191(n % m)) n",["aesop","norm_num","simp"]],["Algebra/Algebra/Operations.lean",422,"case h.h\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nM N : Submodule R A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5M\nhy : (fun i \u21a6 map f.toLinearMap (map ((LinearMap.mul R A) \u2191i) N)) y = S\nx\u271d : A'\n\u22a2 x\u271d \u2208 (fun s \u21a6 map ((LinearMap.mul R A') \u2191s) (map f.toLinearMap N)) \u27e8f \u2191y, \u22ef\u27e9 \u2194\n    x\u271d \u2208 (fun i \u21a6 map f.toLinearMap (map ((LinearMap.mul R A) \u2191i) N)) y",["simp","aesop","norm_num"]],["Algebra/Algebra/Operations.lean",509,"case right\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid A\ninst\u271d\u00b9 : Mul A\ninst\u271d : Module R A\nS S' : Set A\nx : A\nhx : x \u2208 span R (S * S')\nU : Finset A\nh\u271d : \u2191U \u2286 S * S'\nhU : x \u2208 span R \u2191U\nT T' : Finset A\nhS : \u2191T \u2286 S\nhS' : \u2191T' \u2286 S'\nh : U \u2286 T * T'\nh' : \u2191U \u2286 \u2191T * \u2191T'\nh'' : x \u2208 span R (\u2191T * \u2191T')\n\u22a2 x \u2208 span R (\u2191T * \u2191T')",["assumption","aesop","congr","gcongr","tauto"]],["Topology/UniformSpace/UniformEmbedding.lean",536,"\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nm : \u03b2 \u2192 \u03b1\nhm : IsUniformInducing m\ndense : DenseRange m\nh : \u2200 (f : Filter \u03b2), Cauchy f \u2192 \u2203 x, map m f \u2264 \ud835\udcdd x\nf : Filter \u03b1\nhf : Cauchy f\np : Set (\u03b1 \u00d7 \u03b1) \u2192 Set \u03b1 \u2192 Set \u03b1 := fun s t \u21a6 {y | \u2203 x \u2208 t, (x, y) \u2208 s}\ng : Filter \u03b1 := (\ud835\udce4 \u03b1).lift fun s \u21a6 f.lift' (p s)\nmp\u2080 : Monotone p\nmp\u2081 : \u2200 {s : Set (\u03b1 \u00d7 \u03b1)}, Monotone (p s)\nthis\u271d\u2075 : f \u2264 g\nthis\u271d\u2074 : g.NeBot\nthis\u271d\u00b3 : (comap m g).NeBot\nthis\u271d\u00b2 : Cauchy g\nthis\u271d\u00b9 : Cauchy (comap m g)\nx : \u03b1\nhx : map m (comap m g) \u2264 \ud835\udcdd x\nthis\u271d : ClusterPt x (map m (comap m g))\nthis : ClusterPt x g\n\u22a2 f \u2264 g",["assumption","aesop","congr","gcongr","tauto"]],["NumberTheory/Zsqrtd/Basic.lean",904,"case h\nR : Type\ninst\u271d : CommRing R\nd : \u2124\nf : \u2124\u221ad \u2192+* R\n\u22a2 ((fun r \u21a6 { toFun := fun a \u21a6 \u2191a.re + \u2191a.im * \u2191r, map_one' := \u22ef, map_mul' := \u22ef, map_zero' := \u22ef, map_add' := \u22ef })\n        ((fun f \u21a6 \u27e8f sqrtd, \u22ef\u27e9) f))\n      sqrtd =\n    f sqrtd",["simp","aesop","norm_num"]],["NumberTheory/Zsqrtd/Basic.lean",774,"d : \u2115\ndnsq : Nonsquare d\nx y : \u2115\ne : (x + 1) * (x + 1) = d * (y + 1) * (y + 1)\nt : x + 1 = 0\n\u22a2 False",["contradiction","omega","aesop","linarith","tauto"]],["LinearAlgebra/Matrix/Transvection.lean",667,"n : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n \ud835\udd5c\n\u22a2 Fintype.card n = Fintype.card (Fin (Fintype.card n))",["simp","aesop","norm_num"]],["LinearAlgebra/Matrix/Transvection.lean",661,"\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : Field \ud835\udd5c\nr : \u2115\nIH :\n  \u2200 (n : Type) [inst : Fintype n] [inst_1 : DecidableEq n] (M : Matrix n n \ud835\udd5c),\n    Fintype.card n = r \u2192 \u2203 L L' D, (List.map toMatrix L).prod * M * (List.map toMatrix L').prod = diagonal D\nn : Type\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nM : Matrix n n \ud835\udd5c\nhn : Fintype.card n = r + 1\ne : n \u2243 Fin r \u2295 Unit\nN : Matrix (Fin r) (Fin r) \ud835\udd5c\n\u22a2 Fintype.card (Fin r) = r",["simp","aesop","norm_num"]],["LinearAlgebra/Matrix/Transvection.lean",483,"case mk\n\ud835\udd5c : Type u_3\ninst\u271d : Field \ud835\udd5c\nr : \u2115\nM : Matrix (Fin r \u2295 Unit) (Fin r \u2295 Unit) \ud835\udd5c\nhM : M (inr ()) (inr ()) \u2260 0\nval\u271d : \u2115\nisLt\u271d : val\u271d < r\nIH :\n  \u2191\u27e8val\u271d, isLt\u271d\u27e9 \u2264 r \u2192\n    (M * (List.take (\u2191\u27e8val\u271d, isLt\u271d\u27e9) (listTransvecRow M)).prod) (inr ()) (inl \u27e8val\u271d, isLt\u271d\u27e9) =\n      if \u2191\u27e8val\u271d, isLt\u271d\u27e9 \u2264 \u2191\u27e8val\u271d, isLt\u271d\u27e9 then M (inr ()) (inl \u27e8val\u271d, isLt\u271d\u27e9) else 0\nhk : \u2191\u27e8val\u271d, isLt\u271d\u27e9 + 1 \u2264 r\nhnr : \u2191\u27e8val\u271d, isLt\u271d\u27e9 < r\nn' : Fin r := \u27e8\u2191\u27e8val\u271d, isLt\u271d\u27e9, hnr\u27e9\nA :\n  (listTransvecRow M)[\u2191\u27e8val\u271d, isLt\u271d\u27e9]? =\n    some (transvection (inr ()) (inl n') (-M (inr ()) (inl n') / M (inr ()) (inr ())))\nh : \u00acn' = \u27e8val\u271d, isLt\u271d\u27e9\n\u22a2 False",["tauto","aesop","contradiction"]],["Algebra/Homology/HomologicalComplex.lean",135,"\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nK : HomologicalComplex V c\np\u2082 p\u2081 : \u03b9\n\u22a2 K.d p\u2081 p\u2082 \u226b (K.XIsoOfEq \u22ef).hom = K.d p\u2081 p\u2082",["simp","aesop"]],["Algebra/Homology/HomologicalComplex.lean",408,"case hnc\n\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\nj i : \u03b9\nh : \u00acc.Rel i j\nhi : c.Rel i j\nthis : c.prev j = i\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/Homology/HomologicalComplex.lean",426,"case hnc.intro\n\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nc : ComplexShape \u03b9\nC : HomologicalComplex V c\ni j : \u03b9\nh : \u00acc.Rel i j\nhj : c.Rel i j\nthis : c.next i = j\n\u22a2 False",["contradiction","aesop","tauto"]],["Data/Complex/Trigonometric.lean",795,"x : \u211d\nhx : |x| \u2264 1\n\u22a2 \u2016\u2191(cos x - (1 - x ^ 2 / 2))\u2016 = \u2016Complex.cos \u2191x - (1 - \u2191x ^ 2 / 2)\u2016",["simp","aesop","norm_num"]],["Data/Complex/Trigonometric.lean",919,"x : \u211d\n\u22a2 0 < Real.cosh x",["positivity","tauto"]],["Data/Complex/Trigonometric.lean",814,"x : \u211d\nhx : |x| \u2264 1\n\u22a2 0 < 4",["decide","omega","aesop","linarith","positivity","tauto","norm_num","simp"]],["Data/Complex/Trigonometric.lean",815,"x : \u211d\nhx : |x| \u2264 1\n\u22a2 0 < 4",["decide","omega","aesop","linarith","positivity","tauto","norm_num","simp"]],["Data/Complex/Trigonometric.lean",844,"x : \u211d\nhx : |x| \u2264 1\n\u22a2 0 < 4",["decide","omega","aesop","linarith","positivity","tauto","norm_num","simp"]],["Data/Complex/Trigonometric.lean",845,"x : \u211d\nhx : |x| \u2264 1\n\u22a2 0 < 4",["decide","omega","aesop","linarith","positivity","tauto","norm_num","simp"]],["Data/Complex/Trigonometric.lean",870,"x : \u211d\nhx0 : 0 < x\nhx : x \u2264 1\n\u22a2 1 \u2264 4",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["Data/Complex/Trigonometric.lean",873,"x : \u211d\nhx0 : 0 < x\nhx : x \u2264 1\n\u22a2 1 \u2264 3",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["CategoryTheory/Sites/IsSheafFor.lean",221,"case mpr\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nP : C\u1d52\u1d56 \u2964 Type w\nX : C\nS : Sieve X\nx : FamilyOfElements P S.arrows\nh : x.SieveCompatible\nY\u2081 Y\u2082 Z : C\ng\u2081 : Z \u27f6 Y\u2081\ng\u2082 : Z \u27f6 Y\u2082\nf\u2081 : Y\u2081 \u27f6 X\nf\u2082 : Y\u2082 \u27f6 X\nh\u2081 : S.arrows f\u2081\nh\u2082 : S.arrows f\u2082\nk : g\u2081 \u226b f\u2081 = g\u2082 \u226b f\u2082\n\u22a2 x (g\u2081 \u226b f\u2081) \u22ef = x (g\u2082 \u226b f\u2082) \u22ef",["congr"]],["CategoryTheory/Sites/IsSheafFor.lean",396,"C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX : C\nP : C\u1d52\u1d56 \u2964 Type w\nx : FamilyOfElements P \u22a4\nt\u2081 t\u2082 : P.obj (op X)\nh\u2081 : x.IsAmalgamation t\u2081\nh\u2082 : x.IsAmalgamation t\u2082\n\u22a2 \u22a4 (\ud835\udfd9 X)",["tauto"]],["CategoryTheory/Sites/IsSheafFor.lean",397,"C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX : C\nP : C\u1d52\u1d56 \u2964 Type w\nx : FamilyOfElements P \u22a4\nt\u2081 t\u2082 : P.obj (op X)\nh\u2081 : x.IsAmalgamation t\u2081\nh\u2082 : x.IsAmalgamation t\u2082\nq\u2081 : P.map (\ud835\udfd9 X).op t\u2081 = x (\ud835\udfd9 X) trivial\n\u22a2 \u22a4 (\ud835\udfd9 X)",["tauto"]],["Analysis/Normed/Lp/ProdLp.lean",410,"p : \u211d\u22650\u221e\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : WithLp p (\u03b1 \u00d7 \u03b2)\nh : 1 \u2264 p.toReal\npos : 0 < p.toReal\n\u22a2 0 \u2264 1 / p.toReal",["positivity","aesop","norm_num","simp"]],["Order/RelSeries.lean",390,"case h.e'_1.h.e'_4.h\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\n\u03b2 : Type u_2\ns : Rel \u03b2 \u03b2\np : RelSeries r\ni : Fin p.length\nhi : \u2191i + 1 \u2264 p.length\n\u22a2 \u2191i.succ.rev = \u2191\u27e8p.length - (\u2191i + 1), \u22ef\u27e9.castSucc",["simp","aesop"]],["Order/RelSeries.lean",578,"\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np q : RelSeries r\nh : p.last = q.head\ni : Fin q.length\nH : \u2191(Fin.natAdd p.length i).succ < p.length\n\u22a2 p.length < p.length + (\u2191i + 1)",["omega","aesop","simp"]],["GroupTheory/FreeGroup/Basic.lean",315,"case not\n\u03b1 : Type u\nL\u2081\u271d L\u2082\u271d : List (\u03b1 \u00d7 Bool)\nx\u271d : \u03b1\nb\u271d : Bool\n\u22a2 L\u2081\u271d ++ L\u2082\u271d <+ L\u2081\u271d ++ (x\u271d, b\u271d) :: (x\u271d, !b\u271d) :: L\u2082\u271d",["simp","aesop"]],["GroupTheory/FreeGroup/Basic.lean",689,"\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nx\u271d : FreeGroup \u03b1\nx : \u03b1\n\u22a2 (lift (of \u2218 f)) (of x) = of (f x)",["simp","aesop","congr","tauto"]],["GroupTheory/FreeGroup/Basic.lean",142,"case mp.not.cons.intro\n\u03b1 : Type u\na : \u03b1\nb : Bool\ne : List (\u03b1 \u00d7 Bool)\na' : \u03b1\nb' : Bool\ns' : List (\u03b1 \u00d7 Bool)\n\u22a2 (a, b) :: s' ++ e = (a, b) :: (s' ++ e)",["simp","aesop","congr","tauto"]],["MeasureTheory/Integral/CircleIntegral.lean",196,"c : \u2102\nR \u03b8 : \u211d\n\u22a2 \u2191\u2016deriv (circleMap c R) \u03b8\u2016\u208a \u2264 \u2191(Real.nnabs R)",["simp","aesop","norm_num"]],["MeasureTheory/Integral/CircleIntegral.lean",342,"c w : \u2102\nR : \u211d\n\u22a2 R = 0 \u2228 0 \u2264 -1 \u2228 w \u2209 sphere c |R| \u2194 R = 0 \u2228 w \u2209 sphere c |R|",["norm_num","aesop","tauto","simp"]],["Analysis/SpecialFunctions/Pow/Deriv.lean",366,"case h.e'_9\nx : \u211d\nhx\u271d : x \u2260 0\np : \u211d\nhx : x < 0\nthis :\n  HasStrictDerivAt ((fun x \u21a6 x.1 ^ x.2) \u2218 fun x \u21a6 (id x, p))\n    ((((x, p).2 * (x, p).1 ^ ((x, p).2 - 1)) \u2022 ContinuousLinearMap.fst \u211d \u211d \u211d +\n        ((x, p).1 ^ (x, p).2 * log (x, p).1 - rexp (log (x, p).1 * (x, p).2) * sin ((x, p).2 * \u03c0) * \u03c0) \u2022\n          ContinuousLinearMap.snd \u211d \u211d \u211d)\n      (1, 0))\n    x\n\u22a2 p * x ^ (p - 1) =\n    (((x, p).2 * (x, p).1 ^ ((x, p).2 - 1)) \u2022 ContinuousLinearMap.fst \u211d \u211d \u211d +\n        ((x, p).1 ^ (x, p).2 * log (x, p).1 - rexp (log (x, p).1 * (x, p).2) * sin ((x, p).2 * \u03c0) * \u03c0) \u2022\n          ContinuousLinearMap.snd \u211d \u211d \u211d)\n      (1, 0)",["simp","aesop","norm_num"]],["Analysis/SpecialFunctions/Pow/Deriv.lean",666,"t : \u211d\n\u22a2 \u2200 (x : \u2115), ((fun x \u21a6 (1 + t / x) ^ x) \u2218 Nat.cast) x = (1 + t / \u2191x) ^ x",["simp","aesop","norm_num"]],["Data/List/Cycle.lean",313,"case cons.succ.succ.hy.a\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\ny : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (i : \u2115) (x : \u03b1),\n    (x :: l).Nodup \u2192\n      \u2200 (hi : i < (x :: l).length), (x :: l).prev (x :: l)[i] \u22ef = (x :: l)[(i + ((x :: l).length - 1)) % (x :: l).length]\nx : \u03b1\nh : Function.Injective (x :: y :: l).get\ni : \u2115\nhi : i + 1 + 1 < (x :: y :: l).length\nH : (x :: y :: l)[i + 1 + 1] = x\n\u22a2 ((x :: y :: l)[i + 1 + 1] :: y :: l).get \u27e8i + 1 + 1, hi\u27e9 = ((x :: y :: l)[i + 1 + 1] :: y :: l).get \u27e80, \u22ef\u27e9",["simp","aesop","tauto"]],["Data/List/Cycle.lean",635,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Cycle \u03b1\n\u22a2 \u2200 (a : List \u03b1), b \u2208 map f (Quotient.mk'' a) \u2194 \u2203 a_1 \u2208 Quotient.mk'' a, f a_1 = b",["simp","aesop"]],["Data/List/Cycle.lean",854,"\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Cycle \u03b1\na : \u03b1\nl : List \u03b1\na\u271d : (\u2200 a \u2208 \u2191l, \u2200 b \u2208 \u2191l, r a b) \u2192 Chain r \u2191l\nhs : \u2200 a_1 \u2208 \u2191(a :: l), \u2200 b \u2208 \u2191(a :: l), r a_1 b\n\u22a2 a \u2208 \u2191(a :: l)",["simp","aesop","tauto"]],["Data/List/Cycle.lean",299,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\ny : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (i : \u2115) (x : \u03b1),\n    (x :: l).Nodup \u2192\n      \u2200 (hi : i < (x :: l).length), (x :: l).prev (x :: l)[i] \u22ef = (x :: l)[(i + ((x :: l).length - 1)) % (x :: l).length]\nx : \u03b1\nh : (x :: y :: l).Nodup\ni : \u2115\nhi : i + 1 + 1 < (x :: y :: l).length\n\u22a2 \u2200 (k : \u2115) (hk : k < (y :: l).length), (y :: l)[k] = (x :: y :: l)[k + 1]",["simp","aesop","tauto"]],["Data/List/Cycle.lean",494,"\u03b1 : Type u_1\ns : Cycle \u03b1\nx\u271d : List \u03b1\n\u22a2 (reverse (Quot.mk (\u21d1(IsRotated.setoid \u03b1)) x\u271d)).reverse = Quot.mk (\u21d1(IsRotated.setoid \u03b1)) x\u271d",["simp","aesop"]],["Data/List/Cycle.lean",151,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nh\u271d : x \u2208 l\ny : \u03b1\nh : x \u2208 y :: l\nhy : x \u2260 y\nhx : x \u2260 (y :: l).getLast \u22ef\n\u22a2 ?m.9479 \u2208 l",["assumption","aesop","congr","gcongr","tauto"]],["Data/List/Cycle.lean",172,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\ny : \u03b1\nhl : l.Nodup\nh\u271d : (y :: l).getLast \u22ef \u2208 l\nh : (y :: l).getLast \u22ef \u2208 y :: l\nhy : (y :: l).getLast \u22ef \u2260 y\nH : (y :: l).getLast \u22ef \u2208 (y :: l).dropLast\nhk : 0 < (y :: l).dropLast.length\nhk' : (take ((y :: l).length - 1) (y :: l))[0]? = some ((y :: l).getLast \u22ef)\n\u22a2 ?m.11082 \u2208 l",["assumption","congr","gcongr","tauto"]],["Data/List/Cycle.lean",754,"case h.h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\na\u271d : List \u03b1\nhs : Nodup (Quot.mk (\u21d1(IsRotated.setoid \u03b1)) a\u271d)\nhx : x \u2208 Quot.mk (\u21d1(IsRotated.setoid \u03b1)) a\u271d\n\u22a2 x \u2208 a\u271d",["assumption","aesop","congr","tauto"]],["Data/List/Cycle.lean",61,"case cons.nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d d' y : \u03b1\nIH : \u2200 (x_mem : x \u2208 []), x \u2260 [].getLast \u22ef \u2192 [].nextOr x d = [].nextOr x d'\nx_ne : \u00acx = y\nx_mem : x = y\n\u22a2 [y].nextOr x d = [y].nextOr x d'",["contradiction","aesop","tauto"]],["Data/List/Cycle.lean",794,"case nil.cons\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Cycle \u03b1\nb : \u03b1\nm : List \u03b1\nhab : (IsRotated.setoid \u03b1) [] (b :: m)\nthis : [] = b :: m\n\u22a2 (fun l \u21a6\n        match l with\n        | [] => True\n        | a :: m => List.Chain r a (m ++ [a]))\n      [] \u2194\n    (fun l \u21a6\n        match l with\n        | [] => True\n        | a :: m => List.Chain r a (m ++ [a]))\n      (b :: m)",["contradiction","aesop","tauto"]],["Data/List/Cycle.lean",796,"case cons.nil\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Cycle \u03b1\na : \u03b1\nl : List \u03b1\nhab : (IsRotated.setoid \u03b1) (a :: l) []\nthis : a :: l = []\n\u22a2 (fun l \u21a6\n        match l with\n        | [] => True\n        | a :: m => List.Chain r a (m ++ [a]))\n      (a :: l) \u2194\n    (fun l \u21a6\n        match l with\n        | [] => True\n        | a :: m => List.Chain r a (m ++ [a]))\n      []",["contradiction"]],["ModelTheory/Syntax.lean",411,"case rel\nL : Language\n\u03b1 : Type u'\nk n\u271d\u00b9 l\u271d : \u2115\nR\u271d : L.Relations l\u271d\nts\u271d : Fin l\u271d \u2192 L.Term (\u03b1 \u2295 Fin n\u271d\u00b9)\nm\u271d n\u271d : \u2115\nkm\u271d : n\u271d\u00b9 \u2264 m\u271d\nmn\u271d : m\u271d \u2264 n\u271d\n\u22a2 rel R\u271d (Term.relabel (Sum.map id (Fin.castLE mn\u271d) \u2218 Sum.map id (Fin.castLE km\u271d)) \u2218 ts\u271d) =\n    rel R\u271d (Term.relabel (Sum.map id (Fin.castLE \u22ef)) \u2218 ts\u271d)",["simp","aesop"]],["ModelTheory/Syntax.lean",554,"L : Language\n\u03b1 : Type u'\n\u03b2 : Type v'\nn : \u2115\ng : \u03b1 \u2192 \u03b2 \u2295 Fin n\nk : \u2115\n\u03c6 : L.BoundedFormula \u03b1 (k + 1)\n\u22a2 (castLE \u22ef (mapTermRel (fun x t \u21a6 Term.relabel (relabelAux g x) t) (fun x \u21a6 id) (fun x \u21a6 castLE \u22ef) \u03c6)).all =\n    (mapTermRel (fun x t \u21a6 Term.relabel (relabelAux g x) t) (fun x \u21a6 id) (fun x \u21a6 castLE \u22ef) \u03c6).all",["simp","aesop"]],["FieldTheory/Finite/Basic.lean",476,"case h\nhp : Fact (Nat.Prime 2)\n\u22a2 0 ^ 2 + 1 ^ 2 = (fun i \u21a6 i) \u27e81, \u22ef\u27e9",["simp","aesop","congr","tauto","abel","norm_num"]],["FieldTheory/Finite/Basic.lean",385,"K : Type u_1\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Fintype K\nL : Type u_3\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : Finite L\ne : Fin (Module.finrank K L) \u2243 \u21a5(Submonoid.powers (frobeniusAlgHom K L)) := (finCongr \u22ef).symm.trans (finEquivPowers \u22ef)\n\u22a2 Module.finrank K L = Nat.card (Fin (Module.finrank K L))",["simp","aesop","norm_num"]],["FieldTheory/Finite/Basic.lean",108,"K : Type u_1\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : IsDomain K\ninst\u271d : Fintype K\u02e3\n\u22a2 \u2200 (a : K\u02e3) (ha : a \u2208 univ.erase (-1)), a * (fun x x_1 \u21a6 x\u207b\u00b9) a ha = 1",["simp","aesop","norm_num"]],["FieldTheory/Finite/Basic.lean",762,"F : Type u_3\ninst\u271d\u00b9 : Field F\ninst\u271d : Fintype F\nhF : ringChar F \u2260 2\ng : F\u02e3\nhg : \u2200 (x : F\u02e3), x \u2208 Subgroup.zpowers g\nn : \u2115\nhodd : 2 * (Nat.card F / 2) = Nat.card F - 1\nh : (fun x \u21a6 g ^ x) n ^ (Nat.card F / 2) = 1\nkey : 2 * (Nat.card F / 2) \u2223 n * (Nat.card F / 2)\n\u22a2 0 < 2",["norm_num","omega","decide","aesop","linarith","positivity","tauto","simp"]],["Probability/Kernel/Disintegration/CDFToKernel.lean",322,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u211d)\n\u03bd : Kernel \u03b1 \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 \u211a \u2192 \u211d\nhf : IsRatCondKernelCDFAux f \u03ba \u03bd\ninst\u271d : IsFiniteKernel \u03bd\na : \u03b1\nq : \u211a\n\u22a2 (\u03bd a) univ ^ (ENNReal.toReal 1)\u207b\u00b9 * ENNReal.ofReal 1 \u2264 (\u03bd a) univ",["simp","aesop","norm_num"]],["Data/Finset/Card.lean",605,"case inr.intro.refine_1.intro\n\u03b1 : Type u_1\nx y : \u03b1\nhx : x \u2208 {y}\n\u22a2 \u2200 a \u2208 {y}, \u2200 b \u2208 {y}, a = b",["simp","aesop"]],["Data/Finset/Card.lean",134,"\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 a = b \u2228 \u00aca = b",["tauto"]],["Data/Finset/Card.lean",610,"\u03b1 : Type u_1\ns : Finset \u03b1\n\u22a2 (\u2200 a \u2208 s, \u2200 b \u2208 s, a = b) \u2194 \u2200 {a b : \u03b1}, a \u2208 s \u2192 b \u2208 s \u2192 a = b",["tauto","aesop"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",531,"case pos.h\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\np\u271d q\u271d : \u2124\nhpq\u271d : p\u271d + 1 = q\u271d\n\u22a2 (\u03b4 0 1 (Cochain.ofHom \u03c6)).v p\u271d q\u271d hpq\u271d = Cochain.v 0 p\u271d q\u271d hpq\u271d",["simp","aesop","norm_num"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",296,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G K L : CochainComplex C \u2124\nn\u2081 n\u2082 n\u2081\u2082 : \u2124\nz\u2081 : Cochain F G n\u2081\nz\u2082 : Cochain G K (-n\u2082)\nz\u2083 : Cochain K L n\u2082\nh\u2081\u2082 : n\u2081 + -n\u2082 = n\u2081\u2082\n\u22a2 n\u2081 + -n\u2082 + n\u2082 = n\u2081",["omega","aesop","linarith","abel","norm_num","simp"]],["NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean",574,"case neg\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nw\u2080 : InfinitePlace K\nhw\u2080 : w\u2080.IsComplex\nB : \u211d\u22650\nhB : minkowskiBound K 1 < \u2191(convexBodyLT'Factor K) * \u2191B\nthis : minkowskiBound K 1 < volume (convexBodyLT' K (fun w \u21a6 if w = w\u2080 then NNReal.sqrt B else 1) \u27e8w\u2080, hw\u2080\u27e9)\na : \ud835\udcde K\nh_nz : a \u2260 0\nh_le : \u2200 (w : InfinitePlace K), w \u2260 \u2191\u27e8w\u2080, hw\u2080\u27e9 \u2192 w \u2191a < \u2191(if w = w\u2080 then NNReal.sqrt B else 1)\nh_le\u2080 :\n  |((\u2191\u27e8w\u2080, hw\u2080\u27e9).embedding \u2191a).re| < 1 \u2227\n    |((\u2191\u27e8w\u2080, hw\u2080\u27e9).embedding \u2191a).im| < \u2191(if \u2191\u27e8w\u2080, hw\u2080\u27e9 = w\u2080 then NNReal.sqrt B else 1) ^ 2\nw : InfinitePlace K\nh_eq : \u00acw = w\u2080\n\u22a2 1 \u2264 1 + \u2191B ^ 2",["norm_num","aesop","simp"]],["LinearAlgebra/LinearIndependent/Lemmas.lean",249,"R : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nthis : \u2200 (x y : M), LinearIndependent R ![x, y] \u2192 LinearIndependent R ![y, x]\n\u22a2 LinearIndependent R ![x, y] \u2194 LinearIndependent R ![y, x]",["tauto","aesop"]],["Analysis/Calculus/FDeriv/Symmetric.lean",451,"\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : IsRCLikeNormedField \ud835\udd5c\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nx\u271d\u2075 : E\nf'' : E \u2192L[\ud835\udd5c] E \u2192L[\ud835\udd5c] F\nhf : \u2200\u1da0 (y : E) in \ud835\udcdd x\u271d\u2075, HasFDerivAt f (f' y) y\nhx : HasFDerivAt f' f'' x\u271d\u2075\nv w : E\nx\u271d\u2074 : RCLike \ud835\udd5c := IsRCLikeNormedField.rclike \ud835\udd5c\nx\u271d\u00b3 : NormedSpace \u211d E := NormedSpace.restrictScalars \u211d \ud835\udd5c E\nx\u271d\u00b2 : NormedSpace \u211d F := NormedSpace.restrictScalars \u211d \ud835\udd5c F\nx\u271d\u00b9 : LinearMap.CompatibleSMul E F \u211d \ud835\udd5c := LinearMap.IsScalarTower.compatibleSMul\nx\u271d : LinearMap.CompatibleSMul E (E \u2192L[\ud835\udd5c] F) \u211d \ud835\udd5c := LinearMap.IsScalarTower.compatibleSMul\nf'R : E \u2192 E \u2192L[\u211d] F := fun x \u21a6 ContinuousLinearMap.restrictScalars \u211d (f' x)\nhfR : \u2200\u1da0 (y : E) in \ud835\udcdd x\u271d\u2075, HasFDerivAt f (f'R y) y\nx : E\n\u22a2 \u2200 (m : \u211d) (x_1 : E),\n    { toFun := fun y \u21a6 (f'' x) y, map_add' := \u22ef }.toFun (m \u2022 x_1) =\n      (RingHom.id \u211d) m \u2022 { toFun := fun y \u21a6 (f'' x) y, map_add' := \u22ef }.toFun x_1",["simp","aesop","norm_num"]],["MeasureTheory/PiSystem.lean",373,"case h.intro.intro.intro.intro.h.e'_3.h.f.a\n\u03b1 : Type u_3\n\u03b9 : Type u_4\ns : \u03b9 \u2192 Set \u03b1\nS : Set \u03b9\nt : Finset \u03b9\nhtS : \u2191t \u2286 S\nf : \u03b9 \u2192 Set \u03b1\nhft_eq : \u2200 x \u2208 t, f x = s x\nx\u271d\u00b9 : \u03b9\nx\u271d : x\u271d\u00b9 \u2208 t\n\u22a2 x\u271d\u00b9 \u2208 t",["assumption","aesop","congr","gcongr","tauto"]],["Computability/AkraBazzi/GrowsPolynomially.lean",189,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nheq : c\u2081 = c\u2082\nn\u2080 : \u211d\nhn\u2080 : \u2200 b \u2265 n\u2080, \u2200 u \u2208 Set.Icc (1 / 2 * b) b, f u = c\u2082 * f b\nx : \u211d\nhxlb : n\u2080 \u2294 2 \u2264 x\nhxub : x < 2 * (n\u2080 \u2294 2)\n\u22a2 n\u2080 \u2264 1 * (n\u2080 \u2294 2)",["simp","aesop","norm_num"]],["Computability/AkraBazzi/GrowsPolynomially.lean",214,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nheq : c\u2081 = c\u2082\nn\u2080 : \u211d\nhn\u2080 : \u2200 b \u2265 n\u2080, \u2200 u \u2208 Set.Icc (1 / 2 * b) b, f u = c\u2082 * f b\nn : \u2115\nhn : n \u2265 1\nhyp_ind : \u2200 z \u2208 Set.Ico (n\u2080 \u2294 2) (2 ^ n * (n\u2080 \u2294 2)), f z = f (n\u2080 \u2294 2)\nz : \u211d\nhz : z \u2208 Set.Ico (2 ^ n * (n\u2080 \u2294 2)) (2 ^ (n + 1) * (n\u2080 \u2294 2))\nz_nonneg : 0 \u2264 z\nle_2n : n\u2080 \u2294 2 \u2264 2 ^ n * (n\u2080 \u2294 2)\nn\u2080_le_z : n\u2080 \u2264 z\nfz_eq_c\u2082fz : f z = c\u2082 * f z\nz_to_half_z' : f (1 / 2 * z) = c\u2082 * f z\nz_to_half_z : f (1 / 2 * z) = f z\n\u22a2 n\u2080 \u2294 2 \u2264 1 / 2 * 2 ^ 1 * (n\u2080 \u2294 2)",["simp","linarith","norm_num"]],["Computability/AkraBazzi/GrowsPolynomially.lean",292,"case h\nc x\u271d\u00b9 : \u211d\nx\u271d : x\u271d\u00b9 \u2208 Set.Ioo 0 1\nx : \u211d\n\u22a2 \u2200 u \u2208 Set.Icc (x\u271d\u00b9 * x) x, c \u2208 Set.Icc (1 * c) (1 * c)",["simp","aesop","norm_num"]],["Computability/AkraBazzi/GrowsPolynomially.lean",91,"f : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nhf' : \u2200 (a : \u211d), \u2203 b \u2265 a, f b = 0\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 > 0\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nx : \u211d\nhx : \u2200 (y : \u211d), x \u2264 y \u2192 \u2200 u \u2208 Set.Icc (1 / 2 * y) y, f u \u2208 Set.Icc (c\u2081 * f y) (c\u2082 * f y)\nhx_pos : 0 < x\nx\u2080 : \u211d\nhx\u2080_ge : x\u2080 \u2265 x \u2294 1\nhx\u2080 : f x\u2080 = 0\n\u22a2 0 < 1",["norm_num","aesop","linarith","positivity","simp"]],["Computability/AkraBazzi/GrowsPolynomially.lean",190,"case h\nf : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nheq : c\u2081 = c\u2082\nn\u2080 : \u211d\nhn\u2080 : \u2200 b \u2265 n\u2080, \u2200 u \u2208 Set.Icc (1 / 2 * b) b, f u = c\u2082 * f b\nx : \u211d\nhxlb : n\u2080 \u2294 2 \u2264 x\nhxub : x < 2 * (n\u2080 \u2294 2)\n\u22a2 1 \u2264 2",["norm_num","aesop","linarith","simp"]],["Computability/AkraBazzi/GrowsPolynomially.lean",198,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nheq : c\u2081 = c\u2082\nn\u2080 : \u211d\nhn\u2080 : \u2200 b \u2265 n\u2080, \u2200 u \u2208 Set.Icc (1 / 2 * b) b, f u = c\u2082 * f b\nn : \u2115\nhn : n \u2265 1\nhyp_ind : \u2200 z \u2208 Set.Ico (n\u2080 \u2294 2) (2 ^ n * (n\u2080 \u2294 2)), f z = f (n\u2080 \u2294 2)\nz : \u211d\nhz : z \u2208 Set.Ico (2 ^ n * (n\u2080 \u2294 2)) (2 ^ (n + 1) * (n\u2080 \u2294 2))\n\u22a2 0 \u2264 n\u2080 \u2294 2",["norm_num","aesop","positivity","simp"]],["Computability/AkraBazzi/GrowsPolynomially.lean",215,"case h.h.ha\nf : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nheq : c\u2081 = c\u2082\nn\u2080 : \u211d\nhn\u2080 : \u2200 b \u2265 n\u2080, \u2200 u \u2208 Set.Icc (1 / 2 * b) b, f u = c\u2082 * f b\nn : \u2115\nhn : n \u2265 1\nhyp_ind : \u2200 z \u2208 Set.Ico (n\u2080 \u2294 2) (2 ^ n * (n\u2080 \u2294 2)), f z = f (n\u2080 \u2294 2)\nz : \u211d\nhz : z \u2208 Set.Ico (2 ^ n * (n\u2080 \u2294 2)) (2 ^ (n + 1) * (n\u2080 \u2294 2))\nz_nonneg : 0 \u2264 z\nle_2n : n\u2080 \u2294 2 \u2264 2 ^ n * (n\u2080 \u2294 2)\nn\u2080_le_z : n\u2080 \u2264 z\nfz_eq_c\u2082fz : f z = c\u2082 * f z\nz_to_half_z' : f (1 / 2 * z) = c\u2082 * f z\nz_to_half_z : f (1 / 2 * z) = f z\n\u22a2 1 \u2264 2",["norm_num","linarith","simp"]],["Computability/AkraBazzi/GrowsPolynomially.lean",409,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nhfg : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 c * \u2016f x\u2016\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\n\u22a2 0 < 1 / 2",["norm_num","aesop","linarith","positivity","simp"]],["Computability/AkraBazzi/GrowsPolynomially.lean",452,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nhfg : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 c * \u2016f x\u2016\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\n\u22a2 0 < 1 / 2",["norm_num","aesop","linarith","positivity","simp"]],["Computability/AkraBazzi/GrowsPolynomially.lean",377,"f g : \u211d \u2192 \u211d\nhf\u271d\u00b9 : GrowsPolynomially f\nhg\u271d\u00b9 : GrowsPolynomially g\nhf'\u271d : 0 \u2264\u1da0[atTop] f\nhg'\u271d : 0 \u2264\u1da0[atTop] g\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 > 0\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhf\u271d : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 > 0\nc\u2084 : \u211d\nleft\u271d : c\u2084 > 0\nhg\u271d : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, g u \u2208 Set.Icc (c\u2083 * g x) (c\u2084 * g x)\nx : \u211d\nhf : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhg : \u2200 u \u2208 Set.Icc (b * x) x, g u \u2208 Set.Icc (c\u2083 * g x) (c\u2084 * g x)\nhf' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 y \u2264 f y\nhg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 y \u2264 g y\nhx_pos : 0 \u2264 x\nu : \u211d\nhu : u \u2208 Set.Icc (b * x) x\n\u22a2 1 * x = x",["ring","aesop","linarith","norm_num","simp"]],["Analysis/Normed/Group/Hom.lean",718,"V\u2081 : Type u_3\nV\u2082 : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2081\ninst\u271d : SeminormedAddCommGroup V\u2082\nv : V\u2081\n\u22a2 \u20160 v\u2016 \u2264 \u2016v\u2016",["simp","aesop","norm_num"]],["Analysis/Normed/Group/Hom.lean",85,"case mk.mk\nV : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf g : NormedAddGroupHom V\u2081 V\u2082\ntoFun\u271d\u00b9 : V\u2081 \u2192 V\u2082\nmap_add'\u271d\u00b9 : \u2200 (v\u2081 v\u2082 : V\u2081), toFun\u271d\u00b9 (v\u2081 + v\u2082) = toFun\u271d\u00b9 v\u2081 + toFun\u271d\u00b9 v\u2082\nbound'\u271d\u00b9 : \u2203 C, \u2200 (v : V\u2081), \u2016toFun\u271d\u00b9 v\u2016 \u2264 C * \u2016v\u2016\ntoFun\u271d : V\u2081 \u2192 V\u2082\nmap_add'\u271d : \u2200 (v\u2081 v\u2082 : V\u2081), toFun\u271d (v\u2081 + v\u2082) = toFun\u271d v\u2081 + toFun\u271d v\u2082\nbound'\u271d : \u2203 C, \u2200 (v : V\u2081), \u2016toFun\u271d v\u2016 \u2264 C * \u2016v\u2016\nh :\n  { toFun := toFun\u271d\u00b9, map_add' := map_add'\u271d\u00b9, bound' := bound'\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, map_add' := map_add'\u271d, bound' := bound'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_add' := map_add'\u271d\u00b9, bound' := bound'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_add' := map_add'\u271d, bound' := bound'\u271d }",["congr","aesop"]],["Analysis/Normed/Group/Hom.lean",94,"case mk.mk\nV\u2081 : Type u_2\nV\u2082 : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2081\ninst\u271d : SeminormedAddCommGroup V\u2082\ntoFun\u271d\u00b9 : V\u2081 \u2192 V\u2082\nmap_add'\u271d\u00b9 : \u2200 (v\u2081 v\u2082 : V\u2081), toFun\u271d\u00b9 (v\u2081 + v\u2082) = toFun\u271d\u00b9 v\u2081 + toFun\u271d\u00b9 v\u2082\nbound'\u271d\u00b9 : \u2203 C, \u2200 (v : V\u2081), \u2016toFun\u271d\u00b9 v\u2016 \u2264 C * \u2016v\u2016\ntoFun\u271d : V\u2081 \u2192 V\u2082\nmap_add'\u271d : \u2200 (v\u2081 v\u2082 : V\u2081), toFun\u271d (v\u2081 + v\u2082) = toFun\u271d v\u2081 + toFun\u271d v\u2082\nbound'\u271d : \u2203 C, \u2200 (v : V\u2081), \u2016toFun\u271d v\u2016 \u2264 C * \u2016v\u2016\nH :\n  \u21d1{ toFun := toFun\u271d\u00b9, map_add' := map_add'\u271d\u00b9, bound' := bound'\u271d\u00b9 } =\n    \u21d1{ toFun := toFun\u271d, map_add' := map_add'\u271d, bound' := bound'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_add' := map_add'\u271d\u00b9, bound' := bound'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_add' := map_add'\u271d, bound' := bound'\u271d }",["congr","aesop"]],["GroupTheory/Perm/Centralizer.lean",213,"case mk.mk\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng\u271d g : Perm \u03b1\ntoFun\u271d\u00b9 : { x // x \u2208 g.cycleFactorsFinset } \u2192 \u03b1\nmem_support_self'\u271d\u00b9 : \u2200 (c : { x // x \u2208 g.cycleFactorsFinset }), toFun\u271d\u00b9 c \u2208 (\u2191c).support\ntoFun\u271d : { x // x \u2208 g.cycleFactorsFinset } \u2192 \u03b1\nmem_support_self'\u271d : \u2200 (c : { x // x \u2208 g.cycleFactorsFinset }), toFun\u271d c \u2208 (\u2191c).support\nx\u271d :\n  (fun a \u21a6 a.toFun) { toFun := toFun\u271d\u00b9, mem_support_self' := mem_support_self'\u271d\u00b9 } =\n    (fun a \u21a6 a.toFun) { toFun := toFun\u271d, mem_support_self' := mem_support_self'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, mem_support_self' := mem_support_self'\u271d\u00b9 } =\n    { toFun := toFun\u271d, mem_support_self' := mem_support_self'\u271d }",["congr","aesop"]],["GroupTheory/Perm/Centralizer.lean",674,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nm : Multiset \u2115\n\u22a2 (\u2200 \u2983x : Perm \u03b1\u2984, x \u2208 Finset.univ \u2192 \u00acx.cycleType = m) \u2194 \u2200 (x : Perm \u03b1), \u00acx.cycleType = m",["aesop","norm_num","simp"]],["Algebra/Homology/Homotopy.lean",446,"case a\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : ChainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\n\u22a2 \u00ac1 = 0",["decide","omega","aesop","linarith","positivity","tauto","norm_num","simp"]],["Algebra/Homology/Homotopy.lean",576,"case a\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nP Q : CochainComplex V \u2115\nf : (i j : \u2115) \u2192 P.X i \u27f6 Q.X j\n\u22a2 \u00ac1 = 0",["decide","omega","aesop","linarith","positivity","tauto","norm_num","simp"]],["CategoryTheory/Triangulated/Pretriangulated.lean",593,"case h\nC : Type u\ninst\u271d\u2078 : Category.{v, u} C\ninst\u271d\u2077 : HasZeroObject C\ninst\u271d\u2076 : HasShift C \u2124\ninst\u271d\u2075 : Preadditive C\ninst\u271d\u2074 : \u2200 (n : \u2124), (shiftFunctor C n).Additive\nhC : Pretriangulated C\nJ : Type u_1\nT : J \u2192 Triangle C\nhT : \u2200 (j : J), T j \u2208 distinguishedTriangles\ninst\u271d\u00b3 : HasProduct fun j \u21a6 (T j).obj\u2081\ninst\u271d\u00b2 : HasProduct fun j \u21a6 (T j).obj\u2082\ninst\u271d\u00b9 : HasProduct fun j \u21a6 (T j).obj\u2083\ninst\u271d : HasProduct fun j \u21a6 (shiftFunctor C 1).obj (T j).obj\u2081\nf\u2081 : (\u220f\u1d9c fun j \u21a6 (T j).obj\u2081) \u27f6 \u220f\u1d9c fun j \u21a6 (T j).obj\u2082 := Limits.Pi.map fun j \u21a6 (T j).mor\u2081\nZ : C\nf\u2082 : (\u220f\u1d9c fun j \u21a6 (T j).obj\u2082) \u27f6 Z\nf\u2083 : Z \u27f6 (shiftFunctor C 1).obj (\u220f\u1d9c fun j \u21a6 (T j).obj\u2081)\nT' : Triangle C := Triangle.mk f\u2081 f\u2082 f\u2083\nhT' : T' \u2208 distinguishedTriangles\n\u03c6 : (j : J) \u2192 T' \u27f6 T j :=\n  fun j \u21a6\n    completeDistinguishedTriangleMorphism T' (T j) hT' \u22ef (Pi.\u03c0 (fun j \u21a6 (T j).obj\u2081) j) (Pi.\u03c0 (fun j \u21a6 (T j).obj\u2082) j) \u22ef\n\u03c6' : T' \u27f6 productTriangle T := productTriangle.lift T \u03c6\nh\u2081 : \u03c6'.hom\u2081 = \ud835\udfd9 T'.obj\u2081\nh\u2082 : \u03c6'.hom\u2082 = \ud835\udfd9 T'.obj\u2082\nthis\u271d : IsIso \u03c6'.hom\u2081\nthis : IsIso \u03c6'.hom\u2082\nA\u271d A : C\nf : A \u27f6 T'.obj\u2083\nhf : f \u226b \u03c6'.hom\u2083 = 0\nhf' : f \u226b T'.mor\u2083 = 0\ng : A \u27f6 T'.obj\u2082\nhg : f = g \u226b T'.mor\u2082\nhg' : \u2200 (j : J), (g \u226b Pi.\u03c0 (fun j \u21a6 (T j).obj\u2082) j) \u226b (T j).mor\u2082 = 0\nhg'' : \u2200 (j : J), \u2203 g_1, g \u226b Pi.\u03c0 (fun j \u21a6 (T j).obj\u2082) j = g_1 \u226b (T j).mor\u2081\n\u03b1 : (j : J) \u2192 A \u27f6 (T j).obj\u2081 := fun j \u21a6 \u22ef.choose\nh\u03b1 : \u2200 (j : J), g \u226b Pi.\u03c0 (fun j \u21a6 (T j).obj\u2082) j = \u03b1 j \u226b (T j).mor\u2081\nj : J\n\u22a2 \u03b1 j \u226b (T j).mor\u2081 = (Pi.lift \u03b1 \u226b Limits.Pi.map fun j \u21a6 (T j).mor\u2081) \u226b Pi.\u03c0 (fun j \u21a6 (T j).obj\u2082) j",["simp","norm_num"]],["CategoryTheory/Triangulated/Pretriangulated.lean",459,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : \u2200 (n : \u2124), (shiftFunctor C n).Additive\nhC : Pretriangulated C\nT T' : Triangle C\n\u03c6 : T \u27f6 T'\nhT : T \u2208 distinguishedTriangles\nhT' : T' \u2208 distinguishedTriangles\nh\u2082 : IsIso \u03c6.hom\u2082\nh\u2083 : IsIso \u03c6.hom\u2083\n\u22a2 IsIso \u03c6.hom\u2082",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["CategoryTheory/Triangulated/Pretriangulated.lean",331,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : \u2200 (n : \u2124), (CategoryTheory.shiftFunctor C n).Additive\nhC : Pretriangulated C\nT : Triangle C\nhT : T \u2208 distinguishedTriangles\n\u22a2 T.mor\u2083 = 0 \u2227 T.mor\u2081 = 0 \u2194 T.mor\u2081 = 0 \u2227 T.mor\u2083 = 0",["tauto","aesop"]],["CategoryTheory/Triangulated/Pretriangulated.lean",336,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : \u2200 (n : \u2124), (CategoryTheory.shiftFunctor C n).Additive\nhC : Pretriangulated C\nT : Triangle C\nhT : T \u2208 distinguishedTriangles\n\u22a2 T.mor\u2082 = 0 \u2227 T.mor\u2083 = 0 \u2194 T.mor\u2082 = 0 \u2227 T.mor\u2083 = 0",["tauto","aesop","abel","norm_num","simp"]],["Probability/Kernel/RadonNikodym.lean",537,"\u03b1 : Type u_1\n\u03b3 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b3 : MeasurableSpace \u03b3\n\u03ba \u03b7 : Kernel \u03b1 \u03b3\nh\u03b1\u03b3 : MeasurableSpace.CountableOrCountablyGenerated \u03b1 \u03b3\nh\u03ba : IsFiniteKernel \u03ba\ninst\u271d : IsFiniteKernel \u03b7\na : \u03b1\n\u22a2 ((\u03b7.withDensity (\u03ba.rnDeriv \u03b7)) a) univ + ((\u03ba.singularPart \u03b7) a) univ =\n    ((\u03b7.withDensity (\u03ba.rnDeriv \u03b7) + \u03ba.singularPart \u03b7) a) univ",["simp","aesop","congr","tauto","norm_num"]],["Geometry/Euclidean/Basic.lean",120,"case hc\nV : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nv : V\np\u2081 p\u2082 : P\nhv : v \u2260 0\nr : \u211d\nhvi : inner v v \u2260 0\nhd : discrim (inner v v) (2 * inner v (p\u2081 -\u1d65 p\u2082)) 0 = 2 * inner v (p\u2081 -\u1d65 p\u2082) * (2 * inner v (p\u2081 -\u1d65 p\u2082))\n\u22a2 2 \u2260 0",["norm_num","aesop","linarith","positivity","simp"]],["Geometry/Euclidean/Basic.lean",158,"V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\ns : AffineSubspace \u211d P\ninst\u271d : FiniteDimensional \u211d \u21a5s.direction\nhd : finrank \u211d \u21a5s.direction = 2\nc\u2081 c\u2082 p\u2081 p\u2082 p : P\nhc\u2081s : c\u2081 \u2208 s\nhc\u2082s : c\u2082 \u2208 s\nhp\u2081s : p\u2081 \u2208 s\nhp\u2082s : p\u2082 \u2208 s\nhps : p \u2208 s\nr\u2081 r\u2082 : \u211d\nhc : c\u2081 \u2260 c\u2082\nhp : p\u2081 \u2260 p\u2082\nhp\u2081c\u2081 : dist p\u2081 c\u2081 = r\u2081\nhp\u2082c\u2081 : dist p\u2082 c\u2081 = r\u2081\nhpc\u2081 : dist p c\u2081 = r\u2081\nhp\u2081c\u2082 : dist p\u2081 c\u2082 = r\u2082\nhp\u2082c\u2082 : dist p\u2082 c\u2082 = r\u2082\nhpc\u2082 : dist p c\u2082 = r\u2082\nho : inner (c\u2082 -\u1d65 c\u2081) (p\u2082 -\u1d65 p\u2081) = 0\nhop : inner (c\u2082 -\u1d65 c\u2081) (p -\u1d65 p\u2081) = 0\nb : Fin 2 \u2192 V := ![c\u2082 -\u1d65 c\u2081, p\u2082 -\u1d65 p\u2081]\nhb : LinearIndependent \u211d b\nhbs : Submodule.span \u211d (Set.range b) = s.direction\nv : V\nhv : v \u2208 s.direction\n\u22a2 Finset.univ = {0, 1}",["decide","aesop","congr","tauto"]],["AlgebraicGeometry/OpenImmersion.lean",594,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\ninst\u271d : IsOpenImmersion g\ne : Set.range \u21d1(ConcreteCategory.hom f.base) = Set.range \u21d1(ConcreteCategory.hom g.base)\n\u22a2 (lift f g \u22ef \u226b lift g f \u22ef) \u226b g = \ud835\udfd9 Y \u226b g",["simp","aesop","norm_num"]],["AlgebraicGeometry/OpenImmersion.lean",593,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\ninst\u271d : IsOpenImmersion g\ne : Set.range \u21d1(ConcreteCategory.hom f.base) = Set.range \u21d1(ConcreteCategory.hom g.base)\n\u22a2 (lift g f \u22ef \u226b lift f g \u22ef) \u226b f = \ud835\udfd9 X \u226b f",["simp","aesop","norm_num"]],["AlgebraicGeometry/OpenImmersion.lean",309,"case mk.mk\ntoLocallyRingedSpace\u271d\u00b9 : LocallyRingedSpace\nlocal_affine\u271d\u00b9 :\n  \u2200 (x : \u2191toLocallyRingedSpace\u271d\u00b9.toTopCat),\n    \u2203 U R, Nonempty (toLocallyRingedSpace\u271d\u00b9.restrict \u22ef \u2245 Spec.toLocallyRingedSpace.obj (op R))\ntoLocallyRingedSpace\u271d : LocallyRingedSpace\nlocal_affine\u271d :\n  \u2200 (x : \u2191toLocallyRingedSpace\u271d.toTopCat),\n    \u2203 U R, Nonempty (toLocallyRingedSpace\u271d.restrict \u22ef \u2245 Spec.toLocallyRingedSpace.obj (op R))\nH :\n  { toLocallyRingedSpace := toLocallyRingedSpace\u271d\u00b9, local_affine := local_affine\u271d\u00b9 }.toLocallyRingedSpace =\n    { toLocallyRingedSpace := toLocallyRingedSpace\u271d, local_affine := local_affine\u271d }.toLocallyRingedSpace\n\u22a2 { toLocallyRingedSpace := toLocallyRingedSpace\u271d\u00b9, local_affine := local_affine\u271d\u00b9 } =\n    { toLocallyRingedSpace := toLocallyRingedSpace\u271d, local_affine := local_affine\u271d }",["congr","aesop"]],["Order/OmegaCompletePartialOrder.lean",543,"case mk.mk.mk.mk\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b3 : OmegaCompletePartialOrder \u03b1\ninst\u271d\u00b2 : OmegaCompletePartialOrder \u03b2\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b3\ninst\u271d : OmegaCompletePartialOrder \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmonotone'\u271d\u00b9 : Monotone toFun\u271d\u00b9\nmap_\u03c9Sup'\u271d\u00b9 :\n  \u2200 (c : Chain \u03b1),\n    { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 }.toFun (\u03c9Sup c) =\n      \u03c9Sup (c.map { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 })\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmonotone'\u271d : Monotone toFun\u271d\nmap_\u03c9Sup'\u271d :\n  \u2200 (c : Chain \u03b1),\n    { toFun := toFun\u271d, monotone' := monotone'\u271d }.toFun (\u03c9Sup c) =\n      \u03c9Sup (c.map { toFun := toFun\u271d, monotone' := monotone'\u271d })\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, map_\u03c9Sup' := map_\u03c9Sup'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, monotone' := monotone'\u271d, map_\u03c9Sup' := map_\u03c9Sup'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, map_\u03c9Sup' := map_\u03c9Sup'\u271d\u00b9 } =\n    { toFun := toFun\u271d, monotone' := monotone'\u271d, map_\u03c9Sup' := map_\u03c9Sup'\u271d }",["congr","aesop"]],["Order/OmegaCompletePartialOrder.lean",190,"\u03b1 : Type u_2\ninst\u271d : OmegaCompletePartialOrder \u03b1\nc : Chain \u03b1\nx : \u03b1\nh : \u2200 (i : \u2115), c i \u2264 x \u2228 x \u2264 c i\nthis : \u2203 x_1, \u00acc x_1 \u2264 x\n\u22a2 \u2203 i, \u00acc i \u2264 x",["assumption","aesop","congr","gcongr","tauto"]],["Analysis/Complex/Hadamard.lean",112,"E : Type u_1\ninst\u271d : NormedAddCommGroup E\nf : \u2102 \u2192 E\nz : \u2102\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\n\u22a2 (\u03b5 + sSupNormIm f 0) ^ (z - 1).re * (\u03b5 + sSupNormIm f 1) ^ (-z).re =\n    (\u03b5 + sSupNormIm f 0) ^ (z.re - 1) * (\u03b5 + sSupNormIm f 1) ^ (-z.re)",["simp","aesop","congr","tauto","abel","norm_num"]],["Analysis/Normed/Module/Basic.lean",65,"\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nc : \ud835\udd5c\nx : E\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u22a2 \u2016c \u2022 (x - x)\u2016 = 0",["simp","aesop","norm_num"]],["Analysis/Normed/Module/Basic.lean",508,"\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c' : Type u_2\nE\u271d : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\n\ud835\udd5c : Type u_6\nE : Type u_7\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Norm E\ninst\u271d : Module \ud835\udd5c E\ncore : SeminormedAddCommGroup.Core \ud835\udd5c E\nx y : E\n\u22a2 y - x = -1 \u2022 (x - y)",["simp"]],["Analysis/Normed/Module/Basic.lean",513,"\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c' : Type u_2\nE\u271d : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\n\ud835\udd5c : Type u_6\nE : Type u_7\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Norm E\ninst\u271d : Module \ud835\udd5c E\ncore : SeminormedAddCommGroup.Core \ud835\udd5c E\nx y z : E\n\u22a2 x - z = x - y + (y - z)",["abel","aesop","norm_num","simp"]],["RingTheory/GradedAlgebra/HomogeneousLocalization.lean",110,"case mk.mk.mk.mk.mk.mk\n\u03b9 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\n\ud835\udc9c : \u03b9 \u2192 Submodule R A\nx : Submonoid A\ni1 : \u03b9\nn1 : A\nhn1 : n1 \u2208 \ud835\udc9c i1\nd1 : A\nhd1 : d1 \u2208 \ud835\udc9c i1\nh1 : \u2191\u27e8d1, hd1\u27e9 \u2208 x\nhn2 : n1 \u2208 \ud835\udc9c i1\nhd2 : d1 \u2208 \ud835\udc9c i1\nh2 : \u2191\u27e8d1, hd2\u27e9 \u2208 x\n\u22a2 { deg := i1, num := \u27e8n1, hn1\u27e9, den := \u27e8d1, hd1\u27e9, den_mem := h1 } =\n    { deg := i1, num := \u27e8n1, hn2\u27e9, den := \u27e8d1, hd2\u27e9, den_mem := h2 }",["congr","ring","aesop","tauto","abel","norm_num","simp"]],["LinearAlgebra/Span/Basic.lean",356,"case h\nR : Type u_1\nM : Type u_4\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nx\u271d : M \u00d7 M'\n\u22a2 x\u271d \u2208 \u22a4.prod \u22a4 \u2194 x\u271d \u2208 \u22a4",["simp","aesop","tauto"]],["LinearAlgebra/Span/Basic.lean",562,"K : Type u_3\nV : Type u_6\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Submodule K V\nx : V\nhx : x \u2209 s\nh : x \u2208 s\n\u22a2 x = 0",["contradiction","aesop","tauto"]],["RingTheory/Valuation/ValuationSubring.lean",341,"case a\nK : Type u\ninst\u271d : Field K\nA : ValuationSubring K\nS : { S // A \u2264 S }\n\u22a2 \u2191((fun P \u21a6 \u27e8A.ofPrime P.asIdeal, \u22ef\u27e9) ((fun S \u21a6 { asIdeal := A.idealOfLE \u2191S \u22ef, isPrime := \u22ef }) S)) = \u2191S",["simp","aesop","norm_num"]],["RingTheory/Valuation/ValuationSubring.lean",178,"case h\nK : Type u\ninst\u271d : Field K\nA : ValuationSubring K\na : (\u21a5A)\u02e3\n\u22a2 \u2191\u2191a * 1 = \u2191\u2191a",["simp","ring","aesop","norm_num"]],["RingTheory/Valuation/ValuationSubring.lean",429,"K : Type u\ninst\u271d : Field K\nA : ValuationSubring K\nx : \u21a5A.unitGroup\n\u22a2 \u2191(\u27e8\u2191\u2191x, \u22ef\u27e9 * \u27e8\u2191\u2191x\u207b\u00b9, \u22ef\u27e9) = \u21911",["simp","aesop","norm_num"]],["RingTheory/Valuation/ValuationSubring.lean",626,"K : Type u\ninst\u271d : Field K\nA : ValuationSubring K\nx : \u21a5(Units.map \u2191(IsLocalRing.residue \u21a5A)).ker\n\u22a2 (fun x \u21a6 \u27e8A.unitGroupMulEquiv \u27e8\u2191x, \u22ef\u27e9, \u22ef\u27e9) ((fun x \u21a6 \u27e8\u2191(A.unitGroupMulEquiv.symm \u2191x), \u22ef\u27e9) x) = x",["simp","aesop","norm_num"]],["RingTheory/Valuation/ValuationSubring.lean",84,"K : Type u\ninst\u271d : Field K\nA : ValuationSubring K\n\u22a2 IsDomain \u21a5A.toSubring",["infer_instance","tauto"]],["RingTheory/Valuation/ValuationSubring.lean",48,"K : Type u\ninst\u271d : Field K\nA : ValuationSubring K\ntoSubring\u271d\u00b9 : Subring K\nmem_or_inv_mem'\u271d\u00b9 : \u2200 (x : K), x \u2208 toSubring\u271d\u00b9.carrier \u2228 x\u207b\u00b9 \u2208 toSubring\u271d\u00b9.carrier\ntoSubring\u271d : Subring K\nmem_or_inv_mem'\u271d : \u2200 (x : K), x \u2208 toSubring\u271d.carrier \u2228 x\u207b\u00b9 \u2208 toSubring\u271d.carrier\nh :\n  { toSubring := toSubring\u271d\u00b9, mem_or_inv_mem' := mem_or_inv_mem'\u271d\u00b9 }.toSubring =\n    { toSubring := toSubring\u271d, mem_or_inv_mem' := mem_or_inv_mem'\u271d }.toSubring\n\u22a2 { toSubring := toSubring\u271d\u00b9, mem_or_inv_mem' := mem_or_inv_mem'\u271d\u00b9 } =\n    { toSubring := toSubring\u271d, mem_or_inv_mem' := mem_or_inv_mem'\u271d }",["congr","aesop"]],["RingTheory/Valuation/ValuationSubring.lean",78,"case mk.mk\nK : Type u\ninst\u271d : Field K\ntoSubring\u271d\u00b9 : Subring K\nmem_or_inv_mem'\u271d\u00b9 : \u2200 (x : K), x \u2208 toSubring\u271d\u00b9.carrier \u2228 x\u207b\u00b9 \u2208 toSubring\u271d\u00b9.carrier\ntoSubring\u271d : Subring K\nmem_or_inv_mem'\u271d : \u2200 (x : K), x \u2208 toSubring\u271d.carrier \u2228 x\u207b\u00b9 \u2208 toSubring\u271d.carrier\nh :\n  { toSubring := toSubring\u271d\u00b9, mem_or_inv_mem' := mem_or_inv_mem'\u271d\u00b9 }.toSubring =\n    { toSubring := toSubring\u271d, mem_or_inv_mem' := mem_or_inv_mem'\u271d }.toSubring\n\u22a2 { toSubring := toSubring\u271d\u00b9, mem_or_inv_mem' := mem_or_inv_mem'\u271d\u00b9 } =\n    { toSubring := toSubring\u271d, mem_or_inv_mem' := mem_or_inv_mem'\u271d }",["congr","aesop"]],["GroupTheory/GroupAction/Blocks.lean",301,"G : Type u_1\ninst\u271d\u00b9 : Group G\nX : Type u_2\ninst\u271d : MulAction G X\nx\u271d : G\n\u22a2 x\u271d \u2022 Set.univ = Set.univ",["simp","aesop","norm_num"]],["GroupTheory/GroupAction/Blocks.lean",382,"case f\nG : Type u_3\ninst\u271d\u00b9 : AddGroup G\nX : Type u_4\ninst\u271d : AddAction G X\nB : Set X\nH : AddSubgroup G\nhB : AddAction.IsBlock (\u21a5H) B\ng : G\nh' : \u21a5(AddSubgroup.map (AddEquiv.toAddMonoidHom (Additive.toMul (AddAut.conj g))) H)\nh : G\nhH : h \u2208 H\nhh : g + h + -g = \u2191h'\nthis : h' +\u1d65 g +\u1d65 B = g +\u1d65 h +\u1d65 B\nhB' : \u27e8h, hH\u27e9 +\u1d65 B = B\n\u22a2 g +\u1d65 h +\u1d65 B = g +\u1d65 B",["congr","aesop","tauto"]],["GroupTheory/GroupAction/Blocks.lean",399,"case f\nG : Type u_1\ninst\u271d\u00b9 : Group G\nX : Type u_2\ninst\u271d : MulAction G X\nB : Set X\nH : Subgroup G\nhB : IsBlock (\u21a5H) B\ng : G\nh' : \u21a5(Subgroup.map (MulEquiv.toMonoidHom (MulAut.conj g)) H)\nh : G\nhH : h \u2208 H\nhh : g * h * g\u207b\u00b9 = \u2191h'\nthis : h' \u2022 g \u2022 B = g \u2022 h \u2022 B\na\u271d : \u27e8h, hH\u27e9 \u2022 B = B\n\u22a2 g \u2022 h \u2022 B = g \u2022 B",["congr","aesop","tauto"]],["GroupTheory/GroupAction/Blocks.lean",725,"case inl\nG : Type u_1\ninst\u271d\u00b3 : Group G\nX : Type u_2\ninst\u271d\u00b2 : MulAction G X\ninst\u271d\u00b9 : IsPretransitive G X\nB : Set X\ninst\u271d : Finite X\nhB : IsBlock G B\nhB' : Nat.card X < 2 * (orbit G B).ncard\nh : B = \u2205\n\u22a2 0 < 2",["norm_num","omega","decide","aesop","positivity","tauto","simp"]],["FieldTheory/Separable.lean",355,"case inl\nF : Type u\ninst\u271d : Field F\nf : F[X]\nhf : Irreducible f\nH : derivative f = 0\nHF : CharP F 0\nthis\u271d\u00b9 : CharZero F\nthis\u271d : f.natDegree = 0\nthis : f.natDegree \u2260 0\n\u22a2 f.Separable \u2228 \u00acf.Separable \u2227 \u2203 g, Irreducible g \u2227 (expand F 0) g = f",["contradiction","omega","aesop","tauto"]],["RingTheory/MvPowerSeries/Basic.lean",554,"case a.h.a\n\u03c3 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u00b2 : DivisionSemiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\n\u03c6 : MvPowerSeries \u03c3 R\nf : R \u2192+* S\nn : \u03c3 \u2192\u2080 \u2115\n\u22a2 (coeff S n) ((map \u03c3 f) \u03c6) = (coeff S n) 0 \u2194 (coeff R n) \u03c6 = (coeff R n) 0",["simp","aesop","norm_num"]],["RingTheory/MvPowerSeries/Basic.lean",817,"case a\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : CommSemiring R\nx y : MvPolynomial \u03c3 R\nh : Coe.coe x = Coe.coe y\nm\u271d : \u03c3 \u2192\u2080 \u2115\n\u22a2 (MvPowerSeries.coeff R m\u271d) \u2191x = (MvPowerSeries.coeff R m\u271d) \u2191y",["congr","tauto"]],["RingTheory/MvPowerSeries/Basic.lean",783,"case neg\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : CommSemiring R\nn : \u03c3 \u2192\u2080 \u2115\na : R\nh\u2082 : \u00acn = n\n\u22a2 a = 0\n```\n---\n```lean\ncase pos\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : CommSemiring R\nn : \u03c3 \u2192\u2080 \u2115\na : R\nh\u2081 : \u00acn = n\n\u22a2 0 = a",["contradiction","aesop","tauto"]],["MeasureTheory/Function/ConditionalExpectation/AEMeasurable.lean",372,"\u03b1 : Type u_1\nF : Type u_2\np : \u211d\u22650\u221e\ninst\u271d : NormedAddCommGroup F\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nhp : Fact (1 \u2264 p)\nhm : m \u2264 m0\nf : \u21a5(lpMeasSubgroup F m p \u03bc)\n\u22a2 \u2016\u2191f\u2016 = \u2016f\u2016",["congr","aesop","tauto","abel","norm_num","simp"]],["Combinatorics/SimpleGraph/Basic.lean",118,"case mk.refine_3.Adj.h.h.a\nV : Type u\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableEq V\nAdj : V \u2192 V \u2192 Prop\nhs : Symmetric Adj\nhi : Irreflexive Adj\nx\u271d\u00b9 x\u271d : V\n\u22a2 (SimpleGraph.mk' \u27e8fun v w \u21a6 decide (Adj v w), \u22ef\u27e9).Adj x\u271d\u00b9 x\u271d \u2194 { Adj := Adj, symm := hs, loopless := hi }.Adj x\u271d\u00b9 x\u271d",["simp","aesop"]],["Combinatorics/SimpleGraph/Basic.lean",813,"case Adj.h.h.a\nV : Type u\nG G' : SimpleGraph V\nx\u271d\u00b9 x\u271d : V\n\u22a2 (G.deleteEdges G'.edgeSet).Adj x\u271d\u00b9 x\u271d \u2194 (G \\ G').Adj x\u271d\u00b9 x\u271d",["simp","aesop"]],["Combinatorics/SimpleGraph/Basic.lean",594,"case Adj.h.h.a\nV : Type u\ns t : Set (Sym2 V)\nv w : V\n\u22a2 (s(v, w) \u2208 s \u2227 s(v, w) \u2208 t) \u2227 \u00acv = w \u2194 (s(v, w) \u2208 s \u2227 \u00acv = w) \u2227 s(v, w) \u2208 t \u2227 \u00acv = w",["tauto","aesop"]],["Combinatorics/SimpleGraph/Basic.lean",711,"case h\nV : Type u\nG : SimpleGraph V\nv w : V\nh : \u2200 {a b : V}, G.Adj a b \u2192 a \u2260 b\n\u22a2 G.Adj v w \u2228 v \u2260 w \u2227 \u00acG.Adj v w \u2194 \u00acw = v",["tauto"]],["CategoryTheory/Sites/Sheaf.lean",435,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nA : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} A\nF : Sheaf J A\nX : C\nH : \u22a5 \u2208 J X\nY : A\n\u22a2 Presieve.FamilyOfElements.Compatible fun \u2983Y_1\u2984 f a \u21a6 \u22ef.elim",["tauto"]],["GroupTheory/Perm/Cycle/Type.lean",633,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nht : g.IsThreeCycle\n\u22a2 Nat.Coprime 2 3",["norm_num","ring","decide","congr","tauto"]],["GroupTheory/Perm/Cycle/Type.lean",567,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Perm \u03b1\na : \u2115\nh : a \u2208 Multiset.replicate (Fintype.card \u03b1 - \u03c3.support.card) 1\n\u22a2 \u00ac2 \u2264 1",["decide","omega","aesop","tauto","norm_num","simp"]],["RingTheory/PowerSeries/Basic.lean",845,"case h\nU : Type u_2\nV : Type u_3\ninst\u271d\u00b9 : CommSemiring U\ninst\u271d : CommSemiring V\n\u03c6 : U \u2192+* V\nf : U[X]\nn\u271d : \u2115\n\u22a2 (PowerSeries.coeff V n\u271d) \u2191(map \u03c6 f) = (PowerSeries.coeff V n\u271d) ((PowerSeries.map \u03c6) \u2191f)",["simp","aesop","norm_num"]],["RingTheory/PowerSeries/Basic.lean",856,"case a\nR : Type u_1\ninst\u271d : CommSemiring R\nx y : R[X]\nh : Coe.coe x = Coe.coe y\nn\u271d : \u2115\n\u22a2 (PowerSeries.coeff R n\u271d) \u2191x = (PowerSeries.coeff R n\u271d) \u2191y",["congr","tauto"]],["RingTheory/PowerSeries/Basic.lean",606,"R : Type u_2\ninst\u271d : CommSemiring R\n\u03c6 \u03c8 : R\u27e6X\u27e7\nthis : antidiagonal 1 = {(0, 1), (1, 0)}\n\u22a2 (0, 1) \u2209 {(1, 0)}",["norm_num","decide","aesop","tauto","simp"]],["CategoryTheory/Limits/Types.lean",531,"case a\nJ : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : J \u2964 Type u\ninst\u271d : HasColimit F\nj : J\nx : F.obj j\n\u22a2 (colimitEquivQuot F).symm ((colimitEquivQuot F) (colimit.\u03b9 F j x)) =\n    (colimitEquivQuot F).symm (Quot.mk (Quot.Rel F) \u27e8j, x\u27e9)",["simp","aesop"]],["Algebra/Polynomial/FieldDivision.lean",517,"case pos\nR : Type u\ninst\u271d : Field R\nu : R[X]\u02e3\nn : \u2115\nh\u271d : n = 0\n\u22a2 eval 0 \u21911 = 1",["simp","aesop","norm_num"]],["Algebra/Polynomial/FieldDivision.lean",291,"R : Type u\ninst\u271d : Field R\np : R[X]\nthis : p.degree \u2264 0\nhc : p.coeff 0 = 0\nh : degree 0 = 0\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/Algebra/Unitization.lean",707,"case h\nR : Type u_2\nA : Type u_3\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : SMulCommClass R A A\ninst\u271d : IsScalarTower R A A\nx\u271d : Unitization R A\n\u22a2 (NonUnitalAlgHom.toAlgHom 0) x\u271d = x\u271d.fst",["simp","aesop","norm_num"]],["Algebra/Lie/Weights/Killing.lean",167,"case intro.intro.intro.intro\nK : Type u_2\nL : Type u_3\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : LieAlgebra K L\ninst\u271d\u00b2 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsKilling K L\nx : \u21a5H\nhx : x \u2208 corootSpace 0\ny : L\nhy : y \u2208 H\nz : L\nhz : z \u2208 H\n\u22a2 \u2045\u27e8y, hy\u27e9, \u27e8z, hz\u27e9\u2046 = 0",["simp","aesop","norm_num"]],["Algebra/Lie/Weights/Killing.lean",292,"K : Type u_2\nL : Type u_3\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : LieAlgebra K L\ninst\u271d\u2074 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b3 : H.IsCartanSubalgebra\ninst\u271d\u00b2 : IsKilling K L\ninst\u271d\u00b9 : IsTriangularizable K (\u21a5H) L\ninst\u271d : PerfectField K\nx : L\nhx : x \u2208 H\nN S : End K L\nhN : _root_.IsNilpotent ((ad K L) x - S)\nhS : S.IsSemisimple\nhSN : (ad K L) x = N + S\nhS\u2080 : Commute ((ad K L) x) S\nx' : \u21a5H := \u27e8x, hx\u27e9\naux : \u2200 {\u03b1 : \u21a5H \u2192 K} {y : L}, y \u2208 rootSpace H \u03b1 \u2192 S y = \u03b1 x' \u2022 y\nh_der : \u2200 (y z : L), S \u2045y, z\u2046 = \u2045y, S z\u2046 - \u2045z, S y\u2046\n\u22a2 \u2200 (y z : L), S \u2045y, z\u2046 = \u2045y, S z\u2046 - \u2045z, S y\u2046",["assumption","aesop","congr","tauto"]],["Algebra/Lie/Weights/Killing.lean",557,"case intro.intro.intro.intro.intro.intro.mk.intro.intro\nK : Type u_2\nL : Type u_3\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : LieAlgebra K L\ninst\u271d\u2074 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b3 : H.IsCartanSubalgebra\ninst\u271d\u00b2 : IsKilling K L\ninst\u271d\u00b9 : IsTriangularizable K (\u21a5H) L\ninst\u271d : CharZero K\n\u03b1 : Weight K (\u21a5H) L\nh\u03b1 : \u03b1.IsNonZero\ncontra : 1 < finrank K \u21a5(rootSpace H \u21d1\u03b1)\nh e f : L\nht : IsSl2Triple h e f\nhe\u03b1 : e \u2208 rootSpace H \u21d1\u03b1\nhf\u03b1 : f \u2208 rootSpace H (-\u21d1\u03b1)\nF : \u21a5(rootSpace H \u21d1\u03b1) \u2192\u2097[K] K := (killingForm K L) f \u2218\u2097 (\u2191(rootSpace H \u21d1\u03b1)).subtype\nhF : LinearMap.ker F \u2260 \u22a5\ny : L\nhy\u03b1 : y \u2208 rootSpace H \u21d1\u03b1\nhy\u2080 : \u27e8y, hy\u03b1\u27e9 \u2260 0\nhy : \u2045y, f\u2046 = 0\nP : \u22ef.HasPrimitiveVectorWith y (-2)\nn : \u2115\nhn : -2 = \u2191n\n\u22a2 False",["omega","aesop","linarith","tauto","contradiction"]],["Algebra/Lie/Weights/Killing.lean",504,"case intro.intro.intro.intro.refine_1\nK : Type u_2\nL : Type u_3\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : LieAlgebra K L\ninst\u271d\u2074 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b3 : H.IsCartanSubalgebra\ninst\u271d\u00b2 : IsKilling K L\ninst\u271d\u00b9 : IsTriangularizable K (\u21a5H) L\ninst\u271d : CharZero K\n\u03b1 : Weight K (\u21a5H) L\nh\u03b1 : \u03b1.IsNonZero\ne : L\nhe\u03b1 : e \u2208 rootSpace H \u21d1\u03b1\nhe\u2080 : e \u2260 0\nf' : L\nhf\u03b1 : f' \u2208 rootSpace H (-\u21d1\u03b1)\nhf : ((killingForm K L) e) f' \u2260 0\nhef\u271d : \u2045e, f'\u2046 = ((killingForm K L) e) f' \u2022 \u2191((cartanEquivDual H).symm (Weight.toLinear K (\u21a5H) L \u03b1))\nh : \u21a5H := \u27e8\u2045e, f'\u2046, \u22ef\u27e9\nhh : \u03b1 h \u2260 0\nf : L := (2 * (\u03b1 h)\u207b\u00b9) \u2022 f'\ncontra : \u2045e, f\u2046 = 0\n_i : NoZeroSMulDivisors \u2124 L\nhef : e = 0\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/Lie/Weights/Killing.lean",244,"case intro\nK : Type u_2\nL : Type u_3\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b2 : H.IsCartanSubalgebra\ninst\u271d\u00b9 : IsKilling K L\ninst\u271d : IsTriangularizable K (\u21a5H) L\n\u03b1 : Weight K (\u21a5H) L\n\u22a2 \u03b1.IsZero \u2228 \u2203 x, x.IsNonZero \u2227 Weight.toLinear K (\u21a5H) L x = Weight.toLinear K (\u21a5H) L \u03b1",["tauto"]],["Analysis/BoxIntegral/Partition/Basic.lean",286,"case h\n\u03b9 : Type u_1\nI : Box \u03b9\n\u03c0 : Prepartition I\nJ\u271d : Box \u03b9\n\u22a2 (J\u271d \u2208 \u03c0.biUnion fun x \u21a6 \u22a4) \u2194 J\u271d \u2208 \u03c0",["simp","aesop","norm_num"]],["Analysis/BoxIntegral/Partition/Basic.lean",127,"case intro.intro.intro.intro\n\u03b9 : Type u_1\nI J J\u2081 J\u2082 : Box \u03b9\n\u03c0 \u03c0\u2081\u271d \u03c0\u2082\u271d : Prepartition I\nx : \u03b9 \u2192 \u211d\n\u03c0\u2081 \u03c0\u2082 : Prepartition I\nh\u2081 : \u03c0\u2081 \u2264 \u03c0\u2082\nh\u2082 : \u03c0\u2082 \u2264 \u03c0\u2081\nJ' : Box \u03b9\nhJ' : J' \u2208 \u03c0\u2082\nhJ : J' \u2208 \u03c0\u2081.boxes\nhle : J' \u2264 J'\nhJ'' : J' \u2208 \u03c0\u2081\nhle' : J' \u2264 J'\n\u22a2 J' \u2208 \u03c0\u2082.boxes",["assumption","aesop","congr","tauto"]],["Analysis/SpecialFunctions/Complex/Arg.lean",269,"case neg.mpr.mk.intro\ny : \u211d\nh\u2080 : \u00ac{ re := 0, im := y } = 0\nhy : y < 0\n\u22a2 (\u21910 + \u2191y * I).arg = (\u2191(-y) * -I).arg",["simp","aesop","norm_num"]],["LinearAlgebra/Matrix/SesquilinearForm.lean",428,"R : Type u_1\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2081' : Type u_8\nn : Type u_11\nm : Type u_12\nn' : Type u_13\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : AddCommMonoid M\u2082\ninst\u271d\u2078 : Module R M\u2082\ninst\u271d\u2077 : DecidableEq n\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : DecidableEq m\ninst\u271d\u2074 : Fintype m\nb\u2081 : Basis n R M\u2081\nb\u2082 : Basis m R M\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2081'\ninst\u271d\u00b2 : Module R M\u2081'\nb\u2081' : Basis n' R M\u2081'\ninst\u271d\u00b9 : Fintype n'\ninst\u271d : DecidableEq n'\nB : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] R\nf : M\u2081' \u2192\u2097[R] M\u2081\n\u22a2 ((toMatrix b\u2081' b\u2081) f)\u1d40 * (toMatrix\u2082 b\u2081 b\u2082) B * (toMatrix b\u2082 b\u2082) id = ((toMatrix b\u2081' b\u2081) f)\u1d40 * (toMatrix\u2082 b\u2081 b\u2082) B",["simp","aesop","norm_num"]],["LinearAlgebra/Matrix/SesquilinearForm.lean",291,"n : Type u_11\nm : Type u_12\nn' : Type u_13\nm' : Type u_14\nR : Type u_16\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : Fintype m\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype n'\ninst\u271d\u00b2 : Fintype m'\ninst\u271d\u00b9 : DecidableEq n'\ninst\u271d : DecidableEq m'\nB : (n \u2192 R) \u2192\u2097[R] (m \u2192 R) \u2192\u2097[R] R\nM : Matrix n' n R\nN : Matrix m m' R\n\u22a2 M * (toMatrix\u2082' R) B * N = (toMatrix\u2082' R) (B.compl\u2081\u2082 (toLin' M\u1d40) (toLin' N))",["simp","aesop","norm_num"]],["LinearAlgebra/Matrix/SesquilinearForm.lean",281,"n : Type u_11\nm : Type u_12\nn' : Type u_13\nR : Type u_16\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Fintype n\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype n'\ninst\u271d : DecidableEq n'\nB : (n \u2192 R) \u2192\u2097[R] (m \u2192 R) \u2192\u2097[R] R\nf : (n' \u2192 R) \u2192\u2097[R] n \u2192 R\n\u22a2 (toMatrix\u2082' R) (B.compl\u2081\u2082 f id) = (toMatrix' f)\u1d40 * (toMatrix\u2082' R) B",["simp","aesop","norm_num"]],["Algebra/Order/Hom/Monoid.lean",595,"F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b3\ninst\u271d\u2074 : Preorder \u03b4\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b2\ninst\u271d\u00b9 : Mul \u03b3\ninst\u271d : Mul \u03b4\nf\u271d g\u271d f : \u03b1 \u2243*o \u03b2\ng : \u03b2 \u2243*o \u03b3\n\u22a2 \u2200 {a b : \u03b1}, __src\u271d.toFun a \u2264 __src\u271d.toFun b \u2194 a \u2264 b",["simp","aesop"]],["Algebra/Order/Hom/Monoid.lean",302,"case mk.mk.mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b3\ninst\u271d\u2074 : Preorder \u03b4\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : MulOneClass \u03b2\ninst\u271d\u00b9 : MulOneClass \u03b3\ninst\u271d : MulOneClass \u03b4\nf g : \u03b1 \u2192*o \u03b2\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_one'\u271d\u00b9 : toFun\u271d\u00b9 1 = 1\nmap_mul'\u271d\u00b9 :\n  \u2200 (x y : \u03b1),\n    { toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9 }.toFun (x * y) =\n      { toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9 }.toFun x * { toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9 }.toFun y\nmonotone'\u271d\u00b9 : Monotone (\u2191{ toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 }).toFun\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_one'\u271d : toFun\u271d 1 = 1\nmap_mul'\u271d :\n  \u2200 (x y : \u03b1),\n    { toFun := toFun\u271d, map_one' := map_one'\u271d }.toFun (x * y) =\n      { toFun := toFun\u271d, map_one' := map_one'\u271d }.toFun x * { toFun := toFun\u271d, map_one' := map_one'\u271d }.toFun y\nmonotone'\u271d : Monotone (\u2191{ toFun := toFun\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d }).toFun\nh :\n  (fun f \u21a6 (\u2191f.toMonoidHom).toFun)\n      { toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9, monotone' := monotone'\u271d\u00b9 } =\n    (fun f \u21a6 (\u2191f.toMonoidHom).toFun)\n      { toFun := toFun\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d, monotone' := monotone'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9, monotone' := monotone'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d, monotone' := monotone'\u271d }",["congr","aesop"]],["Algebra/Order/Hom/Monoid.lean",689,"case mk.mk.mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b3\ninst\u271d\u2074 : Preorder \u03b4\ninst\u271d\u00b3 : MulZeroOneClass \u03b1\ninst\u271d\u00b2 : MulZeroOneClass \u03b2\ninst\u271d\u00b9 : MulZeroOneClass \u03b3\ninst\u271d : MulZeroOneClass \u03b4\nf g : \u03b1 \u2192*\u2080o \u03b2\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_zero'\u271d\u00b9 : toFun\u271d\u00b9 0 = 0\nmap_one'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9 }.toFun 1 = 1\nmap_mul'\u271d\u00b9 :\n  \u2200 (x y : \u03b1),\n    { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9 }.toFun (x * y) =\n      { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9 }.toFun x * { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9 }.toFun y\nmonotone'\u271d\u00b9 :\n  Monotone (\u2191{ toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, map_one' := map_one'\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 }).toFun\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_zero'\u271d : toFun\u271d 0 = 0\nmap_one'\u271d : { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun 1 = 1\nmap_mul'\u271d :\n  \u2200 (x y : \u03b1),\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun (x * y) =\n      { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun x * { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun y\nmonotone'\u271d :\n  Monotone (\u2191{ toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d }).toFun\nh :\n  (fun f \u21a6 (\u2191f.toMonoidWithZeroHom).toFun)\n      { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, map_one' := map_one'\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9,\n        monotone' := monotone'\u271d\u00b9 } =\n    (fun f \u21a6 (\u2191f.toMonoidWithZeroHom).toFun)\n      { toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d, monotone' := monotone'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, map_one' := map_one'\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9,\n      monotone' := monotone'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d, monotone' := monotone'\u271d }",["congr","aesop"]],["NumberTheory/Padics/PadicVal/Basic.lean",106,"case neg.left.\u00ab1\u00bb.hnc\np n : \u2115\nh\u271d : 1 \u2264 1 \u2228 n = 0\nh : 1 \u2264 1\n\u22a2 \u00ac(1 < 1 \u2227 0 < n \u2227 n % 1 = 0)",["simp","omega","aesop","tauto","norm_num"]],["NumberTheory/Padics/PadicVal/Basic.lean",87,"p n : \u2115\nhp : 1 < p\nhn : 0 < n\nh : p ^ (p.maxPowDiv n + 1) \u2223 n\n\u22a2 p.maxPowDiv n < p.maxPowDiv n + 1",["simp","omega","aesop","linarith","tauto","norm_num"]],["NumberTheory/Padics/PadicVal/Basic.lean",388,"p j : \u2115\nhp : Fact (Nat.Prime p)\nF : \u2115 \u2192 \u211a\nS : Finset \u2115\nhn1 : \u2200 (i : \u2115), 0 < F i\nk : \u2115\nhF : \u2200 i \u2208 {k}, padicValRat p (F j) < padicValRat p (F i)\n\u22a2 k \u2208 {k}",["simp","aesop","tauto","norm_num"]],["NumberTheory/Padics/PadicVal/Basic.lean",244,"p : \u2115\nhp : Fact (Nat.Prime p)\nq : \u211a\nn d : \u2124\nhqz : q \u2260 0\nqdf : q = n /. d\nhd : d \u2260 0\nc : \u2124\nhc1 : n = c * q.num\nhc2 : d = c * \u2191q.den\n\u22a2 \u2191(multiplicity (\u2191p) q.num) - \u2191(multiplicity p q.den) =\n    \u2191(multiplicity (\u2191p) c) + \u2191(multiplicity (\u2191p) q.num) - (\u2191(multiplicity (\u2191p) c) + \u2191(multiplicity p q.den))",["ring","omega","linarith","abel","norm_num","simp"]],["Topology/TietzeExtension.lean",177,"case h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : NormalSpace Y\ne : C(X, Y)\nhe : IsClosedEmbedding \u21d1e\nh3 : 0 < 3\nh23 : 0 < 2 / 3\n\u22a2 \u20160\u2016 \u2264 \u20160\u2016 / 3 \u2227 dist (compContinuous 0 e) 0 \u2264 2 / 3 * \u20160\u2016",["simp","aesop","norm_num"]],["Order/RelIso/Basic.lean",227,"case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u21aa \u03b2\nmap_rel_iff'\u271d\u00b9 : \u2200 {a b : \u03b1}, s (f a) (f b) \u2194 r a b\ng : \u03b1 \u21aa \u03b2\nmap_rel_iff'\u271d : \u2200 {a b : \u03b1}, s (g a) (g b) \u2194 r a b\n\u22a2 { toEmbedding := f, map_rel_iff' := map_rel_iff'\u271d\u00b9 }.toEmbedding =\n      { toEmbedding := g, map_rel_iff' := map_rel_iff'\u271d }.toEmbedding \u2192\n    { toEmbedding := f, map_rel_iff' := map_rel_iff'\u271d\u00b9 } = { toEmbedding := g, map_rel_iff' := map_rel_iff'\u271d }",["simp","aesop"]],["Order/RelIso/Basic.lean",102,"case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_rel'\u271d\u00b9 : \u2200 {a b : \u03b1}, r a b \u2192 s (toFun\u271d\u00b9 a) (toFun\u271d\u00b9 b)\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_rel'\u271d : \u2200 {a b : \u03b1}, r a b \u2192 s (toFun\u271d a) (toFun\u271d b)\nh :\n  (fun o \u21a6 o.toFun) { toFun := toFun\u271d\u00b9, map_rel' := map_rel'\u271d\u00b9 } =\n    (fun o \u21a6 o.toFun) { toFun := toFun\u271d, map_rel' := map_rel'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_rel' := map_rel'\u271d\u00b9 } = { toFun := toFun\u271d, map_rel' := map_rel'\u271d }",["congr","aesop"]],["Order/RelIso/Basic.lean",207,"case mk.mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\ninj'\u271d\u00b9 : Injective toFun\u271d\u00b9\nmap_rel_iff'\u271d\u00b9 :\n  \u2200 {a b : \u03b1}, s ({ toFun := toFun\u271d\u00b9, inj' := inj'\u271d\u00b9 } a) ({ toFun := toFun\u271d\u00b9, inj' := inj'\u271d\u00b9 } b) \u2194 r a b\ntoFun\u271d : \u03b1 \u2192 \u03b2\ninj'\u271d : Injective toFun\u271d\nmap_rel_iff'\u271d : \u2200 {a b : \u03b1}, s ({ toFun := toFun\u271d, inj' := inj'\u271d } a) ({ toFun := toFun\u271d, inj' := inj'\u271d } b) \u2194 r a b\nh :\n  (fun x \u21a6 x.toFun) { toFun := toFun\u271d\u00b9, inj' := inj'\u271d\u00b9, map_rel_iff' := map_rel_iff'\u271d\u00b9 } =\n    (fun x \u21a6 x.toFun) { toFun := toFun\u271d, inj' := inj'\u271d, map_rel_iff' := map_rel_iff'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, inj' := inj'\u271d\u00b9, map_rel_iff' := map_rel_iff'\u271d\u00b9 } =\n    { toFun := toFun\u271d, inj' := inj'\u271d, map_rel_iff' := map_rel_iff'\u271d }",["congr","aesop"]],["Order/RelIso/Basic.lean",535,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ne\u2081 : \u03b1 \u2243 \u03b2\no\u2081 : \u2200 {a b : \u03b1}, s (e\u2081 a) (e\u2081 b) \u2194 r a b\ne\u2082 : \u03b1 \u2243 \u03b2\nmap_rel_iff'\u271d : \u2200 {a b : \u03b1}, s (e\u2082 a) (e\u2082 b) \u2194 r a b\nh : { toEquiv := e\u2081, map_rel_iff' := o\u2081 }.toEquiv = { toEquiv := e\u2082, map_rel_iff' := map_rel_iff'\u271d }.toEquiv\n\u22a2 { toEquiv := e\u2081, map_rel_iff' := o\u2081 } = { toEquiv := e\u2082, map_rel_iff' := map_rel_iff'\u271d }",["congr","aesop"]],["Geometry/RingedSpace/PresheafedSpace/Gluing.lean",281,"case h\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : GlueData C\ninst\u271d : HasLimits C\ni j k : D.J\nU : Opens \u2191\u2191(D.U i)\n\u22a2 (pullback.fst (D.f j i) (D.f j k) \u226b D.t j i \u226b D.f i j).c.app (op U) \u226b\n      invApp (pullback.snd (D.f j i) (D.f j k))\n          ((Opens.map (pullback.fst (D.f j i) (D.f j k)).base).toPrefunctor.1\n            ((Opens.map (D.t j i).base).toPrefunctor.1 ((Opens.map (D.f i j).base).obj U))) \u226b\n        (D.V (j, k)).presheaf.map (eqToHom \u22ef) =\n    (pullback.fst (D.f j i) (D.f j k) \u226b D.t j i \u226b D.f i j).c.app (op U) \u226b\n      invApp (pullback.snd (D.f j i) (D.f j k))\n          ((Opens.map (pullback.fst (D.f j i) (D.f j k) \u226b D.t j i \u226b D.f i j).base).toPrefunctor.1 U) \u226b\n        (D.V (j, k)).presheaf.map (eqToHom ?w)",["congr","aesop","tauto","simp"]],["Topology/EMetricSpace/Defs.lean",552,"case mk.mk.e_toPseudoEMetricSpace.h\n\u03b1 : Type u_2\ntoPseudoEMetricSpace\u271d\u00b9 : PseudoEMetricSpace \u03b1\neq_of_edist_eq_zero\u271d\u00b9 : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y\ntoPseudoEMetricSpace\u271d : PseudoEMetricSpace \u03b1\neq_of_edist_eq_zero\u271d : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y\nh : PseudoEMetricSpace.toEDist = PseudoEMetricSpace.toEDist\n\u22a2 PseudoEMetricSpace.toEDist = PseudoEMetricSpace.toEDist",["assumption","aesop","congr","gcongr","tauto"]],["Topology/EMetricSpace/Defs.lean",451,"\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ns : Set \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nt : Set \u03b2\na : \u03b1\nb : \u03b2\n\u03b5 : \u211d\u22650\u221e\nx\u271d\u00b9 : 0 < \u03b5\n\u03b4 : \u211d\u22650\u221e\nx\u271d : 0 < \u03b4\nx : \u03b1\n\u22a2 edist x a < \u03b4 \u2192 x \u2208 s \u2192 edist (f x) b < \u03b5 \u2227 f x \u2208 t \u2194 x \u2208 s \u2192 edist x a < \u03b4 \u2192 f x \u2208 t \u2227 edist (f x) b < \u03b5",["tauto","aesop"]],["CategoryTheory/Adjunction/Basic.lean",554,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nF_obj : C \u2192 D\ne : (X : C) \u2192 (Y : D) \u2192 (F_obj X \u27f6 Y) \u2243 (X \u27f6 G.obj Y)\nhe : \u2200 (X : C) (Y Y' : D) (g : Y \u27f6 Y') (h : F_obj X \u27f6 Y), (e X Y') (h \u226b g) = (e X Y) h \u226b G.map g\nX\u271d Y\u271d Z\u271d : C\nf : X\u271d \u27f6 Y\u271d\nf' : Y\u271d \u27f6 Z\u271d\n\u22a2 (f \u226b f') \u226b (e Z\u271d (F_obj Z\u271d)) (\ud835\udfd9 (F_obj Z\u271d)) = f \u226b f' \u226b (e Z\u271d (F_obj Z\u271d)) (\ud835\udfd9 (F_obj Z\u271d))",["simp","aesop"]],["CategoryTheory/Adjunction/Basic.lean",595,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nG_obj : D \u2192 C\ne : (X : C) \u2192 (Y : D) \u2192 (F.obj X \u27f6 Y) \u2243 (X \u27f6 G_obj Y)\nhe : \u2200 (X' X : C) (Y : D) (f : X' \u27f6 X) (g : F.obj X \u27f6 Y), (e X' Y) (F.map f \u226b g) = f \u226b (e X Y) g\nY Y' Y'' : D\ng : Y \u27f6 Y'\ng' : Y' \u27f6 Y''\n\u22a2 (e (G_obj Y) Y).symm (\ud835\udfd9 (G_obj Y)) \u226b g \u226b g' = ((e (G_obj Y) Y).symm (\ud835\udfd9 (G_obj Y)) \u226b g) \u226b g'",["simp","aesop"]],["CategoryTheory/Adjunction/Basic.lean",462,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF\u271d : C \u2964 D\nG : D \u2964 C\nF F' : C \u2964 D\niso : F \u2245 F'\nX : C\nY : D\nf : F.obj X \u27f6 Y\n\u22a2 (fun g \u21a6 iso.hom.app X \u226b g) ((fun f \u21a6 iso.inv.app X \u226b f) f) = f",["simp","aesop"]],["CategoryTheory/Adjunction/Basic.lean",253,"case w.h\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nx\u271d : C\n\u22a2 (whiskerRight adj.unit F \u226b whiskerLeft F adj.counit).app x\u271d = (\ud835\udfd9 (\ud835\udfed C \u22d9 F)).app x\u271d",["simp","aesop"]],["CategoryTheory/Adjunction/Basic.lean",179,"case mk.mk\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nunit\u271d\u00b9 : \ud835\udfed C \u27f6 F \u22d9 G\ncounit\u271d\u00b9 : G \u22d9 F \u27f6 \ud835\udfed D\nleft_triangle_components\u271d\u00b9 : \u2200 (X : C), F.map (unit\u271d\u00b9.app X) \u226b counit\u271d\u00b9.app (F.obj X) = \ud835\udfd9 (F.obj X)\nright_triangle_components\u271d\u00b9 : \u2200 (Y : D), unit\u271d\u00b9.app (G.obj Y) \u226b G.map (counit\u271d\u00b9.app Y) = \ud835\udfd9 (G.obj Y)\nunit\u271d : \ud835\udfed C \u27f6 F \u22d9 G\ncounit\u271d : G \u22d9 F \u27f6 \ud835\udfed D\nleft_triangle_components\u271d : \u2200 (X : C), F.map (unit\u271d.app X) \u226b counit\u271d.app (F.obj X) = \ud835\udfd9 (F.obj X)\nright_triangle_components\u271d : \u2200 (Y : D), unit\u271d.app (G.obj Y) \u226b G.map (counit\u271d.app Y) = \ud835\udfd9 (G.obj Y)\nh :\n  { unit := unit\u271d\u00b9, counit := counit\u271d\u00b9, left_triangle_components := left_triangle_components\u271d\u00b9,\n        right_triangle_components := right_triangle_components\u271d\u00b9 }.unit =\n    { unit := unit\u271d, counit := counit\u271d, left_triangle_components := left_triangle_components\u271d,\n        right_triangle_components := right_triangle_components\u271d }.unit\nh' :\n  { unit := unit\u271d\u00b9, counit := counit\u271d\u00b9, left_triangle_components := left_triangle_components\u271d\u00b9,\n        right_triangle_components := right_triangle_components\u271d\u00b9 }.counit =\n    { unit := unit\u271d, counit := counit\u271d, left_triangle_components := left_triangle_components\u271d,\n        right_triangle_components := right_triangle_components\u271d }.counit\n\u22a2 { unit := unit\u271d\u00b9, counit := counit\u271d\u00b9, left_triangle_components := left_triangle_components\u271d\u00b9,\n      right_triangle_components := right_triangle_components\u271d\u00b9 } =\n    { unit := unit\u271d, counit := counit\u271d, left_triangle_components := left_triangle_components\u271d,\n      right_triangle_components := right_triangle_components\u271d }",["aesop","congr"]],["CategoryTheory/Monad/Limits.lean",64,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nT : Monad C\nJ : Type u\ninst\u271d : Category.{v, u} J\nD : J \u2964 T.Algebra\nc : Cone (D \u22d9 T.forget)\nt : IsLimit c\nj : J\n\u22a2 c.\u03c0.app j \u226b \ud835\udfd9 (D.obj j).A = \ud835\udfd9 c.pt \u226b c.\u03c0.app j",["simp","aesop"]],["CategoryTheory/Monad/Limits.lean",265,"C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nJ : Type u\ninst\u271d\u00b2 : Category.{v, u} J\nF : J \u2964 D\nR : D \u2964 C\ninst\u271d\u00b9 : MonadicRightAdjoint R\ninst\u271d : HasLimit (F \u22d9 R)\n\u22a2 HasLimit ((F \u22d9 Monad.comparison (monadicAdjunction R)) \u22d9 (monadicAdjunction R).toMonad.forget)",["assumption","aesop","congr","tauto"]],["CategoryTheory/Monad/Limits.lean",590,"C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nJ : Type u\ninst\u271d\u00b2 : Category.{v, u} J\nF : J \u2964 D\nR : D \u2964 C\ninst\u271d\u00b9 : ComonadicLeftAdjoint R\ninst\u271d : HasColimit (F \u22d9 R)\n\u22a2 HasColimit ((F \u22d9 Comonad.comparison (comonadicAdjunction R)) \u22d9 (comonadicAdjunction R).toComonad.forget)",["assumption","aesop","congr","tauto"]],["LinearAlgebra/RootSystem/Defs.lean",279,"case h\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nP : RootPairing \u03b9 R M N\ni x\u271d : \u03b9\n\u22a2 (\u21d1(P.reflection_perm i))^[2] x\u271d = id x\u271d",["simp","aesop","norm_num"]],["LinearAlgebra/RootSystem/Defs.lean",210,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nP : RootPairing \u03b9 R M N\ni j : \u03b9\n\u22a2 (P.toLin.flip (P.coroot i)) (P.root j) = P.pairing j i",["simp","aesop","congr","tauto","abel","norm_num"]],["LinearAlgebra/RootSystem/Defs.lean",680,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nP : RootSystem \u03b9 R M N\ni j : \u03b9\nh : P.reflection_perm i = P.reflection_perm j\nx : M\n\u22a2 x \u2208 span R (range \u21d1P.root)",["simp","aesop","norm_num"]],["LinearAlgebra/RootSystem/Defs.lean",604,"case a\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nP : RootPairing \u03b9 R M N\n\u22a2 {x | \u2200 (i : \u03b9), (P.root' i) x = 0} = {x | \u2200 f \u2208 range P.root', f x = 0}",["simp","aesop","norm_num"]],["LinearAlgebra/RootSystem/Defs.lean",718,"case h\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nP : RootPairing \u03b9 R M N\ni j : \u03b9\nv : M\nh : P.pairing i j = 0 \u2227 P.pairing j i = 0\n\u22a2 v - (P.toPerfectPairing v) (P.coroot i) \u2022 P.root i - (P.toPerfectPairing v) (P.coroot j) \u2022 P.root j =\n    v - (P.toPerfectPairing v) (P.coroot j) \u2022 P.root j - (P.toPerfectPairing v) (P.coroot i) \u2022 P.root i",["abel","omega","tauto","infer_instance"]],["Probability/Kernel/Composition/CompProd.lean",245,"case pos.h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\n\u03b3 : Type u_4\nm\u03b3 : MeasurableSpace \u03b3\nh : IsSFiniteKernel \u03ba\na : \u03b1\ns : Set (\u03b2 \u00d7 \u03b3)\nhs : MeasurableSet s\n\u22a2 \u222b\u207b (b : \u03b2), (0 (a, b)) (Prod.mk b \u207b\u00b9' s) \u2202\u03ba a = (0 a) s",["simp","aesop","norm_num"]],["Analysis/Calculus/UniformLimitsDeriv.lean",122,"\u03b9 : Type u_1\nl : Filter \u03b9\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\n\ud835\udd5c : Type u_3\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : IsRCLikeNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nf : \u03b9 \u2192 E \u2192 G\nf' : \u03b9 \u2192 E \u2192 E \u2192L[\ud835\udd5c] G\nx : E\nhf : \u2200\u1da0 (n : \u03b9 \u00d7 E) in l \u00d7\u02e2 \ud835\udcdd x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2\nhfg : Cauchy (map (fun n \u21a6 f n x) l)\nthis\u271d\u00b2 : RCLike \ud835\udd5c := IsRCLikeNormedField.rclike \ud835\udd5c\nhf' : TendstoUniformlyOnFilter (fun n z \u21a6 f' n.1 z - f' n.2 z) 0 (l \u00d7\u02e2 l) (\ud835\udcdd x)\nthis\u271d\u00b9 : NormedSpace \u211d E := NormedSpace.restrictScalars \u211d \ud835\udd5c E\nthis\u271d :\n  TendstoUniformlyOnFilter (fun n z \u21a6 f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0 (l \u00d7\u02e2 l) (\ud835\udcdd x) \u2227\n    TendstoUniformlyOnFilter (fun n x_1 \u21a6 f n.1 x - f n.2 x) 0 (l \u00d7\u02e2 l) (\ud835\udcdd x)\nthis :\n  TendstoUniformlyOnFilter ((fun n z \u21a6 f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) + fun n x_1 \u21a6 f n.1 x - f n.2 x) 0\n    (l \u00d7\u02e2 l) (\ud835\udcdd x)\n\u22a2 \u2200\u1da0 (n : (\u03b9 \u00d7 \u03b9) \u00d7 E) in (l \u00d7\u02e2 l) \u00d7\u02e2 \ud835\udcdd x,\n    ((fun n z \u21a6 f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) + fun n x_1 \u21a6 f n.1 x - f n.2 x) n.1 n.2 =\n      f n.1.1 n.2 - f n.1.2 n.2",["simp","aesop","norm_num"]],["Analysis/Calculus/UniformLimitsDeriv.lean",192,"\u03b9 : Type u_1\nl : Filter \u03b9\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\n\ud835\udd5c : Type u_3\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : IsRCLikeNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nf : \u03b9 \u2192 E \u2192 G\nf' : \u03b9 \u2192 E \u2192 E \u2192L[\ud835\udd5c] G\nx : E\nr : \u211d\nhf : \u2200 (n : \u03b9), \u2200 y \u2208 Metric.ball x r, HasFDerivAt (f n) (f' n y) y\nhfg : Cauchy (map (fun n \u21a6 f n x) l)\nthis\u271d\u00b3 : RCLike \ud835\udd5c := IsRCLikeNormedField.rclike \ud835\udd5c\nhf' : TendstoUniformlyOn (fun n z \u21a6 f' n.1 z - f' n.2 z) 0 (l \u00d7\u02e2 l) (Metric.ball x r)\nthis\u271d\u00b2 : NormedSpace \u211d E := NormedSpace.restrictScalars \u211d \ud835\udd5c E\nthis\u271d\u00b9 : l.NeBot\nhr : 0 < r\nthis\u271d :\n  TendstoUniformlyOn (fun n z \u21a6 f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0 (l \u00d7\u02e2 l) (Metric.ball x r) \u2227\n    TendstoUniformlyOn (fun n x_1 \u21a6 f n.1 x - f n.2 x) 0 (l \u00d7\u02e2 l) (Metric.ball x r)\nthis :\n  TendstoUniformlyOn ((fun n z \u21a6 f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) + fun n x_1 \u21a6 f n.1 x - f n.2 x) 0 (l \u00d7\u02e2 l)\n    (Metric.ball x r)\nn : \u03b9 \u00d7 \u03b9\nz : E\na\u271d : z \u2208 Metric.ball x r\n\u22a2 ((fun n z \u21a6 f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) + fun n x_1 \u21a6 f n.1 x - f n.2 x) n z =\n    (fun z \u21a6 f n.1 z - f n.2 z) z",["simp","aesop","norm_num"]],["SetTheory/Ordinal/NaturalOps.lean",632,"case refine_2\na b c d : Ordinal.{u}\nx\u271d :\n  \u2203 a' < a,\n    \u2203 b' < b, \u2203 c' < c, d \u266f a' \u2a33 b' \u2a33 c \u266f a' \u2a33 b \u2a33 c' \u266f a \u2a33 b' \u2a33 c' \u2264 a' \u2a33 b \u2a33 c \u266f a \u2a33 b' \u2a33 c \u266f a \u2a33 b \u2a33 c' \u266f a' \u2a33 b' \u2a33 c'\na' : Ordinal.{u}\nha : a' < a\nb' : Ordinal.{u}\nhb : b' < b\nc' : Ordinal.{u}\nhc : c' < c\nh : d \u266f a' \u2a33 b' \u2a33 c \u266f a' \u2a33 b \u2a33 c' \u266f a \u2a33 b' \u2a33 c' \u2264 a' \u2a33 b \u2a33 c \u266f a \u2a33 b' \u2a33 c \u266f a \u2a33 b \u2a33 c' \u266f a' \u2a33 b' \u2a33 c'\nthis : d < a \u2a33 b \u2a33 c\n\u22a2 d < a \u2a33 b \u2a33 c",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Order/Rearrangement.lean",213,"case refine_1.a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : LinearOrderedSemiring \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : LinearOrderedCancelAddCommMonoid \u03b2\ninst\u271d\u00b9 : Module \u03b1 \u03b2\ninst\u271d : PosSMulStrictMono \u03b1 \u03b2\ns : Finset \u03b9\n\u03c3 : Perm \u03b9\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\nhfg : MonovaryOn f g \u2191s\nh\u03c3 : {x | \u03c3 x \u2260 x} \u2286 \u2191s\nh\u03c3inv : {x | \u03c3\u207b\u00b9 x \u2260 x} \u2286 \u2191s\n\u22a2 \u2211 x \u2208 s, f x \u2022 g ((Equiv.symm \u03c3) x) = \u2211 i \u2208 s, f i \u2022 g (\u03c3\u207b\u00b9 i)",["congr","aesop","tauto","abel"]],["GroupTheory/GroupAction/Hom.lean",142,"case mk.mk\nM' : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\n\u03c6 : M \u2192 N\n\u03c8 : N \u2192 P\n\u03c7 : M \u2192 P\nX : Type u_5\ninst\u271d\u2074 : SMul M X\ninst\u271d\u00b3 : SMul M' X\nY : Type u_6\ninst\u271d\u00b2 : SMul N Y\ninst\u271d\u00b9 : SMul M' Y\nZ : Type u_7\ninst\u271d : SMul P Z\ntoFun\u271d\u00b9 : X \u2192 Y\nmap_smul'\u271d\u00b9 : \u2200 (m : M) (x : X), toFun\u271d\u00b9 (m \u2022 x) = \u03c6 m \u2022 toFun\u271d\u00b9 x\ntoFun\u271d : X \u2192 Y\nmap_smul'\u271d : \u2200 (m : M) (x : X), toFun\u271d (m \u2022 x) = \u03c6 m \u2022 toFun\u271d x\nh : { toFun := toFun\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, map_smul' := map_smul'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 } = { toFun := toFun\u271d, map_smul' := map_smul'\u271d }",["congr","aesop"]],["GroupTheory/GroupAction/Hom.lean",420,"case mk.mk.mk.mk\nM : Type u_1\ninst\u271d\u00b9\u2074 : Monoid M\nN : Type u_2\ninst\u271d\u00b9\u00b3 : Monoid N\nP : Type u_3\ninst\u271d\u00b9\u00b2 : Monoid P\n\u03c6 : M \u2192* N\n\u03c6' : N \u2192* M\n\u03c8 : N \u2192* P\n\u03c7 : M \u2192* P\nA : Type u_4\ninst\u271d\u00b9\u00b9 : AddMonoid A\ninst\u271d\u00b9\u2070 : DistribMulAction M A\nB : Type u_5\ninst\u271d\u2079 : AddMonoid B\ninst\u271d\u2078 : DistribMulAction N B\nB\u2081 : Type u_6\ninst\u271d\u2077 : AddMonoid B\u2081\ninst\u271d\u2076 : DistribMulAction M B\u2081\nC : Type u_7\ninst\u271d\u2075 : AddMonoid C\ninst\u271d\u2074 : DistribMulAction P C\nA' : Type u_8\ninst\u271d\u00b3 : AddGroup A'\ninst\u271d\u00b2 : DistribMulAction M A'\nB' : Type u_9\ninst\u271d\u00b9 : AddGroup B'\ninst\u271d : DistribMulAction N B'\ntoFun\u271d\u00b9 : A \u2192 B\nmap_smul'\u271d\u00b9 : \u2200 (m : M) (x : A), toFun\u271d\u00b9 (m \u2022 x) = \u03c6 m \u2022 toFun\u271d\u00b9 x\nmap_zero'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun 0 = 0\nmap_add'\u271d\u00b9 :\n  \u2200 (x y : A),\n    { toFun := toFun\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun (x + y) =\n      { toFun := toFun\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun x + { toFun := toFun\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun y\ntoFun\u271d : A \u2192 B\nmap_smul'\u271d : \u2200 (m : M) (x : A), toFun\u271d (m \u2022 x) = \u03c6 m \u2022 toFun\u271d x\nmap_zero'\u271d : { toFun := toFun\u271d, map_smul' := map_smul'\u271d }.toFun 0 = 0\nmap_add'\u271d :\n  \u2200 (x y : A),\n    { toFun := toFun\u271d, map_smul' := map_smul'\u271d }.toFun (x + y) =\n      { toFun := toFun\u271d, map_smul' := map_smul'\u271d }.toFun x + { toFun := toFun\u271d, map_smul' := map_smul'\u271d }.toFun y\nh :\n  (fun m \u21a6 m.toFun) { toFun := toFun\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, map_add' := map_add'\u271d\u00b9 } =\n    (fun m \u21a6 m.toFun) { toFun := toFun\u271d, map_smul' := map_smul'\u271d, map_zero' := map_zero'\u271d, map_add' := map_add'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, map_add' := map_add'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_smul' := map_smul'\u271d, map_zero' := map_zero'\u271d, map_add' := map_add'\u271d }",["congr","aesop"]],["LinearAlgebra/Determinant.lean",335,"R : Type u_1\ninst\u271d : CommRing R\na : R\n\u22a2 LinearMap.det (mulLeft R a) = a",["simp","aesop","norm_num"]],["LinearAlgebra/Determinant.lean",644,"case inl\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhsp : \u22a4 \u2264 span R (Set.range v)\nk : \u03b9\n\u22a2 e.det v = \u2191e.det v",["congr","aesop","tauto","abel","norm_num","simp"]],["NumberTheory/Pell.lean",238,"case inr\nd : \u2124\na b : Solution\u2081 d\nha : 0 < a.x\nhb : 0 < b.x\nh : d < 0\n\u22a2 0 < 1 + d * 0 ^ 2 + d * 0 ^ 2",["simp","omega","aesop","linarith","norm_num"]],["NumberTheory/Pell.lean",301,"case refine_1\nd : \u2124\nh\u2080 : 0 < d\na : Solution\u2081 d\nhy : 0 \u2264 a.y\nhx : a.x < 0\n\u22a2 a.x < 0\n```\n---\n```lean\ncase refine_2\nd : \u2124\nh\u2080 : 0 < d\na : Solution\u2081 d\nhy : 0 \u2264 a.y\nhx : a.x < 0\n\u22a2 0 \u2264 a.y\n```\n---\n```lean\ncase refine_4\nd : \u2124\nh\u2080 : 0 < d\na : Solution\u2081 d\nhy : a.y \u2264 0\nhx : a.x < 0\n\u22a2 a.x < 0\n```\n---\n```lean\ncase refine_5\nd : \u2124\nh\u2080 : 0 < d\na : Solution\u2081 d\nhy : a.y \u2264 0\nhx : a.x < 0\n\u22a2 a.y \u2264 0\n```\n---\n```lean\ncase refine_8\nd : \u2124\nh\u2080 : 0 < d\na : Solution\u2081 d\nhy : a.y \u2264 0\nhx : a.x > 0\n\u22a2 a.y \u2264 0",["assumption","omega","aesop","congr","linarith","gcongr","tauto"]],["NumberTheory/Pell.lean",120,"d : \u2124\na : Solution\u2081 d\n\u22a2 a.x ^ 2 = a.x ^ 2 - d * a.y ^ 2 + d * a.y ^ 2",["ring","omega","aesop","linarith","abel","norm_num","simp"]],["NumberTheory/Pell.lean",123,"d : \u2124\na : Solution\u2081 d\n\u22a2 d * a.y ^ 2 = a.x ^ 2 - (a.x ^ 2 - d * a.y ^ 2)",["ring","omega","aesop","linarith","abel","norm_num","simp"]],["GroupTheory/HNNExtension.lean",424,"case pos\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nd : TransversalPair G A B\nu : \u2124\u02e3\nw : NormalWord d\nhcan : Cancels (-u) (unitsSMul \u03c6 u w)\nhncan : \u00acCancels u w\n\u22a2 \u2191(\u22ef.equiv w.head).1 \u2022 ((\u2191(\u22ef.equiv w.head).1)\u207b\u00b9 * w.head * w.head\u207b\u00b9) \u2022 w = w",["simp","aesop"]],["GroupTheory/HNNExtension.lean",73,"G : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nb : \u21a5B\n\u22a2 of \u2191b * t = of \u2191(\u03c6 (\u03c6.symm b)) * t",["simp","aesop"]],["GroupTheory/HNNExtension.lean",573,"case cons.h2.h.a\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nd : TransversalPair G A B\ng : G\nu : \u2124\u02e3\nw : NormalWord d\nh1 : w.head \u2208 d.set u\nh2 : \u2200 u' \u2208 Option.map Prod.fst w.toList.head?, w.head \u2208 toSubgroup A B u \u2192 u = u'\nih : ReducedWord.prod \u03c6 w.toReducedWord \u2022 empty = w\ni\u271d : \u2115\na\u271d : \u2124\u02e3 \u00d7 G\n\u22a2 ((u, (\u2191\u27e81, \u22ef\u27e9)\u207b\u00b9 * w.head) :: w.toList)[i\u271d]? = some a\u271d \u2194 ((u, w.head) :: w.toList)[i\u271d]? = some a\u271d",["simp","aesop"]],["GroupTheory/HNNExtension.lean",450,"case neg.cons.refl.h2\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nd : TransversalPair G A B\nu : \u2124\u02e3\ng : G\nw : NormalWord d\nh1 : w.head \u2208 d.set { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef }\nh2 :\n  \u2200 u' \u2208 Option.map Prod.fst w.toList.head?,\n    w.head \u2208 toSubgroup A B { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef } \u2192\n      { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef } = u'\nhcan\u271d :\n  \u00acCancels (-u)\n      (if h : Cancels u (cons g { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef } w h1 h2) then\n        unitsSMulWithCancel \u03c6 u (cons g { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef } w h1 h2) h\n      else\n        let g' := unitsSMulGroup \u03c6 d u (cons g { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef } w h1 h2).head;\n        cons (\u2191g'.1) u\n          ((\u2191g'.2 * (cons g { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef } w h1 h2).head\u207b\u00b9) \u2022\n            cons g { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef } w h1 h2)\n          \u22ef \u22ef)\nhcan2 : Cancels u (cons g { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef } w h1 h2)\nhcan :\n  \u00acCancels (-u) (unitsSMulWithCancel \u03c6 u (cons g { val := -\u2191u, inv := -\u2191u\u207b\u00b9, val_inv := \u22ef, inv_val := \u22ef } w h1 h2) hcan2)\nthis : (\u22ef.equiv w.head).1 = 1\n\u22a2 (\u21911)\u207b\u00b9 * w.head = w.head",["simp"]],["GroupTheory/HNNExtension.lean",553,"case inv\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nd : TransversalPair G A B\nx : HNNExtension G A B \u03c6\nih : \u2200 (w : NormalWord d), ReducedWord.prod \u03c6 (x \u2022 w).toReducedWord = x * ReducedWord.prod \u03c6 w.toReducedWord\nw : NormalWord d\n\u22a2 ReducedWord.prod \u03c6 (x \u2022 x\u207b\u00b9 \u2022 w).toReducedWord = x * (x\u207b\u00b9 * ReducedWord.prod \u03c6 w.toReducedWord)",["simp","aesop"]],["GroupTheory/HNNExtension.lean",236,"G : Type u_1\ninst\u271d\u00b2 : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nH : Type u_2\ninst\u271d\u00b9 : Group H\nM : Type u_3\ninst\u271d : Monoid M\nd : TransversalPair G A B\n\u22a2 \u2200 (u : \u2124\u02e3) (g : G), (u, g) \u2208 { head := 1, toList := [], chain := \u22ef }.toList \u2192 g \u2208 d.set u",["simp","aesop","tauto"]],["GroupTheory/HNNExtension.lean",81,"G : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nb : \u21a5B\n\u22a2 of \u2191(\u03c6.symm b) = t\u207b\u00b9 * (t * of \u2191(\u03c6.symm b))",["simp","aesop"]],["GroupTheory/HNNExtension.lean",360,"G : Type u_1\ninst\u271d\u00b2 : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nH : Type u_2\ninst\u271d\u00b9 : Group H\nM : Type u_3\ninst\u271d : Monoid M\nd : TransversalPair G A B\nu : \u2124\u02e3\nw : NormalWord d\n\u22a2 (g : G) \u2192 g \u2208 toSubgroup A B u \u2227 none = some (-u) \u2192 NormalWord d",["tauto","aesop"]],["LinearAlgebra/AffineSpace/AffineMap.lean",140,"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V1\ninst\u271d\u2074 : Module k V1\ninst\u271d\u00b3 : AffineSpace V1 P1\ninst\u271d\u00b2 : AddCommGroup V2\ninst\u271d\u00b9 : Module k V2\ninst\u271d : AffineSpace V2 P2\nf g : P1 \u2192\u1d43[k] P2\nh\u2081 : f.linear = g.linear\np : P1\nh\u2082 : f p = g p\nq : P1\n\u22a2 g.linear (q -\u1d65 p) = g.toFun ((q -\u1d65 p) +\u1d65 q) -\u1d65 g.toFun q",["simp","aesop","norm_num"]],["LinearAlgebra/AffineSpace/AffineMap.lean",663,"R : Type u_1\nk : Type u_2\nV1 : Type u_3\nP1 : Type u_4\nV2 : Type u_5\nP2 : Type u_6\nV3 : Type u_7\nP3 : Type u_8\ninst\u271d\u00b9\u00b2 : Ring k\ninst\u271d\u00b9\u00b9 : AddCommGroup V1\ninst\u271d\u00b9\u2070 : AffineSpace V1 P1\ninst\u271d\u2079 : AddCommGroup V2\ninst\u271d\u2078 : AffineSpace V2 P2\ninst\u271d\u2077 : AddCommGroup V3\ninst\u271d\u2076 : AffineSpace V3 P3\ninst\u271d\u2075 : Module k V1\ninst\u271d\u2074 : Module k V2\ninst\u271d\u00b3 : Module k V3\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Module R V2\ninst\u271d : SMulCommClass k R V2\n\u22a2 \u2200 (x y : V1 \u2192\u1d43[k] V2), (fun f \u21a6 (f 0, f.linear)) (x + y) = (fun f \u21a6 (f 0, f.linear)) x + (fun f \u21a6 (f 0, f.linear)) y",["simp","aesop","tauto","norm_num"]],["Data/Sym/Sym2.lean",366,"case mpr\n\u03b1 : Type u_1\nx y : \u03b1\nhne : x \u2260 y\n\u22a2 x \u2208 s(x, y) \u2227 y \u2208 s(x, y)",["simp","aesop"]],["Data/Sym/Sym2.lean",84,"\u03b1 : Type u_1\nx y z w : \u03b1\n\u22a2 Rel \u03b1 (x, y) (z, w) \u2194 x = z \u2227 y = w \u2228 x = w \u2227 y = z",["simp","aesop"]],["Data/Sym/Sym2.lean",557,"\u03b1 : Type u_1\nz : Sym2 \u03b1\n\u22a2 \u2200 (x y : \u03b1), s(x, y) \u2208 fromRel \u22ef \u2194 s(x, y) \u2208 {z | \u00acz.IsDiag}",["simp","aesop","tauto"]],["Data/Sym/Sym2.lean",246,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ng : \u03b2 \u2192 \u03b3\nf : \u03b1 \u2192 \u03b2\nx\u271d y\u271d : \u03b1\n\u22a2 map g (map f s(x\u271d, y\u271d)) = map (g \u2218 f) s(x\u271d, y\u271d)",["aesop","congr","tauto"]],["Data/Sym/Sym2.lean",296,"case intro\n\u03b1 : Type u_1\na b c w\u271d : \u03b1\nh : b = a \u2227 c = w\u271d \u2228 b = w\u271d \u2227 c = a\n\u22a2 a = b \u2228 a = c",["aesop","tauto"]],["Data/Sym/Sym2.lean",311,"case h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx y x' y' : \u03b1\nh : \u2200 (x_1 : \u03b1), Sym2.Mem x_1 s(x, y) \u2194 Sym2.Mem x_1 s(x', y')\nhx : True \u2228 x = y \u2194 x = x' \u2228 x = y'\nhy : y = x \u2228 True \u2194 y = x' \u2228 y = y'\nhx' : x' = x \u2228 x' = y \u2194 True \u2228 x' = y'\nhy' : y' = x \u2228 y' = y \u2194 y' = x' \u2228 True\n\u22a2 s(x, y) = s(x', y')",["aesop","tauto"]],["Data/Sym/Sym2.lean",381,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nx y : \u03b1\n\u22a2 b = f x \u2228 b = f y \u2194 f x = b \u2228 f y = b",["aesop","tauto"]],["Data/Sym/Sym2.lean",614,"\u03b1 : Type u_1\na\u2081 b\u2081 a\u2082 b\u2082 : \u03b1\n\u22a2 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082 \u2228 \u00aca\u2081 = a\u2082 \u2227 b\u2081 = a\u2082 \u2227 b\u2082 = a\u2081 \u2192 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082 \u2228 a\u2081 = b\u2082 \u2227 b\u2081 = a\u2082",["tauto","aesop"]],["RingTheory/Polynomial/Chebyshev.lean",385,"R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Invertible 2\nn : \u2124\nthis : C R n = 2 * (T R n).comp (Polynomial.C \u215f 2 * X)\n\u22a2 C R n = 2 * (T R n).comp (Polynomial.C \u215f 2 * X)",["assumption","aesop","congr","gcongr","tauto"]],["RingTheory/Polynomial/Chebyshev.lean",513,"R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Invertible 2\nn : \u2124\nthis : S R n = (U R n).comp (Polynomial.C \u215f 2 * X)\n\u22a2 S R n = (U R n).comp (Polynomial.C \u215f 2 * X)",["assumption","aesop","congr","gcongr","tauto"]],["Order/Minimal.lean",75,"case mk\n\u03b1 : Type u_1\nP Q : \u03b1 \u2192 Prop\ninst\u271d : LE \u03b1\nx : \u03b1\nhx : Q x\n\u22a2 (P x \u2227 \u2200 (a : \u03b1), Q a \u2192 P a \u2192 a \u2264 x \u2192 x \u2264 a) \u2194 (P x \u2227 Q x) \u2227 \u2200 \u2983y : \u03b1\u2984, P y \u2227 Q y \u2192 y \u2264 x \u2192 x \u2264 y",["tauto","aesop"]],["RingTheory/Algebraic/Basic.lean",114,"case h.e'_3.h\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nh : \u00acFunction.Injective \u21d1(algebraMap R A)\na : A\ninj : Function.Injective \u21d1(aeval a)\nx\u271d : R\n\u22a2 (algebraMap R A) x\u271d = (\u21d1(aeval a) \u2218 \u21d1C) x\u271d",["simp","aesop","norm_num"]],["RingTheory/Algebraic/Basic.lean",641,"case intro.intro.refine_1\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nA : Subalgebra K L\nx : \u21a5A\np : K[X]\nh : 0 \u2260 0\n\u22a2 (aeval x) 0 = 0 \u2192 (\u2191x)\u207b\u00b9 \u2208 A",["contradiction","aesop","tauto"]],["GroupTheory/PushoutI.lean",67,"\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_2\nH : Type u_3\nK : Type u_4\ninst\u271d\u00b2 : Monoid K\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Monoid (G i)\ninst\u271d : Monoid H\n\u03c6 : (i : \u03b9) \u2192 H \u2192* G i\n\u22a2 Mul (con \u03c6).Quotient",["infer_instance","tauto"]],["GroupTheory/PushoutI.lean",358,"case refine_1.left.intro\n\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_2\nH : Type u_3\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Group (G i)\ninst\u271d\u00b2 : Group H\n\u03c6 : (i : \u03b9) \u2192 H \u2192* G i\nd : Transversal \u03c6\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (G i)\nw : Word G\ni : \u03b9\nh : H\nhw : \u2200 (i : \u03b9) (g : G i), \u27e8i, g\u27e9 \u2208 w.toList \u2192 \u2191(\u22ef.equiv g).2 = g\nh\u03c6w : \u2200 (j : \u03b9) (g : G j), \u27e8j, g\u27e9 \u2208 (CoprodI.of ((\u03c6 i) h) \u2022 w).toList \u2192 \u2191(\u22ef.equiv g).2 = g\nhhead : \u2191(\u22ef.equiv ((Word.equivPair i) w).head).2 = ((Word.equivPair i) w).head\nhh1 : \u00ach = 1\nh\u2082 : ((Word.equivPair i) w).head = 1\nh\u2081 : h = 1\n\u22a2 False",["contradiction","aesop","tauto"]],["Probability/Moments/IntegrableExpMul.lean",404,"case h.e'_6.h\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt : \u211d\nht : t \u2260 0\nht_int_pos : Integrable (fun \u03c9 \u21a6 rexp (t * X \u03c9)) \u03bc\nht_int_neg : Integrable (fun \u03c9 \u21a6 rexp (-t * X \u03c9)) \u03bc\nn : \u2115\n\u03c9 : \u03a9\n\u22a2 X \u03c9 ^ n = X \u03c9 ^ \u2191n",["simp","aesop","norm_num"]],["Probability/Moments/IntegrableExpMul.lean",511,"case h.e'_6.h\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nh : 0 \u2208 interior (integrableExpSet X \u03bc)\nn : \u2115\nx\u271d : \u03a9\n\u22a2 |X x\u271d| ^ n = |X x\u271d| ^ n * rexp (0 * X x\u271d)",["simp","aesop","norm_num"]],["Probability/Moments/IntegrableExpMul.lean",495,"case h.e'_6.h.h.e'_5\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nv : \u211d\nhv : v \u2208 interior (integrableExpSet X \u03bc)\nn : \u2115\n\u03c9 : \u03a9\n\u22a2 X \u03c9 ^ n = X \u03c9 ^ \u2191n",["simp","aesop","norm_num"]],["Probability/Moments/IntegrableExpMul.lean",417,"l u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < (v - l) \u2293 (u - v)\n\u22a2 v + (u - v) = u",["abel","ring","aesop","linarith","norm_num","simp"]],["Probability/Moments/IntegrableExpMul.lean",423,"l u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < (v - l) \u2293 (u - v)\n\u22a2 l = v - (v - l)",["abel","ring","aesop","linarith","norm_num","simp"]],["Probability/Moments/IntegrableExpMul.lean",415,"l u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < (v - l) \u2293 (u - v)\n\u22a2 0 < (v - l) \u2293 (u - v)",["positivity","aesop","congr","linarith","gcongr","tauto","assumption"]],["Probability/Moments/IntegrableExpMul.lean",425,"l u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < (v - l) \u2293 (u - v)\n\u22a2 0 < (v - l) \u2293 (u - v)",["positivity","aesop","congr","linarith","gcongr","tauto","assumption"]],["Analysis/Normed/Group/Seminorm.lean",178,"case mk.mk\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst\u271d\u00b2 : Group E\ninst\u271d\u00b9 : Group F\ninst\u271d : Group G\np q : GroupSeminorm E\ntoFun\u271d\u00b9 : E \u2192 \u211d\nmap_one'\u271d\u00b9 : toFun\u271d\u00b9 1 = 0\nmul_le'\u271d\u00b9 : \u2200 (x y : E), toFun\u271d\u00b9 (x * y) \u2264 toFun\u271d\u00b9 x + toFun\u271d\u00b9 y\ninv'\u271d\u00b9 : \u2200 (x : E), toFun\u271d\u00b9 x\u207b\u00b9 = toFun\u271d\u00b9 x\ntoFun\u271d : E \u2192 \u211d\nmap_one'\u271d : toFun\u271d 1 = 0\nmul_le'\u271d : \u2200 (x y : E), toFun\u271d (x * y) \u2264 toFun\u271d x + toFun\u271d y\ninv'\u271d : \u2200 (x : E), toFun\u271d x\u207b\u00b9 = toFun\u271d x\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9, mul_le' := mul_le'\u271d\u00b9, inv' := inv'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, map_one' := map_one'\u271d, mul_le' := mul_le'\u271d, inv' := inv'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_one' := map_one'\u271d\u00b9, mul_le' := mul_le'\u271d\u00b9, inv' := inv'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_one' := map_one'\u271d, mul_le' := mul_le'\u271d, inv' := inv'\u271d }",["congr","aesop"]],["Analysis/Normed/Group/Seminorm.lean",437,"case mk.mk.mk\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst\u271d : AddGroup E\np q : NonarchAddGroupSeminorm E\ntoFun\u271d : E \u2192 \u211d\nmap_zero'\u271d : toFun\u271d 0 = 0\nadd_le_max'\u271d\u00b9 :\n  \u2200 (r s : E),\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun (r + s) \u2264\n      { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun r \u2294 { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun s\nneg'\u271d\u00b9 :\n  \u2200 (r : E),\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun (-r) = { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun r\ntoZeroHom\u271d : ZeroHom E \u211d\nadd_le_max'\u271d : \u2200 (r s : E), toZeroHom\u271d.toFun (r + s) \u2264 toZeroHom\u271d.toFun r \u2294 toZeroHom\u271d.toFun s\nneg'\u271d : \u2200 (r : E), toZeroHom\u271d.toFun (-r) = toZeroHom\u271d.toFun r\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d, map_zero' := map_zero'\u271d, add_le_max' := add_le_max'\u271d\u00b9, neg' := neg'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toZeroHom := toZeroHom\u271d, add_le_max' := add_le_max'\u271d, neg' := neg'\u271d }\n\u22a2 { toFun := toFun\u271d, map_zero' := map_zero'\u271d, add_le_max' := add_le_max'\u271d\u00b9, neg' := neg'\u271d\u00b9 } =\n    { toZeroHom := toZeroHom\u271d, add_le_max' := add_le_max'\u271d, neg' := neg'\u271d }",["congr","aesop"]],["Analysis/Normed/Group/Seminorm.lean",651,"case mk.mk.mk\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst\u271d : Group E\np q : GroupNorm E\ntoFun\u271d : E \u2192 \u211d\nmap_one'\u271d : toFun\u271d 1 = 0\nmul_le'\u271d : \u2200 (x y : E), toFun\u271d (x * y) \u2264 toFun\u271d x + toFun\u271d y\ninv'\u271d : \u2200 (x : E), toFun\u271d x\u207b\u00b9 = toFun\u271d x\neq_one_of_map_eq_zero'\u271d\u00b9 :\n  \u2200 (x : E), { toFun := toFun\u271d, map_one' := map_one'\u271d, mul_le' := mul_le'\u271d, inv' := inv'\u271d }.toFun x = 0 \u2192 x = 1\ntoGroupSeminorm\u271d : GroupSeminorm E\neq_one_of_map_eq_zero'\u271d : \u2200 (x : E), toGroupSeminorm\u271d.toFun x = 0 \u2192 x = 1\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d, map_one' := map_one'\u271d, mul_le' := mul_le'\u271d, inv' := inv'\u271d,\n        eq_one_of_map_eq_zero' := eq_one_of_map_eq_zero'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toGroupSeminorm := toGroupSeminorm\u271d, eq_one_of_map_eq_zero' := eq_one_of_map_eq_zero'\u271d }\n\u22a2 { toFun := toFun\u271d, map_one' := map_one'\u271d, mul_le' := mul_le'\u271d, inv' := inv'\u271d,\n      eq_one_of_map_eq_zero' := eq_one_of_map_eq_zero'\u271d\u00b9 } =\n    { toGroupSeminorm := toGroupSeminorm\u271d, eq_one_of_map_eq_zero' := eq_one_of_map_eq_zero'\u271d }",["congr","aesop"]],["Analysis/Normed/Group/Seminorm.lean",776,"case mk.mk.mk.mk\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst\u271d : AddGroup E\np q : NonarchAddGroupNorm E\ntoFun\u271d : E \u2192 \u211d\nmap_zero'\u271d : toFun\u271d 0 = 0\nadd_le_max'\u271d :\n  \u2200 (r s : E),\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun (r + s) \u2264\n      { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun r \u2294 { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun s\nneg'\u271d :\n  \u2200 (r : E),\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun (-r) = { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun r\neq_zero_of_map_eq_zero'\u271d\u00b9 :\n  \u2200 (x : E), { toFun := toFun\u271d, map_zero' := map_zero'\u271d, add_le_max' := add_le_max'\u271d, neg' := neg'\u271d }.toFun x = 0 \u2192 x = 0\ntoNonarchAddGroupSeminorm\u271d : NonarchAddGroupSeminorm E\neq_zero_of_map_eq_zero'\u271d : \u2200 (x : E), toNonarchAddGroupSeminorm\u271d.toFun x = 0 \u2192 x = 0\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d, map_zero' := map_zero'\u271d, add_le_max' := add_le_max'\u271d, neg' := neg'\u271d,\n        eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun)\n      { toNonarchAddGroupSeminorm := toNonarchAddGroupSeminorm\u271d, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d }\n\u22a2 { toFun := toFun\u271d, map_zero' := map_zero'\u271d, add_le_max' := add_le_max'\u271d, neg' := neg'\u271d,\n      eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d\u00b9 } =\n    { toNonarchAddGroupSeminorm := toNonarchAddGroupSeminorm\u271d, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d }",["congr","aesop"]],["Algebra/Algebra/Quasispectrum.lean",171,"R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\nx y : \u21a5(unitsFstOne R A)\n\u22a2 equiv.symm\n      \u2191({ toFun := fun x \u21a6 { val := equiv (\u2191\u2191x).snd, inv := equiv (\u2191\u2191x\u207b\u00b9).snd, val_inv := \u22ef, inv_val := \u22ef },\n              invFun := fun x \u21a6\n                \u27e8{ val := 1 + \u2191(equiv.symm \u2191x), inv := 1 + \u2191(equiv.symm \u2191x\u207b\u00b9), val_inv := \u22ef, inv_val := \u22ef }, \u22ef\u27e9,\n              left_inv := \u22ef, right_inv := \u22ef }.toFun\n          (x * y)) =\n    equiv.symm\n      \u2191({ toFun := fun x \u21a6 { val := equiv (\u2191\u2191x).snd, inv := equiv (\u2191\u2191x\u207b\u00b9).snd, val_inv := \u22ef, inv_val := \u22ef },\n                invFun := fun x \u21a6\n                  \u27e8{ val := 1 + \u2191(equiv.symm \u2191x), inv := 1 + \u2191(equiv.symm \u2191x\u207b\u00b9), val_inv := \u22ef, inv_val := \u22ef }, \u22ef\u27e9,\n                left_inv := \u22ef, right_inv := \u22ef }.toFun\n            x *\n          { toFun := fun x \u21a6 { val := equiv (\u2191\u2191x).snd, inv := equiv (\u2191\u2191x\u207b\u00b9).snd, val_inv := \u22ef, inv_val := \u22ef },\n                invFun := fun x \u21a6\n                  \u27e8{ val := 1 + \u2191(equiv.symm \u2191x), inv := 1 + \u2191(equiv.symm \u2191x\u207b\u00b9), val_inv := \u22ef, inv_val := \u22ef }, \u22ef\u27e9,\n                left_inv := \u22ef, right_inv := \u22ef }.toFun\n            y)",["simp","aesop","norm_num"]],["Algebra/Algebra/Quasispectrum.lean",198,"case mpr.intro.intro.refine_1.a\nR : Type u_1\ninst\u271d : NonUnitalSemiring R\nx y : R\nhy\u2081 : y + x + x * y = 0\nhy\u2082 : x + y + y * x = 0\n\u22a2 equiv.symm (equiv x * equiv y) = equiv.symm 1\n```\n---\n```lean\ncase mpr.intro.intro.refine_2.a\nR : Type u_1\ninst\u271d : NonUnitalSemiring R\nx y : R\nhy\u2081 : y + x + x * y = 0\nhy\u2082 : x + y + y * x = 0\n\u22a2 equiv.symm (equiv y * equiv x) = equiv.symm 1",["assumption","aesop","tauto"]],["Combinatorics/Enumerative/IncidenceAlgebra.lean",92,"case mk.mk\nF : Type u_1\n\ud835\udd5c : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5e : Type u_4\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b9 : Zero \ud835\udd5c\ninst\u271d : LE \u03b1\na b : \u03b1\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b1 \u2192 \ud835\udd5c\neq_zero_of_not_le'\u271d\u00b9 : \u2200 \u2983a b : \u03b1\u2984, \u00aca \u2264 b \u2192 toFun\u271d\u00b9 a b = 0\ntoFun\u271d : \u03b1 \u2192 \u03b1 \u2192 \ud835\udd5c\neq_zero_of_not_le'\u271d : \u2200 \u2983a b : \u03b1\u2984, \u00aca \u2264 b \u2192 toFun\u271d a b = 0\nh :\n  { toFun := toFun\u271d\u00b9, eq_zero_of_not_le' := eq_zero_of_not_le'\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, eq_zero_of_not_le' := eq_zero_of_not_le'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, eq_zero_of_not_le' := eq_zero_of_not_le'\u271d\u00b9 } =\n    { toFun := toFun\u271d, eq_zero_of_not_le' := eq_zero_of_not_le'\u271d }",["congr","aesop"]],["Order/Hom/CompleteLattice.lean",237,"case mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : SupSet \u03b1\ninst\u271d\u00b2 : SupSet \u03b2\ninst\u271d\u00b9 : SupSet \u03b3\ninst\u271d : SupSet \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_sSup'\u271d\u00b9 : \u2200 (s : Set \u03b1), toFun\u271d\u00b9 (sSup s) = sSup (toFun\u271d\u00b9 '' s)\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_sSup'\u271d : \u2200 (s : Set \u03b1), toFun\u271d (sSup s) = sSup (toFun\u271d '' s)\nh : { toFun := toFun\u271d\u00b9, map_sSup' := map_sSup'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, map_sSup' := map_sSup'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_sSup' := map_sSup'\u271d\u00b9 } = { toFun := toFun\u271d, map_sSup' := map_sSup'\u271d }",["congr","aesop"]],["Order/Hom/CompleteLattice.lean",358,"case mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : InfSet \u03b1\ninst\u271d\u00b2 : InfSet \u03b2\ninst\u271d\u00b9 : InfSet \u03b3\ninst\u271d : InfSet \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_sInf'\u271d\u00b9 : \u2200 (s : Set \u03b1), toFun\u271d\u00b9 (sInf s) = sInf (toFun\u271d\u00b9 '' s)\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_sInf'\u271d : \u2200 (s : Set \u03b1), toFun\u271d (sInf s) = sInf (toFun\u271d '' s)\nh : { toFun := toFun\u271d\u00b9, map_sInf' := map_sInf'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, map_sInf' := map_sInf'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_sInf' := map_sInf'\u271d\u00b9 } = { toFun := toFun\u271d, map_sInf' := map_sInf'\u271d }",["congr","aesop"]],["Order/Hom/CompleteLattice.lean",478,"case mk.mk.mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b2\ninst\u271d\u00b9 : CompleteLattice \u03b3\ninst\u271d : CompleteLattice \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_inf'\u271d\u00b9 : \u2200 (a b : \u03b1), toFun\u271d\u00b9 (a \u2293 b) = toFun\u271d\u00b9 a \u2293 toFun\u271d\u00b9 b\nmap_top'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9 }.toFun \u22a4 = \u22a4\nmap_sSup'\u271d\u00b9 :\n  \u2200 (s : Set \u03b1),\n    { toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9, map_top' := map_top'\u271d\u00b9 }.toFun (sSup s) =\n      sSup ({ toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9, map_top' := map_top'\u271d\u00b9 }.toFun '' s)\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_inf'\u271d : \u2200 (a b : \u03b1), toFun\u271d (a \u2293 b) = toFun\u271d a \u2293 toFun\u271d b\nmap_top'\u271d : { toFun := toFun\u271d, map_inf' := map_inf'\u271d }.toFun \u22a4 = \u22a4\nmap_sSup'\u271d :\n  \u2200 (s : Set \u03b1),\n    { toFun := toFun\u271d, map_inf' := map_inf'\u271d, map_top' := map_top'\u271d }.toFun (sSup s) =\n      sSup ({ toFun := toFun\u271d, map_inf' := map_inf'\u271d, map_top' := map_top'\u271d }.toFun '' s)\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9, map_top' := map_top'\u271d\u00b9, map_sSup' := map_sSup'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, map_inf' := map_inf'\u271d, map_top' := map_top'\u271d, map_sSup' := map_sSup'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_inf' := map_inf'\u271d\u00b9, map_top' := map_top'\u271d\u00b9, map_sSup' := map_sSup'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_inf' := map_inf'\u271d, map_top' := map_top'\u271d, map_sSup' := map_sSup'\u271d }",["congr","aesop"]],["Order/Hom/CompleteLattice.lean",579,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b2\ninst\u271d\u00b9 : CompleteLattice \u03b3\ninst\u271d : CompleteLattice \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_sInf'\u271d\u00b9 : \u2200 (s : Set \u03b1), toFun\u271d\u00b9 (sInf s) = sInf (toFun\u271d\u00b9 '' s)\nmap_sSup'\u271d\u00b9 :\n  \u2200 (s : Set \u03b1),\n    { toFun := toFun\u271d\u00b9, map_sInf' := map_sInf'\u271d\u00b9 }.toFun (sSup s) =\n      sSup ({ toFun := toFun\u271d\u00b9, map_sInf' := map_sInf'\u271d\u00b9 }.toFun '' s)\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_sInf'\u271d : \u2200 (s : Set \u03b1), toFun\u271d (sInf s) = sInf (toFun\u271d '' s)\nmap_sSup'\u271d :\n  \u2200 (s : Set \u03b1),\n    { toFun := toFun\u271d, map_sInf' := map_sInf'\u271d }.toFun (sSup s) =\n      sSup ({ toFun := toFun\u271d, map_sInf' := map_sInf'\u271d }.toFun '' s)\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, map_sInf' := map_sInf'\u271d\u00b9, map_sSup' := map_sSup'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, map_sInf' := map_sInf'\u271d, map_sSup' := map_sSup'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_sInf' := map_sInf'\u271d\u00b9, map_sSup' := map_sSup'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_sInf' := map_sInf'\u271d, map_sSup' := map_sSup'\u271d }",["congr","aesop"]],["GroupTheory/Perm/Sign.lean",617,"\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\n\u03c3 : Perm \u03b1\nh\u03c3 : sign \u03c3 = 1\nh\u03c4 : sign \u03c3 = -1\nthis : 1 = -1\n\u22a2 False",["contradiction","tauto","infer_instance"]],["Analysis/NormedSpace/Multilinear/Curry.lean",411,"\ud835\udd5c : Type u\nG : Type wG\nG' : Type wG'\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf : ContinuousMultilinearMap \ud835\udd5c (fun i \u21a6 G) G'\n\u22a2 \u2016f.curry0\u2016 = \u2016f\u2016",["simp"]],["NumberTheory/LSeries/HurwitzZetaOdd.lean",305,"a : UnitAddCircle\n\u22a2 0 < 3 / 2",["norm_num","aesop","linarith","positivity","simp"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",267,"s : \u2102\nhs : 0 < s.re\nn : \u2115\nhn : n \u2260 0\nthis\u271d : \u2200 (x : \u211d), x = x / \u2191n * \u2191n\nthis :\n  \u222b (x : \u211d) in 0 ..\u2191n, \u2191((1 - x / \u2191n) ^ n) * \u2191(x / \u2191n * \u2191n) ^ (s - 1) =\n    \u2191n \u2022 \u222b (x : \u211d) in 0 / \u2191n..\u2191n / \u2191n, \u2191((1 - x) ^ n) * \u2191(x * \u2191n) ^ (s - 1)\nx : \u211d\nhx : x \u2208 Ioc 0 1\nhn' : \u2191n \u2260 0\n\u22a2 \u2191n ^ (s - 1) * \u2191n ^ 1 = \u2191n ^ (s - 1) * \u2191n",["simp","norm_num"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",517,"case intro.zero\nm : \u2115\nhs : 0 < (-\u2191m).re\n\u22a2 (-\u2191m).re \u2264 0",["simp","aesop","norm_num"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",206,"case zero\nu : \u2102\nhu : 0 < u.re\n\u22a2 1 / u = 1 / \u220f j \u2208 Finset.range (0 + 1), (u + \u2191j)",["simp","aesop","norm_num"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",177,"case h.e'_9\nu v : \u2102\nhu : 0 < u.re\nhv : 0 < v.re\nF : \u211d \u2192 \u2102 := fun x \u21a6 \u2191x ^ u * (1 - \u2191x) ^ v\nhu' : 0 < (u + 1).re\nhv' : 0 < (v + 1).re\nhc : ContinuousOn F (Icc 0 1)\nx : \u211d\nhx : x \u2208 Ioo 0 1\nU : HasDerivAt (fun y \u21a6 y ^ u) (u * \u2191x ^ (u - 1)) \u2191x\nA : HasDerivAt (fun x \u21a6 x ^ v) (v * (1 - \u2191x) ^ (v - 1) * 1) (1 - \u2191x)\nB : HasDerivAt (fun y \u21a6 1 - y) (-1) \u2191x\n\u22a2 -v * (1 - \u2191x) ^ (v - 1) = v * (1 - \u2191x) ^ (v - 1) * 1 * -1",["ring","aesop","norm_num","simp"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",197,"case h.e'_3.h.h.e'_6.h.e'_6\nu v : \u2102\nhu : 0 < u.re\nhv : 0 < v.re\nF : \u211d \u2192 \u2102 := fun x \u21a6 \u2191x ^ u * (1 - \u2191x) ^ v\nhu' : 0 < (u + 1).re\nhv' : 0 < (v + 1).re\nhc : ContinuousOn F (Icc 0 1)\nhder : \u2200 x \u2208 Ioo 0 1, HasDerivAt F (u * (\u2191x ^ (u - 1) * (1 - \u2191x) ^ v) - v * (\u2191x ^ u * (1 - \u2191x) ^ (v - 1))) x\nh_int : IntervalIntegrable (fun x \u21a6 u * (\u2191x ^ (u - 1) * (1 - \u2191x) ^ v) - v * (\u2191x ^ u * (1 - \u2191x) ^ (v - 1))) volume 0 1\nint_ev : \u222b (y : \u211d) in 0 ..1, u * (\u2191y ^ (u - 1) * (1 - \u2191y) ^ v) - v * (\u2191y ^ u * (1 - \u2191y) ^ (v - 1)) = 0\nhF0 : F 0 = 0\nhF1 : F 1 = 0\nx\u271d : \u211d\n\u22a2 v = v + 1 - 1",["ring","aesop","abel","norm_num","simp"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",199,"case h.e'_3.h.h.e'_5.h.e'_6\nu v : \u2102\nhu : 0 < u.re\nhv : 0 < v.re\nF : \u211d \u2192 \u2102 := fun x \u21a6 \u2191x ^ u * (1 - \u2191x) ^ v\nhu' : 0 < (u + 1).re\nhv' : 0 < (v + 1).re\nhc : ContinuousOn F (Icc 0 1)\nhder : \u2200 x \u2208 Ioo 0 1, HasDerivAt F (u * (\u2191x ^ (u - 1) * (1 - \u2191x) ^ v) - v * (\u2191x ^ u * (1 - \u2191x) ^ (v - 1))) x\nh_int : IntervalIntegrable (fun x \u21a6 u * (\u2191x ^ (u - 1) * (1 - \u2191x) ^ v) - v * (\u2191x ^ u * (1 - \u2191x) ^ (v - 1))) volume 0 1\nint_ev : \u222b (y : \u211d) in 0 ..1, u * (\u2191y ^ (u - 1) * (1 - \u2191y) ^ v) - v * (\u2191y ^ u * (1 - \u2191y) ^ (v - 1)) = 0\nhF0 : F 0 = 0\nhF1 : F 1 = 0\nx\u271d : \u211d\n\u22a2 u = u + 1 - 1",["ring","aesop","abel","norm_num","simp"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",375,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\n\u03b1 : Cochain F K (-1)\n\u03b2 : G \u27f6 K\neq : \u03b4 (-1) 0 \u03b1 = Cochain.ofHom (\u03c6 \u226b \u03b2)\n\u22a2 (inl \u03c6).comp (Cochain.ofHom (desc \u03c6 \u03b1 \u03b2 eq)) \u22ef = \u03b1",["simp","aesop","norm_num"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",497,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\n\u03b1 : Cocycle K F 1\n\u03b2 : Cochain K G 0\neq : \u03b4 0 1 \u03b2 + (\u2191\u03b1).comp (Cochain.ofHom \u03c6) \u22ef = 0\n\u22a2 (Cochain.ofHom (lift \u03c6 \u03b1 \u03b2 eq)).comp (snd \u03c6) \u22ef = \u03b2",["simp","aesop","norm_num"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",39,"C : Type u_1\nD : Type u_2\ninst\u271d\u2076 : Category.{u_4, u_1} C\ninst\u271d\u2075 : Category.{?u.268, u_2} D\ninst\u271d\u2074 : Preadditive C\ninst\u271d\u00b3 : Preadditive D\n\u03b9 : Type u_3\ninst\u271d\u00b2 : AddRightCancelSemigroup \u03b9\ninst\u271d\u00b9 : One \u03b9\nF G : CochainComplex C \u03b9\n\u03c6 : F \u27f6 G\ninst\u271d : \u2200 (p : \u03b9), HasBinaryBiproduct (F.X (p + 1)) (G.X p)\ni : \u03b9\n\u22a2 HasBinaryBiproduct (F.X (i + 1)) (G.X i)",["infer_instance","aesop","tauto"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",322,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : Cochain F K m\n\u03b2 : Cochain G K n\nh : m + 1 = n\np\u2081 p\u2082 : \u2124\nh\u2081\u2082 : p\u2081 + n = p\u2082\n\u22a2 p\u2081 + n = p\u2082",["omega","aesop","congr","linarith","gcongr","tauto","assumption"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",437,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : Cochain K F m\n\u03b2 : Cochain K G n\nh : n + 1 = m\np\u2081 p\u2082 : \u2124\nh\u2081\u2082 : p\u2081 + n = p\u2082\n\u22a2 p\u2081 + n = p\u2082",["omega","aesop","congr","linarith","gcongr","tauto","assumption"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",159,"case mp\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\ni j : \u2124\nhij : i + 1 = j\nA : C\nf : A \u27f6 (mappingCone \u03c6).X i\n\u22a2 f \u226b (\u2191(fst \u03c6)).v i j hij = f \u226b (\u2191(fst \u03c6)).v i j hij \u2227 f \u226b (snd \u03c6).v i i \u22ef = f \u226b (snd \u03c6).v i i \u22ef",["tauto","aesop","norm_num","simp"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",174,"case mp\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\ni j : \u2124\nhij : j + 1 = i\nA : C\nf : (mappingCone \u03c6).X j \u27f6 A\n\u22a2 (inl \u03c6).v i j \u22ef \u226b f = (inl \u03c6).v i j \u22ef \u226b f \u2227 (inr \u03c6).f j \u226b f = (inr \u03c6).f j \u226b f",["tauto","aesop","norm_num","simp"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",195,"case mp\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\ni j : \u2124\nhij : i + 1 = j\nK : CochainComplex C \u2124\n\u03b3\u2081 : Cochain K (mappingCone \u03c6) i\n\u22a2 \u03b3\u2081.comp (\u2191(fst \u03c6)) hij = \u03b3\u2081.comp (\u2191(fst \u03c6)) hij \u2227 \u03b3\u2081.comp (snd \u03c6) \u22ef = \u03b3\u2081.comp (snd \u03c6) \u22ef",["tauto","aesop","norm_num","simp"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",213,"case mp\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\ni j : \u2124\nhij : i + 1 = j\nK : CochainComplex C \u2124\n\u03b3\u2081 : Cochain (mappingCone \u03c6) K j\n\u22a2 (inl \u03c6).comp \u03b3\u2081 \u22ef = (inl \u03c6).comp \u03b3\u2081 \u22ef \u2227 (Cochain.ofHom (inr \u03c6)).comp \u03b3\u2081 \u22ef = (Cochain.ofHom (inr \u03c6)).comp \u03b3\u2081 \u22ef",["tauto","aesop","norm_num","simp"]],["NumberTheory/LSeries/ZMod.lean",496,"N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\nh\u03a6 : Function.Even \u03a6\ns : \u2102\nhs\u2080 : s \u2260 0 \u2228 \u2211 j : ZMod N, \u03a6 j = 0\nhs\u2081 : s \u2260 1 \u2228 \u03a6 0 = 0\nF : \u2102 \u2192 \u2102 := fun t \u21a6 completedLFunction \u03a6 (1 - t)\nG : \u2102 \u2192 \u2102 := fun t \u21a6 \u2191N ^ (t - 1) * completedLFunction (\ud835\udcd5 \u03a6) t\nU : Set \u2102 := {t | (t \u2260 0 \u2228 \u2211 j : ZMod N, \u03a6 j = 0) \u2227 (t \u2260 1 \u2228 \u03a6 0 = 0)}\nhsU : s \u2208 U\nh2U : 2 \u2208 U\nhUo : IsOpen U\nhUp : IsPreconnected U\nhF : AnalyticOnNhd \u2102 F U\nhG : AnalyticOnNhd \u2102 G U\n\u22a2 2 \u2208 re \u207b\u00b9' Set.Ioi 1",["simp"]],["NumberTheory/LSeries/ZMod.lean",177,"N : \u2115\ninst\u271d : NeZero N\nj : ZMod N\ns : \u2102\nhjs : j \u2260 0 \u2228 s \u2260 1\nU : Set \u2102 := if j = 0 then {z | z \u2260 1} else Set.univ\nV : Set \u2102 := {z | 1 < z.re}\nhUo : IsOpen U\nf : \u2102 \u2192 \u2102 := LFunction fun k \u21a6 \ud835\udd56 (j * k)\ng : \u2102 \u2192 \u2102 := expZeta (toAddCircle j)\nu : \u2102\n\u22a2 j = 0 \u2192 u \u2208 {z | z \u2260 1} \u2194 u \u2260 1 \u2228 j \u2260 0",["tauto","aesop"]],["Data/Vector/Basic.lean",182,"case mk.mk.nil\n\u03b1 : Type u_1\nn i : \u2115\nih\u271d : i < n - 1\nih : i < 0 - 1\nh\u271d : [].length = n\nh : 0 = n\n\u22a2 (tail \u27e8[], h\u271d\u27e9).get \u27e8i, ih\u271d\u27e9 = get \u27e8[], h\u271d\u27e9 \u27e8i + 1, \u22ef\u27e9",["contradiction","omega","tauto"]],["Data/Complex/Exponential.lean",144,"x : \u2102\nh : cexp x = 0\n\u22a2 x + -x = 0 * cexp (-x)",["simp","ring","aesop","norm_num"]],["Probability/Kernel/Composition/MapComap.lean",264,"case h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03ba \u03b7 : Kernel \u03b1 \u03b2\na\u271d\u00b9 : \u03b1 \u00d7 \u03b3\ns\u271d : Set \u03b2\na\u271d : MeasurableSet s\u271d\n\u22a2 ((prodMkRight \u03b3 (\u03ba + \u03b7)) a\u271d\u00b9) s\u271d = ((prodMkRight \u03b3 \u03ba + prodMkRight \u03b3 \u03b7) a\u271d\u00b9) s\u271d",["simp","aesop","congr","tauto","abel","norm_num"]],["Probability/Kernel/Composition/MapComap.lean",121,"case pos.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\nf\u271d : \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b1\nf : \u03b2 \u2192 \u03b3\nhf : Measurable f\ninst\u271d : IsZeroOrMarkovKernel 0\n\u22a2 IsZeroOrMarkovKernel 0",["infer_instance","tauto"]],["Probability/Kernel/Composition/MapComap.lean",123,"case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\nf\u271d : \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b1\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsZeroOrMarkovKernel \u03ba\nf : \u03b2 \u2192 \u03b3\nhf : \u00acMeasurable f\n\u22a2 IsZeroOrMarkovKernel 0",["infer_instance","tauto"]],["Probability/Kernel/Composition/MapComap.lean",189,"case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\nf : \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b1\nhg : Measurable g\ninst\u271d : IsZeroOrMarkovKernel 0\n\u22a2 IsZeroOrMarkovKernel 0",["infer_instance","tauto"]],["Probability/Kernel/Composition/MapComap.lean",564,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\nb : \u03b2\ninst\u271d : NeZero (\u03ba (a, b))\n\u22a2 NeZero (\u03ba (a, b))",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["Probability/Kernel/Composition/MapComap.lean",608,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\nb : \u03b2\ninst\u271d : NeZero (\u03ba (a, b))\n\u22a2 NeZero (\u03ba (a, b))",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["Logic/Relation.lean",736,"case symm\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nh : Equivalence r\nx\u271d y\u271d : \u03b1\na\u271d : EqvGen r x\u271d y\u271d\na_ih\u271d : r x\u271d y\u271d\n\u22a2 r x\u271d y\u271d",["assumption","omega","congr","infer_instance"]],["Algebra/Homology/ShortComplex/Preadditive.lean",571,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.194743, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nH\u2081 : S\u2081.LeftHomologyData\nH\u2082 : S\u2082.LeftHomologyData\nh\u2080 : S\u2081.X\u2081 \u27f6 S\u2082.X\u2081\nh\u2080_f : h\u2080 \u226b S\u2082.f = 0\nh\u2081 : S\u2081.X\u2082 \u27f6 S\u2082.X\u2081\nh\u2082 : S\u2081.X\u2083 \u27f6 S\u2082.X\u2082\nh\u2083 : S\u2081.X\u2083 \u27f6 S\u2082.X\u2083\ng_h\u2083 : S\u2081.g \u226b h\u2083 = 0\n\u22a2 (H\u2081.i \u226b h\u2081 \u226b S\u2082.f) \u226b S\u2082.g = 0",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/CStarMatrix.lean",624,"A : Type u_1\ninst\u271d\u2074 : NonUnitalCStarAlgebra A\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : StarOrderedRing A\nm : Type u_2\nn : Type u_3\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM : CStarMatrix n n A\nv : C\u22c6\u1d50\u1d52\u1d48 (n \u2192 A)\nh\u2081 : \u2016\u27eav, (toCLM M\u1d34) ((toCLM M) v)\u27eb_A\u2016 \u2264 \u2016star M * M\u2016 * \u2016v\u2016 ^ 2\n\u22a2 \u2016v\u2016 = \u221a(\u2016v\u2016 ^ 2)",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/CStarMatrix.lean",627,"case hx\nA : Type u_1\ninst\u271d\u2074 : NonUnitalCStarAlgebra A\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : StarOrderedRing A\nm : Type u_2\nn : Type u_3\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM : CStarMatrix n n A\nv : C\u22c6\u1d50\u1d52\u1d48 (n \u2192 A)\nh\u2081 : \u2016\u27eav, (toCLM M\u1d34) ((toCLM M) v)\u27eb_A\u2016 \u2264 \u2016star M * M\u2016 * \u2016v\u2016 ^ 2\nh\u2082 : \u2016v\u2016 = \u221a(\u2016v\u2016 ^ 2)\n\u22a2 0 \u2264 \u2016star M * M\u2016",["positivity","norm_num","simp"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",158,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nU : Finset \u03b1\nhU : U \u2208 P.parts\nV : Finset \u03b1\nhV : V \u2208 P.parts\nhUV : U \u2260 V\nhunif : \u00acG.IsUniform \u03b5 U V\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhP\u2081 : 0 < #P.parts\nthis\u271d : 2 ^ #P.parts * \u2191m / (\u2191(#U) * \u03b5) \u2264 \u03b5 / 10\nthis : 2 ^ #P.parts = 2 ^ (#P.parts - 1) * 2\n\u22a2 0 \u2264 2 ^ (#P.parts - 1) * \u2191m",["positivity","aesop","norm_num","simp"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",380,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhUV : U \u2260 V\nhunif : \u00acG.IsUniform \u03b5 U V\nhm : 0 \u2264 1 - (\u2191m)\u207b\u00b9\n\u22a2 0 \u2264 10",["norm_num","aesop","linarith","positivity","simp"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",447,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhUVne : U \u2260 V\nhUV : \u00acG.IsUniform \u03b5 U V\np : \u211d :=\n  (\u2211 ab \u2208 (star hP G \u03b5 hU V).product (star hP G \u03b5 hV U), \u2191(G.edgeDensity ab.1 ab.2)) /\n    (\u2191(#(star hP G \u03b5 hU V)) * \u2191(#(star hP G \u03b5 hV U)))\nq : \u211d :=\n  (\u2211 ab \u2208 (chunk hP G \u03b5 hU).parts.product (chunk hP G \u03b5 hV).parts, \u2191(G.edgeDensity ab.1 ab.2)) /\n    (4 ^ #P.parts * 4 ^ #P.parts)\nr : \u211d := \u2191(G.edgeDensity ((star hP G \u03b5 hU V).biUnion id) ((star hP G \u03b5 hV U).biUnion id))\ns : \u211d := \u2191(G.edgeDensity (G.nonuniformWitness \u03b5 U V) (G.nonuniformWitness \u03b5 V U))\nt : \u211d := \u2191(G.edgeDensity U V)\nhrs : |r - s| \u2264 \u03b5 / 5\nhst : \u03b5 \u2264 |s - t|\nhpr : |p - r| \u2264 \u03b5 ^ 5 / 49\nhqt : |q - t| \u2264 \u03b5 ^ 5 / 49\n\u22a2 1 \u2264 5",["norm_num","omega","decide","aesop","linarith","tauto","simp"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",503,"case refine_2\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhUVne : U \u2260 V\nhUV : \u00acG.IsUniform \u03b5 U V\nt : (star hP G \u03b5 hU V).product (star hP G \u03b5 hV U) \u2286 (chunk hP G \u03b5 hU).parts.product (chunk hP G \u03b5 hV).parts\nh\u03b5 : 0 \u2264 \u03b5\nsp : \u2200 (a b : Finset (Finset \u03b1)), a.product b = a \u00d7\u02e2 b\n\u22a2 ((\u2211 ab \u2208 (chunk hP G \u03b5 hU).parts.product (chunk hP G \u03b5 hV).parts, \u2191(G.edgeDensity ab.1 ab.2)) / 16 ^ #P.parts) ^ 2 \u2264\n    ((\u2211 i \u2208 (chunk hP G \u03b5 hU).parts \u00d7\u02e2 (chunk hP G \u03b5 hV).parts, (fun x \u21a6 \u2191(G.edgeDensity x.1 x.2)) i) /\n        \u2191((4 * 4) ^ #P.parts)) ^\n      2",["norm_num","aesop","simp"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",349,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP : P.IsEquipartition\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhG\u03b5 : 0 \u2264 \u2191(G.edgeDensity U V) - \u03b5 ^ 5 / 50\nthis : 0 \u2264 \u03b5\n\u22a2 \u2191(G.edgeDensity U V) ^ 2 - \u03b5 ^ 5 / 25 = \u2191(G.edgeDensity U V) ^ 2 - 1 * \u03b5 ^ 5 / 25 + 0 ^ 10 / 2500",["ring","aesop","linarith","norm_num","simp"]],["AlgebraicGeometry/Limits.lean",477,"case convert_1.left\nX Y S : Scheme\nf : X \u27f6 S\ng : Y \u27f6 S\ninst\u271d\u00b9 : IsOpenImmersion f\ninst\u271d : IsOpenImmersion g\nhf : IsCompl (Scheme.Hom.opensRange f) (Scheme.Hom.opensRange g)\nc' : Cofan fun j \u21a6 WalkingPair.casesOn j X Y := Cofan.mk S fun j \u21a6 WalkingPair.casesOn j f g\ni : BinaryCofan.mk f g \u2245 c' := Cofan.ext (Iso.refl (BinaryCofan.mk f g).pt) \u22ef\nfi : (j : WalkingPair) \u2192 WalkingPair.casesOn j X Y \u27f6 S := fun j \u21a6 WalkingPair.casesOn j f g\n\u22a2 IsOpenImmersion f\n```\n---\n```lean\ncase convert_1.right\nX Y S : Scheme\nf : X \u27f6 S\ng : Y \u27f6 S\ninst\u271d\u00b9 : IsOpenImmersion f\ninst\u271d : IsOpenImmersion g\nhf : IsCompl (Scheme.Hom.opensRange f) (Scheme.Hom.opensRange g)\nc' : Cofan fun j \u21a6 WalkingPair.casesOn j X Y := Cofan.mk S fun j \u21a6 WalkingPair.casesOn j f g\ni : BinaryCofan.mk f g \u2245 c' := Cofan.ext (Iso.refl (BinaryCofan.mk f g).pt) \u22ef\nfi : (j : WalkingPair) \u2192 WalkingPair.casesOn j X Y \u27f6 S := fun j \u21a6 WalkingPair.casesOn j f g\n\u22a2 IsOpenImmersion g",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["AlgebraicGeometry/Limits.lean",188,"case pos\n\u03b9 : Type u\nf : \u03b9 \u2192 Scheme\nt : Cofan (Scheme.toLocallyRingedSpace \u2218 f)\ni : (disjointGlueData f).toLocallyRingedSpaceGlueData.J\n\u22a2 Scheme.Hom.toLRSHom (eqToHom \u22ef) \u226b t.inj ((MultispanShape.prod \u03b9).fst (i, i)) =\n    (Scheme.Hom.toLRSHom (\ud835\udfd9 (if i = i then f i else \u2205)) \u226b Scheme.Hom.toLRSHom (eqToHom \u22ef)) \u226b\n      t.inj ((MultispanShape.prod \u03b9).snd (i, i))",["congr","aesop","tauto"]],["Analysis/Calculus/TangentCone.lean",549,"a : \u211d\n\u22a2 a \u2208 closure (Ioi a)",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/TwoDim.lean",259,"E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\nx y : E\n\u22a2 inner x (o.rightAngleRotation y) = -inner (o.rightAngleRotation x) y",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/TwoDim.lean",195,"case refine_1.inl\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\nx : E\nh : 0 = \u2016o.rightAngleRotationAux\u2081 x\u2016\n\u22a2 0 \u2264 \u2016x\u2016",["positivity","norm_num","simp"]],["Analysis/InnerProductSpace/TwoDim.lean",508,"E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\nx y : E\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 \u00ac(x = 0 \u2228 y = 0)",["tauto","aesop"]],["MeasureTheory/Constructions/BorelSpace/Real.lean",64,"a : \u211d\nthis : IsGLB (range Rat.cast \u2229 Ioi a) a\nb : \u211a\nx\u271d : b \u2208 Rat.cast \u207b\u00b9' Ioi a\n\u22a2 Ioi \u2191b \u2208 \u22c3 a, {Ioi \u2191a}",["simp","aesop","norm_num"]],["MeasureTheory/Constructions/BorelSpace/Real.lean",402,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\nf : EReal \u2192 \u03b1\nh : Measurable fun p \u21a6 f \u2191p\n\u22a2 {\u22a5, \u22a4}.Finite",["simp","aesop","norm_num"]],["Analysis/Calculus/LineDeriv/Basic.lean",243,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : E \u2192 F\nf' : F\ns t : Set E\nx v : E\nh : HasLineDerivWithinAt \ud835\udd5c f f' t x v\nhst : t \u2208 \ud835\udcdd[s] x\n\u22a2 x = x + 0 \u2022 v",["simp","aesop","norm_num"]],["Analysis/Calculus/LineDeriv/Basic.lean",380,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2081 : E \u2192 F\ns : Set E\nx v : E\nhs : f\u2081 =\u1da0[\ud835\udcdd[s] x] f\nhx : f\u2081 x = f x\nA : Continuous fun t \u21a6 x + t \u2022 v\n\u22a2 x = x + 0 \u2022 v",["simp","aesop","norm_num"]],["Analysis/Calculus/LineDeriv/Basic.lean",333,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf\u2080 f\u2081 : E \u2192 F\nf' : F\ns : Set E\nx v : E\nh : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081\nhx : f\u2080 x = f\u2081 x\nA : Continuous fun t \u21a6 x + t \u2022 v\n\u22a2 x = x + 0 \u2022 v",["simp","aesop","norm_num"]],["Data/List/Sigma.lean",270,"\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nb : \u03b2 a\n\u22a2 b \u2208 lookupAll a [] \u2194 \u27e8a, b\u27e9 \u2208 []",["simp","aesop","tauto"]],["Data/List/Sigma.lean",262,"\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 (lookupAll a []).head? = dlookup a []",["simp","aesop","congr","tauto"]],["Data/List/Sigma.lean",711,"case pos\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nb : \u03b2 a\ntail\u271d : List (Sigma \u03b2)\nih : \u2200 {l\u2082 : List (Sigma \u03b2)}, b \u2208 dlookup a (tail\u271d.kunion l\u2082) \u2194 b \u2208 dlookup a tail\u271d \u2228 a \u2209 tail\u271d.keys \u2227 b \u2208 dlookup a l\u2082\nl\u2082 : List (Sigma \u03b2)\nsnd\u271d : \u03b2 a\n\u22a2 b \u2208 dlookup a ((\u27e8a, snd\u271d\u27e9 :: tail\u271d).kunion l\u2082) \u2194\n    b \u2208 dlookup a (\u27e8a, snd\u271d\u27e9 :: tail\u271d) \u2228 a \u2209 (\u27e8a, snd\u271d\u27e9 :: tail\u271d).keys \u2227 b \u2208 dlookup a l\u2082",["simp","aesop"]],["Data/List/Sigma.lean",426,"\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List (Sigma \u03b2)\n\u22a2 map Sigma.fst (eraseP (fun s \u21a6 decide (a = s.fst)) l) = map Sigma.fst (eraseP (fun x \u21a6 a == x.fst) l)",["congr","aesop","tauto"]],["LinearAlgebra/Basis/Defs.lean",540,"\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u00b9 : Semiring R\u271d\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u271d\ninst\u271d\u2079 : Module R\u271d M\u271d\ninst\u271d\u2078 : AddCommMonoid M'\ninst\u271d\u2077 : Module R\u271d M'\n\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : Module R M'\nS : Type u_13\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M'\ninst\u271d : SMulCommClass R S M'\nc : S\nf : \u03b9 \u2192 M'\ni : \u03b9\n\u22a2 ({ toFun := fun f \u21a6 linearCombination R id \u2218\u2097 lmapDomain R R f \u2218\u2097 \u2191b.repr, map_add' := \u22ef }.toFun (c \u2022 f)) (b i) =\n    ((RingHom.id S) c \u2022 { toFun := fun f \u21a6 linearCombination R id \u2218\u2097 lmapDomain R R f \u2218\u2097 \u2191b.repr, map_add' := \u22ef }.toFun f)\n      (b i)",["simp","aesop"]],["LinearAlgebra/Basis/Defs.lean",599,"\u03b9 : Type u_10\nR : Type u_11\nM : Type u_12\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\ni : \u03b9\n\u22a2 (b.equiv b (Equiv.refl \u03b9)) (b i) = (LinearEquiv.refl R M) (b i)",["simp","aesop"]],["LinearAlgebra/Basis/Defs.lean",140,"\u03b9 : Type u_1\nR : Type u_3\nM : Type u_6\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nb : Basis \u03b9 R M\nv : \u03b9 \u2192\u2080 R\n\u22a2 b.repr.symm v = b.repr.symm (v.sum single)",["simp","aesop"]],["LinearAlgebra/Basis/Defs.lean",106,"case ofRepr.ofRepr\n\u03b9 : Type u_1\nR : Type u_3\nM : Type u_6\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nrepr\u271d\u00b9 repr\u271d : M \u2243\u2097[R] \u03b9 \u2192\u2080 R\nh : { repr := repr\u271d\u00b9 }.repr = { repr := repr\u271d }.repr\n\u22a2 { repr := repr\u271d\u00b9 } = { repr := repr\u271d }",["congr","aesop","tauto"]],["CategoryTheory/Limits/Constructions/LimitsOfProductsAndEqualizers.lean",351,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nJ : Type w\ninst\u271d\u00b9 : SmallCategory J\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : J \u2964 C\nc\u2081 : Cofan fun f \u21a6 F.obj f.fst.1\nc\u2082 : Cofan F.obj\ns\u271d t : c\u2081.pt \u27f6 c\u2082.pt\nhs : \u2200 (f : (p : J \u00d7 J) \u00d7 (p.1 \u27f6 p.2)), c\u2081.\u03b9.app { as := f } \u226b s\u271d = F.map f.snd \u226b c\u2082.\u03b9.app { as := f.fst.2 }\nht : \u2200 (f : (p : J \u00d7 J) \u00d7 (p.1 \u27f6 p.2)), c\u2081.\u03b9.app { as := f } \u226b t = c\u2082.\u03b9.app { as := f.fst.1 }\ni : Cofork s\u271d t\nt\u2081 : IsColimit c\u2081\nt\u2082 : IsColimit c\u2082\nhi : IsColimit i\ns : Cocone F\nj : J\n\u22a2 (buildColimit s\u271d t hs ht i).\u03b9.app j \u226b (fun q \u21a6 hi.desc (Cofork.of\u03c0 (t\u2082.desc (Cofan.mk q.1 fun j \u21a6 q.\u03b9.app j)) \u22ef)) s =\n    s.\u03b9.app j",["simp","aesop"]],["CategoryTheory/Limits/Constructions/LimitsOfProductsAndEqualizers.lean",168,"C : Type u\ninst\u271d\u2078 : Category.{v, u} C\nJ : Type w\ninst\u271d\u2077 : SmallCategory J\nD : Type u\u2082\ninst\u271d\u2076 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2075 : HasLimitsOfShape (Discrete J) C\ninst\u271d\u2074 : HasLimitsOfShape (Discrete ((p : J \u00d7 J) \u00d7 (p.1 \u27f6 p.2))) C\ninst\u271d\u00b3 : HasEqualizers C\nG : C \u2964 D\ninst\u271d\u00b2 : PreservesLimitsOfShape WalkingParallelPair G\ninst\u271d\u00b9 : PreservesLimitsOfShape (Discrete J) G\ninst\u271d : PreservesLimitsOfShape (Discrete ((p : J \u00d7 J) \u00d7 (p.1 \u27f6 p.2))) G\nK : J \u2964 C\nP : C := \u220f\u1d9c K.obj\nQ : C := \u220f\u1d9c fun f \u21a6 K.obj f.fst.2\ns : P \u27f6 Q := Pi.lift fun f \u21a6 limit.\u03c0 (Discrete.functor K.obj) { as := f.fst.1 } \u226b K.map f.snd\nt : P \u27f6 Q := Pi.lift fun f \u21a6 limit.\u03c0 (Discrete.functor K.obj) { as := f.fst.2 }\nI : C := equalizer s t\ni : I \u27f6 P := equalizer.\u03b9 s t\nf : (p : J \u00d7 J) \u00d7 (p.1 \u27f6 p.2)\n\u22a2 G.map ((Fan.mk (\u220f\u1d9c K.obj) fun f \u21a6 limit.\u03c0 (Discrete.functor K.obj) { as := f.fst.1 } \u226b K.map f.snd).\u03c0.app { as := f }) =\n    G.map (Pi.\u03c0 K.obj f.fst.1 \u226b K.map f.snd)",["congr","aesop","tauto","simp"]],["CategoryTheory/Limits/Constructions/LimitsOfProductsAndEqualizers.lean",435,"C : Type u\ninst\u271d\u2078 : Category.{v, u} C\nJ : Type w\ninst\u271d\u2077 : SmallCategory J\nD : Type u\u2082\ninst\u271d\u2076 : Category.{v\u2082, u\u2082} D\ninst\u271d\u2075 : HasColimitsOfShape (Discrete J) C\ninst\u271d\u2074 : HasColimitsOfShape (Discrete ((p : J \u00d7 J) \u00d7 (p.1 \u27f6 p.2))) C\ninst\u271d\u00b3 : HasCoequalizers C\nG : C \u2964 D\ninst\u271d\u00b2 : PreservesColimitsOfShape WalkingParallelPair G\ninst\u271d\u00b9 : PreservesColimitsOfShape (Discrete J) G\ninst\u271d : PreservesColimitsOfShape (Discrete ((p : J \u00d7 J) \u00d7 (p.1 \u27f6 p.2))) G\nK : J \u2964 C\nP : C := \u2210 K.obj\nQ : C := \u2210 fun f \u21a6 K.obj f.fst.1\ns : Q \u27f6 P := Sigma.desc fun f \u21a6 K.map f.snd \u226b colimit.\u03b9 (Discrete.functor K.obj) { as := f.fst.2 }\nt : Q \u27f6 P := Sigma.desc fun f \u21a6 colimit.\u03b9 (Discrete.functor K.obj) { as := f.fst.1 }\nI : C := coequalizer s t\ni : P \u27f6 I := coequalizer.\u03c0 s t\nf : (p : J \u00d7 J) \u00d7 (p.1 \u27f6 p.2)\n\u22a2 G.map\n      ((Cofan.mk (\u2210 K.obj) fun f \u21a6 K.map f.snd \u226b colimit.\u03b9 (Discrete.functor K.obj) { as := f.fst.2 }).\u03b9.app\n        { as := f }) =\n    G.map (K.map f.snd \u226b Sigma.\u03b9 K.obj f.fst.2)",["congr","aesop","tauto","simp"]],["Data/Part.lean",458,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\nx : Part \u03b1\ng : \u03b2 \u2192 Part \u03b3\n\u22a2 (x.bind fun x \u21a6 (some (f x)).bind g) = x.bind fun y \u21a6 g (f y)",["simp","aesop"]],["Data/Part.lean",432,"\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nf : \u03b1 \u2192 Part \u03b2\n\u22a2 \u2200 (a_1 : \u03b2), a_1 \u2208 (some a).bind f \u2194 a_1 \u2208 f a",["simp","aesop"]],["Data/Part.lean",198,"\u03b1 : Type u_1\na : Part \u03b1\nha : a.Dom\nb : Part \u03b1\nh : a = b\n\u22a2 a.get ha = b.get \u22ef",["congr","aesop"]],["Data/Part.lean",636,"\u03b1 : Type u_1\ninst\u271d : Inv \u03b1\na : Part \u03b1\nma : \u03b1\nha : ma \u2208 a\n\u22a2 \u2203 a_1 \u2208 a, a_1\u207b\u00b9 = ma\u207b\u00b9",["aesop","tauto"]],["Data/Part.lean",644,"\u03b1 : Type u_1\ninst\u271d : Div \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 / a = ma / mb",["aesop","tauto"]],["Data/Part.lean",655,"\u03b1 : Type u_1\ninst\u271d : Div \u03b1\na b : Part \u03b1\nhab : (a / b).Dom\n\u22a2 (a.bind fun y \u21a6 map (fun x \u21a6 y / x) b).get \u22ef = a.get \u22ef / b.get \u22ef",["aesop","congr","tauto"]],["Data/Part.lean",661,"\u03b1 : Type u_1\ninst\u271d : Mod \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 % a = ma % mb",["aesop","tauto"]],["Data/Part.lean",670,"\u03b1 : Type u_1\ninst\u271d : Mod \u03b1\na b : Part \u03b1\nhab : (a % b).Dom\n\u22a2 (a.bind fun y \u21a6 map (fun x \u21a6 y % x) b).get \u22ef = a.get \u22ef % b.get \u22ef",["aesop","congr","tauto"]],["Data/Part.lean",675,"\u03b1 : Type u_1\ninst\u271d : Append \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 ++ a = ma ++ mb",["aesop","tauto"]],["Data/Part.lean",684,"\u03b1 : Type u_1\ninst\u271d : Append \u03b1\na b : Part \u03b1\nhab : (a ++ b).Dom\n\u22a2 (a.bind fun y \u21a6 map (fun x \u21a6 y ++ x) b).get \u22ef = a.get \u22ef ++ b.get \u22ef",["aesop","congr","tauto"]],["Data/Part.lean",690,"\u03b1 : Type u_1\ninst\u271d : Inter \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 \u2229 a = ma \u2229 mb",["aesop","tauto"]],["Data/Part.lean",699,"\u03b1 : Type u_1\ninst\u271d : Inter \u03b1\na b : Part \u03b1\nhab : (a \u2229 b).Dom\n\u22a2 (a.bind fun y \u21a6 map (fun x \u21a6 y \u2229 x) b).get \u22ef = a.get \u22ef \u2229 b.get \u22ef",["aesop","congr","tauto"]],["Data/Part.lean",705,"\u03b1 : Type u_1\ninst\u271d : Union \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 \u222a a = ma \u222a mb",["aesop","tauto"]],["Data/Part.lean",714,"\u03b1 : Type u_1\ninst\u271d : Union \u03b1\na b : Part \u03b1\nhab : (a \u222a b).Dom\n\u22a2 (a.bind fun y \u21a6 map (fun x \u21a6 y \u222a x) b).get \u22ef = a.get \u22ef \u222a b.get \u22ef",["aesop","congr","tauto"]],["Data/Part.lean",719,"\u03b1 : Type u_1\ninst\u271d : SDiff \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 \\ a = ma \\ mb",["aesop","tauto"]],["Data/Part.lean",728,"\u03b1 : Type u_1\ninst\u271d : SDiff \u03b1\na b : Part \u03b1\nhab : (a \\ b).Dom\n\u22a2 (a.bind fun y \u21a6 map (fun x \u21a6 y \\ x) b).get \u22ef = a.get \u22ef \\ b.get \u22ef",["aesop","congr","tauto"]],["Combinatorics/SimpleGraph/Matching.lean",455,"case hcd\nV : Type u_1\nG : SimpleGraph V\ninst\u271d : Fintype V\nv w : V\nhcyc : G.IsCycles\np : G.Walk v w\nhp : p.IsPath\nhvw : \u00acv = w\nhpn : \u00acp.Nil\nw' : V\nhwu : \u2200 (y : V), (fun w' \u21a6 p.snd \u2260 w' \u2227 G.Adj v w') y \u2192 y = w'\nhw'1 : p.snd \u2260 w'\nhw'2 : G.Adj v w'\nhnpvw' : \u00acp.toSubgraph.Adj v w'\nhww' : \u00acw = w'\n\u22a2 p.toSubgraph.spanningCoe \u2264 (Walk.cons \u22ef p).toSubgraph.spanningCoe",["aesop","tauto","simp"]],["Combinatorics/SimpleGraph/Matching.lean",504,"V : Type u_1\nG : SimpleGraph V\nv\u271d : V\ninst\u271d : Finite V\nc : G.ConnectedComponent\nh : G.IsCycles\nhv\u271d : v\u271d \u2208 c.supp\nw\u271d : V\nhw : w\u271d \u2208 G.neighborSet v\u271d\nu : V\np : G.Walk u u\nhp : p.IsCycle \u2227 s(v\u271d, w\u271d) \u2208 p.edges\nhvp : v\u271d \u2208 p.support\nv : V\nhv : v \u2208 p.support\nw : V\nhadj : G.Adj v w\n\u22a2 2 \u2260 0",["omega","decide","aesop","tauto","simp"]],["CategoryTheory/ChosenFiniteProducts.lean",673,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : ChosenFiniteProducts C\nD : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} D\ninst\u271d\u00b9 : ChosenFiniteProducts D\nF : C \u2964 D\ninst\u271d : PreservesFiniteProducts F\nX Y : C\n\u22a2 (\u03bcIso F X Y).inv \u226b LaxMonoidal.\u03bc F X Y \u226b F.map (snd X Y) = (\u03bcIso F X Y).inv \u226b snd (F.obj X) (F.obj Y)",["simp","aesop"]],["CategoryTheory/ChosenFiniteProducts.lean",161,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : ChosenFiniteProducts C\nX Y\u2081 Y\u2082 : C\ng : Y\u2081 \u27f6 Y\u2082\n\u22a2 fst X Y\u2081 \u226b \ud835\udfd9 X = fst X Y\u2081",["simp","aesop"]],["CategoryTheory/ChosenFiniteProducts.lean",669,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : ChosenFiniteProducts C\nD : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} D\ninst\u271d\u00b9 : ChosenFiniteProducts D\nF : C \u2964 D\ninst\u271d : PreservesFiniteProducts F\nX Y : C\n\u22a2 (\u03bcIso F X Y).inv \u226b LaxMonoidal.\u03bc F X Y \u226b F.map (fst X Y) = (\u03bcIso F X Y).inv \u226b fst (F.obj X) (F.obj Y)",["simp","aesop"]],["CategoryTheory/ChosenFiniteProducts.lean",479,"C : Type u\ninst\u271d\u2076 : Category.{v, u} C\ninst\u271d\u2075 : ChosenFiniteProducts C\nD : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} D\ninst\u271d\u00b3 : ChosenFiniteProducts D\nF : C \u2964 D\nA\u271d B A' B' : C\nE : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} E\ninst\u271d\u00b9 : ChosenFiniteProducts E\nG : D \u2964 E\nA : C\ninst\u271d : \u2200 (B : C), IsIso (prodComparison F A B)\n\u22a2 \u2200 (X : C), IsIso ((prodComparisonNatTrans F A).app X)",["assumption","aesop","congr","tauto"]],["NumberTheory/Divisors.lean",96,"n : \u2115\n\u22a2 1 \u2208 n.divisors \u2194 n \u2260 0",["simp","aesop"]],["NumberTheory/Divisors.lean",167,"case h\na\u271d : \u2115\n\u22a2 a\u271d \u2208 divisors 0 \u2194 a\u271d \u2208 \u2205",["simp","aesop","tauto"]],["NumberTheory/Divisors.lean",309,"case a.h\nn : \u2115\na\u271d : \u2115 \u00d7 \u2115\n\u22a2 a\u271d \u2208 map ({ toFun := fun d \u21a6 (n / d, d), inj' := \u22ef }.trans (Equiv.prodComm \u2115 \u2115).toEmbedding) n.divisors \u2194\n    a\u271d \u2208 map { toFun := fun d \u21a6 (d, n / d), inj' := \u22ef } n.divisors",["simp","aesop","tauto"]],["NumberTheory/Divisors.lean",188,"case h\na\u271d : \u2115\n\u22a2 a\u271d \u2208 divisors 1 \u2194 a\u271d \u2208 {1}",["simp","aesop","tauto"]],["NumberTheory/Divisors.lean",241,"case h\na\u271d : \u2115 \u00d7 \u2115\n\u22a2 a\u271d \u2208 divisorsAntidiagonal 0 \u2194 a\u271d \u2208 \u2205",["simp","aesop","tauto"]],["NumberTheory/Divisors.lean",414,"case refine_1.refine_2.refine_1\nn m : \u2115\nhdvd : m \u2223 n\nthis : n \u2264 0\nh : properDivisors 0 = {1}\n\u22a2 False",["contradiction","tauto"]],["NumberTheory/Divisors.lean",454,"case h\np : \u2115\npp : Prime p\nk a : \u2115\nthis : a \u2223 p ^ k \u2227 a < p ^ k \u2194 \u2203 j, \u2203 (_ : j < k), a = p ^ j\nj : \u2115\nhj : j < k\nhap : a = p ^ j\n\u22a2 j < k \u2227 p ^ j = a",["tauto","omega","aesop"]],["Algebra/Polynomial/Derivative.lean",405,"case h.a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nx\u271d\u00b9 : R\nx\u271d : R[X]\na\u271d n\u271d : \u2115\n\u22a2 (({ toFun := fun p \u21a6 Finsupp.onFinset (range (p.natDegree + 1)) (fun x \u21a6 (\u21d1derivative)^[x] p) \u22ef, map_add' := \u22ef }.toFun\n            (x\u271d\u00b9 \u2022 x\u271d))\n          a\u271d).coeff\n      n\u271d =\n    (((RingHom.id R) x\u271d\u00b9 \u2022\n            { toFun := fun p \u21a6 Finsupp.onFinset (range (p.natDegree + 1)) (fun x \u21a6 (\u21d1derivative)^[x] p) \u22ef,\n                  map_add' := \u22ef }.toFun\n              x\u271d)\n          a\u271d).coeff\n      n\u271d",["simp","aesop","norm_num"]],["Algebra/Polynomial/Derivative.lean",84,"case hf\nR : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\n\u22a2 C (0 * \u2191n) * X ^ (n - 1) = 0",["simp","aesop","norm_num"]],["Algebra/Polynomial/Derivative.lean",587,"R : Type u\ninst\u271d : Ring R\nn : \u2124\nf : R[X]\n\u22a2 derivative (\u2191n * f) = \u2191n * derivative f",["simp","aesop","norm_num"]],["NumberTheory/LegendreSymbol/JacobiSymbol.lean",284,"a : \u2124\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nh : J(a | p) = 1\n\u22a2 \u00ac1 = -1",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["NumberTheory/LegendreSymbol/JacobiSymbol.lean",511,"a b : \u2115\nflip : Bool\nha0 : a > 0\nha4 : a % 4 = 0\n\u22a2 1 < 4",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["NumberTheory/LegendreSymbol/JacobiSymbol.lean",512,"a b : \u2115\nflip : Bool\nha0 : a > 0\nha4 : \u00aca % 4 = 0\nha2 : a % 2 = 0\n\u22a2 1 < 2",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["LinearAlgebra/Matrix/SchurComplement.lean",520,"case h.e'_1.h.e'_7.h.e'_8\nm : Type u_2\nn : Type u_3\n\ud835\udd5c : Type u_5\ninst\u271d\u2077 : CommRing \ud835\udd5c\ninst\u271d\u2076 : StarRing \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u2074 : StarOrderedRing \ud835\udd5c\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\nA : Matrix m m \ud835\udd5c\nB : Matrix m n \ud835\udd5c\nD : Matrix n n \ud835\udd5c\nhD : D.PosDef\ninst\u271d : Invertible D\n\u22a2 B = B\u1d34\u1d34\n```\n---\n```lean\ncase h.e'_2.h.e'_7.h.e'_6.h.e'_5.h.e'_5\nm : Type u_2\nn : Type u_3\n\ud835\udd5c : Type u_5\ninst\u271d\u2077 : CommRing \ud835\udd5c\ninst\u271d\u2076 : StarRing \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u2074 : StarOrderedRing \ud835\udd5c\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\nA : Matrix m m \ud835\udd5c\nB : Matrix m n \ud835\udd5c\nD : Matrix n n \ud835\udd5c\nhD : D.PosDef\ninst\u271d : Invertible D\n\u22a2 B = B\u1d34\u1d34",["simp","omega","aesop","tauto","infer_instance","norm_num"]],["RingTheory/Idempotents.lean",338,"R : Type u_1\ninst\u271d : Ring R\ne\u2081 e\u2082 : R\nhe\u2081 : IsIdempotentElem e\u2081\nhe\u2082 : IsIdempotentElem e\u2082\nH : IsNilpotent (e\u2081 - e\u2082)\nH' : Commute e\u2081 e\u2082\n\u22a2 e\u2081 - e\u2082 * e\u2081 - (e\u2082 * e\u2081 - e\u2082 * e\u2081) - (e\u2082 * e\u2081 - e\u2082 * e\u2081 - (e\u2082 * e\u2081 - e\u2082)) = e\u2081 - e\u2082",["abel","aesop","norm_num","simp"]],["NumberTheory/PythagoreanTriples.lean",617,"case h.inl.left\nx y z : \u2124\nh : PythagoreanTriple x y z\nh_coprime : x.gcd y = 1\nh_parity : x % 2 = 1\nh_pos : 0 < z\nm n : \u2124\nht2 : z = m ^ 2 + n ^ 2 \u2228 z = -(m ^ 2 + n ^ 2)\nht3 : m.gcd n = 1\nht4 : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0\nhm : m < 0\nh_odd : x = m ^ 2 - n ^ 2 \u2227 y = 2 * m * n\n\u22a2 2 * m * n = 2 * -m * -n",["ring","aesop","linarith","norm_num","simp"]],["NumberTheory/PythagoreanTriples.lean",533,"case h\nx y z : \u2124\nh : PythagoreanTriple x y z\nhc : y.gcd x = 1\nhzpos : 0 < z\nh2 : x % 2 = 1 \u2227 y % 2 = 0\nm n : \u2124\nH :\n  (y = m ^ 2 - n ^ 2 \u2227 x = 2 * m * n \u2228 y = 2 * m * n \u2227 x = m ^ 2 - n ^ 2) \u2227\n    m.gcd n = 1 \u2227 (m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0)\n\u22a2 (x = m ^ 2 - n ^ 2 \u2227 y = 2 * m * n \u2228 x = 2 * m * n \u2227 y = m ^ 2 - n ^ 2) \u2227\n    m.gcd n = 1 \u2227 (m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0)",["tauto","omega","aesop"]],["NumberTheory/PythagoreanTriples.lean",145,"case inr.inr.intro.intro.intro\nz x0 y0 : \u2124\nhx : (x0 * 2 + 1) % 2 = 1\nhy : (y0 * 2 + 1) % 2 = 1\nh : PythagoreanTriple (x0 * 2 + 1) (y0 * 2 + 1) z\nhc : (x0 * 2 + 1).gcd (y0 * 2 + 1) = 1\n\u22a2 2 % 4 % 4 = 2",["decide","ring","omega","aesop","congr","tauto","abel","norm_num","simp"]],["NumberTheory/PythagoreanTriples.lean",225,"case h\ny z : \u2124\nh : PythagoreanTriple 0 y z\nhc : y.natAbs = 1\nhy : y = \u2191y.natAbs\n\u22a2 (0 = 1 ^ 2 - 0 ^ 2 \u2227 \u21911 = 2 * 1 * 0 \u2228 0 = 2 * 1 * 0 \u2227 \u21911 = 1 ^ 2 - 0 ^ 2) \u2227\n    Int.natAbs 1 = 1 \u2227 (1 % 2 = 0 \u2227 0 % 2 = 1 \u2228 1 % 2 = 1 \u2227 0 % 2 = 0)",["decide","omega","tauto","norm_num","simp"]],["NumberTheory/PythagoreanTriples.lean",228,"case h\ny z : \u2124\nh : PythagoreanTriple 0 y z\nhc : y.natAbs = 1\nhy : y = -\u2191y.natAbs\n\u22a2 (0 = 0 ^ 2 - 1 ^ 2 \u2227 -\u21911 = 2 * 0 * 1 \u2228 0 = 2 * 0 * 1 \u2227 -\u21911 = 0 ^ 2 - 1 ^ 2) \u2227\n    Int.natAbs 1 = 1 \u2227 (0 % 2 = 0 \u2227 1 % 2 = 1 \u2228 0 % 2 = 1 \u2227 1 % 2 = 0)",["decide"]],["NumberTheory/PythagoreanTriples.lean",317,"m n : \u2124\nh : m.gcd n = 1\nhm : m % 2 = 0\nhn : n % 2 = 1\nH : \u00ac(m ^ 2 - n ^ 2).gcd (m ^ 2 + n ^ 2) = 1\np : \u2115\nhp : Nat.Prime p\nhp1 : \u2191p \u2223 m ^ 2 - n ^ 2\nhp2 : \u2191p \u2223 m ^ 2 + n ^ 2\nh2m : \u2191p \u2223 2 * m ^ 2\nh2n : \u2191p \u2223 2 * n ^ 2\nhmc : p = 2 \u2228 p \u2223 m.natAbs\nhnc : p = 2 \u2228 p \u2223 n.natAbs\nh2 : p = 2\n\u22a2 (0 % 2 % 2 * (0 % 2 % 2) % 2 % 2 + 1 % 2 % 2 * (1 % 2 % 2) % 2 % 2) % 2 = 1",["decide"]],["NumberTheory/PythagoreanTriples.lean",351,"case intro.intro.intro.inl.inl\nm n : \u2124\nh : m.gcd n = 1\nhm : m % 2 = 0\nhn : n % 2 = 1\nH : \u00ac(m ^ 2 - n ^ 2).gcd (2 * m * n) = 1\np : \u2115\nhp : Nat.Prime p\nhp2\u271d : \u2191p \u2223 2 * m * n\nhnp : \u00ac\u2191p \u2223 \u2191(m.gcd n)\nhp2m : p \u2223 Int.natAbs 2 * m.natAbs\nhp2 : p \u2223 Int.natAbs 2\nhp2' : p = 2\n\u22a2 \u00ac-(1 % 2) % 2 = 0",["decide","omega","aesop","positivity","tauto","norm_num","simp"]],["NumberTheory/PythagoreanTriples.lean",393,"case H\nm0 n0 : \u2124\nhm : (m0 * 2 + 1) % 2 = 1\nhn : (n0 * 2 + 1) % 2 = 1\nh : (m0 * 2 + 1).gcd (n0 * 2 + 1) = 1\nh1 : (m0 * 2 + 1) ^ 2 + (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1)\nh2 : (m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0))\n\u22a2 2 \u2260 0",["decide"]],["NumberTheory/PythagoreanTriples.lean",395,"m0 n0 : \u2124\nhm : (m0 * 2 + 1) % 2 = 1\nhn : (n0 * 2 + 1) % 2 = 1\nh : (m0 * 2 + 1).gcd (n0 * 2 + 1) = 1\nh1 : (m0 * 2 + 1) ^ 2 + (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1)\nh2 : (m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0))\nh3 : ((m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2) / 2 % 2 = 0\n\u22a2 2 \u2260 0",["decide"]],["NumberTheory/PythagoreanTriples.lean",498,"case neg.inl.inl\nx y z : \u2124\nh : PythagoreanTriple x y z\nhc : x.gcd y = 1\nhyo : y % 2 = 1\nhzpos : 0 < z\nh0 : \u00acx = 0\nv : \u211a := \u2191x / \u2191z\nw : \u211a := \u2191y / \u2191z\nhq : v ^ 2 + w ^ 2 = 1\nhvz : v \u2260 0\nhw1 : w \u2260 -1\nhQ : \u2200 (x : \u211a), 1 + x ^ 2 \u2260 0\nhp : (v, w) \u2208 {p | p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1}\nq : \u211a := (circleEquivGen hQ).symm \u27e8(v, w), hp\u27e9\nht4 : v = 2 * q / (1 + q ^ 2) \u2227 w = (1 - q ^ 2) / (1 + q ^ 2)\nm : \u2124 := \u2191q.den\nn : \u2124 := q.num\nhm0 : m \u2260 0\nhq2 : q = \u2191n / \u2191m\nhm2n2 : 0 < m ^ 2 + n ^ 2\nhm2n20 : \u2191m ^ 2 + \u2191n ^ 2 \u2260 0\nhx1 : \u2200 {j k : \u211a}, k \u2260 0 \u2192 k ^ 2 + j ^ 2 \u2260 0 \u2192 (1 - (j / k) ^ 2) / (1 + (j / k) ^ 2) = (k ^ 2 - j ^ 2) / (k ^ 2 + j ^ 2)\nhw2 : w = (\u2191m ^ 2 - \u2191n ^ 2) / (\u2191m ^ 2 + \u2191n ^ 2)\nhx2 : \u2200 {j k : \u211a}, k \u2260 0 \u2192 k ^ 2 + j ^ 2 \u2260 0 \u2192 2 * (j / k) / (1 + (j / k) ^ 2) = 2 * k * j / (k ^ 2 + j ^ 2)\nhv2 : v = 2 * \u2191m * \u2191n / (\u2191m ^ 2 + \u2191n ^ 2)\nhnmcp : n.gcd m = 1\nhmncp : m.gcd n = 1\nhm2 : m % 2 = 0\nhn2 : n % 2 = 0\n\u22a2 2 \u2223 \u21911 \u2192 False",["decide"]],["Analysis/InnerProductSpace/l2Space.lean",219,"case pos\n\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2076 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : InnerProductSpace \ud835\udd5c E\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b3 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\ninst\u271d\u00b9 : CompleteSpace E\nV : (i : \u03b9) \u2192 G i \u2192\u2097\u1d62[\ud835\udd5c] E\nhV : OrthogonalFamily \ud835\udd5c G V\ninst\u271d : DecidableEq \u03b9\nj : \u03b9\nx : G j\n\u22a2 (V j) (Pi.single j x j) = (V j) x",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/l2Space.lean",410,"\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nb : HilbertBasis \u03b9 \ud835\udd5c E\nv : E\ni : \u03b9\n\u22a2 \u2191(b.repr v) i = inner 1 (\u2191(b.repr v) i)",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/l2Space.lean",224,"\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2077 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : InnerProductSpace \ud835\udd5c E\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u2074 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\ninst\u271d\u00b2 : CompleteSpace E\nV : (i : \u03b9) \u2192 G i \u2192\u2097\u1d62[\ud835\udd5c] E\nhV : OrthogonalFamily \ud835\udd5c G V\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (G i)\nW\u2080 : \u03a0\u2080 (i : \u03b9), G i\n\u22a2 hV.linearIsometry (W\u2080.sum (lp.single 2)) = W\u2080.sum fun i \u21a6 \u21d1(V i)",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/l2Space.lean",123,"\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2074 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\nf g : \u21a5(lp G 2)\n\u22a2 (starRingEnd \ud835\udd5c) (inner g f) = (starRingEnd \ud835\udd5c) (\u2211' (i : \u03b9), inner (\u2191g i) (\u2191f i))",["congr","ring","aesop","tauto","abel","norm_num","simp"]],["Analysis/InnerProductSpace/l2Space.lean",126,"\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2074 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\nf g : \u21a5(lp G 2)\n\u22a2 \u2211' (i : \u03b9), inner (\u2191f i) (\u2191g i) = inner f g",["congr","ring","aesop","tauto","abel","norm_num","simp"]],["Analysis/InnerProductSpace/l2Space.lean",133,"\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2074 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\nf\u2081 f\u2082 g : \u21a5(lp G 2)\n\u22a2 \u2211' (i : \u03b9), inner (\u2191f\u2081 i) (\u2191g i) + \u2211' (i : \u03b9), inner (\u2191f\u2082 i) (\u2191g i) = inner f\u2081 g + inner f\u2082 g",["congr","ring","aesop","tauto","abel","norm_num","simp"]],["Analysis/InnerProductSpace/l2Space.lean",196,"\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\ninst\u271d : CompleteSpace E\nV : (i : \u03b9) \u2192 G i \u2192\u2097\u1d62[\ud835\udd5c] E\nhV\u271d hV : OrthogonalFamily \ud835\udd5c G V\nf : \u21a5(lp G 2)\n\u22a2 0 < ENNReal.toReal 2",["norm_num","aesop","simp"]],["Topology/ContinuousMap/CompactlySupported.lean",680,"case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b1 \u2192C_c \u211d\u22650\nx : \u03b1\n\u22a2 (f + g).toReal x = (f.toReal + g.toReal) x",["simp","aesop","norm_num"]],["Topology/ContinuousMap/CompactlySupported.lean",74,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : Zero \u03b2\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d\u00b9 : Continuous toFun\u271d\u00b9\nhasCompactSupport'\u271d\u00b9 : HasCompactSupport { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun\ntoFun\u271d : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d : Continuous toFun\u271d\nhasCompactSupport'\u271d : HasCompactSupport { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }.toFun\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, hasCompactSupport' := hasCompactSupport'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, hasCompactSupport' := hasCompactSupport'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, hasCompactSupport' := hasCompactSupport'\u271d\u00b9 } =\n    { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, hasCompactSupport' := hasCompactSupport'\u271d }",["congr","aesop"]],["Topology/Algebra/UniformGroup/Basic.lean",537,"G : Type u\ninst\u271d\u00b3 : Group G\nus : UniformSpace G\ninst\u271d\u00b2 : UniformGroup G\ninst\u271d\u00b9 : FirstCountableTopology G\nN : Subgroup G\ninst\u271d : N.Normal\nhG : CompleteSpace G\n\u22a2 CompleteSpace (G \u29f8 N)",["infer_instance","omega","aesop","tauto"]],["Topology/Algebra/UniformGroup/Basic.lean",405,"case mk.right.intro.intro.intro.intro.intro.intro.intro.intro.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nG : Type u_5\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b9\u00b2 : IsTopologicalAddGroup \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b2\ninst\u271d\u2079 : TopologicalSpace \u03b3\ninst\u271d\u2078 : AddCommGroup \u03b3\ninst\u271d\u2077 : IsTopologicalAddGroup \u03b3\ninst\u271d\u2076 : TopologicalSpace \u03b4\ninst\u271d\u2075 : AddCommGroup \u03b4\ninst\u271d\u2074 : UniformSpace G\ninst\u271d\u00b3 : AddCommGroup G\ne : \u03b2 \u2192+ \u03b1\nde : IsDenseInducing \u21d1e\nf : \u03b4 \u2192+ \u03b3\ndf : IsDenseInducing \u21d1f\n\u03c6 : \u03b2 \u2192+ \u03b4 \u2192+ G\nh\u03c6 : Continuous fun p \u21a6 (\u03c6 p.1) p.2\ninst\u271d\u00b2 : UniformAddGroup G\ninst\u271d\u00b9 : T0Space G\ninst\u271d : CompleteSpace G\nx\u2080 : \u03b1\ny\u2080 : \u03b3\nW' : Set G\nW'_nhd : W' \u2208 \ud835\udcdd 0\nU : Set \u03b2\nV : Set \u03b4\nh : \u2200 x \u2208 U, \u2200 x' \u2208 U, \u2200 y \u2208 V, \u2200 y' \u2208 V, (fun p \u21a6 (\u03c6 p.1) p.2) (x', y') - (fun p \u21a6 (\u03c6 p.1) p.2) (x, y) \u2208 W'\nU' : Set \u03b1\nU'_nhd : U' \u2208 \ud835\udcdd x\u2080\nU'_sub : \u21d1e \u207b\u00b9' U' \u2286 U\nV' : Set \u03b3\nV'_nhd : V' \u2208 \ud835\udcdd y\u2080\nV'_sub : \u21d1f \u207b\u00b9' V' \u2286 V\nthis : U' \u00d7\u02e2 V' \u2208 \ud835\udcdd x\u2080 \u00d7\u02e2 \ud835\udcdd y\u2080\n\u22a2 \u2203 t \u2208 \ud835\udcdd x\u2080 \u00d7\u02e2 \ud835\udcdd y\u2080, t \u00d7\u02e2 t \u2286 (U' \u00d7\u02e2 V') \u00d7\u02e2 U' \u00d7\u02e2 V'",["tauto","aesop"]],["Data/Nat/Factorization/Basic.lean",366,"case pos\n\u22a2 \u220f p \u2208 primeFactors 0, p \u2223 0",["simp","decide","aesop","tauto","norm_num"]],["Data/Nat/Factorization/Basic.lean",388,"case hd.inl\na b : \u2115\nha_pos : a \u2260 0\nhb_pos : b \u2260 0\ndfac : \u2115 \u2192\u2080 \u2115 := a.factorization \u2293 b.factorization\nd : \u2115 := dfac.prod fun x1 x2 \u21a6 x1 ^ x2\ndfac_prime : \u2200 p \u2208 dfac.support, Prime p\nh1 : d.factorization = dfac\nhd_pos : d \u2260 0\nheb : 0 \u2223 b\nhea : a = 0\n\u22a2 0 \u2223 d",["contradiction","omega","aesop","tauto"]],["Algebra/Group/Subgroup/Defs.lean",300,"case mk.mk.mk.mk.mk.mk\nG : Type u_1\ninst\u271d\u00b9 : Group G\nA : Type u_2\ninst\u271d : AddGroup A\nhp : Set G\nmul_mem'\u271d\u00b9 : \u2200 {a b : G}, a \u2208 hp \u2192 b \u2208 hp \u2192 a * b \u2208 hp\none_mem'\u271d\u00b9 : 1 \u2208 { carrier := hp, mul_mem' := mul_mem'\u271d\u00b9 }.carrier\ninv_mem'\u271d\u00b9 :\n  \u2200 {x : G},\n    x \u2208 { carrier := hp, mul_mem' := mul_mem'\u271d\u00b9, one_mem' := one_mem'\u271d\u00b9 }.carrier \u2192\n      x\u207b\u00b9 \u2208 { carrier := hp, mul_mem' := mul_mem'\u271d\u00b9, one_mem' := one_mem'\u271d\u00b9 }.carrier\nhq : Set G\nmul_mem'\u271d : \u2200 {a b : G}, a \u2208 hq \u2192 b \u2208 hq \u2192 a * b \u2208 hq\none_mem'\u271d : 1 \u2208 { carrier := hq, mul_mem' := mul_mem'\u271d }.carrier\ninv_mem'\u271d :\n  \u2200 {x : G},\n    x \u2208 { carrier := hq, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d }.carrier \u2192\n      x\u207b\u00b9 \u2208 { carrier := hq, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d }.carrier\nh :\n  (fun s \u21a6 s.carrier) { carrier := hp, mul_mem' := mul_mem'\u271d\u00b9, one_mem' := one_mem'\u271d\u00b9, inv_mem' := inv_mem'\u271d\u00b9 } =\n    (fun s \u21a6 s.carrier) { carrier := hq, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d, inv_mem' := inv_mem'\u271d }\n\u22a2 { carrier := hp, mul_mem' := mul_mem'\u271d\u00b9, one_mem' := one_mem'\u271d\u00b9, inv_mem' := inv_mem'\u271d\u00b9 } =\n    { carrier := hq, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d, inv_mem' := inv_mem'\u271d }",["congr","aesop"]],["NumberTheory/LSeries/PrimesInAP.lean",243,"case h\nq : \u2115\na : ZMod q\nh\u2080 : \u2200 (n : \u2115), 0 \u2264 (if Nat.Prime n then 0 else residueClass a n) / \u2191n\nhleF\u2080 : \u2200 (n : \u2115), (if Nat.Prime n then 0 else residueClass a n) / \u2191n \u2264 ArithmeticFunction.vonMangoldt.F\u2080 n\nhF\u2080 : \u2200 (p : Nat.Primes), ArithmeticFunction.vonMangoldt.F\u2080 \u2191p = 0\nn : Nat.Primes \u00d7 \u2115\n\u22a2 ArithmeticFunction.vonMangoldt.F\u2080 \u2191(prodNatEquiv n) = ArithmeticFunction.vonMangoldt.F\u2080 (\u2191n.1 ^ (n.2 + 1))",["congr","aesop","tauto","abel"]],["NumberTheory/LSeries/PrimesInAP.lean",317,"case refine_1\nq : \u2115\na : ZMod q\ninst\u271d : NeZero q\ns : \u2102\nhs : s = 1 \u2228 \u2200 (\u03c7 : DirichletCharacter \u2102 q), \u00acLFunction \u03c7 s = 0\nthis : 1 \u2260 1 \u2228 s \u2260 1 \u2192 1 \u2264 s.re \u2192 LFunction 1 s \u2260 0\n\u22a2 s \u2208 {s | s = 1 \u2228 LFunctionTrivChar q s \u2260 0}",["tauto","aesop"]],["MeasureTheory/Integral/MeanInequalities.lean",409,"\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhpq : p.IsConjExponent q\nf g : \u03b1 \u2192 \u211d\u22650\u221e\nhf : AEMeasurable f \u03bc\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 \u22a4\nhg : AEMeasurable g \u03bc\nhg_top : \u222b\u207b (a : \u03b1), g a ^ p \u2202\u03bc \u2260 \u22a4\nh_add_zero : \u222b\u207b (a : \u03b1), (f + g) a ^ p \u2202\u03bc \u2260 0\nh_add_top : \u222b\u207b (a : \u03b1), (f + g) a ^ p \u2202\u03bc \u2260 \u22a4\nhp_not_nonpos : \u00acp \u2264 0\nhtop_rpow : (\u222b\u207b (a : \u03b1), (f + g) a ^ p \u2202\u03bc) ^ (1 / p) \u2260 \u22a4\nh0_rpow : (\u222b\u207b (a : \u03b1), (f + g) a ^ p \u2202\u03bc) ^ (1 / p) \u2260 0\nh :\n  \u222b\u207b (a : \u03b1), (f + g) a ^ p \u2202\u03bc \u2264\n    ((\u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b (a : \u03b1), g a ^ p \u2202\u03bc) ^ (1 / p)) * (\u222b\u207b (a : \u03b1), (f + g) a ^ p \u2202\u03bc) ^ (1 / q)\n\u22a2 1 / q = p\u207b\u00b9 + q\u207b\u00b9 - 1 / p",["ring","aesop","norm_num","simp"]],["MeasureTheory/Measure/Stieltjes.lean",543,"\u22a2 \u2200 \u2983a b : \u211d\u2984, a < b \u2192 (StieltjesFunction.measure 0) (Ioc a b) = 0 (Ioc a b)",["simp","aesop","norm_num"]],["MeasureTheory/Measure/Stieltjes.lean",410,"f : StieltjesFunction\na b : \u211d\nhab : a < b\nA : Disjoint (Ioo a b) {b}\n\u22a2 \u2191f b - \u2191f a = \u2191f b - leftLim (\u2191f) b + (leftLim (\u2191f) b - \u2191f a)",["abel","ring","aesop","linarith","norm_num","simp"]],["RingTheory/Perfection.lean",520,"case refine_1\nK : Type u\u2081\ninst\u271d\u2074 : Field K\nv : Valuation K \u211d\u22650\nO : Type u\u2082\ninst\u271d\u00b3 : CommRing O\ninst\u271d\u00b2 : Algebra O K\nhv : v.Integers O\np : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nf g : PreTilt O p\nhf : \u00acf = 0\nhg : \u00acg = 0\nm n : \u2115\nhm : (coeff (ModP O p) p (m \u2294 n)) f \u2260 0\nhn : (coeff (ModP O p) p (m \u2294 n)) g \u2260 0\n\u22a2 (coeff (ModP O p) p (m \u2294 n)) f \u2260 0",["assumption","aesop","congr","tauto"]],["RingTheory/Perfection.lean",521,"case refine_2\nK : Type u\u2081\ninst\u271d\u2074 : Field K\nv : Valuation K \u211d\u22650\nO : Type u\u2082\ninst\u271d\u00b3 : CommRing O\ninst\u271d\u00b2 : Algebra O K\nhv : v.Integers O\np : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact \u00acIsUnit \u2191p\nf g : PreTilt O p\nhf : \u00acf = 0\nhg : \u00acg = 0\nm n : \u2115\nhm : (coeff (ModP O p) p (m \u2294 n)) f \u2260 0\nhn : (coeff (ModP O p) p (m \u2294 n)) g \u2260 0\n\u22a2 (coeff (ModP O p) p (m \u2294 n)) g \u2260 0",["assumption","aesop","congr","tauto"]],["Data/TypeVec.lean",193,"n : \u2115\n\u03b1 : TypeVec.{u_1} (n + 1)\n\u03b1' : TypeVec.{u_2} (n + 1)\nf f' : \u03b1.drop \u27f9 \u03b1'.drop\ng g' : \u03b1.last \u2192 \u03b1'.last\nH : splitFun f g = splitFun f' g'\n\u22a2 dropFun (splitFun f' g') = f' \u2227 lastFun (splitFun f' g') = g'",["simp","aesop","tauto"]],["Data/TypeVec.lean",276,"case h\nn : \u2115\n\u03b2 : (v : TypeVec.{?u.23356} 0) \u2192 (v' : TypeVec.{?u.23369} 0) \u2192 v \u27f9 v' \u2192 Sort u_1\nf : \u03b2 Fin2.elim0 Fin2.elim0 nilFun\nv : TypeVec.{?u.23356} 0\nv' : TypeVec.{?u.23369} 0\nfs : v \u27f9 v'\ni : Fin2 0\n\u22a2 v i = i.elim0",["contradiction","tauto"]],["Data/TypeVec.lean",277,"case h\nn : \u2115\n\u03b2 : (v : TypeVec.{?u.23356} 0) \u2192 (v' : TypeVec.{?u.23369} 0) \u2192 v \u27f9 v' \u2192 Sort u_1\nf : \u03b2 Fin2.elim0 Fin2.elim0 nilFun\nv : TypeVec.{?u.23356} 0\nv' : TypeVec.{?u.23369} 0\nfs : v \u27f9 v'\neq\u2081 : v = Fin2.elim0\ni : Fin2 0\n\u22a2 v' i = i.elim0",["contradiction"]],["Data/TypeVec.lean",278,"case h\nn : \u2115\n\u03b2 : (v : TypeVec.{?u.23356} 0) \u2192 (v' : TypeVec.{?u.23369} 0) \u2192 v \u27f9 v' \u2192 Sort u_1\nf : \u03b2 Fin2.elim0 Fin2.elim0 nilFun\nv : TypeVec.{?u.23356} 0\nv' : TypeVec.{?u.23369} 0\nfs : v \u27f9 v'\neq\u2081 : v = Fin2.elim0\neq\u2082 : v' = Fin2.elim0\ni : Fin2 0\n\u22a2 fs i = nilFun i",["contradiction"]],["Data/Nat/Squarefree.lean",137,"n k : \u2115\npk : Prime k\ndk : k \u2223 n\ndkk : \u00ack * k \u2223 n\no : Option \u2115\nH : (n / k).MinSqFacProp o\npp : Prime k\ndp : k * k \u2223 n\n\u22a2 False",["contradiction","omega","tauto"]],["Data/Nat/Squarefree.lean",166,"case inl\nn k : \u2115\nn0 : 0 < n\ni : \u2115\ne : k = 2 * i + 3\nih : \u2200 (m : \u2115), Prime m \u2192 m \u2223 n \u2192 k \u2264 m\nh : \u00acn < k * k\nk2 : 2 \u2264 k\nk0 : 0 < k\nn' : \u2115\nnd' : n' \u2223 n\nnk : \u00ack \u2223 n'\nhn' : n' \u2264 n\nthis : n'.sqrt - k < n.sqrt + 2 - k\nm2 : Prime k\nd : k \u2223 n'\n\u22a2 k + 2 \u2264 k",["contradiction"]],["Data/Nat/Squarefree.lean",194,"case neg.inr\nn : \u2115\nd2 : 2 \u2223 n\nd4 : \u00ac2 \u2223 n / 2\nn0 : n > 0\npp : Prime 2\ndp : 2 \u2223 n / 2\n\u22a2 False",["contradiction","omega","aesop","tauto"]],["Data/Nat/Squarefree.lean",201,"case neg.inr\nn : \u2115\nd2 : \u00ac2 \u2223 n\nn0 : n > 0\npp : Prime 2\ndp : 2 \u2223 n\n\u22a2 False",["contradiction"]],["Data/Nat/Squarefree.lean",189,"d2 : 2 \u2223 0\nd4 : \u00ac2 \u2223 0 / 2\n\u22a2 2 \u2223 0 / 2",["decide","omega","aesop","congr","gcongr","tauto","assumption","norm_num","contradiction","simp"]],["Data/Nat/Squarefree.lean",197,"d2 : \u00ac2 \u2223 0\n\u22a2 2 \u2223 0",["decide"]],["Combinatorics/Colex.lean",340,"\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns t : Colex \u03b1\n\u22a2 (\u2200 (h : s \u2260 t), (s.ofColex \u2206 t.ofColex).max' \u22ef \u2208 t.ofColex) \u2227 s \u2260 t \u2194\n    \u2203 (h : s \u2260 t), (s.ofColex \u2206 t.ofColex).max' \u22ef \u2208 t.ofColex",["aesop","tauto"]],["Topology/Homeomorph/Lemmas.lean",130,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nh : X \u2243\u209c Y\nx : X\n\u22a2 range \u21d1h \u2208 \ud835\udcdd (h x)",["simp","aesop"]],["Topology/Homotopy/Basic.lean",200,"case h\nX : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf\u2080 f\u2081 : C(X, Y)\nF : f\u2080.Homotopy f\u2081\nx\u271d : \u2191I \u00d7 X\n\u22a2 F.symm.symm x\u271d = F x\u271d",["simp","aesop","norm_num"]],["Topology/Homotopy/Basic.lean",104,"case mk.mk.mk.mk\nF : Type u_1\nX : Type u\nY : Type v\nZ : Type w\nZ' : Type x\n\u03b9 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace Z'\nf\u2080 f\u2081 : C(X, Y)\ntoFun\u271d\u00b9 : \u2191I \u00d7 X \u2192 Y\ncontinuous_toFun\u271d\u00b9 : Continuous toFun\u271d\u00b9\nmap_zero_left\u271d\u00b9 : \u2200 (x : X), { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun (0, x) = f\u2080 x\nmap_one_left\u271d\u00b9 : \u2200 (x : X), { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun (1, x) = f\u2081 x\ntoFun\u271d : \u2191I \u00d7 X \u2192 Y\ncontinuous_toFun\u271d : Continuous toFun\u271d\nmap_zero_left\u271d : \u2200 (x : X), { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }.toFun (0, x) = f\u2080 x\nmap_one_left\u271d : \u2200 (x : X), { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }.toFun (1, x) = f\u2081 x\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, map_zero_left := map_zero_left\u271d\u00b9,\n        map_one_left := map_one_left\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, map_zero_left := map_zero_left\u271d,\n        map_one_left := map_one_left\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, map_zero_left := map_zero_left\u271d\u00b9,\n      map_one_left := map_one_left\u271d\u00b9 } =\n    { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, map_zero_left := map_zero_left\u271d,\n      map_one_left := map_one_left\u271d }",["congr","aesop"]],["Topology/Homotopy/Basic.lean",194,"F\u271d : Type u_1\nX : Type u\nY : Type v\nZ : Type w\nZ' : Type x\n\u03b9 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace Z'\nf\u2080 f\u2081 : C(X, Y)\nF : f\u2080.Homotopy f\u2081\n\u22a2 \u2200 (x : X), { toFun := fun x \u21a6 F (\u03c3 x.1, x.2), continuous_toFun := \u22ef }.toFun (0, x) = f\u2081 x",["norm_num","aesop","simp"]],["Topology/Homotopy/Basic.lean",195,"F\u271d : Type u_1\nX : Type u\nY : Type v\nZ : Type w\nZ' : Type x\n\u03b9 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace Z'\nf\u2080 f\u2081 : C(X, Y)\nF : f\u2080.Homotopy f\u2081\n\u22a2 \u2200 (x : X), { toFun := fun x \u21a6 F (\u03c3 x.1, x.2), continuous_toFun := \u22ef }.toFun (1, x) = f\u2080 x",["norm_num","aesop","simp"]],["Topology/Homotopy/Basic.lean",219,"F\u271d : Type u_1\nX : Type u\nY : Type v\nZ : Type w\nZ' : Type x\n\u03b9 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace Z'\nf\u2080 f\u2081 f\u2082 : C(X, Y)\nF : f\u2080.Homotopy f\u2081\nG : f\u2081.Homotopy f\u2082\nx : X\n\u22a2 { toFun := fun x \u21a6 if \u2191x.1 \u2264 1 / 2 then (F.extend (2 * \u2191x.1)) x.2 else (G.extend (2 * \u2191x.1 - 1)) x.2,\n          continuous_toFun := \u22ef }.toFun\n      (0, x) =\n    f\u2080 x",["norm_num","aesop","simp"]],["Combinatorics/Configuration.lean",489,"K : Type u_3\ninst\u271d : Field K\na b c d : Fin 3 \u2192 K\nhac : a \u2b1d\u1d65 c = 0\nhbc : b \u2b1d\u1d65 c = 0\nhad : a \u2b1d\u1d65 d = 0\nhbd : b \u2b1d\u1d65 d = 0\nh : LinearIndependent K ![a, b] \u2227 LinearIndependent K ![c, d]\nA : Matrix (Fin 2) (Fin 3) K := ![a, b]\nB : Matrix (Fin 2) (Fin 3) K := ![c, d]\nhAB : (Nat.succ 0).succ + (Nat.succ 0).succ \u2264 3\n\u22a2 False",["contradiction","omega","aesop","linarith","tauto"]],["Analysis/Convex/Segment.lean",264,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : OrderedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nc x y : E\nh : LinearIndependent \ud835\udd5c ![x - c, y - c]\np : \ud835\udd5c\np0 : 0 \u2264 p\np1 : p \u2264 1\nq : \ud835\udd5c\nH : (1 - q) \u2022 c + q \u2022 y = (1 - p) \u2022 c + p \u2022 x\nq0 : 0 \u2264 q\nq1 : q \u2264 1\n\u22a2 x = x - c + c",["abel","aesop","norm_num","simp"]],["AlgebraicTopology/SimplicialSet/NerveAdjunction.lean",180,"C : Type u\ninst\u271d : SmallCategory C\nX : SSet.Truncated 2\nF : oneTruncation\u2082.obj X \u27f6 ReflQuiv.of C\nhyp : \u2200 (\u03c6 : X.obj (op { obj := [2], property := \u22ef })), F.map (ev02\u2082 \u03c6) = F.map (ev01\u2082 \u03c6) \u226b F.map (ev12\u2082 \u03c6)\nx : X.obj (op { obj := [1 + 1], property := \u22ef })\n\u22a2 0 \u2264 1",["decide","aesop","tauto","norm_num","simp"]],["AlgebraicTopology/SimplicialSet/NerveAdjunction.lean",185,"C : Type u\ninst\u271d : SmallCategory C\nX : SSet.Truncated 2\nF : oneTruncation\u2082.obj X \u27f6 ReflQuiv.of C\nhyp : \u2200 (\u03c6 : X.obj (op { obj := [2], property := \u22ef })), F.map (ev02\u2082 \u03c6) = F.map (ev01\u2082 \u03c6) \u226b F.map (ev12\u2082 \u03c6)\nx : X.obj (op { obj := [1 + 1], property := \u22ef })\n\u22a2 0 \u2264 0",["decide"]],["AlgebraicTopology/SimplicialSet/NerveAdjunction.lean",205,"C : Type u\ninst\u271d : SmallCategory C\nX : SSet.Truncated 2\nF : oneTruncation\u2082.obj X \u27f6 ReflQuiv.of C\nhyp : \u2200 (\u03c6 : X.obj (op { obj := [2], property := \u22ef })), F.map (ev02\u2082 \u03c6) = F.map (ev01\u2082 \u03c6) \u226b F.map (ev12\u2082 \u03c6)\nx : X.obj (op { obj := [1 + 1], property := \u22ef })\n\u22a2 1 \u2264 1",["decide"]],["NumberTheory/Padics/RingHoms.lean",365,"p : \u2115\nhp_prime : Fact (Nat.Prime p)\nn : \u2115\nih : \u2200 (x : \u2124_[p]), \u2191p ^ n \u2223 x - \u2191(x.appr n)\nx : \u2124_[p]\nh : \u00acx - \u2191(x.appr n) = 0\nhc : x - \u2191(x.appr n) = 0\n\u22a2 False",["contradiction","aesop","tauto"]],["Data/Finset/Basic.lean",443,"case refine_2\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nt\u2081 t\u2082 : Set \u03b1\nh : \u2191s \u2286 t\u2081 \u222a t\u2082\nx : \u03b1\n\u22a2 x \u2208 \u2191(filter (fun x \u21a6 x \u2208 t\u2081) s) \u2192 x \u2208 t\u2081",["simp","aesop"]],["Data/Finset/Basic.lean",480,"case h\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b2\nb a\u271d : \u03b2\n\u22a2 a\u271d \u2208 s \u2227 \u00acb = a\u271d \u2194 \u00aca\u271d = b \u2227 a\u271d \u2208 s",["tauto","aesop"]],["Data/Finset/Sups.lean",303,"\u03b1 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : Fintype \u03b1\n\u22a2 univ \u22bc univ = univ",["simp","aesop"]],["Data/Finset/Sups.lean",616,"case h\n\u03b1 : Type u_2\ninst\u271d : BooleanAlgebra \u03b1\ns : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 s\u1d9c\u02e2\u1d9c\u02e2 \u2194 a\u271d \u2208 s",["simp","aesop"]],["Data/Finset/Sups.lean",629,"case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : BooleanAlgebra \u03b1\ninst\u271d : Fintype \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 univ\u1d9c\u02e2 \u2194 a\u271d \u2208 univ",["simp","aesop"]],["Algebra/Algebra/Equiv.lean",322,"case H\nR : Type uR\nA\u2081 : Type uA\u2081\nA\u2082 : Type uA\u2082\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\u2081\ninst\u271d\u00b2 : Semiring A\u2082\ninst\u271d\u00b9 : Algebra R A\u2081\ninst\u271d : Algebra R A\u2082\ne : A\u2081 \u2243\u2090[R] A\u2082\nx\u271d : A\u2081\n\u22a2 ((\u2191e.symm).comp \u2191e) x\u271d = (AlgHom.id R A\u2081) x\u271d",["simp","aesop"]],["Order/SupClosed.lean",381,"\u03b1 : Type u_3\ninst\u271d : SemilatticeInf \u03b1\n\u22a2 infClosure Set.univ = Set.univ",["simp","aesop"]],["Order/SupClosed.lean",448,"\u03b1 : Type u_3\ninst\u271d : Lattice \u03b1\na : \u03b1\n\u22a2 latticeClosure {a} = {a}",["simp","aesop"]],["Order/SupClosed.lean",380,"\u03b1 : Type u_3\ninst\u271d : SemilatticeInf \u03b1\na : \u03b1\n\u22a2 infClosure {a} = {a}",["simp","aesop"]],["Order/SupClosed.lean",309,"\u03b1 : Type u_3\ninst\u271d : SemilatticeSup \u03b1\n\u22a2 supClosure Set.univ = Set.univ",["simp","aesop"]],["Algebra/MvPolynomial/Equiv.lean",411,"R : Type u\ninst\u271d : CommSemiring R\nn : \u2115\nj : Fin (n + 1) \u2192\u2080 \u2115\nr : R\nhjmi : j \u2260 j\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/Polynomial/AlgebraMap.lean",656,"R : Type u\ninst\u271d : CommSemiring R\nP : R[X]\nh : \u2200 (r : R), r \u2022 P = 0 \u2192 r = 0\nQ : R[X]\nhQ : P * Q = 0\nl : \u2115\nIH : \u2200 m > l, P.coeff m \u2022 Q = 0\nhl : (P.coeff l \u2022 Q).natDegree = Q.natDegree\nm : \u2115 := Q.natDegree\n\u22a2 (l, m) \u2209 antidiagonal (l + m) \u2192 P.coeff (l, m).1 * Q.coeff (l, m).2 = 0",["simp","aesop","norm_num"]],["Algebra/Polynomial/AlgebraMap.lean",320,"R\u271d : Type u\nS : Type v\nT : Type w\nA : Type z\nA' : Type u_1\nB : Type u_2\na b : R\u271d\nn : \u2115\ninst\u271d\u2076 : CommSemiring R\u271d\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : CommSemiring A'\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R\u271d A\ninst\u271d\u00b9 : Algebra R\u271d B\np q : R\u271d[X]\nx : A\nR : Type u_3\ninst\u271d : CommRing R\n\u22a2 (-X).comp (-X) = X",["simp","aesop","norm_num"]],["Algebra/Polynomial/AlgebraMap.lean",305,"R\u271d : Type u\nS : Type v\nT : Type w\nA : Type z\nA' : Type u_1\nB : Type u_2\na b : R\u271d\nn : \u2115\ninst\u271d\u2076 : CommSemiring R\u271d\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : CommSemiring A'\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R\u271d A\ninst\u271d\u00b9 : Algebra R\u271d B\np q : R\u271d[X]\nx : A\nR : Type u_3\ninst\u271d : CommRing R\nt : R\n\u22a2 (X - C t).comp (X + C t) = X",["simp","aesop","norm_num"]],["Algebra/Polynomial/AlgebraMap.lean",176,"case H\nR : Type u\nA : Type z\nB : Type u_2\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Semiring B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\nC : Type z\ninst\u271d\u00b9 : Semiring C\ninst\u271d : Algebra R C\nf : B \u2192\u2090[R] C\ng : A \u2192\u2090[R] B\nx : A[X]\n\u22a2 map ((\u2191f).comp \u2191g) x = map (\u2191(f.comp g)) x",["congr","aesop","tauto","abel"]],["Algebra/Polynomial/AlgebraMap.lean",182,"case H\nR : Type u\nA : Type z\nB : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Semiring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\nx : A[X]\n\u22a2 (mapAlgHom f) x = (eval\u2082AlgHom' (CAlgHom.comp f) X \u22ef) x",["congr","aesop","tauto","abel"]],["Algebra/Polynomial/AlgebraMap.lean",207,"case h\nR : Type u\nA : Type z\nB : Type u_2\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Semiring B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\nC : Type z\ninst\u271d\u00b9 : Semiring C\ninst\u271d : Algebra R C\nf : A \u2243\u2090[R] B\ng : B \u2243\u2090[R] C\nx : A[X]\n\u22a2 map ((\u2191g).comp \u2191f) x = map (\u2191(f.trans g)) x",["congr","aesop","tauto","abel"]],["Geometry/Euclidean/Angle/Sphere.lean",351,"V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\nhd2 : Fact (finrank \u211d V = 2)\ninst\u271d : Oriented \u211d V (Fin 2)\np\u2081 p\u2082 p\u2083 p\u2084 : P\nh : 2 \u2022 \u2221 p\u2081 p\u2082 p\u2084 = 2 \u2022 \u2221 p\u2081 p\u2083 p\u2084\nhn : \u00acCollinear \u211d {p\u2081, p\u2082, p\u2084}\nhn' : \u00acCollinear \u211d {p\u2081, p\u2083, p\u2084}\nt\u2081 : Affine.Triangle \u211d P := { points := ![p\u2081, p\u2082, p\u2084], independent := \u22ef }\nt\u2082 : Affine.Triangle \u211d P := { points := ![p\u2081, p\u2083, p\u2084], independent := \u22ef }\n\u22a2 1 \u2260 2",["decide","omega","aesop","tauto","simp"]],["Topology/LocallyConstant/Basic.lean",293,"case h.e'_3.h\nX\u271d : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\u271d\nX : Type u_5\ninst\u271d\u00b9 : TopologicalSpace X\nU : Set X\ninst\u271d : (x : X) \u2192 Decidable (x \u2208 U)\nhU : IsClopen U\nx\u271d : X\n\u22a2 x\u271d \u2208 ((fun x \u21a6 if x \u2208 U then 0 else 1) \u207b\u00b9' {1})\u1d9c \u2194 x\u271d \u2208 U",["simp","aesop"]],["Topology/LocallyConstant/Basic.lean",503,"X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : (s : Set X) \u2192 (x : X) \u2192 Decidable (x \u2208 s)\nx\u271d : TopologicalSpace.Clopens X\n\u22a2 (fun f \u21a6 { carrier := \u21d1f \u207b\u00b9' {0}, isClopen' := \u22ef }) ((fun s \u21a6 ofIsClopen \u22ef) x\u271d) = x\u271d",["simp","aesop"]],["Topology/LocallyConstant/Basic.lean",502,"X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : (s : Set X) \u2192 (x : X) \u2192 Decidable (x \u2208 s)\nx\u271d : LocallyConstant X (Fin 2)\n\u22a2 \u21d1((fun s \u21a6 ofIsClopen \u22ef) ((fun f \u21a6 { carrier := \u21d1f \u207b\u00b9' {0}, isClopen' := \u22ef }) x\u271d)) \u207b\u00b9' {0} = \u21d1x\u271d \u207b\u00b9' {0}",["simp","aesop"]],["Topology/LocallyConstant/Basic.lean",215,"case mk.mk\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d : TopologicalSpace X\ntoFun\u271d\u00b9 : X \u2192 Y\nisLocallyConstant\u271d\u00b9 : IsLocallyConstant toFun\u271d\u00b9\ntoFun\u271d : X \u2192 Y\nisLocallyConstant\u271d : IsLocallyConstant toFun\u271d\na\u271d :\n  { toFun := toFun\u271d\u00b9, isLocallyConstant := isLocallyConstant\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, isLocallyConstant := isLocallyConstant\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, isLocallyConstant := isLocallyConstant\u271d\u00b9 } =\n    { toFun := toFun\u271d, isLocallyConstant := isLocallyConstant\u271d }",["congr","aesop"]],["Topology/LocallyConstant/Basic.lean",289,"case h.e'_3.h\nX\u271d : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\u271d\nX : Type u_5\ninst\u271d\u00b9 : TopologicalSpace X\nU : Set X\ninst\u271d : (x : X) \u2192 Decidable (x \u2208 U)\nhU : IsClopen U\nx\u271d : X\n\u22a2 x\u271d \u2209 U \u2192 False \u2194 x\u271d \u2208 U",["tauto","aesop","simp"]],["Topology/LocallyConstant/Basic.lean",301,"case h\nX : Type u_5\ninst\u271d\u00b9 : TopologicalSpace X\nU : Set X\ninst\u271d : (x : X) \u2192 Decidable (x \u2208 U)\nhU : IsClopen U\nx\u271d : X\n\u22a2 x\u271d \u2209 U \u2192 False \u2194 x\u271d \u2208 U",["tauto","aesop","simp"]],["RingTheory/Flat/FaithfullyFlat/Basic.lean",367,"R : Type u\nM : Type v\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\nN : Type u_4\nN' : Type u_5\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : AddCommGroup N'\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : Module R N'\nf : N \u2192\u2097[R] N'\ninst\u271d : FaithfullyFlat R M\n\u22a2 Function.Exact \u21d10 \u21d1(LinearMap.lTensor M f) \u2194 Function.Exact \u21d1(LinearMap.lTensor M 0) \u21d1(LinearMap.lTensor M f)",["simp","aesop","norm_num"]],["RingTheory/Flat/FaithfullyFlat/Basic.lean",375,"R : Type u\nM : Type v\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\nN : Type u_4\nN' : Type u_5\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : AddCommGroup N'\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : Module R N'\nf : N \u2192\u2097[R] N'\ninst\u271d : FaithfullyFlat R M\n\u22a2 Function.Exact \u21d1(LinearMap.lTensor M f) \u21d10 \u2194 Function.Exact \u21d1(LinearMap.lTensor M f) \u21d1(LinearMap.lTensor M 0)",["simp","aesop","norm_num"]],["RingTheory/Flat/FaithfullyFlat/Basic.lean",94,"case pos\nR : Type u\nM : Type v\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nfl : FaithfullyFlat R M\nN : Type u_1\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\ninst\u271d : Nontrivial N\nn : N\nhn : n \u2260 0\nI : Ideal R := (Submodule.span R {n}).annihilator\nI_ne_top : n = 0\n\u22a2 Nontrivial (N \u2297[R] M)",["contradiction","aesop","tauto"]],["RingTheory/Flat/FaithfullyFlat/Basic.lean",147,"R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx\u271d :\n  Flat R M \u2227 \u2200 (N : Type (max u v)) [inst : AddCommGroup N] [inst_1 : Module R N], Nontrivial N \u2192 Nontrivial (N \u2297[R] M)\nflat : Flat R M\nm : Ideal R\nhm : m.IsMaximal\nrid : m \u2022 \u22a4 = \u22a4\nfaithful : Nontrivial (ULift.{v, u} (R \u29f8 m) \u2297[R] M)\nthis\u271d : Nontrivial ((R \u29f8 m) \u2297[R] M)\nthis : Nontrivial (M \u29f8 m \u2022 \u22a4)\nH : \u00acNontrivial (M \u29f8 m \u2022 \u22a4)\n\u22a2 False",["contradiction","aesop","tauto"]],["RingTheory/Flat/FaithfullyFlat/Basic.lean",81,"R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx\u271d : Flat R M\nI : Ideal R\n\u22a2 I \u2260 \u22a4 \u2192 I \u2022 \u22a4 \u2260 \u22a4 \u2194 I \u2022 \u22a4 = \u22a4 \u2192 I = \u22a4",["tauto","aesop"]],["RingTheory/Flat/FaithfullyFlat/Basic.lean",156,"R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx\u271d\u00b2 : Flat R M\nN : Type (max u v)\nx\u271d\u00b9 : AddCommGroup N\nx\u271d : Module R N\n\u22a2 \u00acSubsingleton N \u2192 \u00acSubsingleton (N \u2297[R] M) \u2194 Subsingleton (N \u2297[R] M) \u2192 Subsingleton N",["tauto","aesop"]],["RingTheory/Flat/FaithfullyFlat/Basic.lean",176,"R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx\u271d\u00b2 : Flat R M\nN : Type (max u v)\nx\u271d\u00b9 : AddCommGroup N\nx\u271d : Module R N\n\u22a2 \u00acSubsingleton N \u2192 \u00acSubsingleton (M \u2297[R] N) \u2194 Subsingleton (M \u2297[R] N) \u2192 Subsingleton N",["tauto","aesop"]],["Data/Nat/PartENat.lean",531,"n : \u2115\nx\u271d : Decidable (\u2191n).Dom\n\u22a2 (\u2191n).toWithTop = (\u2191n).toWithTop",["congr"]],["Analysis/MellinTransform.lean",381,"case h.e'_9\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\na b : \u211d\nf : \u211d \u2192 E\ns : \u2102\nhfc : LocallyIntegrableOn f (Ioi 0) volume\nhf_top : f =O[atTop] fun x \u21a6 x ^ (-a)\nhs_top : s.re < a\nhf_bot : f =O[\ud835\udcdd[>] 0] fun x \u21a6 x ^ (-b)\nhs_bot : b < s.re\nF : \u2102 \u2192 \u211d \u2192 E := fun z t \u21a6 \u2191t ^ (z - 1) \u2022 f t\nF' : \u2102 \u2192 \u211d \u2192 E := fun z t \u21a6 (\u2191t ^ (z - 1) * \u2191(log t)) \u2022 f t\nv : \u211d\nhv0 : 0 < v\nhv1 : v < s.re - b\nhv2 : v < a - s.re\nbound : \u211d \u2192 \u211d := fun t \u21a6 (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * \u2016f t\u2016\nh1 : \u2200\u1da0 (z : \u2102) in \ud835\udcdd s, AEStronglyMeasurable (F z) (volume.restrict (Ioi 0))\nh2 : IntegrableOn (F s) (Ioi 0) volume\nh3 : AEStronglyMeasurable (F' s) (volume.restrict (Ioi 0))\nh4 : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), \u2200 z \u2208 Metric.ball s v, \u2016F' z t\u2016 \u2264 bound t\nh5 : IntegrableOn bound (Ioi 0) volume\nt : \u211d\nht : t \u2208 Ioi 0\ny : \u2102\nx\u271d : y \u2208 Metric.ball s v\nht' : \u2191t \u2260 0\n\u22a2 \u2191t ^ (y - 1) * Complex.log \u2191t = \u2191t ^ (y - 1) * Complex.log \u2191t * 1",["ring","aesop","norm_num","simp"]],["Analysis/Normed/Operator/Banach.lean",99,"case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomIsometric \u03c3\ninst\u271d\u00b9 : RingHomIsometric \u03c3'\ninst\u271d : CompleteSpace F\nsurj : Surjective \u21d1f\nA : \u22c3 n, closure (\u21d1f '' ball 0 \u2191n) = Set.univ\nn : \u2115\na : F\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nH : ball a \u03b5 \u2286 closure (\u21d1f '' ball 0 \u2191n)\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\n\u22a2 dist (f 0) 0 \u2264 1 / 2 * \u20160\u2016 \u2227 \u20160\u2016 \u2264 (\u03b5 / 2)\u207b\u00b9 * \u2016c\u2016 * 2 * \u2191n * \u20160\u2016",["simp","aesop","norm_num"]],["Analysis/Normed/Operator/Banach.lean",103,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomIsometric \u03c3\ninst\u271d\u00b9 : RingHomIsometric \u03c3'\ninst\u271d : CompleteSpace F\nsurj : Surjective \u21d1f\nA : \u22c3 n, closure (\u21d1f '' ball 0 \u2191n) = Set.univ\nn : \u2115\na : F\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nH : ball a \u03b5 \u2286 closure (\u21d1f '' ball 0 \u2191n)\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\ny : F\nhy : y \u2260 0\nhc' : 1 < \u2016\u03c3 c\u2016\nd : \ud835\udd5c'\nhd : d \u2260 0\nydlt : \u2016d \u2022 y\u2016 < \u03b5 / 2\ndinv : \u2016d\u2016\u207b\u00b9 \u2264 (\u03b5 / 2)\u207b\u00b9 * \u2016\u03c3 c\u2016 * \u2016y\u2016\n\u03b4 : \u211d := \u2016d\u2016 * \u2016y\u2016 / 4\n\u22a2 0 < 4",["norm_num","aesop","linarith","positivity","simp"]],["RingTheory/Smooth/StandardSmooth.lean",230,"R : Type u\nS : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nr : R\ninst\u271d : IsLocalization.Away r S\n\u22a2 (pderiv ()) (C r * X () - 1) = C r",["simp","aesop","norm_num"]],["RingTheory/Smooth/StandardSmooth.lean",188,"n m : \u2115\nR : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nP : PreSubmersivePresentation R S\nh\u271d : Function.Bijective \u21d1(algebraMap R S)\na b : PEmpty.{t + 1}\nh : a.elim = b.elim\n\u22a2 a = b",["contradiction","aesop","tauto"]],["RingTheory/Smooth/StandardSmooth.lean",204,"case a\nR : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nh : Function.Bijective \u21d1(algebraMap R S)\ni j : PEmpty.{?u.46898 + 1}\n\u22a2 (algebraMap (ofBijectiveAlgebraMap h).Ring S).mapMatrix (ofBijectiveAlgebraMap h).jacobiMatrix i j = 1 i j",["contradiction"]],["Topology/MetricSpace/GromovHausdorffRealized.lean",157,"X : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nf : GromovHausdorff.ProdSpaceFun X Y\nfA : f \u2208 candidates X Y\nx : Y\ny : X\n\u22a2 \u2191(GromovHausdorff.maxVar X Y) = \u2191(GromovHausdorff.maxVar X Y) * 1",["simp","ring","aesop","linarith","norm_num"]],["Topology/MetricSpace/GromovHausdorffRealized.lean",67,"X : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\n\u22a2 1 = 2 * 0 + 1 + 2 * 0",["simp","ring","aesop","linarith","norm_num"]],["Topology/MetricSpace/GromovHausdorffRealized.lean",422,"case intro\nX : Type u\nY : Type v\ninst\u271d\u2075 : MetricSpace X\ninst\u271d\u2074 : CompactSpace X\ninst\u271d\u00b3 : Nonempty X\ninst\u271d\u00b2 : MetricSpace Y\ninst\u271d\u00b9 : CompactSpace Y\ninst\u271d : Nonempty Y\nleft\u271d : Classical.choose \u22ef \u2208 GromovHausdorff.candidatesB X Y\nright\u271d : \u2200 g \u2208 GromovHausdorff.candidatesB X Y, HD (Classical.choose \u22ef) \u2264 HD g\n\u22a2 GromovHausdorff.optimalGHDist X Y \u2208 GromovHausdorff.candidatesB X Y",["assumption","aesop","congr","tauto"]],["Topology/MetricSpace/GromovHausdorffRealized.lean",147,"X : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nf : GromovHausdorff.ProdSpaceFun X Y\nfA : f \u2208 candidates X Y\nx y : X\n\u22a2 dist (inl x) (inl y) = 1 * dist (inl x) (inl y)",["ring","aesop","linarith","norm_num","simp"]],["Topology/MetricSpace/GromovHausdorffRealized.lean",165,"X : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nf : GromovHausdorff.ProdSpaceFun X Y\nfA : f \u2208 candidates X Y\nx y : Y\n\u22a2 dist (inr x) (inr y) = 1 * dist (inr x) (inr y)",["ring","aesop","linarith","norm_num","simp"]],["NumberTheory/Modular.lean",454,"case inl\ng : SL(2, \u2124)\nz : \u210d\nhz : z \u2208 \ud835\udc9f\u1d52\nhg : g \u2022 z \u2208 \ud835\udc9f\u1d52\nc' : \u2124 := \u2191g 1 0\nc : \u211d := \u2191c'\nthis : c \u2260 0 \u2192 9 * c ^ 4 < 16\nhc : c = 0\n\u22a2 3 * 0 ^ 2 < 4",["norm_num","aesop","linarith","simp"]],["CategoryTheory/Groupoid/Subgroupoid.lean",427,"case im.hf\nC : Type u\ninst\u271d\u00b9 : Groupoid C\nS\u271d : Subgroupoid C\nD : Type u_1\ninst\u271d : Groupoid D\n\u03c6 : C \u2964 D\nh\u03c6 : Function.Injective \u03c6.obj\nS : Subgroupoid C\nc d : D\nc\u271d d\u271d : C\nf\u271d : c\u271d \u27f6 d\u271d\nhf\u271d : f\u271d \u2208 S.arrows c\u271d d\u271d\n\u22a2 f\u271d \u2208 S.arrows c\u271d d\u271d",["assumption","aesop","congr","gcongr","tauto"]],["CategoryTheory/Groupoid/Subgroupoid.lean",552,"case intro\nC : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nc\u271d d\u271d : C\na\u271d : c\u271d \u27f6 d\u271d\nleft\u271d : c\u271d = d\u271d\nright\u271d : a\u271d \u2208 S.arrows c\u271d d\u271d\n\u22a2 a\u271d \u2208 S.arrows c\u271d d\u271d",["assumption","aesop","congr","gcongr","tauto"]],["MeasureTheory/SetSemiring.lean",197,"case h.e'_4\n\u03b1 : Type u_1\nC : Set (Set \u03b1)\ns : Set \u03b1\nI : Finset (Set \u03b1)\nhC : IsSetSemiring C\nhs : s \u2208 C\nt : Set \u03b1\nI' : Finset (Set \u03b1)\na\u271d\u00b2 : t \u2209 I'\nh : \u2191I' \u2286 C \u2192 \u2203 J, \u2191J \u2286 C \u2227 (\u2191J).PairwiseDisjoint id \u2227 s \\ \u22c3\u2080 \u2191I' = \u22c3\u2080 \u2191J\nhI : insert t \u2191I' \u2286 C\nht : t \u2208 C\nJ : Finset (Set \u03b1)\nh_ss : \u2191J \u2286 C\nh_dis : (\u2191J).PairwiseDisjoint id\nh_eq : s \\ \u22c3\u2080 \u2191I' = \u22c3\u2080 \u2191J\nJu : (u : Set \u03b1) \u2192 u \u2208 C \u2192 Finset (Set \u03b1) := fun u hu \u21a6 hC.disjointOfDiff hu ht\nhJu_subset : \u2200 (u : Set \u03b1) (hu : u \u2208 C), \u2191(Ju u hu) \u2286 C\nhJu_disj : \u2200 (u : Set \u03b1) (hu : u \u2208 C), (\u2191(Ju u hu)).PairwiseDisjoint id\nhJu_sUnion : \u2200 (u : Set \u03b1) (hu : u \u2208 C), \u22c3\u2080 \u2191(Ju u hu) = u \\ t\nhJu_disj' : \u2200 (u : Set \u03b1) (hu : u \u2208 C) (v : Set \u03b1) (hv : v \u2208 C), Disjoint u v \u2192 Disjoint (\u22c3\u2080 \u2191(Ju u hu)) (\u22c3\u2080 \u2191(Ju v hv))\nJ' : Finset (Set \u03b1) := Finset.univ.biUnion fun u \u21a6 Ju \u2191u \u22ef\nhJ'_subset : \u2191J' \u2286 C\nx : { x // x \u2208 J }\na\u271d\u00b9 : x \u2208 \u2191J.attach\ny : { x // x \u2208 J }\na\u271d : y \u2208 \u2191J.attach\nhxy : x \u2260 y\nhxy_disj : Disjoint \u2191x \u2191y\n\u22a2 (fun i' \u21a6 \u22c3 i \u2208 Ju \u2191i' \u22ef, i) x = \u22c3 i \u2208 \u2191(Ju \u2191x \u22ef), i",["congr","aesop","tauto","simp"]],["MeasureTheory/SetSemiring.lean",199,"case h.e'_5\n\u03b1 : Type u_1\nC : Set (Set \u03b1)\ns : Set \u03b1\nI : Finset (Set \u03b1)\nhC : IsSetSemiring C\nhs : s \u2208 C\nt : Set \u03b1\nI' : Finset (Set \u03b1)\na\u271d\u00b2 : t \u2209 I'\nh : \u2191I' \u2286 C \u2192 \u2203 J, \u2191J \u2286 C \u2227 (\u2191J).PairwiseDisjoint id \u2227 s \\ \u22c3\u2080 \u2191I' = \u22c3\u2080 \u2191J\nhI : insert t \u2191I' \u2286 C\nht : t \u2208 C\nJ : Finset (Set \u03b1)\nh_ss : \u2191J \u2286 C\nh_dis : (\u2191J).PairwiseDisjoint id\nh_eq : s \\ \u22c3\u2080 \u2191I' = \u22c3\u2080 \u2191J\nJu : (u : Set \u03b1) \u2192 u \u2208 C \u2192 Finset (Set \u03b1) := fun u hu \u21a6 hC.disjointOfDiff hu ht\nhJu_subset : \u2200 (u : Set \u03b1) (hu : u \u2208 C), \u2191(Ju u hu) \u2286 C\nhJu_disj : \u2200 (u : Set \u03b1) (hu : u \u2208 C), (\u2191(Ju u hu)).PairwiseDisjoint id\nhJu_sUnion : \u2200 (u : Set \u03b1) (hu : u \u2208 C), \u22c3\u2080 \u2191(Ju u hu) = u \\ t\nhJu_disj' : \u2200 (u : Set \u03b1) (hu : u \u2208 C) (v : Set \u03b1) (hv : v \u2208 C), Disjoint u v \u2192 Disjoint (\u22c3\u2080 \u2191(Ju u hu)) (\u22c3\u2080 \u2191(Ju v hv))\nJ' : Finset (Set \u03b1) := Finset.univ.biUnion fun u \u21a6 Ju \u2191u \u22ef\nhJ'_subset : \u2191J' \u2286 C\nx : { x // x \u2208 J }\na\u271d\u00b9 : x \u2208 \u2191J.attach\ny : { x // x \u2208 J }\na\u271d : y \u2208 \u2191J.attach\nhxy : x \u2260 y\nhxy_disj : Disjoint \u2191x \u2191y\n\u22a2 (fun i' \u21a6 \u22c3 i \u2208 Ju \u2191i' \u22ef, i) y = \u22c3 i \u2208 \u2191(Ju \u2191y \u22ef), i",["congr"]],["Data/PFun.lean",492,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192. \u03b2\nx\u271d\u00b9 : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 f.comp (PFun.id \u03b1) x\u271d\u00b9 \u2194 x\u271d \u2208 f x\u271d\u00b9",["simp","aesop"]],["Data/PFun.lean",488,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192. \u03b2\nx\u271d\u00b9 : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 (PFun.id \u03b2).comp f x\u271d\u00b9 \u2194 x\u271d \u2208 f x\u271d\u00b9",["simp","aesop"]],["Data/PFun.lean",339,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : \u03b1 \u2192 Sort u_7\nf : \u03b1 \u2192. \u03b2 \u2295 \u03b1\nb : \u03b2\na a' : \u03b1\nh : b \u2208 f.fix a\nh' : b \u2208 f.fix a'\nfa : Sum.inr a' \u2208 f a\nhbase : (a_final : \u03b1) \u2192 Sum.inl b \u2208 f a_final \u2192 C a_final\nhind : (a\u2080 a\u2081 : \u03b1) \u2192 b \u2208 f.fix a\u2081 \u2192 Sum.inr a\u2081 \u2208 f a\u2080 \u2192 C a\u2081 \u2192 C a\u2080\n\u22a2 (fun x e \u21a6\n      Sum.casesOn (motive := fun y \u21a6 (f a).get \u22ef = y \u2192 C a) x\n          (fun b' e \u21a6\n            let_fun e := \u22ef;\n            hbase a \u22ef)\n          (fun a'' e \u21a6\n            let_fun e := \u22ef;\n            hind a a'' \u22ef e\n              ((fun x h' \u21a6\n                  fixInduction \u22ef fun a' h ih \u21a6\n                    Sum.casesOn (motive := fun x \u21a6 (f a').get \u22ef = x \u2192 C a') ((f a').get \u22ef)\n                      (fun b' e \u21a6\n                        let_fun e := \u22ef;\n                        hbase a' \u22ef)\n                      (fun a'' e \u21a6\n                        let_fun e := \u22ef;\n                        hind a' a'' \u22ef e (ih a'' e))\n                      \u22ef)\n                a'' e))\n          \u22ef =\n        hind a a' h' fa\n          (fixInduction h' fun a' h ih \u21a6\n            Sum.casesOn (motive := fun x \u21a6 (f a').get \u22ef = x \u2192 (fun x \u21a6 C x) a') ((f a').get \u22ef)\n              (fun b' e \u21a6\n                let_fun e := \u22ef;\n                hbase a' \u22ef)\n              (fun a'' e \u21a6\n                let_fun e := \u22ef;\n                hind a' a'' \u22ef e (ih a'' e))\n              \u22ef))\n    (Sum.inr a') \u22ef",["simp","aesop","congr","tauto"]],["Topology/UniformSpace/Completion.lean",253,"\u03b1 : Type u\ninst\u271d\u00b2 : UniformSpace \u03b1\n\u03b2 : Type v\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : CompleteSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : \u00acUniformContinuous f\na _b : CauchyFilter \u03b1\n\u22a2 f \u22ef.some = f \u22ef.some",["congr","aesop","tauto","simp"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Basic.lean",394,"A : Type u_2\ninst\u271d : NonUnitalCStarAlgebra A\nx\u271d : PartialOrder A := spectralOrder A\nx p : A\na\u271d : Nontrivial A\n\u22a2 IsSelfAdjoint 0 \u2227 \u2200 x \u2208 spectrum \u211d \u21910, 0 \u2264 x",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Basic.lean",216,"case ha\nA : Type u_2\ninst\u271d : CStarAlgebra A\na : A\nt : \u211d\u22650\nha : IsSelfAdjoint a\nht : spectralRadius \u211d a \u2264 \u2191t\nthis : IsSelfAdjoint ((algebraMap \u211d A) \u2191t - a)\n\u22a2 IsSelfAdjoint ((algebraMap \u211d A) \u2191t - a)\n```\n---\n```lean\ncase ha\nA : Type u_2\ninst\u271d : CStarAlgebra A\na : A\nt : \u211d\u22650\nha : IsSelfAdjoint a\nht : spectralRadius \u2102 a \u2264 \u2191t\nthis : IsSelfAdjoint ((algebraMap \u211d A) \u2191t - a)\n\u22a2 IsSelfAdjoint a\n```\n---\n```lean\nA : Type u_2\ninst\u271d : CStarAlgebra A\na : A\nt : \u211d\u22650\nha : IsSelfAdjoint a\nht : spectralRadius \u2102 a \u2264 \u2191t\nthis : IsSelfAdjoint ((algebraMap \u211d A) \u2191t - a)\n\u22a2 IsSelfAdjoint ((algebraMap \u211d A) \u2191t - a)\n```\n---\n```lean\nA : Type u_2\ninst\u271d : CStarAlgebra A\na : A\nt : \u211d\u22650\nha : IsSelfAdjoint a\nht : \u2191\u2016a\u2016\u208a \u2264 \u2191t\nthis : IsSelfAdjoint ((algebraMap \u211d A) \u2191t - a)\n\u22a2 IsSelfAdjoint a",["assumption","aesop","congr","gcongr","tauto"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Basic.lean",295,"A : Type u_2\ninst\u271d : CStarAlgebra A\nb : A\na : A := star b * b\na_def : a = star b * b\nha : IsSelfAdjoint a\nc : A := b * a\u207b\nh_eq_negPart_a : -(star c * c) = a\u207b ^ 3\nh_c_spec\u2080 : SpectrumRestricts (-(star c * c)) fun x \u21a6 ContinuousMap.realToNNReal x\n\u22a2 0 \u2264 \u21912",["norm_num","aesop","linarith","positivity","simp"]],["Topology/Path.lean",448,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3 : Path x y\na\u2081 a\u2082 a\u2083 : X\nb\u2081 b\u2082 b\u2083 : Y\n\u03b3\u2081 : Path a\u2081 a\u2082\n\u03b3\u2082 : Path b\u2081 b\u2082\n\u22a2 (\u03b3\u2081.prodMk \u03b3\u2082.toContinuousMap).toFun 1 = (a\u2082, b\u2082)",["simp","aesop","norm_num"]],["Topology/Path.lean",474,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d : Path x y\n\u03c7 : \u03b9 \u2192 Type u_4\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c7 i)\nas bs cs : (i : \u03b9) \u2192 \u03c7 i\n\u03b3 : (i : \u03b9) \u2192 Path (as i) (bs i)\n\u22a2 (ContinuousMap.pi fun i \u21a6 (\u03b3 i).toContinuousMap).toFun 0 = as",["simp","aesop","norm_num"]],["Topology/Path.lean",63,"case mk.mk\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\ntoContinuousMap\u271d\u00b9 : C(\u2191I, X)\nsource'\u271d\u00b9 : toContinuousMap\u271d\u00b9.toFun 0 = x\ntarget'\u271d\u00b9 : toContinuousMap\u271d\u00b9.toFun 1 = y\ntoContinuousMap\u271d : C(\u2191I, X)\nsource'\u271d : toContinuousMap\u271d.toFun 0 = x\ntarget'\u271d : toContinuousMap\u271d.toFun 1 = y\nh :\n  { toContinuousMap := toContinuousMap\u271d\u00b9, source' := source'\u271d\u00b9, target' := target'\u271d\u00b9 }.toContinuousMap =\n    { toContinuousMap := toContinuousMap\u271d, source' := source'\u271d, target' := target'\u271d }.toContinuousMap\n\u22a2 { toContinuousMap := toContinuousMap\u271d\u00b9, source' := source'\u271d\u00b9, target' := target'\u271d\u00b9 } =\n    { toContinuousMap := toContinuousMap\u271d, source' := source'\u271d, target' := target'\u271d }",["congr","aesop"]],["Topology/Path.lean",258,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\n\u03b3' : Path y z\n\u22a2 { toFun := (fun t \u21a6 if t \u2264 1 / 2 then \u03b3.extend (2 * t) else \u03b3'.extend (2 * t - 1)) \u2218 Subtype.val,\n          continuous_toFun := \u22ef }.toFun\n      0 =\n    x",["norm_num","aesop","infer_instance","simp"]],["CategoryTheory/Sites/Grothendieck.lean",250,"case intro.mk.intro.intro\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y : C\nS R : Sieve X\u271d\nJ\u271d : GrothendieckTopology C\nT : Set (GrothendieckTopology C)\nX : C\nJ : GrothendieckTopology C\nhJ : J \u2208 T\n\u22a2 \u22a4 \u2208 (fun f \u21a6 \u2191f X) \u27e8J.sieves, \u22ef\u27e9",["simp","aesop"]],["CategoryTheory/Sites/Grothendieck.lean",480,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y\u271d : C\nS\u271d R : Sieve X\nJ : GrothendieckTopology C\nS : J.Cover X\nY : C\nf : Y \u27f6 X\n\u22a2 (\u2191(S.pullback (\ud835\udfd9 X))).arrows f \u2194 (\u2191S).arrows f",["simp","aesop"]],["CategoryTheory/Sites/Grothendieck.lean",89,"case mk.mk\nC : Type u\ninst\u271d : Category.{v, u} C\nsieves\u271d\u00b9 : (X : C) \u2192 Set (Sieve X)\ntop_mem'\u271d\u00b9 : \u2200 (X : C), \u22a4 \u2208 sieves\u271d\u00b9 X\npullback_stable'\u271d\u00b9 : \u2200 \u2983X Y : C\u2984 \u2983S : Sieve X\u2984 (f : Y \u27f6 X), S \u2208 sieves\u271d\u00b9 X \u2192 Sieve.pullback f S \u2208 sieves\u271d\u00b9 Y\ntransitive'\u271d\u00b9 :\n  \u2200 \u2983X : C\u2984 \u2983S : Sieve X\u2984,\n    S \u2208 sieves\u271d\u00b9 X \u2192\n      \u2200 (R : Sieve X), (\u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, S.arrows f \u2192 Sieve.pullback f R \u2208 sieves\u271d\u00b9 Y) \u2192 R \u2208 sieves\u271d\u00b9 X\nsieves\u271d : (X : C) \u2192 Set (Sieve X)\ntop_mem'\u271d : \u2200 (X : C), \u22a4 \u2208 sieves\u271d X\npullback_stable'\u271d : \u2200 \u2983X Y : C\u2984 \u2983S : Sieve X\u2984 (f : Y \u27f6 X), S \u2208 sieves\u271d X \u2192 Sieve.pullback f S \u2208 sieves\u271d Y\ntransitive'\u271d :\n  \u2200 \u2983X : C\u2984 \u2983S : Sieve X\u2984,\n    S \u2208 sieves\u271d X \u2192 \u2200 (R : Sieve X), (\u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, S.arrows f \u2192 Sieve.pullback f R \u2208 sieves\u271d Y) \u2192 R \u2208 sieves\u271d X\nh :\n  (fun J X \u21a6 J.sieves X)\n      { sieves := sieves\u271d\u00b9, top_mem' := top_mem'\u271d\u00b9, pullback_stable' := pullback_stable'\u271d\u00b9,\n        transitive' := transitive'\u271d\u00b9 } =\n    (fun J X \u21a6 J.sieves X)\n      { sieves := sieves\u271d, top_mem' := top_mem'\u271d, pullback_stable' := pullback_stable'\u271d, transitive' := transitive'\u271d }\n\u22a2 { sieves := sieves\u271d\u00b9, top_mem' := top_mem'\u271d\u00b9, pullback_stable' := pullback_stable'\u271d\u00b9, transitive' := transitive'\u271d\u00b9 } =\n    { sieves := sieves\u271d, top_mem' := top_mem'\u271d, pullback_stable' := pullback_stable'\u271d, transitive' := transitive'\u271d }",["congr","aesop"]],["CategoryTheory/Sites/Grothendieck.lean",393,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : C\nS R : Sieve X\nJ : GrothendieckTopology C\nx\u271d\u00b3 : J.Cover X\nx\u271d\u00b2 : C\nx\u271d\u00b9 : x\u271d\u00b2 \u27f6 X\nx\u271d : ((fun a \u21a6 \u2191a) x\u271d\u00b3).arrows x\u271d\u00b9\n\u22a2 ((fun a \u21a6 \u2191a) \u22a4).arrows x\u271d\u00b9",["tauto","aesop","simp"]],["Analysis/Fourier/AddCircle.lean",128,"case H\nT z\u271d : \u211d\n\u22a2 Complex.exp (2 * \u2191\u03c0 * Complex.I * \u21910 * \u2191z\u271d / \u2191T) = 1",["norm_num","aesop","simp"]],["Analysis/Fourier/AddCircle.lean",389,"T : \u211d\nhT : Fact (0 < T)\nf : \u21a5(Lp \u2102 2 haarAddCircle)\n\u22a2 0 < ENNReal.toReal 2",["norm_num","aesop","simp"]],["Data/Finsupp/Defs.lean",549,"case pos.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d : AddZeroClass M\nf : \u03b1 \u21aa \u03b2\nv w : \u03b1 \u2192\u2080 M\na : \u03b1\n\u22a2 ({ toFun := fun v \u21a6 embDomain f v, map_zero' := \u22ef }.toFun (v + w)) (f a) =\n    ({ toFun := fun v \u21a6 embDomain f v, map_zero' := \u22ef }.toFun v +\n        { toFun := fun v \u21a6 embDomain f v, map_zero' := \u22ef }.toFun w)\n      (f a)",["simp","aesop"]],["Data/Finsupp/Defs.lean",248,"\u03b1 : Type u_1\nM : Type u_5\ninst\u271d\u00b9 : Zero M\ninst\u271d : DecidableEq M\ns : Finset \u03b1\nf : \u03b1 \u2192 M\nhf : \u2200 (a : \u03b1), f a \u2260 0 \u2192 a \u2208 s\n\u22a2 filter (fun a \u21a6 \u00acf a = 0) s = filter (fun a \u21a6 \u00acf a = 0) s",["congr","aesop"]],["AlgebraicGeometry/GammaSpecAdjunction.lean",469,"X : Scheme\nB : CommRingCat\n\u03c6 : B \u27f6 \u0393(X, \u22a4)\n\u22a2 (Scheme.\u0393SpecIso B).inv \u226b Scheme.Hom.app (Spec.map \u03c6.op.unop) \u22a4 \u226b Scheme.Hom.app (\u0393Spec.adjunction.unit.app X) \u22a4 = \u03c6",["simp","aesop"]],["AlgebraicGeometry/GammaSpecAdjunction.lean",116,"case h.e'_3\nX : LocallyRingedSpace\nr : \u2191(\u0393.obj (op X))\n\u22a2 (ConcreteCategory.hom (X.toTo\u0393SpecMapBasicOpen r)) r =\n    (ConcreteCategory.hom (X.toRingedSpace.presheaf.map ((homOfLE \u22ef).op \u226b (eqToHom \u22ef).op))) r",["congr","aesop","tauto","abel"]],["Order/Disjoint.lean",636,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : BoundedOrder \u03b1\na b : Complementeds \u03b1\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b",["simp","aesop"]],["Algebra/ContinuedFractions/Computation/Approximations.lean",211,"K : Type u_1\nv : K\nn\u271d : \u2115\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nn : \u2115\nIH : \u2200 m < n + 1 + 1, m \u2264 1 \u2228 \u00ac(of v).TerminatedAt (m - 2) \u2192 \u2191(fib m) \u2264 ((of v).contsAux m).b\nhyp : n + 1 + 1 \u2264 1 \u2228 \u00ac(of v).TerminatedAt (n + 1 + 1 - 2)\ng : GenContFract K := of v\n\u22a2 \u00acn + 2 \u2264 1",["omega","aesop","linarith","tauto","norm_num","simp"]],["RingTheory/DedekindDomain/AdicValuation.lean",542,"case neg.intro.intro\nR : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDedekindDomain R\nK : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nv : HeightOneSpectrum R\na : adicCompletion K v\nd : \u2124\nha : 0 < d\nhd : Valued.v a = \u2191(ofAdd d)\n\u03d6 : R\nh\u03d6 : v.intValuationDef \u03d6 = \u2191(ofAdd (-1))\nh\u03d60 : \u03d6 \u2260 0\n\u22a2 d + d * -1 \u2264 0",["omega","aesop","linarith","tauto","infer_instance","norm_num","simp"]],["LinearAlgebra/FiniteDimensional/Basic.lean",203,"K : Type u\nV : Type v\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\n\u03b9 : Type u_1\ns : Finset \u03b9\nS : \u03b9 \u2192 Submodule K V\ninst\u271d : \u2200 (i : \u03b9), FiniteDimensional K \u21a5(S i)\ni : \u03b9\nx\u271d : i \u2208 s\n\u22a2 (fun i \u21a6 FiniteDimensional K \u21a5i) (S i)",["infer_instance","aesop","tauto"]],["Topology/ContinuousMap/ZeroAtInfty.lean",147,"\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Zero \u03b2\nG : Type u_2\ninst\u271d\u00b2 : FunLike G \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousMapClass G \u03b1 \u03b2\ninst\u271d : CompactSpace \u03b1\n\u22a2 \u2200 (f : G), Tendsto (\u21d1f) (cocompact \u03b1) (\ud835\udcdd 0)",["simp","aesop","norm_num"]],["Topology/ContinuousMap/ZeroAtInfty.lean",78,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : Zero \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : ZeroAtInftyContinuousMapClass F \u03b1 \u03b2\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d\u00b9 : Continuous toFun\u271d\u00b9\nzero_at_infty'\u271d\u00b9 : Tendsto { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun (cocompact \u03b1) (\ud835\udcdd 0)\ntoFun\u271d : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d : Continuous toFun\u271d\nzero_at_infty'\u271d : Tendsto { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }.toFun (cocompact \u03b1) (\ud835\udcdd 0)\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, zero_at_infty' := zero_at_infty'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, zero_at_infty' := zero_at_infty'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, zero_at_infty' := zero_at_infty'\u271d\u00b9 } =\n    { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, zero_at_infty' := zero_at_infty'\u271d }",["congr","aesop"]],["Topology/ContinuousMap/ZeroAtInfty.lean",416,"\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b2\ninst\u271d : Zero \u03b2\n\u22a2 Isometry toBCF",["tauto"]],["Algebra/Polynomial/Splits.lean",418,"case a\nK : Type v\nL : Type w\ninst\u271d\u00b9 : Field K\ninst\u271d : Field L\ni : K \u2192+* L\nx : K\nh : K[X]\nh_splits : Splits i h\nh_roots : (map i h).roots = {i x}\n\u22a2 C (i h.leadingCoeff) * (Multiset.map (fun a \u21a6 X - C a) {i x}).prod = map i (C h.leadingCoeff * (X - C x))",["simp","aesop","norm_num"]],["Algebra/Polynomial/Splits.lean",72,"K : Type v\nL : Type w\ninst\u271d\u00b9 : CommRing K\ninst\u271d : Field L\ni : K \u2192+* L\nf : K[X]\nhf : (map i f).degree = 1\ng\u271d : L[X]\nhg : Irreducible g\u271d\nx\u271d : g\u271d \u2223 map i f\np : L[X]\nhp : map i f = g\u271d * p\nthis : g\u271d.degree = 1 \u2227 p.degree = 0\n\u22a2 g\u271d.degree = 1",["tauto","aesop"]],["NumberTheory/NumberField/Units/DirichletTheorem.lean",227,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nw\u2081 : InfinitePlace K\nB : \u2115\nhB : minkowskiBound K 1 < \u2191(convexBodyLTFactor K) * \u2191B\nx : \ud835\udcde K\nhx : x \u2260 0\nhx' : (algebraMap (\ud835\udcde K) K) x \u2260 0\nf : InfinitePlace K \u2192 \u211d\u22650 := fun w \u21a6 \u27e8w \u2191x / 2, \u22ef\u27e9\nthis : \u2200 (w : InfinitePlace K), w \u2260 w\u2081 \u2192 f w \u2260 0\ng : InfinitePlace K \u2192 \u211d\u22650\nh_geqf : \u2200 (w : InfinitePlace K), w \u2260 w\u2081 \u2192 g w = f w\nh_gprod : \u220f w : InfinitePlace K, g w ^ w.mult = \u2191B\ny : \ud835\udcde K\nh_ynz : y \u2260 0\nh_yle : \u2200 (w : InfinitePlace K), w \u2191y < \u2191(g w)\nw : InfinitePlace K\nhw : w \u2260 w\u2081\n\u22a2 1 < 2",["norm_num","aesop","linarith","simp"]],["NumberTheory/NumberField/Units/DirichletTheorem.lean",350,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u22a2 0 < 1",["norm_num","aesop","linarith","positivity","simp"]],["CategoryTheory/Adjunction/Mates.lean",436,"case h\nA : Type u\u2081\nB : Type u\u2082\nC : Type u\u2083\nD : Type u\u2084\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} A\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} B\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u2081 : A \u2964 C\nU\u2081 : C \u2964 A\nF\u2082 : B \u2964 D\nU\u2082 : D \u2964 B\nL\u2081 : A \u2964 B\nR\u2081 : B \u2964 A\nL\u2082 : C \u2964 D\nR\u2082 : D \u2964 C\nadj\u2081 : L\u2081 \u22a3 R\u2081\nadj\u2082 : L\u2082 \u22a3 R\u2082\nadj\u2083 : F\u2081 \u22a3 U\u2081\nadj\u2084 : F\u2082 \u22a3 U\u2082\n\u03b1 : TwoSquare U\u2082 R\u2082 R\u2081 U\u2081\nX\u271d : A\n\u22a2 ((mateEquiv adj\u2081 adj\u2082).symm ((mateEquiv adj\u2084 adj\u2083).symm \u03b1)).natTrans.app X\u271d =\n    (((conjugateEquiv (adj\u2081.comp adj\u2084) (adj\u2083.comp adj\u2082)).symm.trans (equivNatTrans F\u2081 L\u2081 L\u2082 F\u2082).symm) \u03b1).natTrans.app X\u271d",["simp","aesop"]],["CategoryTheory/Adjunction/Mates.lean",290,"case w.h\nC : Type u\u2081\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : Category.{v\u2082, u\u2082} D\nL\u2081 : C \u2964 D\nR\u2081 : D \u2964 C\nadj\u2081 : L\u2081 \u22a3 R\u2081\nx\u271d : D\n\u22a2 ((conjugateEquiv adj\u2081 adj\u2081) (\ud835\udfd9 L\u2081)).app x\u271d = (\ud835\udfd9 R\u2081).app x\u271d",["simp","aesop"]],["CategoryTheory/Adjunction/Mates.lean",221,"A : Type u\u2081\nB : Type u\u2082\nC : Type u\u2083\nD : Type u\u2084\nE : Type u\u2085\nF : Type u\u2086\nX : Type u\u2087\nY : Type u\u2088\nZ : Type u\u2089\ninst\u271d\u2078 : Category.{v\u2081, u\u2081} A\ninst\u271d\u2077 : Category.{v\u2082, u\u2082} B\ninst\u271d\u2076 : Category.{v\u2083, u\u2083} C\ninst\u271d\u2075 : Category.{v\u2084, u\u2084} D\ninst\u271d\u2074 : Category.{v\u2085, u\u2085} E\ninst\u271d\u00b3 : Category.{v\u2086, u\u2086} F\ninst\u271d\u00b2 : Category.{v\u2087, u\u2087} X\ninst\u271d\u00b9 : Category.{v\u2088, u\u2088} Y\ninst\u271d : Category.{v\u2089, u\u2089} Z\nG\u2081 : A \u2964 D\nH\u2081 : B \u2964 E\nK\u2081 : C \u2964 F\nG\u2082 : D \u2964 X\nH\u2082 : E \u2964 Y\nK\u2082 : F \u2964 Z\nL\u2081 : A \u2964 B\nR\u2081 : B \u2964 A\nL\u2082 : B \u2964 C\nR\u2082 : C \u2964 B\nL\u2083 : D \u2964 E\nR\u2083 : E \u2964 D\nL\u2084 : E \u2964 F\nR\u2084 : F \u2964 E\nL\u2085 : X \u2964 Y\nR\u2085 : Y \u2964 X\nL\u2086 : Y \u2964 Z\nR\u2086 : Z \u2964 Y\nadj\u2081 : L\u2081 \u22a3 R\u2081\nadj\u2082 : L\u2082 \u22a3 R\u2082\nadj\u2083 : L\u2083 \u22a3 R\u2083\nadj\u2084 : L\u2084 \u22a3 R\u2084\nadj\u2085 : L\u2085 \u22a3 R\u2085\nadj\u2086 : L\u2086 \u22a3 R\u2086\n\u03b1 : TwoSquare G\u2081 L\u2081 L\u2083 H\u2081\n\u03b2 : TwoSquare H\u2081 L\u2082 L\u2084 K\u2081\n\u03b3 : TwoSquare G\u2082 L\u2083 L\u2085 H\u2082\n\u03b4 : TwoSquare H\u2082 L\u2084 L\u2086 K\u2082\nvcomp :\n  (mateEquiv (adj\u2081.comp adj\u2082) (adj\u2085.comp adj\u2086)) ((\u03b1 \u226b\u1d65 \u03b2) \u226b\u2095 \u03b3 \u226b\u1d65 \u03b4) =\n    ((mateEquiv adj\u2082 adj\u2084) \u03b2 \u226b\u2095 (mateEquiv adj\u2081 adj\u2083) \u03b1) \u226b\u1d65 (mateEquiv adj\u2084 adj\u2086) \u03b4 \u226b\u2095 (mateEquiv adj\u2083 adj\u2085) \u03b3\n\u22a2 (mateEquiv (adj\u2081.comp adj\u2082) (adj\u2085.comp adj\u2086)) ((\u03b1 \u226b\u1d65 \u03b2) \u226b\u2095 \u03b3 \u226b\u1d65 \u03b4) =\n    ((mateEquiv adj\u2082 adj\u2084) \u03b2 \u226b\u2095 (mateEquiv adj\u2081 adj\u2083) \u03b1) \u226b\u1d65 (mateEquiv adj\u2084 adj\u2086) \u03b4 \u226b\u2095 (mateEquiv adj\u2083 adj\u2085) \u03b3",["assumption","aesop","congr","gcongr","tauto"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",129,"s : \u211d\nthis : \u2200 (r : \u211d), \u2191r = \u2191r\nx : \u211d\nhx : x \u2208 Ioi 0\n\u22a2 \u2191(rexp (-x)) * \u2191x ^ (\u2191s - 1) = \u2191(rexp (-x)) * \u2191x ^ \u2191(s - 1)",["simp","aesop","norm_num"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",328,"case succ\nn : \u2115\nhn : Gamma (\u2191n + 1) = \u2191n !\n\u22a2 (\u2191n + 1) * Gamma (\u2191n + 1) = (\u2191n + 1) * \u2191n !",["congr","aesop","tauto"]],["Order/SymmDiff.lean",88,"\u22a2 \u2200 (p q : Bool), p \u2206 q = (p ^^ q)",["decide"]],["NumberTheory/NumberField/Discriminant/Basic.lean",192,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nh : 1 < finrank \u211a K\nx : \ud835\udcde K\nh_nz : x \u2260 0\nh_nm : 1 \u2264 \u2191|(Algebra.norm \u211a) \u2191x|\nh_bd :\n  \u2191(finrank \u211a K) ^ (finrank \u211a K * 2) / ((4 / \u03c0) ^ (nrComplexPlaces K * 2) * \u2191(finrank \u211a K).factorial ^ 2) \u2264 \u2191|discr K|\na : \u2115 \u2192 \u211d := fun n \u21a6 \u2191n ^ (n * 2) / ((4 / \u03c0) ^ n * \u2191n.factorial ^ 2)\nn m : \u2115\nhmn\u271d : 2 \u2264 m\nh_m : 4 / 9 * (3 * \u03c0 / 4) ^ m \u2264 a m\n\u22a2 0 \u2264 1 / \u2191m",["positivity","aesop","norm_num","simp"]],["NumberTheory/NumberField/Discriminant/Basic.lean",301,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nN : \u2115\nhK : |discr K| \u2264 \u2191N\nthis : boundOfDiscBdd N - 1 < boundOfDiscBdd N\n\u22a2 2\u207b\u00b9 \u2264 1",["norm_num","aesop","simp"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Order.lean",433,"A : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na b : A\nhb : autoParam (IsSelfAdjoint b) _auto\u271d\nh\u2081 : a * b * star a = star (star a) * b * star a\n\u22a2 a * star a = star (star a) * star a",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Order.lean",319,"A : Type u_1\ninst\u271d\u00b2 : CStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\nb : A\u02e3\nha : 0 \u2264 a\nhb : 0 \u2264 \u2191b\n\u22a2 \u2016sqrt a * \u2191b ^ (-(1 / 2))\u2016 \u2264 1 \u2194 \u2016sqrt a * \u2191b ^ (-1 * (1 / 2))\u2016 \u2264 1",["norm_num","ring","aesop","simp"]],["Analysis/SpecialFunctions/Log/Basic.lean",299,"x : \u211d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 x - 1 \u2264 x",["linarith","aesop","norm_num","simp"]],["Algebra/MvPolynomial/Degrees.lean",158,"case a.inr.intro.refine_1\nR : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nd : \u03c3 \u2192\u2080 \u2115\nhd : coeff d p \u2260 0\nj : \u03c3\nhj : j \u2208 d.support\nh : coeff d q \u2260 0\n\u22a2 coeff d p \u2260 0\n```\n---\n```lean\ncase a.inr.intro.refine_2\nR : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nd : \u03c3 \u2192\u2080 \u2115\nhd : coeff d p \u2260 0\nj : \u03c3\nhj : j \u2208 d.support\nh : coeff d q \u2260 0\n\u22a2 coeff d q \u2260 0",["assumption","aesop","congr","tauto"]],["LinearAlgebra/Span/Defs.lean",453,"R : Type u_1\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx : M\n\u22a2 span R {x} = \u22a5 \u2194 x = 0",["simp","aesop"]],["LinearAlgebra/Span/Defs.lean",360,"case h\nR : Type u_1\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np p' : Submodule R M\nx\u271d : M\n\u22a2 (\u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x\u271d) \u2194 \u2203 x \u2208 \u2191p, \u2203 y \u2208 \u2191p', x + y = x\u271d",["simp","aesop","tauto"]],["LinearAlgebra/Span/Defs.lean",398,"R : Type u_1\nM : Type u_4\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx : M\n\u22a2 (\u2200 v \u2208 \u22a4, \u2203 r, r \u2022 x = v) \u2194 \u2200 (v : M), \u2203 r, r \u2022 x = v",["tauto","aesop","simp"]],["Probability/Kernel/Disintegration/MeasurableStieltjes.lean",187,"q : \u211a\nhq : q \u2264 -1\n\u22a2 -1 < 0",["linarith","decide","aesop","congr","tauto","norm_num","simp"]],["MeasureTheory/MeasurableSpace/Defs.lean",397,"\u03b1 : Type u_1\n\u22a2 \u2200 t \u2208 {univ}, MeasurableSet t",["simp","aesop"]],["MeasureTheory/MeasurableSpace/Defs.lean",214,"\u03b1 : Type u_1\nMeasurableSet'\u271d\u00b9 : Set \u03b1 \u2192 Prop\nmeasurableSet_empty\u271d\u00b9 : MeasurableSet'\u271d\u00b9 \u2205\nmeasurableSet_compl\u271d\u00b9 : \u2200 (s : Set \u03b1), MeasurableSet'\u271d\u00b9 s \u2192 MeasurableSet'\u271d\u00b9 s\u1d9c\nmeasurableSet_iUnion\u271d\u00b9 : \u2200 (f : \u2115 \u2192 Set \u03b1), (\u2200 (i : \u2115), MeasurableSet'\u271d\u00b9 (f i)) \u2192 MeasurableSet'\u271d\u00b9 (\u22c3 i, f i)\nMeasurableSet'\u271d : Set \u03b1 \u2192 Prop\nmeasurableSet_empty\u271d : MeasurableSet'\u271d \u2205\nmeasurableSet_compl\u271d : \u2200 (s : Set \u03b1), MeasurableSet'\u271d s \u2192 MeasurableSet'\u271d s\u1d9c\nmeasurableSet_iUnion\u271d : \u2200 (f : \u2115 \u2192 Set \u03b1), (\u2200 (i : \u2115), MeasurableSet'\u271d (f i)) \u2192 MeasurableSet'\u271d (\u22c3 i, f i)\nx\u271d : MeasurableSet = MeasurableSet\n\u22a2 { MeasurableSet' := MeasurableSet'\u271d\u00b9, measurableSet_empty := measurableSet_empty\u271d\u00b9,\n      measurableSet_compl := measurableSet_compl\u271d\u00b9, measurableSet_iUnion := measurableSet_iUnion\u271d\u00b9 } =\n    { MeasurableSet' := MeasurableSet'\u271d, measurableSet_empty := measurableSet_empty\u271d,\n      measurableSet_compl := measurableSet_compl\u271d, measurableSet_iUnion := measurableSet_iUnion\u271d }",["congr","aesop"]],["NumberTheory/LSeries/SumCoeff.lean",61,"f : \u2115 \u2192 \u2102\nr : \u211d\ns : \u2102\nhf : f 0 = 0\nhO : (fun n \u21a6 \u2211 k \u2208 Icc 1 n, \u2016f k\u2016) =O[atTop] fun n \u21a6 \u2191n ^ r\nhr : 0 \u2264 r\nhs : r < s.re\nh\u2081 : -s \u2260 0\nh\u2082 : (-s).re + r \u2264 0\nh\u2083 : \u2200 t \u2208 Set.Ici 1, DifferentiableAt \u211d (fun x \u21a6 \u2016\u2191x ^ (-s)\u2016) t\nh\u2084 : (deriv fun t \u21a6 \u2016\u2191t ^ (-s)\u2016) =\u1da0[atTop] fun t \u21a6 -s.re * t ^ (-(s.re + 1))\n\u22a2 \u2200 (x : \u2115), \u2191x ^ 0 = 1",["simp","aesop","norm_num"]],["NumberTheory/LSeries/SumCoeff.lean",185,"f : \u2115 \u2192 \u2102\nl : \u2102\nhlim : Tendsto (fun n \u21a6 (\u2211 k \u2208 Icc 1 n, f k) / \u2191n) atTop (\ud835\udcdd l)\ns : \u211d\nhs : 1 < s\nh\u2081 : LocallyIntegrableOn (fun t \u21a6 (\u2211 k \u2208 Icc 1 \u230at\u230b\u208a, f k) * \u2191t ^ (-\u2191s - 1)) (Set.Ici 1) volume\nh\u2082 : (fun t \u21a6 \u2211 k \u2208 Icc 1 \u230at\u230b\u208a, f k) =O[atTop] fun t \u21a6 t ^ 1\n\u22a2 1 + (-s - 1) \u2264 -s",["linarith","aesop","norm_num","simp"]],["NumberTheory/LSeries/SumCoeff.lean",347,"f : \u2115 \u2192 \u2102\nl : \u2102\nhlim : Tendsto (fun n \u21a6 (\u2211 k \u2208 Icc 1 n, f k) / \u2191n) atTop (\ud835\udcdd l)\nhfS : \u2200 (s : \u211d), 1 < s \u2192 LSeriesSummable f \u2191s\nh\u2081 : \u2200 {C \u03b5 : \u211d}, Tendsto (fun s \u21a6 (s - 1) * s * C + s * \u03b5) (\ud835\udcdd[>] 1) (\ud835\udcdd \u03b5)\nh\u2082 : IsBoundedUnder (fun x1 x2 \u21a6 x1 \u2264 x2) (\ud835\udcdd[>] 1) fun s \u21a6 \u2016(\u2191s - 1) * LSeries f \u2191s - \u2191s * l\u2016\nthis : Tendsto (fun s \u21a6 (\u2191s - 1) * LSeries f \u2191s - \u2191s * l) (\ud835\udcdd[>] 1) (\ud835\udcdd 0)\nh\u2083 : Tendsto (fun s \u21a6 \u2191s * l) (\ud835\udcdd[>] 1) (\ud835\udcdd (1 * l))\nx\u271d : \u211d\n\u22a2 (\u2191x\u271d - 1) * LSeries f \u2191x\u271d - \u2191x\u271d * l + \u2191x\u271d * l = (\u2191x\u271d - 1) * LSeries f \u2191x\u271d",["ring","aesop","abel","norm_num","simp"]],["Geometry/Manifold/ContMDiff/Constructions.lean",436,"\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2074 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : ChartedSpace H M\nM' : Type u_16\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H M'\nx y : M\n\u22a2 \u2191(extChartAt I (Sum.inl x)) (Sum.inl y) = \u2191(extChartAt I x) y",["simp","aesop","norm_num"]],["Geometry/Manifold/ContMDiff/Constructions.lean",459,"case inl.h\u2081.h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2079 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : ChartedSpace H M\nM' : Type u_16\ninst\u271d\u2076 : TopologicalSpace M'\ninst\u271d\u2075 : ChartedSpace H M'\nn : WithTop \u2115\u221e\nE' : Type u_17\ninst\u271d\u2074 : NormedAddCommGroup E'\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E'\nH' : Type u_18\ninst\u271d\u00b2 : TopologicalSpace H'\nJ : ModelWithCorners \ud835\udd5c E' H'\nN : Type u_20\ninst\u271d\u00b9 : TopologicalSpace N\ninst\u271d : ChartedSpace H' N\nf : M \u2192 N\ng : M' \u2192 N\nhf : ContMDiff I J n f\nhg : ContMDiff I J n g\nx : M\nthis :\n  ContDiffWithinAt \ud835\udd5c n (\u2191(extChartAt J (f x)) \u2218 f \u2218 \u2191(extChartAt I x).symm) (range \u2191I)\n    (\u2191(extChartAt I (Sum.inl x)) (Sum.inl x))\na : E\n\u22a2 (\u2191((chartAt H' (f x)).extend J) \u2218 Sum.elim f g \u2218 \u2191(((chartAt H x).lift_openEmbedding \u22ef).extend I).symm) a =\n    (\u2191((chartAt H' (f x)).extend J) \u2218 f \u2218 \u2191((chartAt H x).extend I).symm) a",["congr","aesop","tauto","abel","norm_num","simp"]],["Geometry/Manifold/ContMDiff/Constructions.lean",462,"case inl.hx\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2079 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : ChartedSpace H M\nM' : Type u_16\ninst\u271d\u2076 : TopologicalSpace M'\ninst\u271d\u2075 : ChartedSpace H M'\nn : WithTop \u2115\u221e\nE' : Type u_17\ninst\u271d\u2074 : NormedAddCommGroup E'\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E'\nH' : Type u_18\ninst\u271d\u00b2 : TopologicalSpace H'\nJ : ModelWithCorners \ud835\udd5c E' H'\nN : Type u_20\ninst\u271d\u00b9 : TopologicalSpace N\ninst\u271d : ChartedSpace H' N\nf : M \u2192 N\ng : M' \u2192 N\nhf : ContMDiff I J n f\nhg : ContMDiff I J n g\nx : M\nthis :\n  ContDiffWithinAt \ud835\udd5c n (\u2191(extChartAt J (f x)) \u2218 f \u2218 \u2191(extChartAt I x).symm) (range \u2191I)\n    (\u2191(extChartAt I (Sum.inl x)) (Sum.inl x))\n\u22a2 (\u2191((chartAt H' (f x)).extend J) \u2218 Sum.elim f g \u2218 \u2191(((chartAt H x).lift_openEmbedding \u22ef).extend I).symm)\n      (\u2191(((chartAt H x).lift_openEmbedding \u22ef).extend I) (Sum.inl x)) =\n    (\u2191((chartAt H' (f x)).extend J) \u2218 f \u2218 \u2191((chartAt H x).extend I).symm)\n      (\u2191(((chartAt H x).lift_openEmbedding \u22ef).extend I) (Sum.inl x))",["congr","aesop","tauto","abel","norm_num","simp"]],["Geometry/Manifold/ContMDiff/Constructions.lean",475,"case inr.h\u2081.h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2079 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : ChartedSpace H M\nM' : Type u_16\ninst\u271d\u2076 : TopologicalSpace M'\ninst\u271d\u2075 : ChartedSpace H M'\nn : WithTop \u2115\u221e\nE' : Type u_17\ninst\u271d\u2074 : NormedAddCommGroup E'\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E'\nH' : Type u_18\ninst\u271d\u00b2 : TopologicalSpace H'\nJ : ModelWithCorners \ud835\udd5c E' H'\nN : Type u_20\ninst\u271d\u00b9 : TopologicalSpace N\ninst\u271d : ChartedSpace H' N\nf : M \u2192 N\ng : M' \u2192 N\nhf : ContMDiff I J n f\nhg : ContMDiff I J n g\nx : M'\nthis :\n  ContDiffWithinAt \ud835\udd5c n (\u2191(extChartAt J (g x)) \u2218 g \u2218 \u2191(extChartAt I x).symm) (range \u2191I)\n    (\u2191(extChartAt I (Sum.inr x)) (Sum.inr x))\na : E\n\u22a2 (\u2191((chartAt H' (g x)).extend J) \u2218 Sum.elim f g \u2218 \u2191(((chartAt H x).lift_openEmbedding \u22ef).extend I).symm) a =\n    (\u2191((chartAt H' (g x)).extend J) \u2218 g \u2218 \u2191((chartAt H x).extend I).symm) a",["congr","aesop","tauto","abel","norm_num","simp"]],["Geometry/Manifold/ContMDiff/Constructions.lean",478,"case inr.hx\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2079 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : ChartedSpace H M\nM' : Type u_16\ninst\u271d\u2076 : TopologicalSpace M'\ninst\u271d\u2075 : ChartedSpace H M'\nn : WithTop \u2115\u221e\nE' : Type u_17\ninst\u271d\u2074 : NormedAddCommGroup E'\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E'\nH' : Type u_18\ninst\u271d\u00b2 : TopologicalSpace H'\nJ : ModelWithCorners \ud835\udd5c E' H'\nN : Type u_20\ninst\u271d\u00b9 : TopologicalSpace N\ninst\u271d : ChartedSpace H' N\nf : M \u2192 N\ng : M' \u2192 N\nhf : ContMDiff I J n f\nhg : ContMDiff I J n g\nx : M'\nthis :\n  ContDiffWithinAt \ud835\udd5c n (\u2191(extChartAt J (g x)) \u2218 g \u2218 \u2191(extChartAt I x).symm) (range \u2191I)\n    (\u2191(extChartAt I (Sum.inr x)) (Sum.inr x))\n\u22a2 (\u2191((chartAt H' (g x)).extend J) \u2218 Sum.elim f g \u2218 \u2191(((chartAt H x).lift_openEmbedding \u22ef).extend I).symm)\n      (\u2191(((chartAt H x).lift_openEmbedding \u22ef).extend I) (Sum.inr x)) =\n    (\u2191((chartAt H' (g x)).extend J) \u2218 g \u2218 \u2191((chartAt H x).extend I).symm)\n      (\u2191(((chartAt H x).lift_openEmbedding \u22ef).extend I) (Sum.inr x))",["congr","aesop","tauto","abel","norm_num","simp"]],["Tactic/Positivity/Basic.lean",465,"\u03b1 : Type u_1\nq : \u211a\u22650\n\u22a2 0 < q.den",["positivity","aesop","norm_num","simp"]],["Order/Hom/Bounded.lean",186,"case mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Top \u03b1\ninst\u271d\u00b2 : Top \u03b2\ninst\u271d\u00b9 : Top \u03b3\ninst\u271d : Top \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_top'\u271d\u00b9 : toFun\u271d\u00b9 \u22a4 = \u22a4\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_top'\u271d : toFun\u271d \u22a4 = \u22a4\nh : { toFun := toFun\u271d\u00b9, map_top' := map_top'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, map_top' := map_top'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_top' := map_top'\u271d\u00b9 } = { toFun := toFun\u271d, map_top' := map_top'\u271d }",["congr","aesop"]],["Order/Hom/Bounded.lean",359,"case mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Bot \u03b1\ninst\u271d\u00b2 : Bot \u03b2\ninst\u271d\u00b9 : Bot \u03b3\ninst\u271d : Bot \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_bot'\u271d\u00b9 : toFun\u271d\u00b9 \u22a5 = \u22a5\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_bot'\u271d : toFun\u271d \u22a5 = \u22a5\nh : { toFun := toFun\u271d\u00b9, map_bot' := map_bot'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, map_bot' := map_bot'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, map_bot' := map_bot'\u271d\u00b9 } = { toFun := toFun\u271d, map_bot' := map_bot'\u271d }",["congr","aesop"]],["Order/Hom/Bounded.lean",539,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b3\ninst\u271d\u2074 : Preorder \u03b4\ninst\u271d\u00b3 : BoundedOrder \u03b1\ninst\u271d\u00b2 : BoundedOrder \u03b2\ninst\u271d\u00b9 : BoundedOrder \u03b3\ninst\u271d : BoundedOrder \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmonotone'\u271d\u00b9 : Monotone toFun\u271d\u00b9\nmap_top'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 }.toFun \u22a4 = \u22a4\nmap_bot'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 }.toFun \u22a5 = \u22a5\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmonotone'\u271d : Monotone toFun\u271d\nmap_top'\u271d : { toFun := toFun\u271d, monotone' := monotone'\u271d }.toFun \u22a4 = \u22a4\nmap_bot'\u271d : { toFun := toFun\u271d, monotone' := monotone'\u271d }.toFun \u22a5 = \u22a5\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, map_top' := map_top'\u271d\u00b9, map_bot' := map_bot'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, monotone' := monotone'\u271d, map_top' := map_top'\u271d, map_bot' := map_bot'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, map_top' := map_top'\u271d\u00b9, map_bot' := map_bot'\u271d\u00b9 } =\n    { toFun := toFun\u271d, monotone' := monotone'\u271d, map_top' := map_top'\u271d, map_bot' := map_bot'\u271d }",["congr","aesop"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",353,"case h.intro.intro.inr.inr\nV : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\nv : V\nhadj1 : \u2203 i, (p.getVert i = u \u2227 p.getVert (i + 1) = p.snd \u2228 p.getVert i = p.snd \u2227 p.getVert (i + 1) = u) \u2227 i < p.length\nhadj2 :\n  \u2203 i,\n    (p.getVert i = u \u2227 p.getVert (i + 1) = p.penultimate \u2228 p.getVert i = p.penultimate \u2227 p.getVert (i + 1) = u) \u2227\n      i < p.length\ni : \u2115\nright\u271d : i < p.length\nhr : p.getVert i = v \u2227 p.getVert (i + 1) = u\nh2 : i + 1 = p.length\n\u22a2 v = p.snd \u2228 v = p.getVert i",["aesop","tauto"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",283,"V : Type u\nG : SimpleGraph V\nu v\u271d : V\np : G.Walk u v\u271d\nhp : p.IsPath\nhnp : \u00acp.Nil\nv : V\nhadj1 : \u2203 i, (p.getVert i = u \u2227 p.getVert (i + 1) = p.snd \u2228 p.getVert i = p.snd \u2227 p.getVert (i + 1) = u) \u2227 i < p.length\ni : \u2115\nright\u271d : i < p.length\nhl : p.getVert i = u \u2227 p.getVert (i + 1) = v\n\u22a2 0 \u2264 p.length",["omega","aesop","simp"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",327,"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nhp : p.IsPath\ni : \u2115\nhl1 : p.getVert i = u\nhadj : p.toSubgraph.Adj u (p.getVert (i + 1))\nhi :\n  (p.getVert i = u \u2227 p.getVert (i + 1) = p.getVert (i + 1) \u2228 p.getVert i = p.getVert (i + 1) \u2227 p.getVert (i + 1) = u) \u2227\n    i < p.length\n\u22a2 0 \u2264 p.length",["omega","aesop","simp"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",289,"case h.intro.intro.inr\nV : Type u\nG : SimpleGraph V\nu v\u271d : V\np : G.Walk u v\u271d\nhp : p.IsPath\nhnp : \u00acp.Nil\nv : V\nhadj1 : \u2203 i, (p.getVert i = u \u2227 p.getVert (i + 1) = p.snd \u2228 p.getVert i = p.snd \u2227 p.getVert (i + 1) = u) \u2227 i < p.length\ni : \u2115\nright\u271d : i < p.length\nhr : p.getVert i = v \u2227 p.getVert (i + 1) = u\nthis : i + 1 = 0\n\u22a2 v = p.snd",["contradiction"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",333,"case inr.intro\nV : Type u\nG : SimpleGraph V\nu v v' : V\np : G.Walk u v\nhp : p.IsPath\nhadj : p.toSubgraph.Adj u v'\ni : \u2115\nhi : (p.getVert i = u \u2227 p.getVert (i + 1) = v' \u2228 p.getVert i = v' \u2227 p.getVert (i + 1) = u) \u2227 i < p.length\nhr1 : p.getVert i = v'\nhr2 : p.getVert (i + 1) = u\nthis : i + 1 = 0\n\u22a2 p.snd = v'",["contradiction"]],["Data/Finmap.lean",139,"\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nl\u2081 : Multiset (Sigma \u03b2)\nh\u2081 : l\u2081.NodupKeys\nl\u2082 : Multiset (Sigma \u03b2)\nnodupKeys\u271d : l\u2082.NodupKeys\nH : { entries := l\u2081, nodupKeys := h\u2081 }.entries = { entries := l\u2082, nodupKeys := nodupKeys\u271d }.entries\n\u22a2 { entries := l\u2081, nodupKeys := h\u2081 } = { entries := l\u2082, nodupKeys := nodupKeys\u271d }",["congr","aesop"]],["Algebra/Group/Units/Defs.lean",224,"\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na\u271d b u : \u03b1\u02e3\nn : \u2115\na : \u03b1\u02e3\n\u22a2 (\u2191a\u207b\u00b9 * \u2191a) ^ n = 1",["simp"]],["Algebra/Group/Units/Defs.lean",497,"M : Type u_1\ninst\u271d : Monoid M\na : M\nh : IsUnit a\n\u22a2 a * \u2191h.unit\u207b\u00b9 = \u2191h.unit * \u2191h.unit\u207b\u00b9",["congr","simp"]],["Analysis/PSeries.lean",297,"p : \u211d\n\u22a2 (Summable fun n \u21a6 1 / \u2191n ^ p) \u2194 1 < p",["simp","aesop","norm_num"]],["Analysis/PSeries.lean",395,"case hf\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\nk n i : \u2115\n_hi : i \u2208 Ioc k ((k + 1) \u2294 n)\n_hident : i \u2209 Ioo k n\n\u22a2 0 \u2264 (\u2191i ^ 2)\u207b\u00b9",["positivity","aesop","norm_num","simp"]],["Analysis/PSeries.lean",270,"case inl\np : \u211d\nhp : 0 \u2264 p\n\u22a2 2 = 0 \u2227 1 - p \u2260 0 \u2228 1 < 2 \u2227 1 - p < 0 \u2228 2 < 1 \u2227 0 < 1 - p \u2194 1 < p",["norm_num","aesop","simp"]],["Topology/Order/LeftRightNhds.lean",248,"\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na u' : \u03b1\ns : Set \u03b1\nhu' : a < u'\n\u22a2 [s \u2208 \ud835\udcdd[\u2265] a, s \u2208 \ud835\udcdd[Icc a u'] a, s \u2208 \ud835\udcdd[Ico a u'] a, \u2203 u \u2208 Ioc a u', Ico a u \u2286 s, \u2203 u \u2208 Ioi a, Ico a u \u2286 s][3]? =\n    some (\u2203 u \u2208 Ioc a u', Ico a u \u2286 s)",["norm_num","aesop","congr","tauto","simp"]],["Topology/Order/LeftRightNhds.lean",257,"\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na u' : \u03b1\ns : Set \u03b1\nhu' : a < u'\n\u22a2 [s \u2208 \ud835\udcdd[\u2265] a, s \u2208 \ud835\udcdd[Icc a u'] a, s \u2208 \ud835\udcdd[Ico a u'] a, \u2203 u \u2208 Ioc a u', Ico a u \u2286 s, \u2203 u \u2208 Ioi a, Ico a u \u2286 s][4]? =\n    some (\u2203 u \u2208 Ioi a, Ico a u \u2286 s)",["norm_num","aesop","congr","tauto","simp"]],["Topology/Order/LeftRightNhds.lean",319,"\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na l' : \u03b1\ns : Set \u03b1\nhl' : l' < a\n\u22a2 [s \u2208 \ud835\udcdd[\u2264] a, s \u2208 \ud835\udcdd[Icc l' a] a, s \u2208 \ud835\udcdd[Ioc l' a] a, \u2203 l \u2208 Ico l' a, Ioc l a \u2286 s, \u2203 l \u2208 Iio a, Ioc l a \u2286 s][3]? =\n    some (\u2203 l \u2208 Ico l' a, Ioc l a \u2286 s)",["norm_num","aesop","congr","tauto","simp"]],["Topology/Order/LeftRightNhds.lean",328,"\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na l' : \u03b1\ns : Set \u03b1\nhl' : l' < a\n\u22a2 [s \u2208 \ud835\udcdd[\u2264] a, s \u2208 \ud835\udcdd[Icc l' a] a, s \u2208 \ud835\udcdd[Ioc l' a] a, \u2203 l \u2208 Ico l' a, Ioc l a \u2286 s, \u2203 l \u2208 Iio a, Ioc l a \u2286 s][4]? =\n    some (\u2203 l \u2208 Iio a, Ioc l a \u2286 s)",["norm_num","aesop","congr","tauto","simp"]],["Order/SupIndep.lean",214,"case h.e'_3\n\u03b1 : Type u_1\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b9\nt : Finset \u03b9'\nf : \u03b9 \u00d7 \u03b9' \u2192 \u03b1\nhs : s.SupIndep fun i \u21a6 t.sup fun i' \u21a6 f (i, i')\nht : t.SupIndep fun i' \u21a6 s.sup fun i \u21a6 f (i, i')\nu : Finset (\u03b9 \u00d7 \u03b9')\nhu : u \u2286 s \u00d7\u02e2 t\ni : \u03b9\ni' : \u03b9'\nhi : (i, i').1 \u2208 s \u2227 (i, i').2 \u2208 t\nhiu : (i, i') \u2209 u\nj : \u03b9\nj' : \u03b9'\nhij\u271d : (i, i') \u2260 (j, j')\nhj : (j, j').1 \u2208 s \u2227 (j, j').2 \u2208 t\nhij : i \u2260 j\n\u22a2 f (j, j') = f ((j, j').1, (j, j').2)",["simp","aesop","congr","tauto"]],["Order/SupIndep.lean",336,"\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\n\u22a2 (\u2200 (i : \u03b9), Disjoint (t i) (sSup (t '' {j | j \u2260 i}))) \u2194 \u2200 (i : \u03b9), Disjoint (t i) (sSup {a | \u2203 j, j \u2260 i \u2227 t j = a})",["aesop","tauto"]],["Algebra/Group/Subgroup/Lattice.lean",164,"G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\nx\u271d : \u2203 g, \u2191H = {g}\ng : G\nhg : \u2191H = {g}\n\u22a2 Subsingleton \u2191{g}",["infer_instance","aesop","simp"]],["Algebra/Group/Subgroup/Lattice.lean",187,"G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\nthis : Nontrivial \u21a5H \u2194 H \u2260 \u22a5\n\u22a2 H = \u22a5 \u2228 Nontrivial \u21a5H",["tauto"]],["Data/Matroid/Restrict.lean",274,"\u03b1 : Type u_1\nM M' : Matroid \u03b1\n\u22a2 { toMatroid := M } \u2264 { toMatroid := M' } \u2194 M \u2264r M'",["simp","aesop","tauto"]],["Data/Matroid/Restrict.lean",141,"\u03b1 : Type u_1\nM : Matroid \u03b1\nR X : Set \u03b1\n\u22a2 \u00ac(M.Indep X \u2227 X \u2286 R) \u2227 X \u2286 R \u2194 \u00acM.Indep X \u2227 X \u2286 R",["tauto","aesop"]],["Data/Matroid/Restrict.lean",188,"\u03b1 : Type u_1\nM : Matroid \u03b1\nR I X : Set \u03b1\n\u22a2 (((M.Indep I \u2227 I \u2286 R) \u2227 I \u2286 X) \u2227 \u2200 \u2983y : Set \u03b1\u2984, M.Indep y \u2192 y \u2286 R \u2192 y \u2286 X \u2192 I \u2264 y \u2192 I = y) \u2194\n    ((M.Indep I \u2227 I \u2286 X \u2227 I \u2286 R) \u2227 \u2200 \u2983y : Set \u03b1\u2984, M.Indep y \u2192 y \u2286 X \u2192 y \u2286 R \u2192 I \u2264 y \u2192 I = y) \u2227 I \u2286 R",["tauto","aesop"]],["CategoryTheory/Functor/KanExtension/Pointwise.lean",143,"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst\u271d\u00b2 : Category.{?u.37361, u_1} C\ninst\u271d\u00b9 : Category.{?u.37365, u_2} D\ninst\u271d : Category.{?u.37369, u_3} H\nL : C \u2964 D\nF : C \u2964 H\nE E' : L.LeftExtension F\ne : E \u2245 E'\nh : E'.IsPointwiseLeftKanExtension\n\u22a2 (fun h Y \u21a6 (isPointwiseLeftKanExtensionAtEquivOfIso e Y) (h Y))\n      ((fun h Y \u21a6 (isPointwiseLeftKanExtensionAtEquivOfIso e Y).symm (h Y)) h) =\n    h",["simp","aesop"]],["CategoryTheory/Functor/KanExtension/Pointwise.lean",142,"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst\u271d\u00b2 : Category.{?u.37361, u_1} C\ninst\u271d\u00b9 : Category.{?u.37365, u_2} D\ninst\u271d : Category.{?u.37369, u_3} H\nL : C \u2964 D\nF : C \u2964 H\nE E' : L.LeftExtension F\ne : E \u2245 E'\nh : E.IsPointwiseLeftKanExtension\n\u22a2 (fun h Y \u21a6 (isPointwiseLeftKanExtensionAtEquivOfIso e Y).symm (h Y))\n      ((fun h Y \u21a6 (isPointwiseLeftKanExtensionAtEquivOfIso e Y) (h Y)) h) =\n    h",["simp","omega","aesop"]],["Combinatorics/Additive/AP/Three/Behrend.lean",376,"N : \u2115\nhN\u2083 : 8 \u2264 N\nhN\u2080 : 0 < \u2191N\nthis : \u2191(nValue N) \u2264 2 * \u221a(log \u2191N)\n\u22a2 1 < 8",["norm_num","omega","decide","aesop","linarith","simp"]],["Combinatorics/Additive/AP/Three/Behrend.lean",377,"N : \u2115\nhN\u2083 : 8 \u2264 N\nhN\u2080 : 0 < \u2191N\n\u22a2 2 \u2264 8",["norm_num","omega","decide","aesop","linarith","simp"]],["Data/PFunctor/Univariate/M.lean",468,"case e_approx.h.succ.mk\nF : PFunctor.{u}\nX : Type u_2\nf : X \u2192 \u2191F X\nx\u2080 : X\nn : \u2115\nfst\u271d : F.A\nsnd\u271d : F.B fst\u271d \u2192 X\n\u22a2 (CofixA.intro fst\u271d fun i \u21a6 sCorec f (snd\u271d i) n) = CofixA.intro fst\u271d fun i \u21a6 ((M.corec f \u2218 snd\u271d) i).approx n",["congr","aesop","tauto"]],["NumberTheory/LucasLehmer.lean",59,"\u22a2 Odd (mersenne 0) \u2194 0 \u2260 0",["simp","decide","aesop","tauto","norm_num"]],["NumberTheory/LucasLehmer.lean",180,"case mpr\np : \u2115\nw : 1 < p\nh : sMod p (p - 2) = 0\n\u22a2 \u21910 = 0",["simp","ring","aesop","norm_num"]],["NumberTheory/LucasLehmer.lean",415,"p' : \u2115\nh : lucasLehmerResidue (p' + 2) = 0\n\u22a2 (-1) ^ 2 = 1",["simp","ring","aesop","norm_num"]],["NumberTheory/LucasLehmer.lean",212,"case mk.mk\nq : \u2115+\nfst\u271d\u00b9 snd\u271d\u00b9 fst\u271d snd\u271d : ZMod \u2191q\nh\u2081 : (fst\u271d\u00b9, snd\u271d\u00b9).1 = (fst\u271d, snd\u271d).1\nh\u2082 : (fst\u271d\u00b9, snd\u271d\u00b9).2 = (fst\u271d, snd\u271d).2\n\u22a2 (fst\u271d\u00b9, snd\u271d\u00b9) = (fst\u271d, snd\u271d)",["congr","aesop"]],["NumberTheory/LucasLehmer.lean",93,"k : \u2115\n\u22a2 1 \u2264 2",["norm_num","omega","decide","aesop","tauto","simp"]],["NumberTheory/LucasLehmer.lean",146,"case zero\np' : \u2115\n\u22a2 4 = \u21914",["norm_num","ring","aesop","simp"]],["NumberTheory/LucasLehmer.lean",501,"p k : \u2115\nhp : 2 \u2264 p\n\u22a2 4 = 2 ^ 2",["norm_num","ring","omega","decide","aesop","congr","tauto","simp"]],["NumberTheory/LucasLehmer.lean",155,"p : \u2115\n\u22a2 0 < 2",["decide","omega","aesop","positivity","tauto","norm_num","simp"]],["NumberTheory/LucasLehmer.lean",395,"p' : \u2115\nk : \u2124\nt : 2 ^ p' + 2 ^ p' = 2 ^ (p' + 1)\nh : \u03c9 ^ 2 ^ (p' + 1) = \u2191k * \u2191(2 ^ (p' + 2) - 1) * \u03c9 ^ 2 ^ p' - 1\n\u22a2 0 < 2",["decide"]],["Algebra/Lie/Weights/RootSystem.lean",362,"case neg\nK : Type u_1\nL : Type u_2\ninst\u271d\u2077 : Field K\ninst\u271d\u2076 : CharZero K\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : IsKilling K L\ninst\u271d\u00b2 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsTriangularizable K (\u21a5H) L\n\u03b1\u271d \u03b2\u271d \u03b1 \u03b2 : Weight K (\u21a5H) L\nh\u03b1 : \u00ac\u03b1.IsZero\n\u22a2 -(\u2191(chainBotCoeff (\u21d1\u03b1) \u03b2) - \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2)) \u2264 \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2) \u2227\n    - -(\u2191(chainBotCoeff (\u21d1\u03b1) \u03b2) - \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2)) \u2264 \u2191(chainBotCoeff (\u21d1\u03b1) \u03b2)",["omega","aesop","norm_num","simp"]],["Order/Interval/Basic.lean",133,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b3\ns : NonemptyInterval \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 Nonempty \u03b1",["infer_instance","aesop","congr","tauto","assumption"]],["Order/Interval/Basic.lean",42,"case mk.mk\n\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ntoProd\u271d\u00b9 : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d\u00b9 : toProd\u271d\u00b9.1 \u2264 toProd\u271d\u00b9.2\ntoProd\u271d : \u03b1 \u00d7 \u03b1\nfst_le_snd\u271d : toProd\u271d.1 \u2264 toProd\u271d.2\nh : { toProd := toProd\u271d\u00b9, fst_le_snd := fst_le_snd\u271d\u00b9 }.toProd = { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }.toProd\n\u22a2 { toProd := toProd\u271d\u00b9, fst_le_snd := fst_le_snd\u271d\u00b9 } = { toProd := toProd\u271d, fst_le_snd := fst_le_snd\u271d }",["congr","aesop"]],["NumberTheory/LSeries/AbstractFuncEq.lean",331,"case inr.inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nP : WeakFEPair E\nx : \u211d\nhx : 0 < x\nhx' : 1 < x\n\u22a2 P.f x - P.f\u2080 + 0 - P.f x + P.f\u2080 = 0 + 0",["abel","aesop","norm_num","simp"]],["RingTheory/AdicCompletion/Basic.lean",466,"R : Type u_1\ninst\u271d\u00b2 : CommRing R\nI : Ideal R\nM : Type u_4\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : AdicCauchySequence I M\nk : \u2115\nh : \u2200 n \u2265 k, \u2203 m \u2265 n, \u2203 l \u2265 n, \u2191f m \u2208 I ^ l \u2022 \u22a4\nn : \u2115\n\u22a2 n + k \u2265 k",["omega","aesop","linarith","norm_num","simp"]],["RingTheory/LocalProperties/Basic.lean",206,"R S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\nP : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nH : HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] \u21a6 P\nhf : Function.Bijective \u21d1f\nthis : Algebra R S := f.toAlgebra\n\u22a2 Submonoid.powers 1 \u2264 IsUnit.submonoid R",["simp","aesop","norm_num"]],["RingTheory/LocalProperties/Basic.lean",274,"P : {R S : Type u} \u2192 [inst : CommRing R] \u2192 [inst_1 : CommRing S] \u2192 (R \u2192+* S) \u2192 Prop\nH : LocalizationPreserves P\nR S : Type u\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\nf : R \u2192+* S\nr : R\nR' S' : Type u\ninst\u271d\u2075 : CommRing R'\ninst\u271d\u2074 : CommRing S'\ninst\u271d\u00b3 : Algebra R R'\ninst\u271d\u00b2 : Algebra S S'\ninst\u271d\u00b9 : IsLocalization.Away r R'\ninst\u271d : IsLocalization.Away (f r) S'\nhf : P f\n\u22a2 IsLocalization (Submonoid.powers (f r)) S'",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["NumberTheory/Padics/Hensel.lean",177,"case hnorm\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nhnorm : \u2016Polynomial.eval a F\u2016 < \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 ^ 2\nz z' z1 : \u2124_[p]\nhz' : z' = z - z1\nn : \u2115\nhz : ih_gen n z\nh1 : \u2016\u2191(Polynomial.eval z F) / \u2191(Polynomial.eval z (Polynomial.derivative F))\u2016 \u2264 1\nhzeq : z1 = \u27e8\u2191(Polynomial.eval z F) / \u2191(Polynomial.eval z (Polynomial.derivative F)), h1\u27e9\n\u22a2 \u2016Polynomial.eval a F\u2016 < \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 ^ 2",["assumption","aesop","congr","linarith","gcongr","tauto"]],["NumberTheory/Padics/Hensel.lean",308,"case hg.hnorm\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nhnorm : \u2016Polynomial.eval a F\u2016 < \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 ^ 2\n\u22a2 \u2016Polynomial.eval a F\u2016 < \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 ^ 2",["assumption","aesop","congr","linarith","gcongr","tauto"]],["NumberTheory/Padics/Hensel.lean",362,"case hc.hnorm\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nhnorm : \u2016Polynomial.eval a F\u2016 < \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 ^ 2\nhnsol : Polynomial.eval a F \u2260 0\nn : \u2115\nthis : 2 \u2264 2 ^ (n + 1)\n\u22a2 \u2016Polynomial.eval a F\u2016 < \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 ^ 2",["assumption","aesop","congr","linarith","gcongr","tauto"]],["NumberTheory/Padics/Hensel.lean",370,"case hnsol\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nF : Polynomial \u2124_[p]\na : \u2124_[p]\nhnorm : \u2016Polynomial.eval a F\u2016 < \u2016Polynomial.eval a (Polynomial.derivative F)\u2016 ^ 2\nhnsol : Polynomial.eval a F \u2260 0\nk : \u2115\n_h : 0 < k + 2\n\u22a2 Polynomial.eval a F \u2260 0",["assumption","aesop","congr","tauto"]],["Algebra/Homology/HomotopyCofiber.lean",346,"case mp\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nF G : HomologicalComplex C c\ninst\u271d : DecidableRel c.Rel\n\u03c6 : F \u27f6 G\nK : HomologicalComplex C c\nx : (\u03b1 : G \u27f6 K) \u00d7 Homotopy (\u03c6 \u226b \u03b1) 0\n\u22a2 x.fst = x.fst \u2227 \u2200 (i j : \u03b9), c.Rel j i \u2192 x.snd.hom i j = x.snd.hom i j",["tauto","aesop","norm_num","simp"]],["Geometry/Manifold/Instances/Real.lean",190,"n : \u2115\ninst\u271d : NeZero n\n\u22a2 { toFun := Subtype.val, invFun := fun x \u21a6 \u27e8update x 0 (x 0 \u2294 0), \u22ef\u27e9, source := univ, target := {x | 0 \u2264 x 0},\n        map_source' := \u22ef, map_target' := \u22ef, left_inv' := \u22ef, right_inv' := \u22ef }.target \u2286\n    closure\n      (interior\n        { toFun := Subtype.val, invFun := fun x \u21a6 \u27e8update x 0 (x 0 \u2294 0), \u22ef\u27e9, source := univ, target := {x | 0 \u2264 x 0},\n            map_source' := \u22ef, map_target' := \u22ef, left_inv' := \u22ef, right_inv' := \u22ef }.target)",["simp","aesop","norm_num"]],["Geometry/Manifold/Instances/Real.lean",315,"x y : \u211d\nhxy : Fact (x < y)\n\u22a2 \u2191(\ud835\udce1\u2202 1) \u27e8fun x \u21a6 0, \u22ef\u27e9 = 0",["congr","aesop","tauto"]],["Geometry/Manifold/Instances/Real.lean",381,"x y : \u211d\nhxy : Fact (x < y)\n\u22a2 \u2191(\ud835\udce1\u2202 1) \u27e8fun x \u21a6 0, \u22ef\u27e9 = 0",["congr","aesop","tauto"]],["Topology/Homotopy/HomotopyGroup.lean",188,"case H\nN : Type u_1\nX : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\nx : X\ninst\u271d : DecidableEq N\ni : N\np : \u2191(\u03a9^ N X x)\nt : { j // j \u2260 i } \u2192 \u2191I\n\u22a2 (Cube.insertAt i) (1, t) i = 1",["simp","aesop","norm_num"]],["Topology/Homotopy/HomotopyGroup.lean",106,"N : Type u_1\nX : Type u_2\ninst\u271d : TopologicalSpace X\nx : X\nx\u271d\u00b2 x\u271d\u00b9 : \u2191(\u03a9^ N X x)\nf : (N \u2192 \u2191I) \u2192 X\ncontinuous_toFun\u271d\u00b9 : Continuous f\nproperty\u271d\u00b9 : { toFun := f, continuous_toFun := continuous_toFun\u271d\u00b9 } \u2208 \u03a9^ N X x\ng : (N \u2192 \u2191I) \u2192 X\ncontinuous_toFun\u271d : Continuous g\nproperty\u271d : { toFun := g, continuous_toFun := continuous_toFun\u271d } \u2208 \u03a9^ N X x\nx\u271d :\n  (fun f \u21a6 \u21d1\u2191f) \u27e8{ toFun := f, continuous_toFun := continuous_toFun\u271d\u00b9 }, property\u271d\u00b9\u27e9 =\n    (fun f \u21a6 \u21d1\u2191f) \u27e8{ toFun := g, continuous_toFun := continuous_toFun\u271d }, property\u271d\u27e9\n\u22a2 \u27e8{ toFun := f, continuous_toFun := continuous_toFun\u271d\u00b9 }, property\u271d\u00b9\u27e9 =\n    \u27e8{ toFun := g, continuous_toFun := continuous_toFun\u271d }, property\u271d\u27e9",["congr","aesop"]],["Algebra/Category/Grp/Basic.lean",632,"G : Type u\ninst\u271d : Monoid G\nH : CommGrp\nf : G \u2192* \u2191H\n\u22a2 (CommGrp.Hom.hom (\ud835\udfd9 H)).comp f = f",["simp","omega","aesop","congr","tauto","infer_instance"]],["Algebra/Category/Grp/Basic.lean",397,"X Y : CommGrp\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s",["simp","aesop"]],["Algebra/Category/Grp/Basic.lean",558,"\u03b1 : Type u\n\u22a2 (fun g \u21a6 Iso.toEquiv g) 1 = 1",["aesop","congr","tauto"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",178,"case e_a\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : \u211d\u22650\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\n\u03b5 : \u211d\nb : E\n\u03b50 : 0 \u2264 \u03b5\nh\u03b5 : closedBall b \u03b5 \u2286 s\ny : F\nhy : y \u2208 closedBall (f b) (((\u2191f'symm.nnnorm)\u207b\u00b9 - \u2191c) * \u03b5)\nhc : \u2191c < (\u2191f'symm.nnnorm)\u207b\u00b9\nIf' : 0 < \u2191f'symm.nnnorm\nIcf' : \u2191c * \u2191f'symm.nnnorm < 1\nJf' : \u2191f'symm.nnnorm \u2260 0\nJcf' : 1 - \u2191c * \u2191f'symm.nnnorm \u2260 0\ng : E \u2192 E := fun x \u21a6 x + f'symm.toFun (y - f x)\nhg : g = fun x \u21a6 x + f'symm.toFun (y - f x)\nu : \u2115 \u2192 E := fun n \u21a6 g^[n] b\nhu : u = fun n \u21a6 g^[n] b\nusucc : \u2200 (n : \u2115), u (n + 1) = g (u n)\nA : \u2200 (z : E), dist (g z) z \u2264 \u2191f'symm.nnnorm * dist (f z) y\nz : E\nhz : z \u2208 closedBall b \u03b5\nhgz : g z \u2208 closedBall b \u03b5\nv : E := f'symm.toFun (y - f z)\n\u22a2 f (z + v) - y = f (z + v) - f z - f' v + f' v - (y - f z)",["abel","aesop","norm_num","simp"]],["Algebra/FreeAlgebra.lean",335,"R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nf : X \u2192 A\n\u22a2 (algebraMap R A) 0 = 0",["simp","aesop","norm_num"]],["Algebra/FreeAlgebra.lean",328,"R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nf : X \u2192 A\n\u22a2 (algebraMap R A) 1 = 1",["simp","omega","aesop","norm_num"]],["Algebra/FreeAlgebra.lean",317,"case mul_zero\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nf : X \u2192 A\na\u271d\u00b9 : FreeAlgebra R X\na b a\u271d : Pre R X\n\u22a2 liftFun R X f a\u271d * (algebraMap R A) 0 = (algebraMap R A) 0",["simp","aesop","norm_num"]],["Algebra/FreeAlgebra.lean",339,"R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nf : X \u2192 A\n\u22a2 \u2200 (r : R),\n    (\u2191\u2191{ toFun := fun a \u21a6 Quot.liftOn a (liftFun R X f) \u22ef, map_one' := \u22ef, map_mul' := \u22ef, map_zero' := \u22ef,\n                map_add' := \u22ef }).toFun\n        ((algebraMap R (FreeAlgebra R X)) r) =\n      (algebraMap R A) r",["tauto"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",172,"f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhn : n \u2260 0\nhx : 0 < x\nhx' : x \u2264 1\nhn' : 0 < \u2191n\nthis : f \u2191n + x * log \u2191n = (1 - x) * f \u2191n + x * f (\u2191n + 1)\n\u22a2 1 - x + x = 1",["linarith","ring","aesop","abel","norm_num","simp"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",246,"case h.e'_4\nf : \u211d \u2192 \u211d\nx : \u211d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhx : 0 < x\nthis : \u2200 (m : \u2115), \u2191m < x \u2192 x \u2264 \u2191m + 1 \u2192 Tendsto (logGammaSeq x) atTop (\ud835\udcdd (f x - f 1))\nh\u271d : 1 \u2264 x\n\u22a2 x = x - 1 + 1",["abel","ring","aesop","linarith","norm_num","simp"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",326,"\u22a2 0 < 3 / 2",["norm_num","aesop","linarith","positivity","simp"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",227,"f : \u211d \u2192 \u211d\nx : \u211d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhx : 0 < x\nhx' : x \u2264 1\n\u22a2 f x - f 1 = f x - f 1 - x * 0",["ring","aesop","linarith","norm_num","simp"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",265,"f : \u211d \u2192 \u211d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nm : \u2115\nx : \u211d\nhx : 0 < x\nhy : \u2191m < x - 1\nhy' : x - 1 \u2264 \u2191m + 1\nhm : Tendsto (logGammaSeq (x - 1)) atTop (\ud835\udcdd (f (x - 1) - f 1))\nn : \u2115\nhn : 1 \u2264 n\nthis : logGammaSeq x (n - 1) = logGammaSeq (x - 1) n + log (x - 1) - x * (log (\u2191(n - 1) + 1) - log \u2191(n - 1))\n\u22a2 logGammaSeq (x - 1) n =\n    logGammaSeq (x - 1) n + log (x - 1) - x * (log (\u2191(n - 1) + 1) - log \u2191(n - 1)) +\n        x * (log (\u2191(n - 1) + 1) - log \u2191(n - 1)) -\n      log (x - 1)",["ring","aesop","linarith","abel","norm_num","simp"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",178,"f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhn : 2 \u2264 n\nhx : 0 < x\n\u22a2 1 < n",["omega","aesop","congr","linarith","tauto","assumption"]],["ModelTheory/DirectLimit.lean",131,"case intro.intro.hjk\nL : Language\n\u03b9 : Type v\ninst\u271d\u00b3 : Preorder \u03b9\nG : \u03b9 \u2192 Type w\ninst\u271d\u00b2 : (i : \u03b9) \u2192 L.Structure (G i)\nf : (i j : \u03b9) \u2192 i \u2264 j \u2192 G i \u21aa[L] G j\ninst\u271d\u00b9 : DirectedSystem G fun i j h \u21a6 \u21d1(f i j h)\ninst\u271d : IsDirected \u03b9 fun x1 x2 \u21a6 x1 \u2264 x2\nx\u271d\u2074 x\u271d\u00b3 x\u271d\u00b2 : \u03a3\u02e3 f\ni : \u03b9\nx : G i\nj : \u03b9\ny : G j\nx\u271d\u00b9 :\n  match \u27e8i, x\u27e9 with\n  | \u27e8i, x\u27e9 =>\n    match \u27e8j, y\u27e9 with\n    | \u27e8j, y\u27e9 => \u2203 k, \u2203 (ik : i \u2264 k) (jk : j \u2264 k), (f i k ik) x = (f j k jk) y\nk : \u03b9\nz : G k\nx\u271d :\n  match \u27e8j, y\u27e9 with\n  | \u27e8i, x\u27e9 =>\n    match \u27e8k, z\u27e9 with\n    | \u27e8j, y\u27e9 => \u2203 k, \u2203 (ik : i \u2264 k) (jk : j \u2264 k), (f i k ik) x = (f j k jk) y\nij : \u03b9\nhiij : i \u2264 ij\nhjij : j \u2264 ij\nhij : (f i ij hiij) x = (f j ij hjij) y\njk : \u03b9\nhjjk : j \u2264 jk\nhkjk : k \u2264 jk\nhjk : (f j jk hjjk) y = (f k jk hkjk) z\nijk : \u03b9\nhijijk : ij \u2264 ijk\nhjkijk : jk \u2264 ijk\n\u22a2 jk \u2264 ijk",["assumption","aesop","congr","gcongr","tauto"]],["Analysis/Normed/Operator/Compact.lean",394,"case h.e'_5\n\ud835\udd5c\u2081 : Type u_1\n\ud835\udd5c\u2082 : Type u_2\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2081\ninst\u271d\u2079 : NormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c\u2081 \u2192+* \ud835\udd5c\u2082\nM\u2081 : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u2078 : SeminormedAddCommGroup M\u2081\ninst\u271d\u2077 : AddCommGroup M\u2082\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2081 M\u2081\ninst\u271d\u2075 : Module \ud835\udd5c\u2082 M\u2082\ninst\u271d\u2074 : UniformSpace M\u2082\ninst\u271d\u00b3 : UniformAddGroup M\u2082\ninst\u271d\u00b2 : ContinuousConstSMul \ud835\udd5c\u2082 M\u2082\ninst\u271d\u00b9 : T2Space M\u2082\ninst\u271d : CompleteSpace M\u2082\nu : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nhu : \u2200 U \u2208 \ud835\udcdd 0, \u2203 y \u2208 {f | IsCompactOperator \u21d1f}, y - u \u2208 U\nU : Set M\u2082\nhU : U \u2208 \ud835\udcdd 0\nV : Set M\u2082\nhV : V \u2208 \ud835\udcdd 0\nhVU : \u2200 v \u2208 V, \u2200 w \u2208 V, v + w \u2208 U\nSV : Set M\u2081 \u00d7 Set M\u2082 := (closedBall 0 1, -V)\nv : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nhv : v \u2208 {f | IsCompactOperator \u21d1f}\nhuv : v - u \u2208 {f | \u2200 x \u2208 SV.1, f x \u2208 SV.2}\nT : Set M\u2082\nhT : T.Finite\nhTv : closure (\u21d1\u2191v '' closedBall 0 1) \u2286 \u22c3 y \u2208 T, y +\u1d65 V\nx : M\u2081\nhx : x \u2208 closedBall 0 1\nt : M\u2082\nht : t \u2208 T\nhtx : v x - t \u2208 V\n\u22a2 u x - t = v x - t + -(v x - u x)",["abel","aesop","norm_num","simp"]],["Topology/Connected/PathConnected.lean",514,"X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : PathConnectedSpace X\nn : \u2115\np : Fin (n + 1) \u2192 X\n\u22a2 PathConnectedSpace X",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["Topology/Connected/PathConnected.lean",520,"X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : PathConnectedSpace X\nn : \u2115\np : Fin (n + 1) \u2192 X\n\u22a2 PathConnectedSpace X",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["Topology/Connected/PathConnected.lean",414,"X : Type u_1\ninst\u271d : TopologicalSpace X\nn : \u2115\ns : Set X\nh : IsPathConnected s\np : Fin (n + 1) \u2192 X\nhp : \u2200 (i : Fin (n + 1)), p i \u2208 s\np' : \u2115 \u2192 X := fun k \u21a6 if h : k < n + 1 then p \u27e8k, h\u27e9 else p \u27e80, \u22ef\u27e9\n\u03b3 : Path (p' 0) (p' n)\nh\u03b3 : (\u2200 i \u2264 n, p' i \u2208 range \u21d1\u03b3) \u2227 range \u21d1\u03b3 \u2286 s\nhpp' : \u2200 k < n + 1, p \u2191k = p' k\ni : \u2115\nhi : i < n + 1\nthis : i = i % n.succ\n\u22a2 p \u27e8i, hi\u27e9 = p \u2191i",["congr"]],["Analysis/SpecialFunctions/Pow/Continuity.lean",348,"case hz\ny : \u2102\nh : 0 < y.re \u2228 0 \u2260 0\n\u22a2 0 < y.re",["tauto","aesop"]],["LinearAlgebra/Finsupp/LinearCombination.lean",141,"case h.h\n\u03b1 : Type u_1\nR : Type u_5\ninst\u271d\u00b2 : Semiring R\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv' : \u03b1' \u2192 M'\nf : \u03b1 \u2192 \u03b1'\na\u271d : \u03b1\n\u22a2 ((linearCombination R v' \u2218\u2097 lmapDomain R R f) \u2218\u2097 lsingle a\u271d) 1 = (linearCombination R (v' \u2218 f) \u2218\u2097 lsingle a\u271d) 1",["simp","aesop"]],["LinearAlgebra/Finsupp/LinearCombination.lean",195,"\u03b1 : Type u_1\nM : Type u_2\nR : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b1 \u2192 M\ns : Set \u03b1\nx : M\n\u22a2 x \u2208 map (linearCombination R v) (supported R R s) \u2194 \u2203 l \u2208 supported R R s, (linearCombination R v) l = x",["simp","aesop","tauto"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",40,"case h\n\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : TopologicalSpace A\ninst\u271d\u00b3 : T2Space A\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : Algebra \ud835\udd5c A\ns : Set \ud835\udd5c\nx\u271d : CompactSpace \u2191s\n\u03c6 \u03c8 : C(\u2191s, \ud835\udd5c) \u2192\u22c6\u2090[\ud835\udd5c] A\nh\u03c6 : Continuous \u21d1\u03c6\nh\u03c8 : Continuous \u21d1\u03c8\nh : \u03c6 (ContinuousMap.restrict s (ContinuousMap.id \ud835\udd5c)) = \u03c8 (ContinuousMap.restrict s (ContinuousMap.id \ud835\udd5c))\na\u271d : \u2191s\n\u22a2 ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X) a\u271d = (ContinuousMap.restrict s (ContinuousMap.id \ud835\udd5c)) a\u271d\n```\n---\n```lean\ncase h\n\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : TopologicalSpace A\ninst\u271d\u00b3 : T2Space A\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : Algebra \ud835\udd5c A\ns : Set \ud835\udd5c\nx\u271d : CompactSpace \u2191s\n\u03c6 \u03c8 : C(\u2191s, \ud835\udd5c) \u2192\u22c6\u2090[\ud835\udd5c] A\nh\u03c6 : Continuous \u21d1\u03c6\nh\u03c8 : Continuous \u21d1\u03c8\nh : \u03c6 (ContinuousMap.restrict s (ContinuousMap.id \ud835\udd5c)) = \u03c8 (ContinuousMap.restrict s (ContinuousMap.id \ud835\udd5c))\na\u271d : \u2191s\n\u22a2 ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X) a\u271d = (ContinuousMap.restrict s (ContinuousMap.id \ud835\udd5c)) a\u271d",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",115,"X : Type u_1\ninst\u271d\u2075 : TopologicalSpace X\nA : Type u_2\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : Algebra \u211d A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : IsTopologicalRing A\n\u03c6 : C(X, \u211d\u22650) \u2192\u22c6\u2090[\u211d\u22650] A\n\u22a2 (fun f \u21a6 \u03c6 f.toNNReal - \u03c6 (-f).toNNReal) 1 = 1",["simp","aesop","norm_num"]],["RingTheory/UniqueFactorizationDomain/Basic.lean",141,"case intro.refine_1\n\u03b1 : Type u_1\ninst\u271d : CancelCommMonoidWithZero \u03b1\na : \u03b1\nf : Multiset \u03b1\nha : Irreducible a\npfa : (\u2200 b \u2208 f, Prime b) \u2227 f.prod ~\u1d64 a\nthis : DecidableEq \u03b1\np : \u03b1\ns : Multiset \u03b1\na\u271d : s.prod ~\u1d64 a \u2192 (\u2200 b \u2208 s, Prime b) \u2192 \u2203 p, a ~\u1d64 p \u2227 s = {p}\nu : \u03b1\u02e3\nhu : (p ::\u2098 s).prod * \u2191u = a\nhs : \u2200 b \u2208 p ::\u2098 s, Prime b\nhs0 : \u00acs = 0\nq : \u03b1\nhq : q \u2208 s\n\u22a2 \u2191u * (p ::\u2098 s).prod = \u2191u * (p * s.prod)",["simp","aesop"]],["RingTheory/UniqueFactorizationDomain/Basic.lean",450,"case refine_1\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : UniqueFactorizationMonoid R\na : R\na\u271d : 0 \u2260 0\nb\u271d : R\n\u22a2 \u2203 a' b' c', IsRelPrime a' b' \u2227 c' * a' = 0 \u2227 c' * b' = b\u271d",["contradiction","aesop","tauto"]],["RingTheory/UniqueFactorizationDomain/Basic.lean",469,"case neg.intro.intro.intro.intro.intro.inl\nR : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : UniqueFactorizationMonoid R\na p : R\np_prime : Prime p\na' b' c' : R\ncoprime : IsRelPrime a' b'\na_ne_zero : c' * a' \u2260 0\nih_a : c' * a' \u2260 0 \u2192 \u2200 (b : R), \u2203 a'_1 b' c'_1, IsRelPrime a'_1 b' \u2227 c'_1 * a'_1 = c' * a' \u2227 c'_1 * b' = b\npa_ne_zero : p * (c' * a') \u2260 0\nh : \u00acp \u2223 c' * b'\nq : R\nq_dvd_pa' : q \u2223 p * a'\nq_dvd_b' : q \u2223 b'\np_dvd_q : p \u2223 q\nthis : p \u2223 c' * b'\n\u22a2 IsUnit q",["contradiction"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",100,"p : \u211d\nhp : p < 0\nhp' : p < -1\n\u22a2 -p < 1 - p",["linarith","aesop","norm_num","simp"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",142,"p\u271d p : \u211d\nh : p \u2260 2\u207b\u00b9\nhp : p < 2\u207b\u00b9\nhp\u2080 : p \u2264 0\n\u22a2 1 < 2",["norm_num","aesop","linarith","simp"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",265,"\u22a2 0 < 1 / 2",["norm_num","aesop","linarith","positivity","simp"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",282,"\u22a2 1 - 2\u207b\u00b9 < 1",["norm_num","aesop","linarith","simp"]],["Combinatorics/SimpleGraph/Finite.lean",70,"V : Type u_1\nG\u2081 G\u2082 : SimpleGraph V\ninst\u271d\u00b9 : Fintype \u2191G\u2081.edgeSet\ninst\u271d : Fintype \u2191G\u2082.edgeSet\n\u22a2 G\u2081.edgeFinset \u2286 G\u2082.edgeFinset \u2194 G\u2081 \u2264 G\u2082",["simp","aesop"]],["Combinatorics/SimpleGraph/Finite.lean",68,"V : Type u_1\nG\u2081 G\u2082 : SimpleGraph V\ninst\u271d\u00b9 : Fintype \u2191G\u2081.edgeSet\ninst\u271d : Fintype \u2191G\u2082.edgeSet\n\u22a2 G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082",["simp","aesop"]],["Combinatorics/SimpleGraph/Finite.lean",492,"case right\nV : Type u_1\ns : Set V\ninst\u271d\u00b3 : DecidablePred fun x \u21a6 x \u2208 s\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\nv w : V\nhadj : G.Adj v w\nhv : v \u2208 s\nhw : w \u2208 s\n\u22a2 \u2191\u27e8v, hv\u27e9 = v \u2227 \u2191\u27e8w, hw\u27e9 = w \u2228 \u2191\u27e8v, hv\u27e9 = w \u2227 \u2191\u27e8w, hw\u27e9 = v",["tauto","aesop","simp"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",131,"case succ\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\nk : \u2115\nhak : a \u2264 k\nhk :\n  Nat.leRec Kernel.id (fun k x \u03ba_k \u21a6 (Kernel.id \u00d7\u2096 (\u03ba k).map \u21d1(piSingleton k) \u2218\u2096 \u03ba_k).map (_root_.IicProdIoc k (k + 1)))\n      \u22ef =\n    (Kernel.id \u00d7\u2096 (\u03ba k).map \u21d1(piSingleton k) \u2218\u2096 partialTraj \u03ba a k).map (_root_.IicProdIoc k (k + 1))\n\u22a2 a \u2264 k + 1",["omega","linarith","tauto"]],["CategoryTheory/Preadditive/Mat.lean",407,"case pos\nC : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} C\ninst\u271d\u2074 : Preadditive C\nD : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} D\ninst\u271d\u00b2 : Preadditive D\ninst\u271d\u00b9 : HasFiniteBiproducts D\nF : C \u2964 D\ninst\u271d : F.Additive\nX : Mat_ C\nj : X.\u03b9\n\u22a2 biproduct.\u03b9 (fun i \u21a6 F.obj (X.X i)) j \u226b\n      (biproduct.matrix fun i j \u21a6 F.map (\ud835\udfd9 X i j)) \u226b biproduct.\u03c0 (fun i \u21a6 F.obj (X.X i)) j =\n    biproduct.\u03b9 (fun i \u21a6 F.obj (X.X i)) j \u226b \ud835\udfd9 (\u2a01 fun i \u21a6 F.obj (X.X i)) \u226b biproduct.\u03c0 (fun i \u21a6 F.obj (X.X i)) j",["simp","aesop","norm_num"]],["CategoryTheory/Preadditive/Mat.lean",320,"case h.h\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : Preadditive C\nM : Mat_ C\ni j : M.\u03b9\n\u22a2 ((fun j x \u21a6 if h : j = i then eqToHom \u22ef else 0) \u226b fun x k \u21a6 if h : i = k then eqToHom \u22ef else 0) i j =\n    if h : i = j then eqToHom \u22ef else 0",["simp","aesop"]],["CategoryTheory/Preadditive/Mat.lean",220,"case H.mk.mk.h\u2080.hnc\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : Preadditive C\nn : \u2115\nf : Fin n \u2192 Mat_ C\ni : Fin n\nj : (f i).\u03b9\ni' : Fin n\nj' : (f i').\u03b9\nb : (f i).\u03b9\na\u271d : b \u2208 Finset.univ\nhb : b \u2260 j\n\u22a2 \u00acj = b",["tauto"]],["MeasureTheory/Measure/AddContent.lean",81,"case mk.mk\n\u03b1 : Type u_1\nC : Set (Set \u03b1)\ns t : Set \u03b1\nI : Finset (Set \u03b1)\ntoFun\u271d\u00b9 : Set \u03b1 \u2192 \u211d\u22650\u221e\nempty'\u271d\u00b9 : toFun\u271d\u00b9 \u2205 = 0\nsUnion'\u271d\u00b9 : \u2200 (I : Finset (Set \u03b1)), \u2191I \u2286 C \u2192 (\u2191I).PairwiseDisjoint id \u2192 \u22c3\u2080 \u2191I \u2208 C \u2192 toFun\u271d\u00b9 (\u22c3\u2080 \u2191I) = \u2211 u \u2208 I, toFun\u271d\u00b9 u\ntoFun\u271d : Set \u03b1 \u2192 \u211d\u22650\u221e\nempty'\u271d : toFun\u271d \u2205 = 0\nsUnion'\u271d : \u2200 (I : Finset (Set \u03b1)), \u2191I \u2286 C \u2192 (\u2191I).PairwiseDisjoint id \u2192 \u22c3\u2080 \u2191I \u2208 C \u2192 toFun\u271d (\u22c3\u2080 \u2191I) = \u2211 u \u2208 I, toFun\u271d u\nx\u271d :\n  (fun m s \u21a6 m.toFun s) { toFun := toFun\u271d\u00b9, empty' := empty'\u271d\u00b9, sUnion' := sUnion'\u271d\u00b9 } =\n    (fun m s \u21a6 m.toFun s) { toFun := toFun\u271d, empty' := empty'\u271d, sUnion' := sUnion'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, empty' := empty'\u271d\u00b9, sUnion' := sUnion'\u271d\u00b9 } =\n    { toFun := toFun\u271d, empty' := empty'\u271d, sUnion' := sUnion'\u271d }",["congr","aesop"]],["LinearAlgebra/Reflection.lean",76,"R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nf : Dual R M\nh : f x = 2\n\u22a2 x - (x + x) = -x",["abel","aesop","norm_num","simp"]],["Data/Complex/Module.lean",136,"R : Type u_1\nS : Type u_2\nz z' : \u2102\n\u22a2 (fun z \u21a6 ![z.re, z.im]) (z + z') = (fun z \u21a6 ![z.re, z.im]) z + (fun z \u21a6 ![z.re, z.im]) z'",["simp","aesop","norm_num"]],["Data/Complex/Module.lean",132,"R : Type u_1\nS : Type u_2\nz : \u2102\n\u22a2 (fun c \u21a6 \u2191(c 0) + c 1 \u2022 I) ({ toFun := fun z \u21a6 ![z.re, z.im], map_add' := \u22ef, map_smul' := \u22ef }.toFun z) = z",["simp","omega","infer_instance","norm_num"]],["Data/Complex/Module.lean",469,"A : Type u_1\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\n\u22a2 \u2200 (x y : \u21a5(selfAdjoint \u2102)), (fun z \u21a6 (\u2191z).re) (x + y) = (fun z \u21a6 (\u2191z).re) x + (fun z \u21a6 (\u2191z).re) y",["simp","aesop","tauto","norm_num"]],["Algebra/Category/ModuleCat/Basic.lean",133,"R : Type u\ninst\u271d : Ring R\nM N O : ModuleCat R\nf : M \u27f6 N\ng : N \u27f6 O\nx : \u2191M\n\u22a2 (ConcreteCategory.hom (f \u226b g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)",["simp","aesop","tauto","abel","norm_num"]],["Algebra/Category/ModuleCat/Basic.lean",527,"R : Type u\ninst\u271d : Ring R\nX\u2081 X\u2082 : Type v\nM N : ModuleCat R\nA : AddCommGrp\n\u03c6 : R \u2192+* End A\n\u22a2 \u2200 (b : \u2191(mkOfSMul' \u03c6)), 1 \u2022 b = b",["simp","aesop"]],["Analysis/SpecialFunctions/Exp.lean",294,"case h.e'_3.h\nb c : \u211d\nn : \u2115\nhb : 0 \u2260 b\nb' c' : \u211d\nh : 0 < b'\nx : \u211d\n\u22a2 x ^ n / (b' * rexp x + c') = (fun x \u21a6 (b' * rexp x + c') / x ^ n)\u207b\u00b9 x",["simp","aesop","norm_num"]],["Analysis/SpecialFunctions/Exp.lean",43,"r : \u211d\nhr_nonneg : 0 \u2264 r\nhr_le : r \u2264 1\nx y : \u2102\nhyx : \u2016y - x\u2016 < r\n\u22a2 y = x + (y - x)",["abel","ring","aesop","norm_num","simp"]],["Data/QPF/Multivariate/Constructions/Cofix.lean",282,"case a\nn : \u2115\nF : TypeVec.{u} (n + 1) \u2192 Type u\nq : MvQPF F\n\u03b1 : TypeVec.{u} n\nr : Cofix F \u03b1 \u2192 Cofix F \u03b1 \u2192 Prop\nh : \u2200 (x y : Cofix F \u03b1), r x y \u2192 LiftR' (\u03b1.RelLast' r) x.dest y.dest\nx\u271d y\u271d : Cofix F \u03b1\na\u271d : r x\u271d y\u271d\n\u22a2 r x\u271d y\u271d",["assumption","aesop","congr","gcongr","tauto"]],["NumberTheory/Padics/PadicIntegers.lean",366,"p : \u2115\nhp : Fact (Nat.Prime p)\nz1 z2 : \u2124_[p]\nhz2 : \u2016z2\u2016 < 1\n\u22a2 \u2016z1 * z2\u2016 = \u2016z1\u2016 * \u2016z2\u2016",["simp","aesop","norm_num"]],["NumberTheory/Padics/PadicIntegers.lean",76,"p : \u2115\nhp : Fact (Nat.Prime p)\nx y : \u2124_[p]\n\u22a2 0 \u2208 { carrier := {x | \u2016x\u2016 \u2264 1}, mul_mem' := \u22ef, one_mem' := \u22ef }.carrier",["norm_num","aesop","simp"]],["NumberTheory/Padics/PadicIntegers.lean",77,"p : \u2115\nhp : Fact (Nat.Prime p)\nx y : \u2124_[p]\n\u22a2 1 \u2208 { carrier := {x | \u2016x\u2016 \u2264 1}, mul_mem' := \u22ef }.carrier",["norm_num","aesop","simp"]],["Order/BooleanSubalgebra.lean",164,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9 : BooleanAlgebra \u03b2\ninst\u271d : BooleanAlgebra \u03b3\nL M : BooleanSubalgebra \u03b1\nf : BoundedLatticeHom \u03b1 \u03b2\ns t : Set \u03b1\na b x\u271d : \u03b1\n\u22a2 x\u271d \u2208 {\u22a5, \u22a4} \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 {\u22a5, \u22a4} \u2192 x\u271d \u2294 b \u2208 {\u22a5, \u22a4}",["simp","aesop"]],["Order/BooleanSubalgebra.lean",163,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9 : BooleanAlgebra \u03b2\ninst\u271d : BooleanAlgebra \u03b3\nL M : BooleanSubalgebra \u03b1\nf : BoundedLatticeHom \u03b1 \u03b2\ns t : Set \u03b1\na b : \u03b1\n\u22a2 \u2200 {a : \u03b1},\n    a \u2208 { carrier := {\u22a5, \u22a4}, supClosed' := \u22ef, infClosed' := \u22ef }.carrier \u2192\n      a\u1d9c \u2208 { carrier := {\u22a5, \u22a4}, supClosed' := \u22ef, infClosed' := \u22ef }.carrier",["simp","omega","infer_instance"]],["Order/BooleanSubalgebra.lean",233,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9 : BooleanAlgebra \u03b2\ninst\u271d : BooleanAlgebra \u03b3\nL\u271d M : BooleanSubalgebra \u03b1\nf\u271d : BoundedLatticeHom \u03b1 \u03b2\ns t : Set \u03b1\na b : \u03b1\nf : BoundedLatticeHom \u03b1 \u03b2\nL : BooleanSubalgebra \u03b2\n\u22a2 \u22a5 \u2208 { carrier := \u21d1f \u207b\u00b9' \u2191L, supClosed' := \u22ef, infClosed' := \u22ef }.carrier",["simp","aesop"]],["Order/BooleanSubalgebra.lean",33,"case mk.mk\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9 : BooleanAlgebra \u03b2\ninst\u271d : BooleanAlgebra \u03b3\nL M\u271d : BooleanSubalgebra \u03b1\nf : BoundedLatticeHom \u03b1 \u03b2\ns t : Set \u03b1\na b : \u03b1\nM : BooleanSubalgebra \u03b1\ncarrier\u271d : Set \u03b1\nsupClosed'\u271d : SupClosed carrier\u271d\ninfClosed'\u271d : InfClosed carrier\u271d\ncompl_mem'\u271d :\n  \u2200 {a : \u03b1},\n    a \u2208 { carrier := carrier\u271d, supClosed' := supClosed'\u271d, infClosed' := infClosed'\u271d }.carrier \u2192\n      a\u1d9c \u2208 { carrier := carrier\u271d, supClosed' := supClosed'\u271d, infClosed' := infClosed'\u271d }.carrier\nbot_mem'\u271d : \u22a5 \u2208 { carrier := carrier\u271d, supClosed' := supClosed'\u271d, infClosed' := infClosed'\u271d }.carrier\nh :\n  (fun L \u21a6 L.carrier)\n      { carrier := carrier\u271d, supClosed' := supClosed'\u271d, infClosed' := infClosed'\u271d, compl_mem' := compl_mem'\u271d,\n        bot_mem' := bot_mem'\u271d } =\n    (fun L \u21a6 L.carrier) M\n\u22a2 { carrier := carrier\u271d, supClosed' := supClosed'\u271d, infClosed' := infClosed'\u271d, compl_mem' := compl_mem'\u271d,\n      bot_mem' := bot_mem'\u271d } =\n    M",["congr","aesop"]],["Analysis/InnerProductSpace/Orthonormal.lean",82,"case h.e'_3\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : DecidableEq E\ns : Set E\nh : \u2200 v \u2208 s, \u2200 w \u2208 s, inner v w = if v = w then 1 else 0\nv : E\nhv : v \u2208 s\nw : E\nhw : w \u2208 s\n\u22a2 (if \u27e8v, hv\u27e9 = \u27e8w, hw\u27e9 then 1 else 0) = if v = w then 1 else 0",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/Orthonormal.lean",348,"case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2078 : RCLike \ud835\udd5c\ninst\u271d\u2077 : SeminormedAddCommGroup E\ninst\u271d\u2076 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\n\u03b9' : Type u_5\n\u03b9'' : Type u_6\nE' : Type u_7\ninst\u271d\u00b3 : SeminormedAddCommGroup E'\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E'\nE'' : Type u_8\ninst\u271d\u00b9 : SeminormedAddCommGroup E''\ninst\u271d : InnerProductSpace \ud835\udd5c E''\nv : Basis \u03b9 \ud835\udd5c E\nhv : Orthonormal \ud835\udd5c \u21d1v\nv' : Basis \u03b9' \ud835\udd5c E'\nhv' : Orthonormal \ud835\udd5c \u21d1v'\ne : \u03b9 \u2243 \u03b9'\ni : \u03b9\n\u22a2 (\u21d1(v.equiv v' e) \u2218 \u21d1v) i = (\u21d1v' \u2218 \u21d1e) i",["simp","aesop","norm_num"]],["Analysis/InnerProductSpace/Orthonormal.lean",262,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhv : Orthonormal \ud835\udd5c v\ni : \u03b9\n\u22a2 1 \u2260 0",["norm_num","aesop","linarith","positivity","simp"]],["NumberTheory/Harmonic/ZetaAsymp.lean",224,"case hab\ns : \u211d\nhs : 1 < s\nn : \u2115\n\u22a2 \u2191n \u2264 \u2191n + 1",["linarith","aesop","norm_num","simp"]],["NumberTheory/Harmonic/ZetaAsymp.lean",420,"\u22a2 0 \u2264 4",["norm_num","aesop","linarith","positivity","simp"]],["NumberTheory/Harmonic/ZetaAsymp.lean",339,"case h\nf : \u2102 \u2192 \u2102 := fun s \u21a6 riemannZeta s - 1 / (s - 1)\nt : \u2102\nht : t \u2208 {1}\u1d9c\nht' : t = 1\n\u22a2 f t - f 1 = 0",["tauto","aesop","contradiction"]],["RingTheory/Ideal/GoingUp.lean",398,"A : Type u_1\ninst\u271d\u2076 : CommRing A\np : Ideal A\ninst\u271d\u2075 : p.IsMaximal\nB : Type u_3\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : NoZeroSMulDivisors A B\ninst\u271d : Algebra.IsIntegral A B\n\u22a2 RingHom.ker (algebraMap A B) \u2264 p",["simp","aesop","norm_num"]],["RingTheory/Ideal/GoingUp.lean",49,"case refine_1\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nS : Type u_2\ninst\u271d : CommRing S\nf : R \u2192+* S\nI : Ideal S\nr : S\nr_non_zero_divisor : \u2200 {x : S}, x * r = 0 \u2192 x = 0\nhr : r \u2208 I\np : R[X]\nh : 0 \u2260 0\n\u22a2 eval\u2082 f r 0 = 0 \u2192 \u2203 i, coeff 0 i \u2260 0 \u2227 coeff 0 i \u2208 comap f I",["contradiction","aesop","tauto"]],["GroupTheory/Perm/Cycle/Concrete.lean",209,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Perm \u03b1\nx : \u03b1\n\u22a2 2 \u2264 (p.toList x).length \u2194 x \u2208 p.support",["simp","aesop","norm_num"]],["GroupTheory/Perm/Cycle/Concrete.lean",65,"case neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\nhl : l.Nodup\nhl' : l'.Nodup\nhn : 2 \u2264 l.length\nhn' : 2 \u2264 l'.length\nh : \u2200 \u2983a : \u03b1\u2984, a \u2208 l \u2192 a \u2208 l' \u2192 False\nx : \u03b1\nhx : x \u2208 l\nhx' : x \u2209 l'\nthis : l'.formPerm x = x\n\u22a2 l.formPerm x = x \u2228 l'.formPerm x = x\n```\n---\n```lean\ncase neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\nhl : l.Nodup\nhl' : l'.Nodup\nhn : 2 \u2264 l.length\nhn' : 2 \u2264 l'.length\nh : \u2200 \u2983a : \u03b1\u2984, a \u2208 l \u2192 a \u2208 l' \u2192 False\nx : \u03b1\nhx : x \u2209 l\nthis : l.formPerm x = x\n\u22a2 l.formPerm x = x \u2228 l'.formPerm x = x",["tauto"]],["Data/Set/Finite/Lattice.lean",60,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\ninst\u271d\u00b9 : DecidableEq \u03b1\n\u03b9 : Type u_1\ns : Set \u03b9\ninst\u271d : Fintype \u2191s\nt : \u03b9 \u2192 Set \u03b1\nH : (i : \u03b9) \u2192 i \u2208 s \u2192 Fintype \u2191(t i)\nthis : (i : { x // x \u2208 s.toFinset }) \u2192 Fintype \u2191(t \u2191i)\nx : \u03b1\n\u22a2 (x \u2208 s.toFinset.attach.biUnion fun x \u21a6 (t \u2191x).toFinset) \u2194 x \u2208 \u22c3 x \u2208 s, t x",["simp","aesop"]],["Data/Set/Finite/Lattice.lean",41,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype (PLift \u03b9)\nf : \u03b9 \u2192 Set \u03b1\ninst\u271d : (i : \u03b9) \u2192 Fintype \u2191(f i)\n\u22a2 \u2200 (x : \u03b1), (x \u2208 Finset.univ.biUnion fun i \u21a6 (f i.down).toFinset) \u2194 x \u2208 \u22c3 i, f i",["simp","aesop"]],["Data/Set/Finite/Lattice.lean",162,"case neg\n\u03b1 : Type u\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b9\nht : t.Finite\nhs : \u2200 i \u2208 t, (s i).Finite\nhe : \u2200 i \u2209 t, s i = \u2205\ni : \u03b9\nx : \u03b1\nhx : False\nhi : i \u2209 t\n\u22a2 x \u2208 \u22c3 i \u2208 t, s i",["contradiction","aesop","tauto"]],["Data/Int/Init.lean",96,"n : \u2115\n\u22a2 \u2191n \u2260 0 \u2194 n \u2260 0",["omega","simp"]],["Data/Int/Init.lean",101,"n : \u2115\n\u22a2 0 < \u2191n \u2194 0 < n",["omega","simp"]],["Data/Int/Init.lean",106,"n : \u2115\n\u22a2 \u2191n \u2264 0 \u2194 n = 0",["omega","simp"]],["Data/Int/Init.lean",50,"\u22a2 1 \u2260 0",["decide","omega","simp"]],["Data/Int/Init.lean",460,"\u22a2 1 \u2260 -1",["decide","omega","simp"]],["Probability/Kernel/Disintegration/StandardBorel.lean",267,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03a9 : Type u_4\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\ninst\u271d\u2074 : MeasurableSpace \u03a9\ninst\u271d\u00b3 : StandardBorelSpace \u03a9\ninst\u271d\u00b2 : Nonempty \u03a9\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03a9)\ninst\u271d\u00b9 : IsSFiniteKernel \u03ba\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u211d\ninst\u271d : IsSFiniteKernel \u03b7\nh\u03b7 : (\u03ba.map (Prod.map id (embeddingReal \u03a9))).fst \u2297\u2096 \u03b7 = \u03ba.map (Prod.map id (embeddingReal \u03a9))\ne : \u03a9 \u2192 \u211d := embeddingReal \u03a9\nhe : MeasurableEmbedding (embeddingReal \u03a9) := measurableEmbedding_embeddingReal \u03a9\n\u03ba' : Kernel \u03b1 (\u03b2 \u00d7 \u211d) := \u03ba.map (Prod.map id e)\nh\u03b7' : \u03ba'.fst \u2297\u2096 \u03b7 = \u03ba'\nh_prod_embed : MeasurableEmbedding (Prod.map id e)\nh_fst : \u03ba'.fst = \u03ba.fst\na : \u03b1\nt : Set (\u03b2 \u00d7 \u03a9)\nht : MeasurableSet t\nx : \u03b2 \u00d7 \u03a9\n\u22a2 x \u2208 Prod.map id e \u207b\u00b9' (univ \u00d7\u02e2 range e)\u1d9c \u2194 x \u2208 \u2205",["simp","aesop","norm_num"]],["Probability/Kernel/Disintegration/StandardBorel.lean",254,"case h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03a9 : Type u_4\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\ninst\u271d\u2074 : MeasurableSpace \u03a9\ninst\u271d\u00b3 : StandardBorelSpace \u03a9\ninst\u271d\u00b2 : Nonempty \u03a9\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03a9)\ninst\u271d\u00b9 : IsSFiniteKernel \u03ba\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u211d\ninst\u271d : IsSFiniteKernel \u03b7\nh\u03b7 : (\u03ba.map (Prod.map id (embeddingReal \u03a9))).fst \u2297\u2096 \u03b7 = \u03ba.map (Prod.map id (embeddingReal \u03a9))\ne : \u03a9 \u2192 \u211d := embeddingReal \u03a9\nhe : MeasurableEmbedding (embeddingReal \u03a9) := measurableEmbedding_embeddingReal \u03a9\n\u03ba' : Kernel \u03b1 (\u03b2 \u00d7 \u211d) := \u03ba.map (Prod.map id e)\nh\u03b7' : \u03ba'.fst \u2297\u2096 \u03b7 = \u03ba'\nh_prod_embed : MeasurableEmbedding (Prod.map id e)\na : \u03b1\nu : Set \u03b2\na\u271d : MeasurableSet u\n\u22a2 (Measure.map (Prod.fst \u2218 Prod.map id e) (\u03ba a)) u = (Measure.map Prod.fst (\u03ba a)) u",["congr","aesop","tauto","abel"]],["Analysis/SpecialFunctions/Log/Base.lean",418,"b x : \u211d\n\u22a2 (x = 0 \u2228 x = 1 \u2228 x = -1) \u2228 b = 0 \u2228 b = 1 \u2228 b = -1 \u2194 b = 0 \u2228 b = 1 \u2228 b = -1 \u2228 x = 0 \u2228 x = 1 \u2228 x = -1",["tauto","aesop"]],["Topology/Gluing.lean",102,"D : GlueData\nU : Set \u2191D.glued\n\u22a2 (\u2200 (j : Discrete (MultispanShape.prod D.J).R),\n      IsOpen\n        (\u21d1(ConcreteCategory.hom (colimit.\u03b9 (Discrete.functor D.diagram.right) j)) \u207b\u00b9'\n          (\u21d1(ConcreteCategory.hom (coequalizer.\u03c0 D.diagram.fstSigmaMap D.diagram.sndSigmaMap)) \u207b\u00b9'\n            (\u21d1(homeoOfIso (Multicoequalizer.isoCoequalizer D.diagram).symm) \u207b\u00b9' U)))) \u2194\n    \u2200 (i : D.J), IsOpen (\u21d1(ConcreteCategory.hom (Sigma.\u03b9 D.diagram.right i \u226b Multicoequalizer.sigma\u03c0 D.diagram)) \u207b\u00b9' U)",["tauto","aesop"]],["Algebra/Polynomial/Degree/Definitions.lean",419,"case neg\nR : Type u\ninst\u271d : Semiring R\na : R\nn : \u2115\nha : \u00aca = 0\n\u22a2 (if n = n then a else 0) = a",["simp","aesop"]],["Algebra/Polynomial/Degree/Definitions.lean",63,"R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d\u00b9 : Semiring R\np q r : R[X]\ninst\u271d : DecidableEq R\n\u22a2 Decidable (p.leadingCoeff = 1)",["infer_instance","aesop","tauto"]],["Algebra/Polynomial/Degree/Definitions.lean",300,"R : Type u\ninst\u271d : Semiring R\np : R[X]\n\u22a2 \u00acp.natDegree = 0 \u2192 p.coeff (p.natDegree - 1) = 0 \u2194 \u00acp.natDegree = 0 \u2192 \u00acp.natDegree = 0 \u2227 p.coeff (p.natDegree - 1) = 0",["aesop","tauto"]],["Combinatorics/SetFamily/AhlswedeZhang.lean",201,"\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\ninst\u271d : BoundedOrder \u03b1\na : \u03b1\n\u22a2 a \u2209 upperClosure \u2191\u2205",["simp","aesop","norm_num"]],["Combinatorics/SetFamily/AhlswedeZhang.lean",345,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\n\u22a2 \u2200 s \u2208 univ, True",["simp","aesop","tauto","norm_num"]],["Combinatorics/SetFamily/AhlswedeZhang.lean",138,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : SemilatticeSup \u03b1\ninst\u271d\u2074 : SemilatticeSup \u03b2\ninst\u271d\u00b3 : BoundedOrder \u03b2\ninst\u271d\u00b2 : DecidableLE \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : DecidableLE \u03b2\ne : \u03b1 \u2243o \u03b2\ns : Finset \u03b1\na : \u03b1\n\u22a2 e a \u2208 lowerClosure \u2191(map e.toEmbedding s) \u2194 a \u2208 lowerClosure \u2191s",["simp","aesop","norm_num"]],["Algebra/BigOperators/Fin.lean",430,"case zero\n\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nn : \u2115\nf : Fin n \u2192 \u03b1\n\u22a2 (take 0 (ofFn f)).prod = \u220f j \u2208 Finset.filter (fun j \u21a6 \u2191j < 0) univ, f j",["simp","aesop"]],["Algebra/BigOperators/Fin.lean",442,"case pos\n\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nn : \u2115\nf : Fin n \u2192 \u03b1\ni : \u2115\nIH : (take i (ofFn f)).prod = \u220f j \u2208 Finset.filter (fun j \u21a6 \u2191j < i) univ, f j\nh : i < n\nthis : i < (ofFn f).length\nA : Finset.filter (fun j \u21a6 \u2191j < i + 1) univ = Finset.filter (fun j \u21a6 \u2191j < i) univ \u222a {\u27e8i, h\u27e9}\nB : _root_.Disjoint (Finset.filter (fun j \u21a6 \u2191j < i) univ) {\u27e8i, h\u27e9}\n\u22a2 (\u220f j \u2208 Finset.filter (fun j \u21a6 \u2191j < i) univ, f j) * (ofFn f)[i] =\n    (\u220f x \u2208 Finset.filter (fun j \u21a6 \u2191j < i) univ, f x) * \u220f x \u2208 {\u27e8i, h\u27e9}, f x",["simp"]],["Algebra/BigOperators/Fin.lean",168,"M : Type u_3\ninst\u271d : CommMonoid M\na : \u2115\nf : Fin a \u2192 M\n\u22a2 \u220f i : Fin a, f (Fin.cast \u22ef i) = \u220f i : Fin a, f i",["congr","aesop","tauto","simp"]],["CategoryTheory/Abelian/Pseudoelements.lean",342,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nS : ShortComplex C\nhS : S.Exact\nb' : Pseudoelement S.X\u2082\nb : Over S.X\u2082\nhb : pseudoApply S.g \u27e6b\u27e7 = 0\nhb' : b.hom \u226b S.g = 0\nc : (\ud835\udfed C).obj b.left \u27f6 (KernelFork.of\u03b9 (image.\u03b9 S.f) \u22ef).pt\nhc : c \u226b Fork.\u03b9 (KernelFork.of\u03b9 (image.\u03b9 S.f) \u22ef) = b.hom\n\u22a2 pullback.snd (Abelian.factorThruImage S.f) c \u226b c \u226b kernel.\u03b9 (cokernel.\u03c0 S.f) =\n    pullback.snd (Abelian.factorThruImage S.f) c \u226b b.hom",["congr","aesop","tauto"]],["Analysis/Analytic/IsolatedZeros.lean",324,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx : \ud835\udd5c\nf : \ud835\udd5c \u2192 E\ns : Set E\nhfx : AnalyticAt \ud835\udd5c f x\nh\u2082f : \u00acEventuallyConst f (\ud835\udcdd x)\nhs : s \u2208 \ud835\udcdd[\u2260] f x\n\u22a2 \u2200 a \u2208 f \u207b\u00b9' insert (f x) s, f a \u2208 insert (f x) s",["tauto","aesop","norm_num","simp"]],["Analysis/Analytic/IsolatedZeros.lean",333,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx : \ud835\udd5c\nf : \ud835\udd5c \u2192 E\ns : Set E\nhfx : AnalyticAt \ud835\udd5c f x\nhs : s \u2208 \ud835\udcdd[\u2260] f x\nthis : \u2200\u1da0 (z : \ud835\udd5c) in \ud835\udcdd x, f z \u2208 insert (f x) s\nh : \u00acf \u207b\u00b9' s \u2208 \ud835\udcdd[\u2260] x\nz : \ud835\udd5c\nh\u2081z : f z \u2208 s \u2192 False\nh\u2082z : f z = f x \u2228 f z \u2208 s\n\u22a2 f z = f x",["tauto","aesop"]],["Analysis/Analytic/IsolatedZeros.lean",358,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nU : Set \ud835\udd5c\ns : Set E\nf : \ud835\udd5c \u2192 E\nhfU : AnalyticOnNhd \ud835\udd5c f U\nh\u2082f : \u2200 x \u2208 U, \u00acEventuallyConst f (\ud835\udcdd x)\nhs : \u2200 x \u2208 f '' U, s \u222a (f '' U)\u1d9c \u2208 \ud835\udcdd[\u2260] x\nx\u271d : \ud835\udd5c\nhx\u271d : x\u271d \u2208 U\nx : \ud835\udd5c\nhx : \u2200 x_1 \u2208 U, \u00acf x_1 = f x\n\u22a2 x \u2209 U",["tauto","aesop"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",255,"b\u271d : \u2102\nhb\u271d : 0 < b\u271d.re\nb : \u2102\nhb : b = 0\n\u22a2 re 0 \u2264 0",["simp","aesop","positivity","tauto","norm_num"]],["CategoryTheory/Limits/Shapes/WidePullbacks.lean",215,"case init.id\nJ : Type w\nC : Type u\ninst\u271d : Category.{v, u} C\nB : C\nobjs : J \u2192 C\narrows : (j : J) \u2192 B \u27f6 objs j\nj\u271d : J\n\u22a2 Hom.rec (motive := fun a a_1 x \u21a6 none = a \u2192 some j\u271d = a_1 \u2192 HEq (Hom.init j\u271d \u226b \ud835\udfd9 (some j\u271d)) x \u2192 (B \u27f6 objs j\u271d))\n      (fun X h \u21a6\n        Eq.rec (motive := fun x x_1 \u21a6 some j\u271d = x \u2192 HEq (Hom.init j\u271d \u226b \ud835\udfd9 (some j\u271d)) (\ud835\udfd9 x) \u2192 (B \u27f6 objs j\u271d))\n          (fun h \u21a6\n            Eq.rec (motive := fun x x_1 \u21a6 (f : none \u27f6 x) \u2192 HEq f (\ud835\udfd9 none) \u2192 (B \u27f6 Option.rec B (fun val \u21a6 objs val) x))\n              (fun f h \u21a6 \ud835\udfd9 B) \u22ef (Hom.init j\u271d \u226b \ud835\udfd9 (some j\u271d)))\n          h)\n      (fun j h h \u21a6\n        Eq.rec (motive := fun x x_1 \u21a6 (f : none \u27f6 x) \u2192 HEq f (Hom.init j) \u2192 (B \u27f6 Option.rec B (fun val \u21a6 objs val) x))\n          (fun f h \u21a6 arrows j) \u22ef (Hom.init j\u271d \u226b \ud835\udfd9 (some j\u271d)))\n      (Hom.init j\u271d \u226b \ud835\udfd9 (some j\u271d)) \u22ef \u22ef \u22ef =\n    arrows j\u271d",["congr"]],["Algebra/Module/Presentation/Basic.lean",356,"A : Type u\ninst\u271d\u2074 : Ring A\nrelations : Relations A\nM : Type v\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nf : M \u2192\u2097[A] N\n\u22a2 solution.postcomp ((fun s \u21a6 h.desc s) ((fun f \u21a6 solution.postcomp f) f)) = solution.postcomp f",["simp","aesop"]],["Algebra/Module/Presentation/Basic.lean",409,"A : Type u\ninst\u271d : Ring A\nrelations : Relations A\n\u22a2 (ofQuotient relations).fromQuotient = LinearMap.id",["aesop","congr","tauto"]],["NumberTheory/Padics/MahlerBasis.lean",236,"case inl\np : \u2115\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211a_[p] E\ninst\u271d : IsUltrametricDist E\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\ns : \u2115\nthis : Tendsto (fun s \u21a6 \u20160\u2016 / \u2191p ^ s) atTop (\ud835\udcdd 0)\nhs : \u20160\u2016 / \u2191p ^ s < \u03b5\n\u22a2 \u2203 t, \u2200 (x y : \u2124_[p]), \u2016x - y\u2016 \u2264 \u2191p ^ (-\u2191t) \u2192 \u20160 x - 0 y\u2016 \u2264 \u20160\u2016 / \u2191p ^ s",["simp","aesop","norm_num"]],["Algebra/Module/Injective.lean",129,"R : Type u\ninst\u271d\u2076 : Ring R\nQ : Type v\ninst\u271d\u2075 : AddCommGroup Q\ninst\u271d\u2074 : Module R Q\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\ni : M \u2192\u2097[R] N\nf : M \u2192\u2097[R] Q\nX Y : ExtensionOf i f\nx : N\ny : x \u2208 (X \u2293 Y).domain\nh : x \u2208 (X.toLinearPMap \u2293 Y.toLinearPMap).domain\n\u22a2 \u2191(X \u2293 Y).toLinearPMap \u27e8x, y\u27e9 = \u2191(X.toLinearPMap \u2293 Y.toLinearPMap) \u27e8x, h\u27e9",["congr","aesop","tauto","abel"]],["Algebra/Module/Injective.lean",365,"R : Type u\ninst\u271d\u2076 : Ring R\nQ : Type v\ninst\u271d\u2075 : AddCommGroup Q\ninst\u271d\u2074 : Module R Q\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nh : Baer R Q\nf : M \u2192\u2097[R] N\nhf : Function.Injective \u21d1f\ng : M \u2192\u2097[R] Q\nthis : Fact (Function.Injective \u21d1f)\nx y : N\n\u22a2 (fun x \u21a6 \u2191(extensionOfMax f g).toLinearPMap \u27e8x, \u22ef\u27e9) (x + y) = \u2191(extensionOfMax f g).toLinearPMap (\u27e8x, \u22ef\u27e9 + \u27e8y, \u22ef\u27e9)",["congr","aesop","tauto","abel","norm_num","simp"]],["Order/Closure.lean",332,"\u03b1 : Type u_1\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nu : \u03b2 \u2192 \u03b1\nl\u2081 : \u03b1 \u2192 \u03b2\ngc'\u271d\u00b9 : GaloisConnection l\u2081 u\nl\u2082 : \u03b1 \u2192 \u03b2\ngc'\u271d : GaloisConnection l\u2082 u\nh : { toFun := l\u2081, gc' := gc'\u271d\u00b9 }.toFun = { toFun := l\u2082, gc' := gc'\u271d }.toFun\n\u22a2 { toFun := l\u2081, gc' := gc'\u271d\u00b9 } = { toFun := l\u2082, gc' := gc'\u271d }",["congr","aesop"]],["Topology/Algebra/Ring/Basic.lean",383,"case mk.mk\n\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\ntoTopologicalSpace\u271d\u00b9 : TopologicalSpace \u03b1\ntoIsTopologicalRing\u271d\u00b9 : IsTopologicalRing \u03b1\ntoTopologicalSpace\u271d : TopologicalSpace \u03b1\ntoIsTopologicalRing\u271d : IsTopologicalRing \u03b1\na\u271d :\n  { toTopologicalSpace := toTopologicalSpace\u271d\u00b9, toIsTopologicalRing := toIsTopologicalRing\u271d\u00b9 }.toTopologicalSpace =\n    { toTopologicalSpace := toTopologicalSpace\u271d, toIsTopologicalRing := toIsTopologicalRing\u271d }.toTopologicalSpace\n\u22a2 { toTopologicalSpace := toTopologicalSpace\u271d\u00b9, toIsTopologicalRing := toIsTopologicalRing\u271d\u00b9 } =\n    { toTopologicalSpace := toTopologicalSpace\u271d, toIsTopologicalRing := toIsTopologicalRing\u271d }",["congr","aesop"]],["Analysis/Convex/Cone/Basic.lean",408,"case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst\u271d\u00b2 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\nx\u271d\u00b9 : ConvexCone \ud835\udd5c E\nx\u271d : E\n\u22a2 x\u271d \u2208 0 + x\u271d\u00b9 \u2194 x\u271d \u2208 x\u271d\u00b9",["simp","aesop","norm_num"]],["Analysis/Convex/Cone/Basic.lean",409,"case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst\u271d\u00b2 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\nx\u271d\u00b9 : ConvexCone \ud835\udd5c E\nx\u271d : E\n\u22a2 x\u271d \u2208 x\u271d\u00b9 + 0 \u2194 x\u271d \u2208 x\u271d\u00b9",["simp"]],["Analysis/Convex/Cone/Basic.lean",128,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_5\nx : E\nf : \u03b9 \u2192 ConvexCone \ud835\udd5c E\n\u22a2 (\u2200 i \u2208 Set.range f, x \u2208 \u2191i) \u2194 \u2200 (i : \u03b9), x \u2208 f i",["simp","aesop","norm_num"]],["Analysis/Convex/Cone/Basic.lean",74,"case mk.mk\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst\u271d\u00b2 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nS T : ConvexCone \ud835\udd5c E\ncarrier\u271d\u00b9 : Set E\nsmul_mem'\u271d\u00b9 : \u2200 \u2983c : \ud835\udd5c\u2984, 0 < c \u2192 \u2200 \u2983x : E\u2984, x \u2208 carrier\u271d\u00b9 \u2192 c \u2022 x \u2208 carrier\u271d\u00b9\nadd_mem'\u271d\u00b9 : \u2200 \u2983x : E\u2984, x \u2208 carrier\u271d\u00b9 \u2192 \u2200 \u2983y : E\u2984, y \u2208 carrier\u271d\u00b9 \u2192 x + y \u2208 carrier\u271d\u00b9\ncarrier\u271d : Set E\nsmul_mem'\u271d : \u2200 \u2983c : \ud835\udd5c\u2984, 0 < c \u2192 \u2200 \u2983x : E\u2984, x \u2208 carrier\u271d \u2192 c \u2022 x \u2208 carrier\u271d\nadd_mem'\u271d : \u2200 \u2983x : E\u2984, x \u2208 carrier\u271d \u2192 \u2200 \u2983y : E\u2984, y \u2208 carrier\u271d \u2192 x + y \u2208 carrier\u271d\nh :\n  { carrier := carrier\u271d\u00b9, smul_mem' := smul_mem'\u271d\u00b9, add_mem' := add_mem'\u271d\u00b9 }.carrier =\n    { carrier := carrier\u271d, smul_mem' := smul_mem'\u271d, add_mem' := add_mem'\u271d }.carrier\n\u22a2 { carrier := carrier\u271d\u00b9, smul_mem' := smul_mem'\u271d\u00b9, add_mem' := add_mem'\u271d\u00b9 } =\n    { carrier := carrier\u271d, smul_mem' := smul_mem'\u271d, add_mem' := add_mem'\u271d }",["congr","aesop"]],["Order/Heyting/Hom.lean",306,"F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : HeytingAlgebra \u03b1\ninst\u271d\u00b2 : HeytingAlgebra \u03b2\ninst\u271d\u00b9 : HeytingAlgebra \u03b3\ninst\u271d : HeytingAlgebra \u03b4\nf : HeytingHom \u03b2 \u03b3\ng : HeytingHom \u03b1 \u03b2\n\u22a2 { toFun := \u21d1f \u2218 \u21d1g, map_sup' := \u22ef, map_inf' := \u22ef }.toFun \u22a5 = \u22a5",["simp","aesop"]],["Order/Heyting/Hom.lean",517,"F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : BiheytingAlgebra \u03b1\ninst\u271d\u00b2 : BiheytingAlgebra \u03b2\ninst\u271d\u00b9 : BiheytingAlgebra \u03b3\ninst\u271d : BiheytingAlgebra \u03b4\nf : BiheytingHom \u03b2 \u03b3\ng : BiheytingHom \u03b1 \u03b2\na b : \u03b1\n\u22a2 { toFun := \u21d1f \u2218 \u21d1g, map_sup' := \u22ef, map_inf' := \u22ef }.toFun (a \\ b) =\n    { toFun := \u21d1f \u2218 \u21d1g, map_sup' := \u22ef, map_inf' := \u22ef }.toFun a \\\n      { toFun := \u21d1f \u2218 \u21d1g, map_sup' := \u22ef, map_inf' := \u22ef }.toFun b",["simp","aesop"]],["Order/Heyting/Hom.lean",163,"F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b2 : EquivLike F \u03b1 \u03b2\ninst\u271d\u00b9 : BiheytingAlgebra \u03b1\nx\u271d : BiheytingAlgebra \u03b2\ninst\u271d : OrderIsoClass F \u03b1 \u03b2\nf : F\na b : \u03b1\nc : \u03b2\n\u22a2 f (EquivLike.inv f c \u2293 a) \u2264 f b \u2194 EquivLike.inv f (c \u2293 f a) \u2264 b",["simp","aesop"]],["Data/Set/Pairwise/Basic.lean",132,"\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 (((\u2200 x \u2208 s, \u2200 x_1 \u2208 s, x \u2260 x_1 \u2192 r x x_1) \u2227 \u2200 x \u2208 t, \u2200 x_1 \u2208 s, x \u2260 x_1 \u2192 r x x_1) \u2227\n      (\u2200 x \u2208 s, \u2200 x_1 \u2208 t, x \u2260 x_1 \u2192 r x x_1) \u2227 \u2200 x \u2208 t, \u2200 x_1 \u2208 t, x \u2260 x_1 \u2192 r x x_1) \u2194\n    (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 x \u2260 y \u2192 r x y) \u2227\n      (\u2200 \u2983x : \u03b1\u2984, x \u2208 t \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 t \u2192 x \u2260 y \u2192 r x y) \u2227\n        (\u2200 x \u2208 s, \u2200 x_1 \u2208 t, x \u2260 x_1 \u2192 r x x_1) \u2227 \u2200 x \u2208 s, \u2200 x_2 \u2208 t, x \u2260 x_2 \u2192 r x_2 x",["aesop","tauto"]],["Combinatorics/SimpleGraph/Regularity/Uniform.lean",315,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \ud835\udd5c\ninst\u271d : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\nhP : P.IsEquipartition\nh : P.parts.Nonempty\n\u22a2 0 \u2264 \u2191(#A)",["positivity","aesop","norm_num","simp"]],["FieldTheory/PrimitiveElement.lean",164,"F : Type u_1\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Infinite F\nE : Type u_2\ninst\u271d\u00b2 : Field E\n\u03b1 \u03b2 : E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : Algebra.IsSeparable F E\nh\u03b1 : IsIntegral F \u03b1\nh\u03b2 : IsIntegral F \u03b2\nf : F[X] := minpoly F \u03b1\ng : F[X] := minpoly F \u03b2\n\u03b9FE : F \u2192+* E := algebraMap F E\n\u03b9EE' : E \u2192+* (Polynomial.map \u03b9FE g).SplittingField := algebraMap E (Polynomial.map \u03b9FE g).SplittingField\nc : F\nhc :\n  \u2200 \u03b1' \u2208 (Polynomial.map (\u03b9EE'.comp \u03b9FE) f).roots,\n    \u2200 \u03b2' \u2208 (Polynomial.map (\u03b9EE'.comp \u03b9FE) g).roots, -(\u03b1' - \u03b9EE' \u03b1) / (\u03b2' - \u03b9EE' \u03b2) \u2260 (\u03b9EE'.comp \u03b9FE) c\n\u03b3 : E := \u03b1 + c \u2022 \u03b2\np : (\u21a5F\u27ee\u03b3\u27ef)[X] :=\n  EuclideanDomain.gcd\n    ((Polynomial.map (algebraMap F \u21a5F\u27ee\u03b3\u27ef) f).comp (C (AdjoinSimple.gen F \u03b3) - C \u27e8(algebraMap F E) c, \u22ef\u27e9 * X))\n    (Polynomial.map (algebraMap F \u21a5F\u27ee\u03b3\u27ef) g)\nh : E[X] := EuclideanDomain.gcd ((Polynomial.map \u03b9FE f).comp (C \u03b3 - C (\u03b9FE c) * X)) (Polynomial.map \u03b9FE g)\nmap_g_ne_zero : Polynomial.map \u03b9FE g \u2260 0\nh_ne_zero : h \u2260 0\nh_sep : h.Separable\nh_root : eval \u03b2 h = 0\nh_splits : Splits \u03b9EE' h\nh_roots : \u2200 x \u2208 (Polynomial.map \u03b9EE' h).roots, x = \u03b9EE' \u03b2\n\u22a2 EuclideanDomain.gcd\n      ((Polynomial.map (algebraMap F E) f).comp (C \u03b3 - C ((algebraMap (\u21a5F\u27ee\u03b3\u27ef) E) \u27e8(algebraMap F E) c, \u22ef\u27e9) * X))\n      (Polynomial.map (algebraMap F E) g) =\n    h",["congr","tauto","abel"]],["Geometry/RingedSpace/LocallyRingedSpace.lean",327,"X Y : LocallyRingedSpace\ne : X \u2245 Y\nx : \u2191X.toTopCat\n\u22a2 (ConcreteCategory.hom (e.hom.base \u226b e.inv.base)) x = (ConcreteCategory.hom (\ud835\udfd9 X.toPresheafedSpace).base) x",["simp","aesop","norm_num"]],["Geometry/RingedSpace/LocallyRingedSpace.lean",405,"X Y : LocallyRingedSpace\ne : X \u2245 Y\nx : \u2191X.toTopCat\n\u22a2 X.presheaf.stalkSpecializes \u22ef \u226b Hom.stalkMap (\ud835\udfd9 X) x = X.presheaf.stalkSpecializes \u22ef",["simp","aesop"]],["Geometry/RingedSpace/LocallyRingedSpace.lean",92,"case mk.mk\nX Y : LocallyRingedSpace\ntoHom\u271d\u00b9 : X.Hom Y.toPresheafedSpace\nprop\u271d\u00b9 : \u2200 (x : \u2191\u2191X.toPresheafedSpace), IsLocalHom (CommRingCat.Hom.hom (toHom\u271d\u00b9.stalkMap x))\ntoHom\u271d : X.Hom Y.toPresheafedSpace\nprop\u271d : \u2200 (x : \u2191\u2191X.toPresheafedSpace), IsLocalHom (CommRingCat.Hom.hom (toHom\u271d.stalkMap x))\nh : { toHom := toHom\u271d\u00b9, prop := prop\u271d\u00b9 }.toShHom = { toHom := toHom\u271d, prop := prop\u271d }.toShHom\n\u22a2 { toHom := toHom\u271d\u00b9, prop := prop\u271d\u00b9 } = { toHom := toHom\u271d, prop := prop\u271d }",["congr","aesop"]],["NumberTheory/WellApproximable.lean",240,"case e_p.h.a\nT : \u211d\nhT : Fact (0 < T)\n\u03b4 : \u2115 \u2192 \u211d\nh\u03b4 : Tendsto \u03b4 atTop (\ud835\udcdd 0)\nthis : SemilatticeSup Nat.Primes := Nat.Subtype.semilatticeSup Irreducible\n\u03bc : Measure \ud835\udd4a := volume\nu : Nat.Primes \u2192 \ud835\udd4a := fun p \u21a6 \u2191(\u21911 / \u2191\u2191p * T)\nhu\u2080 : \u2200 (p : Nat.Primes), addOrderOf (u p) = \u2191p\nhu : Tendsto (addOrderOf \u2218 u) atTop atTop\nE : Set \ud835\udd4a := addWellApproximable \ud835\udd4a \u03b4\nX : \u2115 \u2192 Set \ud835\udd4a := fun n \u21a6 approxAddOrderOf \ud835\udd4a n (\u03b4 n)\nA : \u2115 \u2192 Set \ud835\udd4a := fun p \u21a6 blimsup X atTop fun n \u21a6 0 < n \u2227 \u00acp \u2223 n\nB : \u2115 \u2192 Set \ud835\udd4a := fun p \u21a6 blimsup X atTop fun n \u21a6 0 < n \u2227 p \u2223 n \u2227 \u00acp * p \u2223 n\nC : \u2115 \u2192 Set \ud835\udd4a := fun p \u21a6 blimsup X atTop fun n \u21a6 0 < n \u2227 p ^ 2 \u2223 n\nhA\u2080 : \u2200 (p : \u2115), MeasurableSet (A p)\nhB\u2080 : \u2200 (p : \u2115), MeasurableSet (B p)\nhE\u2080 : NullMeasurableSet E \u03bc\np n : \u2115\n\u22a2 0 < n \u2194 0 < n \u2227 ((\u00acp \u2223 n \u2228 p \u2223 n \u2227 \u00acp * p \u2223 n) \u2228 p * p \u2223 n)",["tauto","omega"]],["Data/Nat/ModEq.lean",446,"n : \u2115\n\u22a2 \u2200 (m : \u2115), m < 4 \u2192 m % 2 = 1 \u2192 m = 1 \u2228 m = 3",["decide","omega"]],["CategoryTheory/SmallObject/Iteration/Basic.lean",168,"case mk\nC : Type u\ninst\u271d : Category.{v, u} C\n\u03a6 : SuccStruct C\nX : C\n\u22a2 \u03a6.toSucc X = \u03a6.toSucc X \u226b eqToHom \u22ef",["simp","aesop"]],["CategoryTheory/SmallObject/Iteration/Basic.lean",326,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nK : Type w\ninst\u271d : LinearOrder K\nx : K\nF G : \u2191(Set.Iic x) \u2964 C\nk\u2081 k\u2082 : K\nh\u2081\u2082 : k\u2081 \u2264 k\u2082\nh\u2082 : k\u2082 \u2264 x\nh : MapEq F G k\u2081 k\u2082 h\u2081\u2082 h\u2082\nthis :\n  \u2203 (hX : F.obj \u27e8k\u2081, \u22ef\u27e9 = G.obj \u27e8k\u2081, \u22ef\u27e9) (hY : F.obj \u27e8k\u2082, h\u2082\u27e9 = G.obj \u27e8k\u2082, h\u2082\u27e9),\n    F.map (homOfLE h\u2081\u2082) = eqToHom hX \u226b G.map (homOfLE h\u2081\u2082) \u226b eqToHom \u22ef\n\u22a2 F.map (homOfLE h\u2081\u2082) = eqToHom \u22ef \u226b G.map (homOfLE h\u2081\u2082) \u226b eqToHom \u22ef",["tauto","aesop"]],["CategoryTheory/SmallObject/Iteration/Basic.lean",428,"C : Type u\ninst\u271d\u2075 : Category.{v, u} C\nJ : Type w\n\u03a6 : SuccStruct C\ninst\u271d\u2074 : LinearOrder J\ninst\u271d\u00b3 : SuccOrder J\ninst\u271d\u00b2 : OrderBot J\ninst\u271d\u00b9 : HasIterationOfShape J C\ninst\u271d : WellFoundedLT J\nj\u2081 j\u2082 : J\niter\u2081 : \u03a6.Iteration j\u2081\niter\u2082 : \u03a6.Iteration j\u2082\nk\u2081 k\u2082 : J\nh : k\u2081 \u2264 k\u2082\nh\u2081 : k\u2082 \u2264 j\u2081\nh\u2082 : k\u2082 \u2264 j\u2082\nthis :\n  \u2203 (hX : iter\u2081.F.obj \u27e8k\u2081, \u22ef\u27e9 = iter\u2082.F.obj \u27e8k\u2081, \u22ef\u27e9) (hY : iter\u2081.F.obj \u27e8k\u2082, h\u2081\u27e9 = iter\u2082.F.obj \u27e8k\u2082, h\u2082\u27e9),\n    iter\u2081.F.map (homOfLE h) = eqToHom hX \u226b iter\u2082.F.map (homOfLE h) \u226b eqToHom \u22ef\n\u22a2 iter\u2081.F.map (homOfLE h) = eqToHom \u22ef \u226b iter\u2082.F.map (homOfLE h) \u226b eqToHom \u22ef",["tauto","aesop"]],["Topology/MetricSpace/Infsep.lean",124,"case inl.inl\n\u03b1 : Type u_1\ninst\u271d : EDist \u03b1\ny b : \u03b1\nhab : b \u2260 b\n\u22a2 edist b y \u2264 edist b b \u2228 edist y b \u2264 edist b b\n```\n---\n```lean\ncase inr.inr\n\u03b1 : Type u_1\ninst\u271d : EDist \u03b1\nx b : \u03b1\nhab : b \u2260 b\n\u22a2 edist x b \u2264 edist b b \u2228 edist b x \u2264 edist b b",["contradiction","aesop","tauto"]],["CategoryTheory/Shift/CommShift.lean",316,"C : Type u_1\nD : Type u_2\ninst\u271d\u2078 : Category.{u_7, u_1} C\ninst\u271d\u2077 : Category.{u_6, u_2} D\nF\u2081 F\u2082 : C \u2964 D\n\u03c4 : F\u2081 \u27f6 F\u2082\nA : Type u_5\ninst\u271d\u2076 : AddMonoid A\ninst\u271d\u2075 : HasShift C A\ninst\u271d\u2074 : HasShift D A\ninst\u271d\u00b3 : F\u2081.CommShift A\ninst\u271d\u00b2 : F\u2082.CommShift A\ninst\u271d\u00b9 : IsIso \u03c4\ninst\u271d : CommShift \u03c4 A\n\u22a2 CommShift (asIso \u03c4).hom A",["assumption","aesop","congr","tauto"]],["Data/Nat/Factorial/Basic.lean",81,"m : \u2115\n\u22a2 m ! * (m + 1) ^ 0 \u2264 (m + 0)!",["simp","aesop"]],["Data/Nat/Factorial/Basic.lean",155,"case inl.a.hi\ni n : \u2115\nh\u271d : 2 \u2264 i\n\u22a2 2 \u2264 i",["assumption","omega","aesop","congr","gcongr","tauto"]],["Data/Nat/Factorial/Basic.lean",274,"n : \u2115\na\u271d : 2 \u2264 1\n\u22a2 (n + 1) ^ 1 < (n + 1).ascFactorial 1",["contradiction","omega","aesop","tauto"]],["Data/Nat/Factorial/Basic.lean",286,"n : \u2115\na\u271d : 2 \u2264 1\n\u22a2 (n + 1).ascFactorial 1 < (n + 1) ^ 1",["contradiction","omega","aesop","tauto"]],["Data/Nat/Factorial/Basic.lean",421,"n : \u2115\na\u271d : 2 \u2264 1\n\u22a2 1 \u2264 n \u2192 (n + 1 - 1) ^ 1 < n.descFactorial 1",["contradiction","omega","aesop","tauto"]],["Data/Nat/Factorial/Basic.lean",434,"n : \u2115\nhn : 1 \u2264 n\na\u271d : 2 \u2264 1\n\u22a2 n.descFactorial 1 < n ^ 1",["contradiction","omega","aesop","tauto"]],["NumberTheory/LSeries/DirichletContinuation.lean",127,"M N : \u2115\ninst\u271d\u00b9 : NeZero M\ninst\u271d : NeZero N\nhMN : M \u2223 N\n\u03c7 : DirichletCharacter \u2102 M\ns : \u2102\nhs : s \u2260 1\nhpc : IsPreconnected {1}\u1d9c\n\u22a2 2 \u2208 {1}\u1d9c",["norm_num","aesop","simp"]],["NumberTheory/LSeries/DirichletContinuation.lean",241,"N : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\ns : \u2102\nhs\u2080 : s \u2260 0 \u2228 N \u2260 1\nhs\u2081 : s \u2260 1 \u2228 \u03c7 \u2260 1\nthis : N \u2260 1 \u2192 \u03c7 0 = 0\n\u22a2 s \u2260 0 \u2228 \u03c7 0 = 0",["tauto","aesop"]],["NumberTheory/LSeries/DirichletContinuation.lean",242,"N : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\ns : \u2102\nhs\u2080 : s \u2260 0 \u2228 N \u2260 1\nhs\u2081 : s \u2260 1 \u2228 \u03c7 \u2260 1\nthis : \u03c7 \u2260 1 \u2192 \u2211 a : ZMod N, \u03c7 a = 0\n\u22a2 s \u2260 1 \u2228 \u2211 j : ZMod N, \u03c7 j = 0",["tauto","aesop"]],["Analysis/SpecialFunctions/Trigonometric/Inverse.lean",277,"case neg\nx : \u211d\nhx\u2081 : \u00ac-1 \u2264 x\nh : \u221a(1 - x ^ 2) = 0\n\u22a2 sin (arcsin x) / 0 = x / 0",["simp","ring","aesop","norm_num"]],["RingTheory/DiscreteValuationRing/Basic.lean",121,"R : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nRDVR : IsDiscreteValuationRing R\ntoIsPrincipalIdealRing\u271d : IsPrincipalIdealRing R\ntoIsLocalRing\u271d : IsLocalRing R\nRlocal : maximalIdeal R \u2260 \u22a5\nhQ1 : Submodule.span R {0} \u2260 \u22a5\nhQ2 : IsPrime (Submodule.span R {0})\n\u22a2 Submodule.span R {0} = \u22a5",["simp","aesop","norm_num"]],["RingTheory/DiscreteValuationRing/Basic.lean",458,"case intro\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDiscreteValuationRing R\nu : R\u02e3\n\u03d6 : R\nh\u03d6 : Irreducible \u03d6\n\u22a2 \u21910 = 0\n```\n---\n```lean\ncase intro\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDiscreteValuationRing R\nu : R\u02e3\n\u03d6 : R\nh\u03d6 : Irreducible \u03d6\n\u22a2 \u2191u = \u2191u * \u03d6 ^ 0",["simp","ring","aesop","norm_num"]],["RingTheory/DiscreteValuationRing/Basic.lean",331,"case h.e_a.a\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDiscreteValuationRing R\nx : R\nhx : x \u2260 0\n\u03d6 : R\nhirr : Irreducible \u03d6\nthis : WfDvdMonoid R\nfx : Multiset R\nhfx : (\u2200 b \u2208 fx, Irreducible b) \u2227 Associated fx.prod x\nH : Associates.mk fx.prod = Associates.mk x\nx\u271d : R\na\u271d : x\u271d \u2208 fx\n\u22a2 x\u271d \u2208 fx",["assumption","aesop","congr","gcongr","tauto"]],["RingTheory/DiscreteValuationRing/Basic.lean",346,"R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDiscreteValuationRing R\ns : Ideal R\nhs : s \u2260 \u22a5\n\u03d6 : R\nhirr : Irreducible \u03d6\n\u22a2 \u00acs = \u22a5",["assumption","aesop","congr","tauto"]],["RingTheory/DiscreteValuationRing/Basic.lean",365,"case refine_1\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDiscreteValuationRing R\nq : R\nhq : Irreducible q\nu v : R\u02e3\nm n : \u2115\nx : R\nhp : Irreducible x\nh : \u2191u * x ^ m = \u2191v * q ^ n\nkey : Associated (Multiset.replicate m x).prod (Multiset.replicate n q).prod\nhx : x \u2208 Multiset.replicate m x\n\u22a2 Irreducible x\n```\n---\n```lean\ncase refine_2\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsDiscreteValuationRing R\np : R\nhp : Irreducible p\nu v : R\u02e3\nm n : \u2115\nx : R\nhq : Irreducible x\nh : \u2191u * p ^ m = \u2191v * x ^ n\nkey : Associated (Multiset.replicate m p).prod (Multiset.replicate n x).prod\nhx : x \u2208 Multiset.replicate n x\n\u22a2 Irreducible x",["assumption","aesop","congr","gcongr","tauto"]],["RingTheory/DiscreteValuationRing/Basic.lean",164,"R : Type u_1\ninst\u271d : CommRing R\n\u03d6 : R\nh\u03d6 : Irreducible \u03d6\nhR : \u2200 {x : R}, x \u2260 0 \u2192 \u2203 n, Associated (\u03d6 ^ n) x\np : R\nhp : Irreducible p\n\u22a2 \u2200 n < 1, n = 0",["decide","omega","aesop","norm_num","simp"]],["Topology/Category/TopCat/Limits/Pullbacks.lean",124,"X Y Z : TopCat\nf : X \u27f6 Z\ng : Y \u27f6 Z\nhomeo : \u2191(pullback f g) \u2243\u209c \u2191(of { p // (ConcreteCategory.hom f) p.1 = (ConcreteCategory.hom g) p.2 }) :=\n  homeoOfIso (pullbackIsoProdSubtype f g)\n\u22a2 induced ((Prod.fst \u2218 Subtype.val) \u2218 \u21d1homeo) X.str \u2293 induced ((Prod.snd \u2218 Subtype.val) \u2218 \u21d1homeo) Y.str =\n    induced (\u21d1(ConcreteCategory.hom (pullback.fst f g))) X.str \u2293\n      induced (\u21d1(ConcreteCategory.hom (pullback.snd f g))) Y.str",["congr","aesop","tauto"]],["NumberTheory/FermatPsp.lean",93,"case neg\nn b : \u2115\nh : n.ProbablePrime b\nh\u2081 : 1 \u2264 n\nh\u2082 : 1 \u2264 b\nh\u2083 : \u00ac2 \u2264 n\n\u22a2 Coprime 1 b",["norm_num","aesop","simp"]],["RingTheory/Filtration.lean",194,"case h.succ.a\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\nn\u2080 : \u2115\nhn : \u2200 n \u2265 n\u2080, I \u2022 F.N n = F.N (n + 1)\nn\u271d : \u2115\nih : F.N (n\u2080 + n\u271d) = I ^ n\u271d \u2022 F.N n\u2080\n\u22a2 n\u2080 + n\u271d \u2265 n\u2080",["omega","aesop","linarith","norm_num","simp"]],["Data/Set/Insert.lean",312,"\u03b1 : Type u\na b : \u03b1\n\u22a2 Disjoint {a} {b} \u2194 a \u2260 b",["simp","aesop"]],["Data/Set/Insert.lean",92,"\u03b1 : Type u\ns t : Set \u03b1\n\u22a2 (s \u2286 t \u2227 \u2203 a \u2208 t, a \u2209 s) \u2194 \u2203 a \u2209 s, a \u2208 t \u2227 s \u2286 t",["aesop","tauto"]],["Data/Set/Insert.lean",315,"\u03b1 : Type u\ns t : Set \u03b1\n\u22a2 (\u2203 a \u2209 s, a \u2208 t \u2227 s \u2286 t) \u2194 \u2203 a \u2208 t, s \u2286 t \u2227 a \u2209 s",["aesop","tauto"]],["Data/Set/Insert.lean",450,"\u03b1 : Type u\nx y z w : \u03b1\n\u22a2 ((x = z \u2228 x = w) \u2227 (y = z \u2228 y = w)) \u2227 (z = x \u2228 z = y) \u2227 (w = x \u2228 w = y) \u2194 x = z \u2227 y = w \u2228 x = w \u2227 y = z",["aesop","tauto"]],["Data/Set/Insert.lean",472,"\u03b1 : Type u\ns : Set \u03b1\nx y : \u03b1\nh : x \u2208 s \u2192 {y} = s \\ {x} \u2192 s = {x, y}\n\u22a2 (s = \u2205 \u2228 s = {y}) \u2228 x \u2208 s \u2227 ((s = \u2205 \u2228 s = {x}) \u2228 s \\ {x} = {y}) \u2192 s = \u2205 \u2228 s = {x} \u2228 s = {y} \u2228 s = {x, y}",["tauto"]],["Topology/DenseEmbedding.lean",197,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ni : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : T3Space \u03b3\nb : \u03b2\nf : \u03b1 \u2192 \u03b3\ndi : IsDenseInducing i\nhf : \u2200\u1da0 (x : \u03b2) in \ud835\udcdd b, \u2203 c, Tendsto f (comap i (\ud835\udcdd x)) (\ud835\udcdd c)\n\u03c6 : \u03b2 \u2192 \u03b3 := di.extend f\nthis : \u2200 (b : \u03b2), (comap i (\ud835\udcdd b)).NeBot\nV' : Set \u03b3\nV'_in : V' \u2208 \ud835\udcdd (\u03c6 b)\nV'_closed : IsClosed V'\nV\u2081 : Set \u03b2 := {x | Tendsto f (comap i (\ud835\udcdd x)) (\ud835\udcdd (\u03c6 x))}\nV\u2081_in : V\u2081 \u2208 \ud835\udcdd b\nV\u2082 : Set \u03b2\nV\u2082_in : V\u2082 \u2208 \ud835\udcdd b\nV\u2082_op : IsOpen V\u2082\nhV\u2082 : \u2200 x \u2208 i \u207b\u00b9' V\u2082, f x \u2208 V'\nx : \u03b2\nx_in\u2081 : x \u2208 V\u2081\nx_in\u2082 : x \u2208 V\u2082\nhV\u2082x : V\u2082 \u2208 \ud835\udcdd x\n\u22a2 V\u2082 \u2208 \ud835\udcdd x \u2227 i \u207b\u00b9' V\u2082 \u2286 {x | (fun x \u21a6 f x \u2208 V') x}",["tauto","aesop"]],["LinearAlgebra/Matrix/SpecialLinearGroup.lean",278,"n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\ni : n\na inv\u271d : R\nval_inv\u271d : a * inv\u271d = 1\ninv_val\u271d : inv\u271d * a = 1\nha : { val := a, inv := inv\u271d, val_inv := val_inv\u271d, inv_val := inv_val\u271d } \u2208 rootsOfUnity (Fintype.card n) R\n\u22a2 \u2191\u2191((fun A \u21a6 rootsOfUnity.mkOfPowEq (\u2191\u2191A i i) \u22ef)\n          ((fun a \u21a6 \u27e8\u27e8a \u2022 1, \u22ef\u27e9, \u22ef\u27e9) \u27e8{ val := a, inv := inv\u271d, val_inv := val_inv\u271d, inv_val := inv_val\u271d }, ha\u27e9)) =\n    \u2191\u2191\u27e8{ val := a, inv := inv\u271d, val_inv := val_inv\u271d, inv_val := inv_val\u271d }, ha\u27e9",["simp","aesop","norm_num"]],["LinearAlgebra/Matrix/SpecialLinearGroup.lean",168,"n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Nontrivial R\ng : SpecialLinearGroup n R\n\u22a2 1 \u2260 0",["norm_num","aesop","simp"]],["Probability/Kernel/Condexp.lean",111,"case inr.e_\u03ba.h.h\n\u03a9 : Type u_1\nm m\u03a9 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : StandardBorelSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsFiniteMeasure \u03bc\nhm : m \u2264 m\u03a9\nh\u271d : Nonempty \u03a9\nthis : m \u2293 m\u03a9 = m\nh : Measure.map id \u03bc \u2297\u2098 condDistrib id id \u03bc = Measure.map (fun a \u21a6 (id a, id a)) \u03bc\na : \u03a9\ns : Set \u03a9\nhs : MeasurableSet s\n\u22a2 ((condDistrib id id \u03bc) a) s = ((condDistrib id id \u03bc) a) s",["congr"]],["NumberTheory/Multiplicity.lean",345,"case h.e'_3\nx y : \u2124\nn : \u2115\nhx : Odd x\nhn : Even n\nhxy : Even (-(x - y))\n\u22a2 y = -(x - y) + x",["abel","ring","omega","aesop","linarith","norm_num","simp"]],["NumberTheory/Multiplicity.lean",300,"case refine_2.zero\nx y : \u2124\nhx : \u00ac2 \u2223 x\nhxy : 4 \u2223 x - y\nhx_odd : Odd x\nhxy_even : Even (x - y)\nhy_odd : Odd y\nhxy' : 2 ^ (1 + 1) \u2223 x ^ 2 ^ 0 + y ^ 2 ^ 0\nthis\u271d : 2 * 2 \u2223 2 * x\nthis : 2 \u2223 x\n\u22a2 False",["contradiction","omega","aesop","tauto"]],["NumberTheory/Multiplicity.lean",282,"case intro\nw\u271d : \u2124\n\u22a2 1 % 4 = 1",["decide","ring","omega","aesop","congr","tauto","abel","norm_num","simp"]],["NumberTheory/Multiplicity.lean",304,"x y : \u2124\nhx : \u00ac2 \u2223 x\nhxy : 4 \u2223 x - y\nhx_odd : Odd x\nhxy_even : Even (x - y)\nhy_odd : Odd y\ni : \u2115\nthis : \u2200 (x : \u2124), Odd x \u2192 x ^ 2 ^ (i + 1) % 4 = 1\n\u22a2 \u00ac(1 + 1) % 4 = 0",["decide"]],["NumberTheory/Multiplicity.lean",360,"case intro\nx y : \u2124\nhxy : 2 \u2223 x - y\nhx : \u00ac2 \u2223 x\nhy : Odd y\nd : \u2115\nhxy4 : 4 \u2223 x ^ 2 - y ^ 2\n\u22a2 2 \u2260 1 \u2227 0 < 2",["decide"]],["Probability/Moments/SubGaussian.lean",172,"case h.e'_3.h.e'_4.h\n\u03a9 : Type u_1\n\u03a9' : Type u_2\nm\u03a9 : MeasurableSpace \u03a9\nm\u03a9' : MeasurableSpace \u03a9'\n\u03bd : Measure \u03a9'\n\u03ba : Kernel \u03a9' \u03a9\nX : \u03a9 \u2192 \u211d\nc : \u211d\u22650\nh : HasSubgaussianMGF X c \u03ba \u03bd\nt : \u211d\np : \u211d\u22650\nhp0 : \u00acp = 0\nh' : \u222b\u207b (a : \u03a9), \u2016rexp (\u2191p * t * X a)\u2016\u2091 \u2202\u21d1\u03ba \u2218\u2098 \u03bd < \u22a4\n\u03c9 : \u03a9\n\u22a2 0 \u2264 \u2191p",["positivity","aesop","norm_num","simp"]],["Analysis/SpecialFunctions/Pow/Asymptotics.lean",114,"case h.e'_3.h.h.e'_6.h.e'_6\nx\u271d : \u211d\n\u22a2 x\u271d = 1 * x\u271d + 0",["ring","aesop","linarith","norm_num","simp"]],["Analysis/SpecialFunctions/Pow/Asymptotics.lean",119,"case h.e'_3.h.h.e'_6.h.e'_6\nx\u271d : \u211d\n\u22a2 x\u271d = 1 * x\u271d + 0",["ring","aesop","linarith","norm_num","simp"]],["Analysis/SpecialFunctions/Pow/Asymptotics.lean",78,"b : \u211d\nhb : 1 < b\n\u22a2 1 < b",["aesop","congr","linarith","gcongr","tauto","assumption"]],["Analysis/SpecialFunctions/Pow/Asymptotics.lean",90,"b : \u211d\nhb : 1 < b\n\u22a2 1 < b",["aesop","congr","linarith","gcongr","tauto","assumption"]],["RingTheory/Derivation/Basic.lean",314,"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : CommSemiring A\ninst\u271d\u2079 : CommSemiring B\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Algebra R B\ninst\u271d\u2075 : Module A M\ninst\u271d\u2074 : Module B M\ninst\u271d\u00b3 : Module R M\nD D1 D2 : Derivation R A M\nr : R\na b : A\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : IsScalarTower R A B\ninst\u271d : IsScalarTower A B M\nd : Derivation R B M\n\u22a2 (\u2191d \u2218\u2097 (IsScalarTower.toAlgHom R A B).toLinearMap) 1 = 0",["simp","aesop","norm_num"]],["GroupTheory/SpecificGroups/Alternating.lean",57,"\u22a2 -1 \u2260 1",["decide","aesop","tauto","norm_num","simp"]],["GroupTheory/SpecificGroups/Alternating.lean",88,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List (Perm \u03b1)\nhl : \u2200 g \u2208 l, g.IsSwap\n\u22a2 -1 \u2260 1",["decide","aesop","tauto","norm_num","simp"]],["GroupTheory/SpecificGroups/Alternating.lean",252,"\u22a2 (Fin.cycleRange 2 * finRotate 5 * (Fin.cycleRange 2)\u207b\u00b9 * (finRotate 5)\u207b\u00b9).support.card = 3",["decide","aesop","congr","tauto"]],["GroupTheory/SpecificGroups/Alternating.lean",278,"g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\n\u22a2 \u2191g1 * \u2191g2 * (\u2191g1)\u207b\u00b9 * (\u2191g2)\u207b\u00b9 = finRotate 5",["decide"]],["GroupTheory/SpecificGroups/Alternating.lean",305,"g : Perm (Fin 5)\nh1 : g \u2260 1\nh_1 : g.cycleType.card = 2\nh2 : g.cycleType = Multiset.replicate 2 2\nh\u271d : 2 * 2 \u2264 card (Fin 5)\nh : 2 \u2264 3\nha : Even 2\n\u22a2 0 \u2260 4",["decide","omega","aesop","tauto","simp"]],["GroupTheory/SpecificGroups/Alternating.lean",306,"g : Perm (Fin 5)\nh1 : g \u2260 1\nh_1 : g.cycleType.card = 2\nh2 : g.cycleType = Multiset.replicate 2 2\nh\u271d : 2 * 2 \u2264 card (Fin 5)\nh : 2 \u2264 3\nha : Even 2\nh04 : 0 \u2260 4\n\u22a2 1 \u2260 3",["decide"]],["GroupTheory/SpecificGroups/Alternating.lean",311,"case \u00ab2\u00bb\ng : Perm (Fin 5)\nh1 : g \u2260 1\nh_1 : g.cycleType.card = 2\nh2 : g.cycleType = Multiset.replicate 2 2\nh\u271d : 2 * 2 \u2264 card (Fin 5)\nh : 2 \u2264 3\nha : Even 2\nh04 : 0 \u2260 4\nh13 : 1 \u2260 3\n\u22a2 _root_.Disjoint {0, 4} {1, 3}",["decide"]],["GroupTheory/SpecificGroups/Alternating.lean",358,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nH : Subgroup \u21a5(alternatingGroup (Fin 5))\nHn : H.Normal\ng : Perm (Fin 5)\ngA : g \u2208 alternatingGroup (Fin 5)\ngH : {\u27e8g, gA\u27e9} \u2286 \u2191H\ng1 : \u27e8g, gA\u27e9 \u2260 1\nn : \u2115\nng : 4 \u2208 g.cycleType\nn2 : 4 \u2260 2\nn2' : 2 < 4\nn5 : 4 \u2264 5\ncon : (-1) ^ ({4}.sum + {4}.card) = 1\n\u22a2 Odd 5",["decide","tauto","contradiction"]],["RingTheory/Ideal/Norm/AbsNorm.lean",360,"case inr.refine_2\nS : Type u_1\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Nontrivial S\ninst\u271d\u00b3 : IsDedekindDomain S\ninst\u271d\u00b2 : Module.Free \u2124 S\ninst\u271d\u00b9 : Module.Finite \u2124 S\ninst\u271d : CharZero S\nn : \u2115\nhn : n > 0\nf : Ideal S \u2192 Ideal (S \u29f8 span {\u2191n}) := fun I \u21a6 map (Quotient.mk (span {\u2191n})) I\nI : Ideal S\nhI : I \u2208 {I | absNorm I = n}\nJ : Ideal S\nhJ : J \u2208 {I | absNorm I = n}\nh : f I = f J\n\u22a2 comap (Quotient.mk (span {\u2191n})) (map (Quotient.mk (span {\u2191n})) I) =\n    comap (Quotient.mk (span {\u2191n})) (map (Quotient.mk (span {\u2191n})) J)",["congr","aesop","tauto"]],["RingTheory/Ideal/Norm/AbsNorm.lean",280,"case pos\nS : Type u_1\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Nontrivial S\ninst\u271d\u2074 : IsDedekindDomain S\ninst\u271d\u00b3 : Module.Free \u2124 S\ninst\u271d\u00b2 : Module.Finite \u2124 S\nE : Type u_2\ne : E\ninst\u271d\u00b9 : EquivLike E S \u21a5\u22a5\ninst\u271d : AddEquivClass E S \u21a5\u22a5\nthis\u271d : 1 \u2260 0\nthis : 1 = 0\n\u22a2 (LinearMap.det (\u2191\u2124 (Submodule.subtype \u22a5) \u2218\u2097 (\u2191e).toIntLinearMap)).natAbs = absNorm \u22a5",["contradiction","aesop","tauto"]],["RingTheory/Ideal/Norm/AbsNorm.lean",383,"S : Type u_1\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Nontrivial S\ninst\u271d\u00b3 : IsDedekindDomain S\ninst\u271d\u00b2 : Module.Free \u2124 S\ninst\u271d\u00b9 : Module.Finite \u2124 S\nn : \u2115\ninst\u271d : CharZero S\nthis\u271d : Finite { I // I \u2208 (Ideal S)\u2070 \u2227 absNorm I \u2264 n }\nthis : Finite { I // I \u2209 (Ideal S)\u2070 \u2227 absNorm I \u2264 n }\nI : Ideal S\n\u22a2 \u00ac((I \u2208 (Ideal S)\u2070 \u2227 absNorm I \u2264 n) \u2227 I \u2209 (Ideal S)\u2070 \u2227 absNorm I \u2264 n)",["tauto","aesop"]],["Analysis/Convex/Jensen.lean",114,"\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b2 : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u2075 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Module \ud835\udd5c \u03b2\ninst\u271d : OrderedSMul \ud835\udd5c \u03b2\ns : Set E\nf : E \u2192 \u03b2\nw : \u03b9 \u2192 \ud835\udd5c\np : \u03b9 \u2192 E\nhf : StrictConvexOn \ud835\udd5c s f\nj k : \u03b9\nhjk : p j \u2260 p k\nu : Finset \u03b9\nhj\u271d : j \u2209 u\nhk\u271d : k \u2209 u\nh\u2080 : \u2200 i \u2208 cons j (cons k u hk\u271d) \u22ef, 0 < w i\nh\u2081 : \u2211 i \u2208 cons j (cons k u hk\u271d) \u22ef, w i = 1\nhmem : \u2200 i \u2208 cons j (cons k u hk\u271d) \u22ef, p i \u2208 s\nhj : j \u2208 cons j (cons k u hk\u271d) \u22ef\nhk : k \u2208 cons j (cons k u hk\u271d) \u22ef\nthis\u271d : k \u2208 (cons j (cons k u hk\u271d) \u22ef).erase j\nthis : 0 < w j\n\u22a2 k \u2208 cons j (cons k u hk\u271d) \u22ef",["simp","aesop","congr","gcongr","tauto","assumption","norm_num"]],["RingTheory/Polynomial/Content.lean",437,"case neg\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\nthis : DecidableEq R := Classical.decEq R\np q r : R[X]\nrprim : r.IsPrimitive\nhr : \u2200 (s : R[X]), p.primPart \u2223 s \u2227 q.primPart \u2223 s \u2194 r \u2223 s\ns : R[X]\nhs : \u00acs = 0\nhpq : \u00acC (lcm p.content q.content) = 0\n\u22a2 (p.content \u2223 s.content \u2227 p.primPart \u2223 s.primPart) \u2227 q.content \u2223 s.content \u2227 q.primPart \u2223 s.primPart \u2194\n    (p.content \u2223 s.content \u2227 q.content \u2223 s.content) \u2227 p.primPart \u2223 s.primPart \u2227 q.primPart \u2223 s.primPart",["tauto"]],["Topology/Category/Compactum.lean",478,"\u22a2 CreatesLimits (profiniteToCompHaus \u22d9 forget CompHaus)",["infer_instance","omega","tauto"]],["Topology/Category/Compactum.lean",164,"case mp\nX : Compactum\nS : Set X.A\nF : Ultrafilter X.A\nh : S \u2208 F\nc : X.str F \u2209 S\ncond : S \u2209 F\n\u22a2 False",["contradiction","aesop","tauto"]],["Topology/Category/Compactum.lean",280,"X : Compactum\nF : Ultrafilter X.A\nx : X.A\nfsu : Type u_1 := Finset (Set (Ultrafilter X.A))\nssu : Type u_1 := Set (Set (Ultrafilter X.A))\n\u03b9 : fsu \u2192 ssu := fun x \u21a6 \u2191x\nT0 : ssu := {S | \u2203 A \u2208 F, S = Compactum.basic A}\nAA : Set (Ultrafilter X.A) := X.str \u207b\u00b9' {x}\nT1 : ssu := insert AA T0\nT2 : Set (Set (Ultrafilter X.A)) := finiteInterClosure T1\nA : Set X.A\nhA : IsClosed A\nh : A \u2208 F\nH : x \u2209 A\ncond : A \u2209 F\n\u22a2 False",["contradiction","aesop","tauto"]],["Topology/Category/Compactum.lean",345,"X : Compactum\nF : Ultrafilter X.A\n\u22a2 \u2200 (s : Set X.A), X.str F \u2208 s \u2192 IsOpen s \u2192 s \u2208 \u2191F",["tauto","aesop"]],["Order/Ideal.lean",100,"case mk.mk\nP : Type u_1\ninst\u271d : LE P\ntoLowerSet\u271d\u00b9 : LowerSet P\nnonempty'\u271d\u00b9 : toLowerSet\u271d\u00b9.carrier.Nonempty\ndirected'\u271d\u00b9 : DirectedOn (fun x1 x2 \u21a6 x1 \u2264 x2) toLowerSet\u271d\u00b9.carrier\ntoLowerSet\u271d : LowerSet P\nnonempty'\u271d : toLowerSet\u271d.carrier.Nonempty\ndirected'\u271d : DirectedOn (fun x1 x2 \u21a6 x1 \u2264 x2) toLowerSet\u271d.carrier\nx\u271d :\n  { toLowerSet := toLowerSet\u271d\u00b9, nonempty' := nonempty'\u271d\u00b9, directed' := directed'\u271d\u00b9 }.toLowerSet =\n    { toLowerSet := toLowerSet\u271d, nonempty' := nonempty'\u271d, directed' := directed'\u271d }.toLowerSet\n\u22a2 { toLowerSet := toLowerSet\u271d\u00b9, nonempty' := nonempty'\u271d\u00b9, directed' := directed'\u271d\u00b9 } =\n    { toLowerSet := toLowerSet\u271d, nonempty' := nonempty'\u271d, directed' := directed'\u271d }",["congr","aesop"]],["Order/Ideal.lean",452,"P : Type u_1\ninst\u271d : BooleanAlgebra P\nx : P\nI : Ideal P\nhI : I.IsProper\nh : x\u1d9c \u2208 I \u2192 x \u2209 I\n\u22a2 x \u2209 I \u2228 x\u1d9c \u2209 I",["tauto"]],["Probability/Distributions/Gaussian.lean",154,"\u03bc : \u211d\nv : \u211d\u22650\nc : \u211d\nhc : c \u2260 0\nx : \u211d\n\u22a2 |c\u207b\u00b9| * gaussianPDFReal (c\u207b\u00b9 * \u03bc) (\u27e8c\u207b\u00b9 ^ 2, \u22ef\u27e9 * v) x = |c\u207b\u00b9| * gaussianPDFReal (c\u207b\u00b9 * \u03bc) (\u27e8(c ^ 2)\u207b\u00b9, \u22ef\u27e9 * v) x",["simp","ring","aesop","norm_num"]],["Algebra/Homology/TotalComplexShift.lean",88,"case mk.mk.a.fst\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK L : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\nf : K \u27f6 L\nx y : \u2124\ninst\u271d : K.HasTotal (up \u2124)\nn a b : \u2124\nh : (a, b) \u2208 (up \u2124).\u03c0 (up \u2124) (up \u2124) \u207b\u00b9' {n}\n\u22a2 a + x - x = a",["omega","ring","aesop","linarith","abel","norm_num","simp","fun_prop"]],["Algebra/Group/Pi/Lemmas.lean",315,"case refine_1.inr.inl.inr\nI : Type u\ninst\u271d\u00b9 : DecidableEq I\nM : Type u_3\ninst\u271d : CommMonoid M\nk l m : I\nu v : M\nhu : u \u2260 1\nhv : v \u2260 1\nhkm : k \u2260 m\nh : mulSingle k u * mulSingle l v = mulSingle m u * mulSingle m v\nhl : ((if l = k then u else 1) * if True then v else 1) = (if l = m then u else 1) * if l = m then v else 1\nhm : ((if True then u else 1) * if m = m then v else 1) = (if m = k then u else 1) * if m = l then v else 1\nhn : ((if m = m then u else 1) * if True then v else 1) = (if m = k then u else 1) * if m = l then v else 1\nhkl : k \u2260 l\nhk : u = 1\n\u22a2 k = m \u2227 l = m \u2228 u = v \u2227 k = m \u2227 l = m \u2228 u * v = 1 \u2227 k = l \u2227 m = m",["contradiction","aesop","tauto"]],["Data/Real/Archimedean.lean",170,"\u22a2 \u00ac(\u2205.Nonempty \u2227 BddAbove \u2205)",["simp","aesop","norm_num"]],["Data/Real/Archimedean.lean",176,"case h.e'_2.h.e'_3\n\u03b9 : Sort u_1\ninst\u271d : IsEmpty \u03b9\nf : \u03b9 \u2192 \u211d\n\u22a2 IsEmpty \u03b9",["infer_instance","aesop","congr","tauto","assumption"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",170,"case h\nb : \u2102\nhb : 0 < b.re\nc : \u211d\nI\u2081 : \u211d \u2192 \u2102 := fun T \u21a6 \u222b (x : \u211d) in -T..T, cexp (-b * (\u2191x + \u2191c * I) ^ 2)\nHI\u2081 : I\u2081 = fun T \u21a6 \u222b (x : \u211d) in -T..T, cexp (-b * (\u2191x + \u2191c * I) ^ 2)\nI\u2082 : \u211d \u2192 \u2102 := fun T \u21a6 \u222b (x : \u211d) in -T..T, cexp (-b * \u2191x ^ 2)\nI\u2084 : \u211d \u2192 \u2102 := fun T \u21a6 \u222b (y : \u211d) in 0 ..c, cexp (-b * (\u2191T + \u2191y * I) ^ 2)\nI\u2085 : \u211d \u2192 \u2102 := fun T \u21a6 \u222b (y : \u211d) in 0 ..c, cexp (-b * (-\u2191T + \u2191y * I) ^ 2)\nT : \u211d\nC : I\u2082 T - I\u2081 T + I * I\u2084 T = I * I\u2085 T\n\u22a2 I\u2081 T = I\u2082 T + (I * I\u2084 T - (I\u2082 T - I\u2081 T + I * I\u2084 T))",["abel","ring","norm_num","simp"]],["Tactic/NormNum/LegendreSymbol.lean",132,"case h\na b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 1\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 2 \u2223 8",["norm_num","omega","decide","aesop","simp"]],["Tactic/NormNum/LegendreSymbol.lean",138,"case h\na b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 7\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 2 \u2223 8",["norm_num","omega","decide","aesop","simp"]],["Tactic/NormNum/LegendreSymbol.lean",144,"case h\na b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 3\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 2 \u2223 8",["norm_num","omega","decide","aesop","simp"]],["Tactic/NormNum/LegendreSymbol.lean",150,"case h\na b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 5\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 2 \u2223 8",["norm_num","omega","decide","aesop","simp"]],["Tactic/NormNum/LegendreSymbol.lean",73,"b : \u2115\nhb : (b / 2).beq 0 = false\n\u22a2 1 < 2 * 1",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["Tactic/NormNum/LegendreSymbol.lean",111,"a b c : \u2115\nr : \u2124\nha : a % 2 = 1\nhb : b % 2 = 0\nhc : b / 2 = c\nhr : jacobiSymNat a c = r\n\u22a2 legendreSym 2 \u21911 = 1",["decide","aesop","congr","tauto","abel","norm_num","simp"]],["Algebra/Homology/Embedding/ExtendHomology.lean",282,"\u03b9 : Type u_1\n\u03b9' : Type u_2\nc : ComplexShape \u03b9\nc' : ComplexShape \u03b9'\nC : Type u_3\ninst\u271d\u00b3 : Category.{u_4, u_3} C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasZeroObject C\nK L M : HomologicalComplex C c\n\u03c6 : K \u27f6 L\n\u03c6' : L \u27f6 M\ne : c.Embedding c'\ninst\u271d : \u2200 (j : \u03b9), K.HasHomology j\nj' : \u03b9'\nh : \u00ac\u2203 j, e.f j = j'\n\u22a2 \u2200 (i : \u03b9), e.f i \u2260 j'",["tauto"]],["Data/Multiset/Filter.lean",314,"case neg.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Injective f\nx : \u03b1\nH : x \u2209 s\nk : \u03b1\nhks : x \u2208 s\nhkx : f k = f x\n\u22a2 False",["contradiction","aesop","tauto"]],["CategoryTheory/GlueData.lean",87,"C : Type u\u2081\ninst\u271d : Category.{v, u\u2081} C\nD : GlueData C\ni j : D.J\n\u22a2 D.t' i j i = (D.t' i j i \u226b pullback.snd (D.f j i) (D.f j i)) \u226b inv (pullback.snd (D.f j i) (D.f j i))",["simp","aesop"]],["NumberTheory/Bernoulli.lean",174,"n : \u2115\nh_odd : Odd n\nhlt : 1 < n\nB : \u211a\u27e6X\u27e7 := PowerSeries.mk fun n \u21a6 bernoulli' n / \u2191n !\nh : B * (exp \u211a - 1) = X * exp \u211a\n\u22a2 evalNegHom (B * (exp \u211a - 1)) * exp \u211a = evalNegHom (X * exp \u211a) * exp \u211a",["congr","aesop","tauto"]],["NumberTheory/Bernoulli.lean",322,"case refine_1.h\nn p : \u2115\nhne : \u2200 (m : \u2115), \u2191m ! \u2260 0\nh_cauchy :\n  ((PowerSeries.mk fun p \u21a6 bernoulli p / \u2191p !) * PowerSeries.mk fun q \u21a6 (coeff \u211a (q + 1)) (exp \u211a ^ n)) =\n    PowerSeries.mk fun p \u21a6 \u2211 i \u2208 range (p + 1), bernoulli i * \u2191((p + 1).choose i) * \u2191n ^ (p + 1 - i) / \u2191(p + 1)!\nhexp : exp \u211a - 1 \u2260 0\nh_r : exp \u211a ^ n - 1 = X * PowerSeries.mk fun p \u21a6 (coeff \u211a (p + 1)) (exp \u211a ^ n)\n\u22a2 (PowerSeries.mk fun n \u21a6 (algebraMap \u211a \u211a) (bernoulli n / \u2191n !)) = PowerSeries.mk fun p \u21a6 bernoulli p / \u2191p !",["congr","aesop","tauto","abel","norm_num","simp"]],["NumberTheory/Bernoulli.lean",95,"\u22a2 1 - \u2211 k \u2208 range 0, \u2191(Nat.choose 0 k) / (\u21910 - \u2191k + 1) * bernoulli' k = 1",["norm_num","aesop","simp"]],["NumberTheory/Bernoulli.lean",114,"\u22a2 Nat.choose 4 2 = 6",["decide","aesop","congr","tauto","abel"]],["Computability/Halting.lean",213,"case neg\nC : Set (\u2115 \u2192. \u2115)\nf g : \u2115 \u2192. \u2115\nhf : Nat.Partrec f\nhg : Nat.Partrec g\nfC : f \u2208 C\nw\u271d : DecidablePred fun c \u21a6 c.eval \u2208 C\nh : Computable fun a \u21a6 decide ((fun c \u21a6 c.eval \u2208 C) a)\nc : Code\nH : (fun b \u21a6 f b) \u2209 C\ne : c.eval = fun b \u21a6 f b\n\u22a2 g \u2208 C",["contradiction","aesop","tauto"]],["Data/Nat/Choose/Basic.lean",109,"x\u271d : \u2115\nhk : x\u271d \u2264 0\n\u22a2 0 < choose 0 0",["decide","aesop","tauto","simp"]],["Data/Nat/Choose/Basic.lean",117,"\u22a2 succ 0 * choose 0 0 = (succ 0).choose (succ 0) * succ 0",["decide","aesop","congr","tauto","simp"]],["GroupTheory/PGroup.lean",169,"p : \u2115\nG : Type u_1\ninst\u271d\u00b2 : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_2\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : Finite \u03b1\nthis\u271d : Fintype \u03b1\nthis : Fintype \u2191(fixedPoints G \u03b1)\nx : \u03b1\n\u22a2 card { y // (orbitRel G \u03b1) y x } = card \u2191(orbit G x)",["congr","tauto","abel"]],["FieldTheory/PolynomialGaloisGroup.lean",240,"F : Type u_1\ninst\u271d\u00b9 : Field F\np q : F[X]\ninst\u271d : Decidable (q = 0)\nhpq : p \u2223 q\n\u22a2 (if hq : q = 0 then 1 else restrict p q.SplittingField) = if hq : q = 0 then 1 else restrict p q.SplittingField",["congr","aesop"]],["Order/Sublattice.lean",388,"\u03ba : Type u_5\n\u03c0 : \u03ba \u2192 Type u_6\ninst\u271d : (i : \u03ba) \u2192 Lattice (\u03c0 i)\nL : (i : \u03ba) \u2192 Sublattice (\u03c0 i)\n\u22a2 \u2191(pi univ L) = \u2191\u22a5 \u2194 \u2203 i, \u2191(L i) = \u2191\u22a5",["simp","omega","aesop","tauto","infer_instance"]],["Order/Sublattice.lean",181,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d : Lattice \u03b1\na : \u03b1\nf : \u03b9 \u2192 Sublattice \u03b1\n\u22a2 a \u2208 \u2191(\u2a05 i, f i) \u2194 \u2200 (i : \u03b9), a \u2208 f i",["simp","aesop"]],["Order/Sublattice.lean",40,"case mk\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : Lattice \u03b2\ninst\u271d : Lattice \u03b3\nL M\u271d : Sublattice \u03b1\nf : LatticeHom \u03b1 \u03b2\ns t : Set \u03b1\na b : \u03b1\nM : Sublattice \u03b1\ncarrier\u271d : Set \u03b1\nsupClosed'\u271d : SupClosed carrier\u271d\ninfClosed'\u271d : InfClosed carrier\u271d\nh :\n  (fun L \u21a6 L.carrier) { carrier := carrier\u271d, supClosed' := supClosed'\u271d, infClosed' := infClosed'\u271d } =\n    (fun L \u21a6 L.carrier) M\n\u22a2 { carrier := carrier\u271d, supClosed' := supClosed'\u271d, infClosed' := infClosed'\u271d } = M",["congr","aesop"]],["Order/Sublattice.lean",385,"\u03ba : Type u_5\n\u03c0 : \u03ba \u2192 Type u_6\ninst\u271d : (i : \u03ba) \u2192 Lattice (\u03c0 i)\ns : Set \u03ba\nL : (i : \u03ba) \u2192 Sublattice (\u03c0 i)\nM : Sublattice ((i : \u03ba) \u2192 \u03c0 i)\n\u22a2 (\u2200 \u2983x : (i : \u03ba) \u2192 \u03c0 i\u2984, x \u2208 M \u2192 \u2200 i \u2208 s, x i \u2208 L i) \u2194 \u2200 i \u2208 s, \u2200 \u2983x : (i : \u03ba) \u2192 \u03c0 i\u2984, x \u2208 M \u2192 x i \u2208 L i",["aesop","omega","tauto","infer_instance"]],["CategoryTheory/Sites/Coverage.lean",280,"case a.a.of.a\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nK : Coverage C\nJ : GrothendieckTopology C\nhJ : J \u2208 {J | K \u2264 ofGrothendieck C J}\nX\u271d : C\nS\u271d : Sieve X\u271d\nX : C\nS : Presieve X\nhS : S \u2208 K.covering X\n\u22a2 S \u2208 K.covering X",["assumption","aesop","congr","gcongr","tauto"]],["CategoryTheory/Sites/Coverage.lean",345,"case mpr.of.intro.intro.hS.a\nC : Type u_2\ninst\u271d : Category.{u_3, u_2} C\nK : Coverage C\nP : C\u1d52\u1d56 \u2964 Type u_1\nH : \u2200 {X : C}, \u2200 R \u2208 K.covering X, IsSheafFor P R\nX\u271d : C\nS\u271d : Sieve X\u271d\nX : C\nS : Presieve X\nhS : S \u2208 K.covering X\nY : C\nf : Y \u27f6 X\nT : Presieve Y\nhT1 : T \u2208 K.covering Y\nhT2 : T.FactorsThruAlong S f\n\u22a2 T \u2208 K.covering Y",["assumption","aesop","congr","gcongr","tauto"]],["CategoryTheory/Sites/Coverage.lean",421,"C : Type u_1\nD : Type u_4\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Category.{u_3, u_4} D\nK : Coverage C\nP : C\u1d52\u1d56 \u2964 D\n\u22a2 (\u2200 (E : D) {X : C}, \u2200 R \u2208 K.covering X, Presieve.IsSheafFor (P \u22d9 coyoneda.obj (Opposite.op E)) R) \u2194\n    \u2200 \u2983X : C\u2984, \u2200 R \u2208 K.covering X, \u2200 (E : D\u1d52\u1d56), Presieve.IsSheafFor (P \u22d9 coyoneda.obj E) R",["aesop","tauto"]],["Algebra/Group/Indicator.lean",58,"\u03b1 : Type u_1\nM : Type u_3\ninst\u271d\u00b9 : One M\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\ninst\u271d : Decidable (a \u2208 s)\n\u22a2 (if a \u2208 s then f a else 1) = if a \u2208 s then f a else 1",["congr","aesop","simp"]],["Data/Rat/Defs.lean",91,"q : \u211a\n\u22a2 0 < q.num \u2228 0 = q.num \u2192 \u00acq = 0 \u2192 q.num < 0 \u2228 q = 0 \u2192 0 < q.num \u2228 0 = q.num",["tauto","omega","aesop"]],["Data/Rat/Defs.lean",387,"q : \u211a\n\u22a2 0 \u2264 q.num \u2192 q.num \u2264 0 \u2192 q.num \u2264 0 \u2227 0 \u2264 q.num",["tauto","omega","aesop"]],["Topology/Sets/Opens.lean",68,"\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : TopologicalSpace \u03b3\nx\u271d\u00b2 x\u271d\u00b9 : Opens \u03b1\ncarrier\u271d\u00b9 : Set \u03b1\nis_open'\u271d\u00b9 : IsOpen carrier\u271d\u00b9\ncarrier\u271d : Set \u03b1\nis_open'\u271d : IsOpen carrier\u271d\nx\u271d : { carrier := carrier\u271d\u00b9, is_open' := is_open'\u271d\u00b9 }.carrier = { carrier := carrier\u271d, is_open' := is_open'\u271d }.carrier\n\u22a2 { carrier := carrier\u271d\u00b9, is_open' := is_open'\u271d\u00b9 } = { carrier := carrier\u271d, is_open' := is_open'\u271d }",["congr","aesop"]],["Algebra/CubicDiscriminant.lean",492,"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst\u271d\u00b9 : Field F\ninst\u271d : Field K\n\u03c6 : F \u2192+* K\nx y z : K\nha : P.a \u2260 0\nh3 : (map \u03c6 P).roots = {x, y, z}\n\u22a2 x \u2260 y \u2227 x \u2260 z \u2227 y \u2260 z \u2194 \u00ac(x = y \u2228 x = z) \u2227 \u00acy = z \u2227 True",["tauto","omega","aesop","infer_instance"]],["CategoryTheory/Monad/Comonadicity.lean",105,"case h\nC : Type u\u2081\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nA : adj.toComonad.Coalgebra\nB : C\ninst\u271d : HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nf : B \u27f6 comparisonRightAdjointObj adj A\n\u22a2 (fun f \u21a6 equalizer.lift ((adj.homEquiv B A.A) f.f) \u22ef)\n        ((fun f \u21a6\n            { f := (adj.homEquiv B A.A).symm (f \u226b equalizer.\u03b9 (G.map A.a) (adj.unit.app (G.toPrefunctor.1 A.A))),\n              h := \u22ef })\n          f) \u226b\n      equalizer.\u03b9 (G.map A.a) (adj.unit.app (G.toPrefunctor.1 A.A)) =\n    f \u226b equalizer.\u03b9 (G.map A.a) (adj.unit.app (G.toPrefunctor.1 A.A))",["simp","aesop"]],["Data/List/Sublists.lean",46,"\u03b1 : Type u\na : \u03b1\nr\u2081 r\u2082 : List (List \u03b1)\n\u22a2 \u2200 (x : Array (List \u03b1)) (y : List \u03b1), (fun r l \u21a6 r ++ [a :: l]) x.toList y = ((fun r l \u21a6 r.push (a :: l)) x y).toList",["simp","aesop"]],["Data/List/Sublists.lean",200,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl : List \u03b1\nf : List \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nr : List \u03b2\ns : List \u03b3\n\u22a2 (g \u2218 f) [] :: (map g r ++ s) = map g (f [] :: r) ++ s",["simp","aesop","congr","tauto"]],["Data/List/Sublists.lean",53,"case H\n\u03b1 : Type u\nl : List \u03b1\nx\u271d : \u03b1\ny\u271d : Array (List \u03b1)\n\u22a2 (Array.foldl (fun r l \u21a6 r.push (x\u271d :: l)) y\u271d.toList.toArray y\u271d.toList.toArray).toList =\n    (Array.foldl (fun r l \u21a6 r.push (x\u271d :: l)) y\u271d y\u271d).toList",["congr","aesop","tauto","simp"]],["Data/List/Sublists.lean",127,"case H\n\u03b1 : Type u_1\nl : List \u03b1\nx\u271d : \u03b1\ny\u271d : Array (List \u03b1)\n\u22a2 (Array.foldl (fun r l \u21a6 (r.push l).push (x\u271d :: l)) #[] y\u271d.toList.toArray).toList =\n    (Array.foldl (fun r l \u21a6 (r.push l).push (x\u271d :: l)) (Array.mkEmpty (y\u271d.size * 2)) y\u271d).toList",["congr","aesop","tauto","simp"]],["MeasureTheory/Measure/Tilted.lean",234,"case inl\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 \u211d\nh : \u03bc = 0\n\u22a2 \u222b (x : \u03b1), rexp (g x) \u2202Measure.tilted 0 f = (\u222b (x : \u03b1), rexp ((f + g) x) \u22020) / \u222b (x : \u03b1), rexp (f x) \u22020",["simp","aesop","norm_num"]],["MeasureTheory/Measure/Tilted.lean",284,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf : Integrable (fun x \u21a6 rexp (f x)) \u03bc\nh : \u03bc = 0\nx\u271d\u00b9 : Set \u03b1\nx\u271d : 0 x\u271d\u00b9 = 0\n\u22a2 0 x\u271d\u00b9 = 0",["simp","aesop","congr","gcongr","tauto","assumption","norm_num"]],["MeasureTheory/Measure/Tilted.lean",272,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf : Integrable (fun x \u21a6 rexp (f x)) \u03bc\n\u22a2 \u03bc.tilted (f + -f) = (\u03bc Set.univ)\u207b\u00b9 \u2022 \u03bc",["simp","aesop","norm_num"]],["MeasureTheory/Measure/Tilted.lean",136,"case inl\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nh\u03bc : \u03bc = 0\n\u22a2 IsZeroOrProbabilityMeasure 0",["infer_instance","tauto"]],["MeasureTheory/Measure/Tilted.lean",141,"case neg\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nh\u03bc : NeZero \u03bc\nhf : \u00acIntegrable (fun x \u21a6 rexp (f x)) \u03bc\n\u22a2 IsZeroOrProbabilityMeasure 0",["infer_instance","tauto"]],["LinearAlgebra/Matrix/Charpoly/Coeff.lean",104,"case h\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : Nontrivial R\nM : Matrix n n R\nh : \u00acFintype.card n = 0\n\u22a2 \u220f x : n, 1 \u2260 0",["simp","aesop","norm_num"]],["LinearAlgebra/Matrix/Charpoly/Coeff.lean",177,"R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\n\u22a2 M.det = (-1 \u2022 eval ((scalar n) 0) (X - C M)).det",["simp","aesop","norm_num"]],["LinearAlgebra/Matrix/Charpoly/Coeff.lean",337,"R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type v\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nM : Matrix n n R\nthis : (1 - X \u2022 M.map \u21d1C).map (eval 0) = 1\n\u22a2 ((evalRingHom 0).mapMatrix (1 - X \u2022 M.map \u21d1C)).det = det 1",["congr","aesop","tauto"]],["NumberTheory/ZetaValues.lean",361,"\u22a2 1 / 4 = (algebraMap \u211a \u211d) (1 / 4)",["norm_num","aesop","simp"]],["NumberTheory/ZetaValues.lean",364,"this : 1 / 4 = (algebraMap \u211a \u211d) (1 / 4)\n\u22a2 8 * \u03c0 ^ 3 * 3 * 32 = \u03c0 ^ 3 * (2 * 6 * 64)",["ring","omega","linarith","tauto","infer_instance"]],["Data/List/Nodup.lean",371,"case refl\n\u03b1 : Type u\nl : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhl : l.Nodup\nh : \u2200 a \u2208 l, \u2200 b \u2208 l, a \u2260 b \u2192 r a b\na : \u03b1\nhab : [a, a] <+ l\nthis : False\n\u22a2 r a a",["contradiction","aesop","tauto"]],["AlgebraicTopology/ExtraDegeneracy.lean",401,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.92318, u_1} C\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : HasZeroObject C\nX : Augmented C\ned : X.ExtraDegeneracy\ni j : \u2115\nh\u271d : i + 1 = j\n\u22a2 drop.obj X _\u298bi + 1\u298c = (AlternatingFaceMapComplex.obj (drop.obj X)).X j",["congr","aesop","tauto"]],["Algebra/Ring/Ext.lean",49,"case mk.mk.mk.mk.mk.mk\nR : Type u\nmul\u271d\u00b9 add\u271d\u00b9 : R \u2192 R \u2192 R\nleft_distrib\u271d\u00b9 : \u2200 (a b c : R), a * (b + c) = a * b + a * c\nright_distrib\u271d\u00b9 : \u2200 (a b c : R), (a + b) * c = a * c + b * c\nmul\u271d add\u271d : R \u2192 R \u2192 R\nleft_distrib\u271d : \u2200 (a b c : R), a * (b + c) = a * b + a * c\nright_distrib\u271d : \u2200 (a b c : R), (a + b) * c = a * c + b * c\nh_add : HAdd.hAdd = HAdd.hAdd\nh_mul : HMul.hMul = HMul.hMul\n\u22a2 mk left_distrib\u271d\u00b9 right_distrib\u271d\u00b9 = mk left_distrib\u271d right_distrib\u271d",["congr"]],["Algebra/Ring/Ext.lean",79,"case mk.mk\nR : Type u\ntoNonUnitalNonAssocSemiring\u271d\u00b9 : NonUnitalNonAssocSemiring R\nmul_assoc\u271d\u00b9 : \u2200 (a b c : R), a * b * c = a * (b * c)\ntoNonUnitalNonAssocSemiring\u271d : NonUnitalNonAssocSemiring R\nmul_assoc\u271d : \u2200 (a b c : R), a * b * c = a * (b * c)\na\u271d : toNonUnitalNonAssocSemiring = toNonUnitalNonAssocSemiring\n\u22a2 mk mul_assoc\u271d\u00b9 = mk mul_assoc\u271d",["congr"]],["Algebra/Ring/Ext.lean",112,"case mk.mk.mk.mk\nR : Type u\ntoAddMonoid\u271d\u00b9 : AddMonoid R\ntoOne\u271d\u00b9 : One R\nnatCast\u271d\u00b9 : \u2115 \u2192 R\nnatCast_zero\u271d\u00b9 : NatCast.natCast 0 = 0\nnatCast_succ\u271d\u00b9 : \u2200 (n : \u2115), NatCast.natCast (n + 1) = NatCast.natCast n + 1\ntoAddMonoid\u271d : AddMonoid R\ntoOne\u271d : One R\nnatCast\u271d : \u2115 \u2192 R\nnatCast_zero\u271d : NatCast.natCast 0 = 0\nnatCast_succ\u271d : \u2200 (n : \u2115), NatCast.natCast (n + 1) = NatCast.natCast n + 1\nh_add : HAdd.hAdd = HAdd.hAdd\nh_one : One.one = One.one\nh_monoid : toAddMonoid = toAddMonoid\nh_zero' : AddMonoid.toZero = AddMonoid.toZero\nh_one' : toOne = toOne\nh_natCast : NatCast.natCast = NatCast.natCast\n\u22a2 mk natCast_zero\u271d\u00b9 natCast_succ\u271d\u00b9 = mk natCast_zero\u271d natCast_succ\u271d",["congr"]],["Algebra/Ring/Ext.lean",116,"case mk.mk\nR : Type u\ntoAddMonoidWithOne\u271d\u00b9 : AddMonoidWithOne R\nadd_comm\u271d\u00b9 : \u2200 (a b : R), a + b = b + a\ntoAddMonoidWithOne\u271d : AddMonoidWithOne R\nadd_comm\u271d : \u2200 (a b : R), a + b = b + a\na\u271d : toAddMonoidWithOne = toAddMonoidWithOne\n\u22a2 mk add_comm\u271d\u00b9 = mk add_comm\u271d",["congr"]],["Algebra/Ring/Ext.lean",150,"case mk.mk\nR : Type u\ntoNonUnitalNonAssocSemiring\u271d\u00b9 : NonUnitalNonAssocSemiring R\ntoOne\u271d\u00b9 : One R\none_mul\u271d\u00b9 : \u2200 (a : R), 1 * a = a\nmul_one\u271d\u00b9 : \u2200 (a : R), a * 1 = a\ntoNatCast\u271d\u00b9 : NatCast R\nnatCast_zero\u271d\u00b9 : NatCast.natCast 0 = 0\nnatCast_succ\u271d\u00b9 : \u2200 (n : \u2115), NatCast.natCast (n + 1) = NatCast.natCast n + 1\ntoNonUnitalNonAssocSemiring\u271d : NonUnitalNonAssocSemiring R\ntoOne\u271d : One R\none_mul\u271d : \u2200 (a : R), 1 * a = a\nmul_one\u271d : \u2200 (a : R), a * 1 = a\ntoNatCast\u271d : NatCast R\nnatCast_zero\u271d : NatCast.natCast 0 = 0\nnatCast_succ\u271d : \u2200 (n : \u2115), NatCast.natCast (n + 1) = NatCast.natCast n + 1\nh_add : HAdd.hAdd = HAdd.hAdd\nh_mul : HMul.hMul = HMul.hMul\nh : toNonUnitalNonAssocSemiring = toNonUnitalNonAssocSemiring\nh_zero : Zero.zero = Zero.zero\nh_one' : MulOneClass.toOne = MulOneClass.toOne\nh_one : One.one = One.one\nthis\u271d : toAddCommMonoidWithOne = toAddCommMonoidWithOne\nthis : toNatCast = toNatCast\n\u22a2 mk one_mul\u271d\u00b9 mul_one\u271d\u00b9 natCast_zero\u271d\u00b9 natCast_succ\u271d\u00b9 = mk one_mul\u271d mul_one\u271d natCast_zero\u271d natCast_succ\u271d",["congr"]],["Algebra/Ring/Ext.lean",191,"case mk.mk\nR : Type u\ntoNonUnitalNonAssocRing\u271d\u00b9 : NonUnitalNonAssocRing R\nmul_assoc\u271d\u00b9 : \u2200 (a b c : R), a * b * c = a * (b * c)\ntoNonUnitalNonAssocRing\u271d : NonUnitalNonAssocRing R\nmul_assoc\u271d : \u2200 (a b c : R), a * b * c = a * (b * c)\nh_add : HAdd.hAdd = HAdd.hAdd\nh_mul : HMul.hMul = HMul.hMul\nthis : toNonUnitalNonAssocRing = toNonUnitalNonAssocRing\n\u22a2 mk mul_assoc\u271d\u00b9 = mk mul_assoc\u271d",["congr"]],["Algebra/Ring/Ext.lean",224,"case h.ofNat\nR : Type u\ninst\u2081 inst\u2082 : AddGroupWithOne R\nh_add : HAdd.hAdd = HAdd.hAdd\nh_one : One.one = One.one\nthis\u271d : toAddMonoidWithOne = toAddMonoidWithOne\nthis : AddMonoidWithOne.toNatCast = AddMonoidWithOne.toNatCast\ntoAddMonoid_eq\u271d : AddMonoidWithOne.toAddMonoid = AddMonoidWithOne.toAddMonoid\ntoNeg_eq\u271d : toNeg = toNeg\ntoSub_eq\u271d : toSub = toSub\nzsmul_eq\u271d : AddGroupWithOne.zsmul = AddGroupWithOne.zsmul\nn : \u2115\n\u22a2 \u2191n = \u2191n",["congr"]],["Algebra/Ring/Ext.lean",225,"case h.negSucc\nR : Type u\ninst\u2081 inst\u2082 : AddGroupWithOne R\nh_add : HAdd.hAdd = HAdd.hAdd\nh_one : One.one = One.one\nthis\u271d : toAddMonoidWithOne = toAddMonoidWithOne\nthis : AddMonoidWithOne.toNatCast = AddMonoidWithOne.toNatCast\ntoAddMonoid_eq\u271d : AddMonoidWithOne.toAddMonoid = AddMonoidWithOne.toAddMonoid\ntoNeg_eq\u271d : toNeg = toNeg\ntoSub_eq\u271d : toSub = toSub\nzsmul_eq\u271d : AddGroupWithOne.zsmul = AddGroupWithOne.zsmul\nn : \u2115\n\u22a2 -\u2191(n + 1) = -\u2191(n + 1)",["congr"]],["Algebra/Ring/Ext.lean",227,"case mk.mk.mk.mk\nR : Type u\ntoAddMonoidWithOne\u271d\u00b9 : AddMonoidWithOne R\ntoNeg\u271d\u00b9 : Neg R\ntoSub\u271d\u00b9 : Sub R\nsub_eq_add_neg\u271d\u00b9 : \u2200 (a b : R), a - b = a + -b\nzsmul\u271d\u00b9 : \u2124 \u2192 R \u2192 R\nzsmul_zero'\u271d\u00b9 : \u2200 (a : R), zsmul\u271d\u00b9 0 a = 0\nzsmul_succ'\u271d\u00b9 : \u2200 (n : \u2115) (a : R), zsmul\u271d\u00b9 (\u2191n.succ) a = zsmul\u271d\u00b9 (\u2191n) a + a\nzsmul_neg'\u271d\u00b9 : \u2200 (n : \u2115) (a : R), zsmul\u271d\u00b9 (Int.negSucc n) a = -zsmul\u271d\u00b9 (\u2191n.succ) a\nneg_add_cancel\u271d\u00b9 : \u2200 (a : R), -a + a = 0\nintCast\u271d\u00b9 : \u2124 \u2192 R\nintCast_ofNat\u271d\u00b9 : \u2200 (n : \u2115), IntCast.intCast \u2191n = \u2191n\nintCast_negSucc\u271d\u00b9 : \u2200 (n : \u2115), IntCast.intCast (Int.negSucc n) = -\u2191(n + 1)\ntoAddMonoidWithOne\u271d : AddMonoidWithOne R\ntoNeg\u271d : Neg R\ntoSub\u271d : Sub R\nsub_eq_add_neg\u271d : \u2200 (a b : R), a - b = a + -b\nzsmul\u271d : \u2124 \u2192 R \u2192 R\nzsmul_zero'\u271d : \u2200 (a : R), zsmul\u271d 0 a = 0\nzsmul_succ'\u271d : \u2200 (n : \u2115) (a : R), zsmul\u271d (\u2191n.succ) a = zsmul\u271d (\u2191n) a + a\nzsmul_neg'\u271d : \u2200 (n : \u2115) (a : R), zsmul\u271d (Int.negSucc n) a = -zsmul\u271d (\u2191n.succ) a\nneg_add_cancel\u271d : \u2200 (a : R), -a + a = 0\nintCast\u271d : \u2124 \u2192 R\nintCast_ofNat\u271d : \u2200 (n : \u2115), IntCast.intCast \u2191n = \u2191n\nintCast_negSucc\u271d : \u2200 (n : \u2115), IntCast.intCast (Int.negSucc n) = -\u2191(n + 1)\nh_add : HAdd.hAdd = HAdd.hAdd\nh_one : One.one = One.one\nthis\u271d\u00b9 : toAddMonoidWithOne = toAddMonoidWithOne\nthis\u271d : AddMonoidWithOne.toNatCast = AddMonoidWithOne.toNatCast\ntoAddMonoid_eq\u271d : AddMonoidWithOne.toAddMonoid = AddMonoidWithOne.toAddMonoid\ntoNeg_eq\u271d : toNeg = toNeg\ntoSub_eq\u271d : toSub = toSub\nzsmul_eq\u271d : AddGroupWithOne.zsmul = AddGroupWithOne.zsmul\nthis : IntCast.intCast = IntCast.intCast\n\u22a2 mk sub_eq_add_neg\u271d\u00b9 zsmul\u271d\u00b9 zsmul_zero'\u271d\u00b9 zsmul_succ'\u271d\u00b9 zsmul_neg'\u271d\u00b9 neg_add_cancel\u271d\u00b9 intCast_ofNat\u271d\u00b9\n      intCast_negSucc\u271d\u00b9 =\n    mk sub_eq_add_neg\u271d zsmul\u271d zsmul_zero'\u271d zsmul_succ'\u271d zsmul_neg'\u271d neg_add_cancel\u271d intCast_ofNat\u271d intCast_negSucc\u271d",["congr"]],["Algebra/Ring/Ext.lean",239,"case mk.mk\nR : Type u\ntoAddCommGroup\u271d\u00b9 : AddCommGroup R\ntoIntCast\u271d\u00b9 : IntCast R\ntoNatCast\u271d\u00b9 : NatCast R\ntoOne\u271d\u00b9 : One R\nnatCast_zero\u271d\u00b9 : NatCast.natCast 0 = 0\nnatCast_succ\u271d\u00b9 : \u2200 (n : \u2115), NatCast.natCast (n + 1) = NatCast.natCast n + 1\nintCast_ofNat\u271d\u00b9 : \u2200 (n : \u2115), IntCast.intCast \u2191n = \u2191n\nintCast_negSucc\u271d\u00b9 : \u2200 (n : \u2115), IntCast.intCast (Int.negSucc n) = -\u2191(n + 1)\ntoAddCommGroup\u271d : AddCommGroup R\ntoIntCast\u271d : IntCast R\ntoNatCast\u271d : NatCast R\ntoOne\u271d : One R\nnatCast_zero\u271d : NatCast.natCast 0 = 0\nnatCast_succ\u271d : \u2200 (n : \u2115), NatCast.natCast (n + 1) = NatCast.natCast n + 1\nintCast_ofNat\u271d : \u2200 (n : \u2115), IntCast.intCast \u2191n = \u2191n\nintCast_negSucc\u271d : \u2200 (n : \u2115), IntCast.intCast (Int.negSucc n) = -\u2191(n + 1)\nh_add : HAdd.hAdd = HAdd.hAdd\nh_one : One.one = One.one\nthis : toAddCommGroup = toAddCommGroup\ntoIntCast_eq\u271d : toIntCast = toIntCast\ntoNeg_eq\u271d : SubNegMonoid.toNeg = SubNegMonoid.toNeg\ntoSub_eq\u271d : SubNegMonoid.toSub = SubNegMonoid.toSub\nzsmul_eq\u271d : SubNegMonoid.zsmul = SubNegMonoid.zsmul\ntoNatCast_eq\u271d : toNatCast = toNatCast\ntoAddMonoid_eq\u271d : SubNegMonoid.toAddMonoid = SubNegMonoid.toAddMonoid\ntoOne_eq\u271d : toOne = toOne\n\u22a2 mk natCast_zero\u271d\u00b9 natCast_succ\u271d\u00b9 intCast_ofNat\u271d\u00b9 intCast_negSucc\u271d\u00b9 =\n    mk natCast_zero\u271d natCast_succ\u271d intCast_ofNat\u271d intCast_negSucc\u271d",["congr"]],["Algebra/Ring/Ext.lean",352,"case mk.mk\nR : Type u\ntoNonUnitalNonAssocSemiring\u271d\u00b9 : NonUnitalNonAssocSemiring R\nmul_comm\u271d\u00b9 : \u2200 (a b : R), a * b = b * a\ntoNonUnitalNonAssocSemiring\u271d : NonUnitalNonAssocSemiring R\nmul_comm\u271d : \u2200 (a b : R), a * b = b * a\na\u271d : toNonUnitalNonAssocSemiring = toNonUnitalNonAssocSemiring\n\u22a2 mk mul_comm\u271d\u00b9 = mk mul_comm\u271d",["congr"]],["Algebra/Ring/Ext.lean",368,"case mk.mk\nR : Type u\ntoNonUnitalSemiring\u271d\u00b9 : NonUnitalSemiring R\nmul_comm\u271d\u00b9 : \u2200 (a b : R), a * b = b * a\ntoNonUnitalSemiring\u271d : NonUnitalSemiring R\nmul_comm\u271d : \u2200 (a b : R), a * b = b * a\na\u271d : toNonUnitalSemiring = toNonUnitalSemiring\n\u22a2 mk mul_comm\u271d\u00b9 = mk mul_comm\u271d",["congr"]],["Algebra/Ring/Ext.lean",386,"case mk.mk\nR : Type u\ntoNonUnitalNonAssocRing\u271d\u00b9 : NonUnitalNonAssocRing R\nmul_comm\u271d\u00b9 : \u2200 (a b : R), a * b = b * a\ntoNonUnitalNonAssocRing\u271d : NonUnitalNonAssocRing R\nmul_comm\u271d : \u2200 (a b : R), a * b = b * a\na\u271d : toNonUnitalNonAssocRing = toNonUnitalNonAssocRing\n\u22a2 mk mul_comm\u271d\u00b9 = mk mul_comm\u271d",["congr"]],["Algebra/Ring/Ext.lean",402,"case mk.mk\nR : Type u\ntoNonUnitalRing\u271d\u00b9 : NonUnitalRing R\nmul_comm\u271d\u00b9 : \u2200 (a b : R), a * b = b * a\ntoNonUnitalRing\u271d : NonUnitalRing R\nmul_comm\u271d : \u2200 (a b : R), a * b = b * a\na\u271d : toNonUnitalRing = toNonUnitalRing\n\u22a2 mk mul_comm\u271d\u00b9 = mk mul_comm\u271d",["congr"]],["Algebra/Ring/Ext.lean",420,"case mk.mk\nR : Type u\ntoSemiring\u271d\u00b9 : Semiring R\nmul_comm\u271d\u00b9 : \u2200 (a b : R), a * b = b * a\ntoSemiring\u271d : Semiring R\nmul_comm\u271d : \u2200 (a b : R), a * b = b * a\na\u271d : toSemiring = toSemiring\n\u22a2 mk mul_comm\u271d\u00b9 = mk mul_comm\u271d",["congr"]],["Algebra/Ring/Ext.lean",435,"case mk.mk\nR : Type u\ntoRing\u271d\u00b9 : Ring R\nmul_comm\u271d\u00b9 : \u2200 (a b : R), a * b = b * a\ntoRing\u271d : Ring R\nmul_comm\u271d : \u2200 (a b : R), a * b = b * a\na\u271d : toRing = toRing\n\u22a2 mk mul_comm\u271d\u00b9 = mk mul_comm\u271d",["congr"]],["Algebra/Ring/Ext.lean",64,"case mk.mk.mk.mk.e_toAddCommMonoid.h_mul\nR : Type u\ntoAddCommMonoid\u271d\u00b9 : AddCommMonoid R\nmul\u271d\u00b9 : R \u2192 R \u2192 R\nleft_distrib\u271d\u00b9 : \u2200 (a b c : R), a * (b + c) = a * b + a * c\nright_distrib\u271d\u00b9 : \u2200 (a b c : R), (a + b) * c = a * c + b * c\nzero_mul\u271d\u00b9 : \u2200 (a : R), 0 * a = 0\nmul_zero\u271d\u00b9 : \u2200 (a : R), a * 0 = 0\ntoAddCommMonoid\u271d : AddCommMonoid R\nmul\u271d : R \u2192 R \u2192 R\nleft_distrib\u271d : \u2200 (a b c : R), a * (b + c) = a * b + a * c\nright_distrib\u271d : \u2200 (a b c : R), (a + b) * c = a * c + b * c\nzero_mul\u271d : \u2200 (a : R), 0 * a = 0\nmul_zero\u271d : \u2200 (a : R), a * 0 = 0\nh_add : HAdd.hAdd = HAdd.hAdd\nh_mul : HMul.hMul = HMul.hMul\n\u22a2 HAdd.hAdd = HAdd.hAdd",["assumption","congr"]],["Algebra/Ring/Ext.lean",168,"case mk.mk.mk.mk.e_toAddCommGroup.h_mul\nR : Type u\ntoAddCommGroup\u271d\u00b9 : AddCommGroup R\nmul\u271d\u00b9 : R \u2192 R \u2192 R\nleft_distrib\u271d\u00b9 : \u2200 (a b c : R), a * (b + c) = a * b + a * c\nright_distrib\u271d\u00b9 : \u2200 (a b c : R), (a + b) * c = a * c + b * c\nzero_mul\u271d\u00b9 : \u2200 (a : R), 0 * a = 0\nmul_zero\u271d\u00b9 : \u2200 (a : R), a * 0 = 0\ntoAddCommGroup\u271d : AddCommGroup R\nmul\u271d : R \u2192 R \u2192 R\nleft_distrib\u271d : \u2200 (a b c : R), a * (b + c) = a * b + a * c\nright_distrib\u271d : \u2200 (a b c : R), (a + b) * c = a * c + b * c\nzero_mul\u271d : \u2200 (a : R), 0 * a = 0\nmul_zero\u271d : \u2200 (a : R), a * 0 = 0\nh_add : HAdd.hAdd = HAdd.hAdd\nh_mul : HMul.hMul = HMul.hMul\n\u22a2 Add.add = Add.add",["assumption","congr"]],["Algebra/Order/AbsoluteValue/Basic.lean",51,"case mk.mk.mk.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nR\u271d : Type u_3\nS\u271d : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u00b9 : Semiring R\ninst\u271d : OrderedSemiring S\nabv : AbsoluteValue R S\ntoFun\u271d\u00b9 : R \u2192 S\nmap_mul'\u271d\u00b9 : \u2200 (x y : R), toFun\u271d\u00b9 (x * y) = toFun\u271d\u00b9 x * toFun\u271d\u00b9 y\nnonneg'\u271d\u00b9 : \u2200 (x : R), 0 \u2264 { toFun := toFun\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 }.toFun x\neq_zero'\u271d\u00b9 : \u2200 (x : R), { toFun := toFun\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 }.toFun x = 0 \u2194 x = 0\nadd_le'\u271d\u00b9 :\n  \u2200 (x y : R),\n    { toFun := toFun\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 }.toFun (x + y) \u2264\n      { toFun := toFun\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 }.toFun x + { toFun := toFun\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 }.toFun y\ntoFun\u271d : R \u2192 S\nmap_mul'\u271d : \u2200 (x y : R), toFun\u271d (x * y) = toFun\u271d x * toFun\u271d y\nnonneg'\u271d : \u2200 (x : R), 0 \u2264 { toFun := toFun\u271d, map_mul' := map_mul'\u271d }.toFun x\neq_zero'\u271d : \u2200 (x : R), { toFun := toFun\u271d, map_mul' := map_mul'\u271d }.toFun x = 0 \u2194 x = 0\nadd_le'\u271d :\n  \u2200 (x y : R),\n    { toFun := toFun\u271d, map_mul' := map_mul'\u271d }.toFun (x + y) \u2264\n      { toFun := toFun\u271d, map_mul' := map_mul'\u271d }.toFun x + { toFun := toFun\u271d, map_mul' := map_mul'\u271d }.toFun y\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9, nonneg' := nonneg'\u271d\u00b9, eq_zero' := eq_zero'\u271d\u00b9, add_le' := add_le'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d, map_mul' := map_mul'\u271d, nonneg' := nonneg'\u271d, eq_zero' := eq_zero'\u271d, add_le' := add_le'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9, nonneg' := nonneg'\u271d\u00b9, eq_zero' := eq_zero'\u271d\u00b9, add_le' := add_le'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_mul' := map_mul'\u271d, nonneg' := nonneg'\u271d, eq_zero' := eq_zero'\u271d, add_le' := add_le'\u271d }",["congr","aesop"]],["Logic/Embedding/Basic.lean",400,"case h\n\u03b1\u2081 : Sort u_1\n\u03b2\u2081 : Sort u_2\n\u03b3\u2081 : Sort u_3\n\u03b1\u2082 : Sort u_4\n\u03b2\u2082 : Sort u_5\n\u03b3\u2082 : Sort u_6\nea : \u03b1\u2081 \u2243 \u03b1\u2082\neb : \u03b2\u2081 \u2243 \u03b2\u2082\nec : \u03b3\u2081 \u2243 \u03b3\u2082\nf : \u03b1\u2081 \u21aa \u03b2\u2081\ng : \u03b2\u2081 \u21aa \u03b3\u2081\nx\u271d : \u03b1\u2082\n\u22a2 ((ea.embeddingCongr ec) (f.trans g)) x\u271d = (((ea.embeddingCongr eb) f).trans ((eb.embeddingCongr ec) g)) x\u271d",["simp","aesop","infer_instance"]],["Logic/Embedding/Basic.lean",376,"case h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nh : \u03b1 \u2243 \u03b2\nh' : \u03b3 \u2243 \u03b4\nx : \u03b2 \u21aa \u03b4\nx\u271d : \u03b2\n\u22a2 ((fun f \u21a6 Embedding.congr h h' f) ((fun f \u21a6 Embedding.congr h.symm h'.symm f) x)) x\u271d = x x\u271d",["simp","aesop"]],["Logic/Embedding/Basic.lean",373,"case h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03b4 : Sort u_4\nh : \u03b1 \u2243 \u03b2\nh' : \u03b3 \u2243 \u03b4\nx : \u03b1 \u21aa \u03b3\nx\u271d : \u03b1\n\u22a2 ((fun f \u21a6 Embedding.congr h.symm h'.symm f) ((fun f \u21a6 Embedding.congr h h' f) x)) x\u271d = x x\u271d",["simp","omega","aesop"]],["Logic/Embedding/Basic.lean",140,"case h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\nx\u271d : \u03b1\n\u22a2 (e.toEmbedding.trans e.symm.toEmbedding) x\u271d = (Embedding.refl \u03b1) x\u271d",["simp","aesop"]],["Logic/Embedding/Basic.lean",29,"case mk.mk\n\u03b1 : Sort u\n\u03b2 : Sort v\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\ninj'\u271d\u00b9 : Injective toFun\u271d\u00b9\ntoFun\u271d : \u03b1 \u2192 \u03b2\ninj'\u271d : Injective toFun\u271d\nh : { toFun := toFun\u271d\u00b9, inj' := inj'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, inj' := inj'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, inj' := inj'\u271d\u00b9 } = { toFun := toFun\u271d, inj' := inj'\u271d }",["congr","aesop"]],["Data/Sign.lean",142,"a : Fin 3\nisLt\u271d : 1 < 3\n\u22a2 (fun a \u21a6\n        match a with\n        | zero => \u27e80, \u22ef\u27e9\n        | pos => \u27e81, \u22ef\u27e9\n        | neg => \u27e82, \u22ef\u27e9)\n      ((fun a \u21a6\n          match a with\n          | \u27e80, isLt\u27e9 => 0\n          | \u27e81, isLt\u27e9 => 1\n          | \u27e82, isLt\u27e9 => -1)\n        \u27e81, isLt\u271d\u27e9) =\n    \u27e81, isLt\u271d\u27e9",["simp","aesop","congr","tauto"]],["Data/Sign.lean",143,"a : Fin 3\nisLt\u271d : 2 < 3\n\u22a2 (fun a \u21a6\n        match a with\n        | zero => \u27e80, \u22ef\u27e9\n        | pos => \u27e81, \u22ef\u27e9\n        | neg => \u27e82, \u22ef\u27e9)\n      ((fun a \u21a6\n          match a with\n          | \u27e80, isLt\u27e9 => 0\n          | \u27e81, isLt\u27e9 => 1\n          | \u27e82, isLt\u27e9 => -1)\n        \u27e82, isLt\u271d\u27e9) =\n    \u27e82, isLt\u271d\u27e9",["simp"]],["Data/Sign.lean",329,"case pos\n\u03b1 : Type u\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableLT \u03b1\na : \u03b1\nh\u271d\u00b9 : \u00ac0 < a\nh\u271d : a < 0\nh : -1 = -1\n\u22a2 a < 0",["assumption","aesop","congr","gcongr","tauto"]],["Data/Sign.lean",267,"\u22a2 Finset.univ = {0, -1, 1}",["decide","aesop","congr","tauto"]],["AlgebraicTopology/SimplicialSet/HomotopyCat.lean",203,"C : Type u\ninst\u271d : Category.{v, u} C\nV : C\u1d52\u1d56 \u2964 Type w\nX Y Z : C\n\u03b1 : X \u27f6 Y\n\u03b2 : Y \u27f6 Z\n\u03c6 : V.obj (op Z)\n\u22a2 V.map \u03b1.op (V.map \u03b2.op \u03c6) = V.map (\u03b1 \u226b \u03b2).op \u03c6",["simp","aesop","norm_num"]],["AlgebraicTopology/SimplicialSet/HomotopyCat.lean",284,"case a\nV : Truncated 2\n\u03c6 : V.obj (op { obj := \u298b2\u298c, property := \u22ef })\nf\u2080\u2081 : ev0\u2082 \u03c6 \u27f6 ev1\u2082 \u03c6\nh\u2080\u2081 : f\u2080\u2081.edge = V.map (\u03b4\u2082 2 \u22ef \u22ef).op \u03c6\nf\u2080\u2082 : ev0\u2082 \u03c6 \u27f6 ev2\u2082 \u03c6\nh\u2080\u2082 : f\u2080\u2082.edge = V.map (\u03b4\u2082 1 \u22ef \u22ef).op \u03c6\nf\u2081\u2082 : ev1\u2082 \u03c6 \u27f6 ev2\u2082 \u03c6\nh\u2081\u2082 : f\u2081\u2082.edge = V.map (\u03b4\u2082 0 \u22ef \u22ef).op \u03c6\n\u22a2 f\u2080\u2081.edge = (ev01\u2082 \u03c6).edge",["assumption","aesop","tauto"]],["AlgebraicTopology/SimplicialSet/HomotopyCat.lean",285,"case a\nV : Truncated 2\n\u03c6 : V.obj (op { obj := \u298b2\u298c, property := \u22ef })\nf\u2080\u2082 : ev0\u2082 \u03c6 \u27f6 ev2\u2082 \u03c6\nh\u2080\u2082 : f\u2080\u2082.edge = V.map (\u03b4\u2082 1 \u22ef \u22ef).op \u03c6\nf\u2081\u2082 : ev1\u2082 \u03c6 \u27f6 ev2\u2082 \u03c6\nh\u2081\u2082 : f\u2081\u2082.edge = V.map (\u03b4\u2082 0 \u22ef \u22ef).op \u03c6\nh\u2080\u2081 : (ev01\u2082 \u03c6).edge = V.map (\u03b4\u2082 2 \u22ef \u22ef).op \u03c6\n\u22a2 f\u2081\u2082.edge = (ev12\u2082 \u03c6).edge",["assumption"]],["AlgebraicTopology/SimplicialSet/HomotopyCat.lean",286,"case a\nV : Truncated 2\n\u03c6 : V.obj (op { obj := \u298b2\u298c, property := \u22ef })\nf\u2080\u2082 : ev0\u2082 \u03c6 \u27f6 ev2\u2082 \u03c6\nh\u2080\u2082 : f\u2080\u2082.edge = V.map (\u03b4\u2082 1 \u22ef \u22ef).op \u03c6\nh\u2080\u2081 : (ev01\u2082 \u03c6).edge = V.map (\u03b4\u2082 2 \u22ef \u22ef).op \u03c6\nh\u2081\u2082 : (ev12\u2082 \u03c6).edge = V.map (\u03b4\u2082 0 \u22ef \u22ef).op \u03c6\n\u22a2 f\u2080\u2082.edge = (ev02\u2082 \u03c6).edge",["assumption"]],["AlgebraicTopology/SimplicialSet/HomotopyCat.lean",69,"\u22a2 2 = Fin.succ 1",["decide"]],["AlgebraicTopology/SimplicialSet/HomotopyCat.lean",73,"\u22a2 Fin.succ 0 < 2",["decide","aesop","tauto","simp"]],["Combinatorics/SimpleGraph/Density.lean",198,"\ud835\udd5c : Type u_1\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : LinearOrderedField \ud835\udd5c\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ninst\u271d : (a : \u03b1) \u2192 DecidablePred (r a)\ns\u2081 s\u2082 : Finset \u03b1\nt\u2081 t\u2082 : Finset \u03b2\n\u03b4 : \ud835\udd5c\nhs : s\u2082 \u2286 s\u2081\nht : t\u2082 \u2286 t\u2081\nh\u03b4\u2080 : 0 \u2264 \u03b4\nh\u03b4\u2081 : \u03b4 < 1\nhs\u2082 : (1 - \u03b4) * \u2191(#s\u2081) \u2264 \u2191(#s\u2082)\nht\u2082 : (1 - \u03b4) * \u2191(#t\u2081) \u2264 \u2191(#t\u2082)\n\u22a2 1 \u2264 2",["norm_num","aesop","simp"]],["CategoryTheory/Functor/Flat.lean",247,"C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nJ : Type v\u2081\ninst\u271d\u00b2 : SmallCategory J\ninst\u271d\u00b9 : FinCategory J\nF : C \u2964 D\ninst\u271d : RepresentablyFlat F\nK : J \u2964 C\nc : Cone K\nhc : IsLimit c\ns : Cone (K \u22d9 F)\nf\u2081 f\u2082 : s.pt \u27f6 F.obj c.pt\nh\u2081 : \u2200 (j : J), f\u2081 \u226b (F.mapCone c).\u03c0.app j = s.\u03c0.app j\nh\u2082 : \u2200 (j : J), f\u2082 \u226b (F.mapCone c).\u03c0.app j = s.\u03c0.app j\n\u03b1\u2081 : (F.mapCone c).toStructuredArrow \u22d9 map f\u2081 \u27f6 s.toStructuredArrow := { app := fun X \u21a6 eqToHom \u22ef, naturality := \u22ef }\n\u03b1\u2082 : (F.mapCone c).toStructuredArrow \u22d9 map f\u2082 \u27f6 s.toStructuredArrow := { app := fun X \u21a6 eqToHom \u22ef, naturality := \u22ef }\nc\u2081 : Cone (s.toStructuredArrow \u22d9 pre s.pt K F) :=\n  (Cones.postcompose (whiskerRight \u03b1\u2081 (pre s.pt K F))).obj (c.toStructuredArrowCone F f\u2081)\nc\u2082 : Cone (s.toStructuredArrow \u22d9 pre s.pt K F) :=\n  (Cones.postcompose (whiskerRight \u03b1\u2082 (pre s.pt K F))).obj (c.toStructuredArrowCone F f\u2082)\nc\u2080 : Cone (biconeMk J c\u2081 c\u2082) := IsCofiltered.cone (biconeMk J c\u2081 c\u2082)\ng\u2081 : c\u2080.pt \u27f6 c\u2081.pt := c\u2080.\u03c0.app Bicone.left\ng\u2082 : c\u2080.pt \u27f6 c\u2082.pt := c\u2080.\u03c0.app Bicone.right\nthis\u271d\u00b9 : \u2200 (j : J), g\u2081.right \u226b c.\u03c0.app j = g\u2082.right \u226b c.\u03c0.app j\nthis\u271d : c.extend g\u2081.right = c.extend g\u2082.right\nthis : g\u2081.right = g\u2082.right\n\u22a2 \ud835\udfd9 s.pt \u226b f\u2082 = f\u2082",["simp","aesop"]],["CategoryTheory/Functor/Flat.lean",233,"C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nJ : Type v\u2081\ninst\u271d\u00b2 : SmallCategory J\ninst\u271d\u00b9 : FinCategory J\nF : C \u2964 D\ninst\u271d : RepresentablyFlat F\nK : J \u2964 C\nc : Cone K\nhc : IsLimit c\ns : Cone (K \u22d9 F)\nf\u2081 f\u2082 : s.pt \u27f6 F.obj c.pt\nh\u2081 : \u2200 (j : J), f\u2081 \u226b (F.mapCone c).\u03c0.app j = s.\u03c0.app j\nh\u2082 : \u2200 (j : J), f\u2082 \u226b (F.mapCone c).\u03c0.app j = s.\u03c0.app j\n\u03b1\u2081 : (F.mapCone c).toStructuredArrow \u22d9 map f\u2081 \u27f6 s.toStructuredArrow := { app := fun X \u21a6 eqToHom \u22ef, naturality := \u22ef }\n\u03b1\u2082 : (F.mapCone c).toStructuredArrow \u22d9 map f\u2082 \u27f6 s.toStructuredArrow := { app := fun X \u21a6 eqToHom \u22ef, naturality := \u22ef }\nc\u2081 : Cone (s.toStructuredArrow \u22d9 pre s.pt K F) :=\n  (Cones.postcompose (whiskerRight \u03b1\u2081 (pre s.pt K F))).obj (c.toStructuredArrowCone F f\u2081)\nc\u2082 : Cone (s.toStructuredArrow \u22d9 pre s.pt K F) :=\n  (Cones.postcompose (whiskerRight \u03b1\u2082 (pre s.pt K F))).obj (c.toStructuredArrowCone F f\u2082)\nc\u2080 : Cone (biconeMk J c\u2081 c\u2082) := IsCofiltered.cone (biconeMk J c\u2081 c\u2082)\ng\u2081 : c\u2080.pt \u27f6 c\u2081.pt := c\u2080.\u03c0.app Bicone.left\ng\u2082 : c\u2080.pt \u27f6 c\u2082.pt := c\u2080.\u03c0.app Bicone.right\nthis\u271d : \u2200 (j : J), g\u2081.right \u226b c.\u03c0.app j = g\u2082.right \u226b c.\u03c0.app j\nthis : c.extend g\u2081.right = c.extend g\u2082.right\n\u22a2 hc.lift (c.extend g\u2081.right) = hc.lift (c.extend g\u2082.right)",["congr"]],["GroupTheory/Torsion.lean",229,"case h\nG : Type u_1\ninst\u271d : CommMonoid G\ntG : IsTorsion G\nx\u271d : G\n\u22a2 x\u271d \u2208 torsion G \u2194 x\u271d \u2208 \u22a4",["tauto","aesop"]],["GroupTheory/Torsion.lean",389,"M : Type u_3\ninst\u271d : AddMonoid M\nx\u271d\u00b9 : \u2115\nx\u271d : M\n\u22a2 x\u271d \u2260 0 \u2192 x\u271d\u00b9 \u2260 0 \u2192 \u00acx\u271d\u00b9 \u2022 x\u271d = 0 \u2194 x\u271d\u00b9 \u2022 x\u271d = 0 \u2192 x\u271d\u00b9 = 0 \u2228 x\u271d = 0",["tauto"]],["GroupTheory/Torsion.lean",395,"G : Type u_1\ninst\u271d : AddGroup G\nx\u271d\u00b9 : \u2124\nx\u271d : G\n\u22a2 x\u271d \u2260 0 \u2192 x\u271d\u00b9 \u2260 0 \u2192 \u00acx\u271d\u00b9 \u2022 x\u271d = 0 \u2194 x\u271d\u00b9 \u2022 x\u271d = 0 \u2192 x\u271d\u00b9 = 0 \u2228 x\u271d = 0",["tauto"]],["AlgebraicGeometry/EllipticCurve/IsomOfJ.lean",307,"F : Type u_1\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : IsSepClosed F\nE\u271d E'\u271d : WeierstrassCurve F\ninst\u271d\u2074 : E\u271d.IsElliptic\ninst\u271d\u00b3 : E'\u271d.IsElliptic\np : \u2115\ninst\u271d\u00b2 : CharP F p\nhchar2 : 2 \u2260 0\nhchar3 : 3 \u2260 0\nthis\u271d\u00b3 : NeZero 2\nthis\u271d\u00b2 : NeZero 4\nthis\u271d\u00b9 : NeZero 6\nthis\u271d : Invertible 2 := invertibleOfNonzero hchar2\nthis : Invertible 3 := invertibleOfNonzero hchar3\nE : WeierstrassCurve F\ninst\u271d\u00b9 : E.IsElliptic\nh\u271d\u00b9 : E.IsShortNF\nE' : WeierstrassCurve F\ninst\u271d : E'.IsElliptic\nh\u271d : E'.IsShortNF\nheq : E'.a\u2084 = 0 \u2228 E.a\u2086 = 0\nha\u2084 : \u00acE.a\u2084 = 0\nha\u2086 : \u00acE.a\u2086 = 0\nha\u2084' : E'.a\u2084 \u2260 0\nh : E'.a\u2086 = 0\n\u22a2 False",["tauto","aesop"]],["RingTheory/MvPolynomial/Symmetric/FundamentalTheorem.lean",250,"\u03c3 : Type u_1\nR : Type u_3\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03c3\np : MvPolynomial \u03c3 R\nhp : p.IsSymmetric\nh0\u271d : p \u2260 0\nh0 : \u00accoeff (ofLex (supDegree (\u21d1toLex) p)) p = 0\ni j : \u03c3\nhle : i \u2264 j\nhlt : (ofLex (supDegree (\u21d1toLex) p)) i < (ofLex (supDegree (\u21d1toLex) p)) j\n\u22a2 coeff (?m.80243 i j hle hlt) p \u2260 0",["assumption","congr","tauto"]],["Analysis/CStarAlgebra/Module/Constructions.lean",78,"A : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\nx y : A\n\u22a2 star (inner x y) = inner y x",["simp","aesop","norm_num"]],["Probability/Process/Filtration.lean",66,"case mk.mk\n\u03a9 : Type u_1\n\u03b9 : Type u_3\nm : MeasurableSpace \u03a9\ninst\u271d : Preorder \u03b9\nseq\u271d\u00b9 : \u03b9 \u2192 MeasurableSpace \u03a9\nmono'\u271d\u00b9 : Monotone seq\u271d\u00b9\nle'\u271d\u00b9 : \u2200 (i : \u03b9), seq\u271d\u00b9 i \u2264 m\nseq\u271d : \u03b9 \u2192 MeasurableSpace \u03a9\nmono'\u271d : Monotone seq\u271d\nle'\u271d : \u2200 (i : \u03b9), seq\u271d i \u2264 m\nh : \u2191{ seq := seq\u271d\u00b9, mono' := mono'\u271d\u00b9, le' := le'\u271d\u00b9 } = \u2191{ seq := seq\u271d, mono' := mono'\u271d, le' := le'\u271d }\n\u22a2 { seq := seq\u271d\u00b9, mono' := mono'\u271d\u00b9, le' := le'\u271d\u00b9 } = { seq := seq\u271d, mono' := mono'\u271d, le' := le'\u271d }",["congr","aesop"]],["Data/Nat/Prime/Defs.lean",210,"n a\u271d : \u2115\nk : \u2115 := a\u271d\nh\u271d\u00b9 : \u00acn < k * k\nh\u271d : \u00ack \u2223 n\n\u22a2 \u00acn < k * k",["assumption","omega","aesop","congr","tauto"]],["Data/Nat/Prime/Defs.lean",255,"case neg.inl\nn : \u2115\nn2 : 2 \u2264 n\nx\u271d : \u2115\nk : \u2115 := x\u271d\ni : \u2115\ne : x\u271d = 2 * i + 3\na : \u2200 (m : \u2115), 2 \u2264 m \u2192 m \u2223 n \u2192 x\u271d \u2264 m\nh : \u00acn < k * k\nk2 : 2 \u2264 k\ndk : \u00ack \u2223 n\nthis : n.sqrt - k < n.sqrt + 2 - k\nm2 : 2 \u2264 x\u271d\nd : x\u271d \u2223 n\n\u22a2 k + 2 \u2264 x\u271d",["contradiction","aesop","tauto"]],["Data/Nat/Prime/Defs.lean",262,"n : \u2115\nn2 : 2 \u2264 n\nx\u271d : \u2115\nk : \u2115 := x\u271d\ni : \u2115\ne : x\u271d = 2 * i + 3\na : \u2200 (m : \u2115), 2 \u2264 m \u2192 m \u2223 n \u2192 x\u271d \u2264 m\nh : \u00acn < k * k\nk2 : 2 \u2264 k\ndk : \u00ack \u2223 n\nthis\u271d : n.sqrt - k < n.sqrt + 2 - k\nm : \u2115\nm2 : 2 \u2264 m\nd : (2 * i + 3).succ \u2223 n\nml : x\u271d < m\nme : x\u271d.succ = m\nd' : 2 * (i + 2) \u2223 n\nthis : 2 * i + 3 \u2264 2\n\u22a2 \u00ac2 * i + 3 \u2264 2",["contradiction"]],["Data/Nat/Prime/Defs.lean",124,"case zero\np : \u2115\nh : 2 \u2264 0 \u2192 0 < p \u2192 \u00ac0 \u2223 p\nl : 0 < p\nd : 0 \u2223 p\n\u22a2 2 \u2264 0 \u2192 0 = 1",["decide","omega","aesop","tauto","simp"]],["Data/Nat/Prime/Defs.lean",162,"\u22a2 Prime 2",["decide"]],["Data/Nat/Prime/Defs.lean",164,"\u22a2 Prime 3",["decide"]],["Data/Nat/Prime/Defs.lean",166,"\u22a2 Prime 5",["decide"]],["Data/Nat/Prime/Defs.lean",168,"\u22a2 Prime 7",["decide"]],["Data/Nat/Prime/Defs.lean",170,"\u22a2 Prime 11",["decide"]],["Data/Nat/Prime/Defs.lean",188,"n k : \u2115\nh : \u00acn < k * k\n\u22a2 0 < 2",["decide","omega","aesop","tauto","simp"]],["Data/Nat/Prime/Defs.lean",338,"n : \u2115\npos : 0 < n\nnp : \u00acPrime n\nh0 : n = n.minFac * 0\n\u22a2 \u00ac0 < 0",["decide","omega","tauto","simp"]],["Order/Chain.lean",314,"case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LE \u03b1\ns t : Flag \u03b1\na : \u03b1\ncarrier\u271d\u00b9 : Set \u03b1\nChain'\u271d\u00b9 : IsChain (fun x1 x2 \u21a6 x1 \u2264 x2) carrier\u271d\u00b9\nmax_chain'\u271d\u00b9 : \u2200 \u2983s : Set \u03b1\u2984, IsChain (fun x1 x2 \u21a6 x1 \u2264 x2) s \u2192 carrier\u271d\u00b9 \u2286 s \u2192 carrier\u271d\u00b9 = s\ncarrier\u271d : Set \u03b1\nChain'\u271d : IsChain (fun x1 x2 \u21a6 x1 \u2264 x2) carrier\u271d\nmax_chain'\u271d : \u2200 \u2983s : Set \u03b1\u2984, IsChain (fun x1 x2 \u21a6 x1 \u2264 x2) s \u2192 carrier\u271d \u2286 s \u2192 carrier\u271d = s\nh :\n  { carrier := carrier\u271d\u00b9, Chain' := Chain'\u271d\u00b9, max_chain' := max_chain'\u271d\u00b9 }.carrier =\n    { carrier := carrier\u271d, Chain' := Chain'\u271d, max_chain' := max_chain'\u271d }.carrier\n\u22a2 { carrier := carrier\u271d\u00b9, Chain' := Chain'\u271d\u00b9, max_chain' := max_chain'\u271d\u00b9 } =\n    { carrier := carrier\u271d, Chain' := Chain'\u271d, max_chain' := max_chain'\u271d }",["congr","aesop"]],["Data/Int/GCD.lean",411,"\u03b1 : Type u_1\ninst\u271d : CommGroupWithZero \u03b1\nm n : \u2115\nhmn : m.Coprime n\na : \u03b1\n\u22a2 (\u2203 y c, y = c ^ m \u2227 a = c ^ n) \u2194 \u2203 y, y ^ n = a",["aesop","omega","tauto","infer_instance"]],["Data/List/AList.lean",60,"\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nl\u2081 : List (Sigma \u03b2)\nh\u2081 : l\u2081.NodupKeys\nl\u2082 : List (Sigma \u03b2)\nnodupKeys\u271d : l\u2082.NodupKeys\nH : { entries := l\u2081, nodupKeys := h\u2081 }.entries = { entries := l\u2082, nodupKeys := nodupKeys\u271d }.entries\n\u22a2 { entries := l\u2081, nodupKeys := h\u2081 } = { entries := l\u2082, nodupKeys := nodupKeys\u271d }",["congr","aesop"]],["Geometry/Manifold/IsManifold/InteriorBoundary.lean",294,"\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2074 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : ChartedSpace H M\nM' : Type u_5\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H M'\np : M \u2295 M'\nhp : \u00acI.IsBoundaryPoint p\nhleft : p.isLeft = true\nx : M := p.getLeft hleft\nh : I.IsBoundaryPoint x\n\u22a2 IsBoundaryPoint ?m.61797 x",["tauto","aesop","congr","gcongr","assumption"]],["Geometry/Manifold/IsManifold/InteriorBoundary.lean",307,"\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2074 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : ChartedSpace H M\nM' : Type u_5\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H M'\np : M \u2295 M'\nhp : I.IsInteriorPoint p\nhright : p.isRight = true\nx : M' := p.getRight hright\nh : \u00acI.IsInteriorPoint x\nthis : I.IsInteriorPoint x \u2228 I.IsBoundaryPoint x\n\u22a2 I.IsBoundaryPoint x",["tauto","aesop"]],["NumberTheory/GaussSum.lean",305,"case refine_1\nF : Type u_1\ninst\u271d\u00b9 : Fintype F\ninst\u271d : Field F\nhF : ringChar F \u2260 2\nhp2 : \u2200 (n : \u2115), 2 ^ n \u2260 0\nn : \u2115+\nhp : Nat.Prime (ringChar F)\nhc : Fintype.card F = ringChar F ^ \u2191n\nFF : Type u_1 := CyclotomicField 8 F\nhchar : ringChar F = ringChar FF\nFFp : Nat.Prime (ringChar FF)\nthis : Fact (Nat.Prime (ringChar FF))\nhFF : ringChar FF \u2260 2\nhu : IsUnit \u2191(ringChar FF)\n\u03c8\u2088 : PrimitiveAddChar (ZMod \u21918) F := primitiveZModChar 8 F \u22ef\n\u03c8\u2088char : AddChar (ZMod 8) FF := \u03c8\u2088.char\n\u03c4 : FF := \u03c8\u2088char 1\n\u22a2 (4 * 2) \u2022 1 = 0",["decide","aesop","congr","tauto","abel"]],["NumberTheory/GaussSum.lean",307,"case refine_2\nF : Type u_1\ninst\u271d\u00b9 : Fintype F\ninst\u271d : Field F\nhF : ringChar F \u2260 2\nhp2 : \u2200 (n : \u2115), 2 ^ n \u2260 0\nn : \u2115+\nhp : Nat.Prime (ringChar F)\nhc : Fintype.card F = ringChar F ^ \u2191n\nFF : Type u_1 := CyclotomicField 8 F\nhchar : ringChar F = ringChar FF\nFFp : Nat.Prime (ringChar FF)\nthis : Fact (Nat.Prime (ringChar FF))\nhFF : ringChar FF \u2260 2\nhu : IsUnit \u2191(ringChar FF)\n\u03c8\u2088 : PrimitiveAddChar (ZMod \u21918) F := primitiveZModChar 8 F \u22ef\n\u03c8\u2088char : AddChar (ZMod 8) FF := \u03c8\u2088.char\n\u03c4 : FF := \u03c8\u2088char 1\n\u22a2 \u00ac4 \u2022 1 = 0",["decide","tauto"]],["Algebra/GroupWithZero/Basic.lean",165,"M\u2080 : Type u_1\ninst\u271d : MonoidWithZero M\u2080\na b : M\u2080\nm n : \u2115\nhmn : m \u2264 n\nh : a ^ m * b = 0\n\u22a2 a ^ (n - m) * 0 = 0",["simp","aesop"]],["Algebra/GroupWithZero/Basic.lean",384,"G\u2080 : Type u_2\ninst\u271d : GroupWithZero G\u2080\na : G\u2080\nh : 0 \u2260 0\nha : a = 0\n\u22a2 False",["contradiction","aesop"]],["Data/Multiset/UnionInter.lean",175,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns t : Multiset \u03b1\n\u22a2 a ::\u2098 s \u2229 t = (a ::\u2098 s) \u2229 (a ::\u2098 t)",["simp","aesop"]],["Data/Multiset/UnionInter.lean",302,"\u03b1 : Type u_1\ns t u : Multiset \u03b1\n\u22a2 _root_.Disjoint t s \u2227 _root_.Disjoint u s \u2194 _root_.Disjoint s t \u2227 _root_.Disjoint s u",["tauto"]],["Data/Multiset/UnionInter.lean",312,"\u03b1 : Type u_1\na : \u03b1\ns t : Multiset \u03b1\n\u22a2 a \u2209 s \u2227 _root_.Disjoint t s \u2194 a \u2209 s \u2227 _root_.Disjoint s t",["tauto"]],["Algebra/BigOperators/Ring/Finset.lean",92,"\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\n\u22a2 \u2211 j \u2208 s, (if i = j then 1 else 0) * f j = if i \u2208 s then f i else 0",["simp","aesop"]],["Algebra/BigOperators/Ring/Finset.lean",175,"\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 (a : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop),\n    (\u2200 (a_1 : \u03b9) (h : a_1 \u2208 s), a a_1 h = True \u2228 a a_1 h \u2208 {False}) \u2192\n      \u2200 (x : \u03b9) (x_1 : x \u2208 s), (x \u2208 s \u2227 \u2203 (h : x \u2208 s), a x h) \u2194 a x x_1",["tauto","aesop"]],["Algebra/BigOperators/Ring/Finset.lean",176,"\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 a \u2286 s, \u2200 (a_1 : \u03b9), (a_1 \u2208 s \u2227 \u2203 (_ : a_1 \u2208 s), a_1 \u2208 a) \u2194 a_1 \u2208 a",["tauto"]],["Algebra/Lie/Derivation/Basic.lean",368,"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nx : L\nD\u2081 D\u2082 : LieDerivation R L M\n\u22a2 \u2045x, D\u2081 + D\u2082\u2046 = \u2045x, D\u2081\u2046 + \u2045x, D\u2082\u2046",["simp","aesop","norm_num"]],["Algebra/Lie/Derivation/Basic.lean",363,"case H\nR : Type u_1\nL : Type u_2\nM : Type u_3\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nt : R\nm : M\na\u271d : L\n\u22a2 ({\n            toFun := fun m \u21a6\n              let __spread.0 := (\u2191(LieModule.toEnd R L M)).flip m;\n              { toLinearMap := __spread.0, leibniz' := \u22ef },\n            map_add' := \u22ef }.toFun\n        (t \u2022 m))\n      a\u271d =\n    ((RingHom.id R) t \u2022\n        {\n              toFun := fun m \u21a6\n                let __spread.0 := (\u2191(LieModule.toEnd R L M)).flip m;\n                { toLinearMap := __spread.0, leibniz' := \u22ef },\n              map_add' := \u22ef }.toFun\n          m)\n      a\u271d",["simp","aesop","norm_num"]],["Algebra/Lie/Derivation/Basic.lean",367,"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nx y : L\nD : LieDerivation R L M\n\u22a2 \u2045x + y, D\u2046 = \u2045x, D\u2046 + \u2045y, D\u2046",["simp","omega","aesop","norm_num"]],["Algebra/Lie/Derivation/Basic.lean",377,"case h\nR : Type u_1\nL : Type u_2\nM : Type u_3\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nx : L\nD : LieDerivation R L M\nx\u271d : L\n\u22a2 \u2045x, \u2191D\u2046 x\u271d = \u2191\u2045x, D\u2046 x\u271d",["simp","aesop","norm_num"]],["CategoryTheory/FiberedCategory/Cartesian.lean",341,"\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} \ud835\udcae\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} \ud835\udcb3\np : \ud835\udcb3 \u2964 \ud835\udcae\nR S : \ud835\udcae\na b : \ud835\udcb3\nf : R \u27f6 S\n\u03c6 : a \u27f6 b\ninst\u271d\u00b9 : p.IsHomLift f \u03c6\ninst\u271d : IsIso \u03c6\n\u22a2 p.IsHomLift f (asIso \u03c6).hom",["aesop","congr","tauto","assumption"]],["Algebra/CharP/Defs.lean",338,"case zero\nR : Type u_1\ninst\u271d\u00b9 : AddMonoidWithOne R\np : \u2115\nhp : CharP R p\ninst\u271d : CharZero R\n\u22a2 0 = 1 \u2194 Nat.Prime 0",["decide","aesop","tauto"]],["Geometry/RingedSpace/LocallyRingedSpace/HasColimits.lean",75,"\u03b9 : Type v\ninst\u271d : Small.{u, v} \u03b9\nF : Discrete \u03b9 \u2964 LocallyRingedSpace\nx\u271d\u00b2 x\u271d\u00b9 : Discrete \u03b9\nj : \u03b9\nx\u271d : { as := j } \u27f6 { as := j }\n\u22a2 F.map { down := { down := \u22ef } } \u226b (fun j \u21a6 { toHom := colimit.\u03b9 (F \u22d9 forgetToSheafedSpace) j, prop := \u22ef }) { as := j } =\n    (fun j \u21a6 { toHom := colimit.\u03b9 (F \u22d9 forgetToSheafedSpace) j, prop := \u22ef }) { as := j } \u226b\n      ((Functor.const (Discrete \u03b9)).obj (coproduct F)).map { down := { down := \u22ef } }",["simp","aesop","norm_num"]],["Geometry/RingedSpace/LocallyRingedSpace/HasColimits.lean",300,"case create.refine_2.right.h.zero\nX Y : LocallyRingedSpace\nf g : X \u27f6 Y\ns : Cofork f g\ne : Hom.toShHom f \u226b Hom.toShHom s.\u03c0 = Hom.toShHom g \u226b Hom.toShHom s.\u03c0\nm :\n  ((Functor.const WalkingParallelPair).obj (coequalizerCofork f g).pt).obj WalkingParallelPair.one \u27f6\n    ((Functor.const WalkingParallelPair).obj s.pt).obj WalkingParallelPair.one\nh : Hom.toShHom (coequalizerCofork f g).\u03c0 \u226b m.toHom = Hom.toShHom s.\u03c0\n\u22a2 (parallelPair (Hom.toShHom f) (Hom.toShHom g)).map WalkingParallelPairHom.left \u226b\n      (colimit.cocone (parallelPair (Hom.toShHom f) (Hom.toShHom g))).\u03b9.app WalkingParallelPair.one \u226b m.toHom =\n    Hom.toShHom f \u226b Hom.toShHom s.\u03c0",["congr","tauto"]],["Testing/Plausible/Functions.lean",269,"case neg\n\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nh\u2080 : xs.Nodup\nh\u2081 : xs ~ ys\nx y : \u03b1\nh : applyId (xs.zip ys) x = applyId (xs.zip ys) y\nhx : applyId (xs.zip ys) y \u2208 ys\nhy : applyId (xs.zip ys) y \u2209 ys\n\u22a2 x = y",["contradiction","aesop","tauto"]],["Testing/Plausible/Functions.lean",272,"case pos\n\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nh\u2080 : xs.Nodup\nh\u2081 : xs ~ ys\nx y : \u03b1\nh : applyId (xs.zip ys) x = applyId (xs.zip ys) y\nhx : applyId (xs.zip ys) y \u2209 ys\nhy : applyId (xs.zip ys) y \u2208 ys\n\u22a2 x = y",["contradiction"]],["Testing/Plausible/Functions.lean",230,"\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nx val x' : \u03b1\nxs : List \u03b1\ny : \u03b1\nys : List \u03b1\nh\u2081 : (x' :: xs).length = (y :: ys).length\nh : \u00acx' = x\nh\u2083 : dlookup x (map Prod.toSigma (xs.zip ys)) = some val\nh\u2085 : List.Pairwise (fun x1 x2 \u21a6 x1 \u2260 x2) xs\nh\u2080 : \u2200 a' \u2208 xs, x' \u2260 a'\nh\u2084 : List.Pairwise (fun x1 x2 \u21a6 x1 \u2260 x2) ys\nh\u2082 : \u2200 a' \u2208 ys, y \u2260 a'\nh\u2086 : xs.length = ys.length\nxs_ih : val \u2208 ys \u2194 x \u2208 xs\nthis : val \u2208 ys\n\u22a2 val = y \u2228 x \u2208 xs \u2194 False \u2228 x \u2208 xs",["tauto","aesop"]],["Order/Directed.lean",166,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\nr r' s : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : IsDirected \u03b1 fun x1 x2 \u21a6 x1 \u2264 x2\n\u22a2 IsDirected \u03b1\u1d52\u1d48 fun x1 x2 \u21a6 x1 \u2265 x2",["assumption","aesop","congr","tauto"]],["Order/Directed.lean",169,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\nr r' s : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : IsDirected \u03b1 fun x1 x2 \u21a6 x1 \u2265 x2\n\u22a2 IsDirected \u03b1\u1d52\u1d48 fun x1 x2 \u21a6 x1 \u2264 x2",["assumption","aesop","congr","tauto"]],["Analysis/CStarAlgebra/ApproximateUnit.lean",59,"A : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na b : A\nhab : \u2191a \u2264 \u2191b\nha : 0 \u2264 \u2191a\nhb : 0 \u2264 \u2191b\nc : Unitization \u2102 A\nhc : autoParam (0 \u2264 c) _auto\u271d\nx : \u211d\u22650\nx\u271d : x \u2208 \u03c3 \u211d\u22650 c\n\u22a2 1 + x \u2260 0",["positivity","aesop","norm_num","simp"]],["Analysis/CStarAlgebra/ApproximateUnit.lean",80,"A : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\nx : \u211d\u22650\nx\u271d : x \u2208 \u03c3\u2099 \u211d\u22650 a\n\u22a2 0 < (1 + x)\u207b\u00b9",["positivity","aesop","norm_num","simp"]],["Analysis/CStarAlgebra/ApproximateUnit.lean",257,"A : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\nm\u271d\u00b9 m\u271d : A\n\u03b5 : \u211d\u22650\nh\u03b5 : 0 < \u03b5\nx\u271d\u00b2 : A\nx m : Unitization \u2102 A\nhm\u2081 : 0 \u2264 m\nhm\u2082 : \u2016m\u2016 < 1\nhx\u2082 : \u2016x\u2016 \u2264 1\nhx\u2080 : 0 \u2264 x\ng : \u211d\u22650 \u2192 \u211d\u22650 := fun y \u21a6 1 - (1 + y)\u207b\u00b9\nhx\u2081 : cfc g (\u03b5\u207b\u00b9 ^ 2 \u2022 m) \u2264 x\nhg : Continuous g\nx\u271d\u00b9 : \u211d\u22650\nx\u271d : x\u271d\u00b9 \u2208 \u03c3 \u211d\u22650 m\n\u22a2 1 + \u03b5\u207b\u00b9 ^ 2 \u2022 x\u271d\u00b9 \u2260 0",["positivity","aesop","norm_num","simp"]],["Topology/ContinuousMap/ContinuousMapZero.lean",356,"X : Type u_1\nY : Type u_2\nM : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9\u2078 : Zero X\ninst\u271d\u00b9\u2077 : Zero Y\ninst\u271d\u00b9\u2076 : CommSemiring M\ninst\u271d\u00b9\u2075 : TopologicalSpace X\ninst\u271d\u00b9\u2074 : TopologicalSpace Y\ninst\u271d\u00b9\u00b3 : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : TopologicalSpace S\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : StarRing R\ninst\u271d\u2079 : IsTopologicalSemiring R\ninst\u271d\u2078 : ContinuousStar R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : StarRing S\ninst\u271d\u2075 : IsTopologicalSemiring S\ninst\u271d\u2074 : ContinuousStar S\ninst\u271d\u00b3 : Module M R\ninst\u271d\u00b2 : Module M S\ninst\u271d\u00b9 : ContinuousConstSMul M R\ninst\u271d : ContinuousConstSMul M S\n\u03c6 : R \u2192\u22c6\u2099\u2090[M] S\nh\u03c6 : Continuous \u21d1\u03c6\nx\u271d\u00b9 x\u271d : C(X, R)\u2080\n\u22a2 \u2200 (x : X),\n    ({ toFun := { toFun := \u21d1\u03c6, continuous_toFun := h\u03c6, map_zero' := \u22ef }.comp, map_smul' := \u22ef, map_zero' := \u22ef,\n              map_add' := \u22ef }.toFun\n          (x\u271d\u00b9 * x\u271d))\n        x =\n      ({ toFun := { toFun := \u21d1\u03c6, continuous_toFun := h\u03c6, map_zero' := \u22ef }.comp, map_smul' := \u22ef, map_zero' := \u22ef,\n                map_add' := \u22ef }.toFun\n            x\u271d\u00b9 *\n          { toFun := { toFun := \u21d1\u03c6, continuous_toFun := h\u03c6, map_zero' := \u22ef }.comp, map_smul' := \u22ef, map_zero' := \u22ef,\n                map_add' := \u22ef }.toFun\n            x\u271d)\n        x",["simp","aesop","norm_num"]],["AlgebraicGeometry/ValuativeCriterion.lean",332,"case h.h.h.a\nX Y : Scheme\nf : X \u27f6 Y\n\u22a2 ValuativeCriterion.Uniqueness f \u2227\n      QuasiSeparated f \u2227 ValuativeCriterion.Existence f \u2227 QuasiCompact f \u2227 LocallyOfFiniteType f \u2194\n    ValuativeCriterion.Existence f \u2227\n      ValuativeCriterion.Uniqueness f \u2227 QuasiCompact f \u2227 QuasiSeparated f \u2227 LocallyOfFiniteType f",["tauto","omega","aesop","infer_instance"]],["Analysis/SpecificLimits/FloorPow.lean",225,"N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < c\u207b\u00b9 ^ 2\n\u22a2 c ^ 3 = c ^ 2 * c",["ring","aesop","congr","linarith","tauto","abel"]],["RingTheory/MvPolynomial/Symmetric/Defs.lean",298,"case refine_1\n\u03c3 : Type u_5\nR : Type u_6\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Fintype \u03c3\ninst\u271d : Nontrivial R\nn : \u2115\nhpos : 0 < n\nhn : n \u2264 Fintype.card \u03c3\nthis : (\u21d1Finsupp.toMultiset \u2218 fun t \u21a6 \u2211 i \u2208 t, Finsupp.single i 1) = val\nx\u271d y\u271d : Finset \u03c3\n\u22a2 x\u271d.val \u222a y\u271d.val = x\u271d.val \u2294 y\u271d.val",["congr","aesop","tauto","abel","norm_num","simp"]],["RingTheory/MvPolynomial/Symmetric/Defs.lean",405,"case h\n\u03c3 : Type u_5\nR : Type u_6\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Fintype \u03c3\ninst\u271d : DecidableEq \u03c3\nthis : (fun x \u21a6 x \u2208 Set.univ) = fun x \u21a6 Nat.Partition.ofSym x = Nat.Partition.indiscrete 1\nx : { x // x \u2208 Set.univ }\n\u22a2 (Multiset.map X \u2191\u2191x).prod = (Multiset.map X \u2191\u2191((Equiv.subtypeEquivProp this) x)).prod",["congr","aesop","tauto","abel"]],["RingTheory/MvPolynomial/Symmetric/Defs.lean",408,"\u03c3 : Type u_5\nR : Type u_6\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Fintype \u03c3\ninst\u271d : DecidableEq \u03c3\nthis : (fun x \u21a6 x \u2208 Set.univ) = fun x \u21a6 Nat.Partition.ofSym x = Nat.Partition.indiscrete 1\nx : \u03c3\n\u22a2 (Multiset.map X {x}).prod = (Multiset.map X \u2191\u2191((Sym.oneEquiv.trans (Equiv.Set.univ (Sym \u03c3 1)).symm) x)).prod",["congr"]],["RingTheory/Polynomial/Cyclotomic/Eval.lean",277,"q : \u211d\nhq' : 1 < q\n\u22a2 eval q (cyclotomic 0 \u211d) \u2264 (q + 1) ^ \u03c6 0",["simp","aesop","norm_num"]],["RingTheory/Polynomial/Cyclotomic/Eval.lean",112,"R : Type u_1\ninst\u271d : LinearOrderedCommRing R\nx : R\nn : \u2115\na\u271d : 1 < x\n\u22a2 2 < n + 1 + 1 + 1\n```\n---\n```lean\nR : Type u_1\ninst\u271d : LinearOrderedCommRing R\nx : R\nn : \u2115\na\u271d : 1 \u2264 x\n\u22a2 2 < n + 1 + 1 + 1",["omega","aesop","linarith","norm_num","simp"]],["Data/Set/NAry.lean",111,"\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\n\u22a2 \u2200 (x : \u03b3), x \u2208 image2 f s \u2205 \u2194 x \u2208 \u2205",["simp","aesop"]],["Data/Set/NAry.lean",179,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\n\u03b4 : Type u_7\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b3 \u2192 \u03b4\ng : \u03b2 \u2192 \u03b3\nx\u271d : \u03b4\n\u22a2 x\u271d \u2208 image2 f s (g '' t) \u2194 x\u271d \u2208 image2 (fun a b \u21a6 f a (g b)) s t",["simp","aesop"]],["Data/Set/NAry.lean",55,"\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\np : \u03b3 \u2192 Prop\n\u22a2 (\u2203 z \u2208 image2 f s t, p z) \u2194 \u2203 x \u2208 s, \u2203 y \u2208 t, p (f x y)",["aesop","simp"]],["Data/Nat/Totient.lean",242,"\u22a2 \u03c6 1 = 1 \u2194 1 = 1 \u2228 1 = 2",["simp","decide","aesop","tauto","norm_num"]],["Data/Nat/Totient.lean",241,"\u22a2 \u03c6 0 = 1 \u2194 0 = 1 \u2228 0 = 2",["simp","omega","decide","aesop","tauto","norm_num"]],["Data/Nat/Totient.lean",233,"case inl\ninst\u271d : Fintype (ZMod 0)\u02e3\n\u22a2 Fintype.card \u2124\u02e3 \u2260 0",["simp","decide","aesop","tauto","norm_num"]],["Data/Nat/Totient.lean",60,"\u22a2 \u03c6 0 = 0 \u2194 0 = 0",["decide","aesop","tauto","norm_num","simp"]],["Topology/DiscreteQuotient.lean",78,"X : Type u_2\ninst\u271d : TopologicalSpace X\ntoSetoid\u271d\u00b9 : Setoid X\nisOpen_setOf_rel\u271d\u00b9 : \u2200 (x : X), IsOpen (setOf (toSetoid\u271d\u00b9 x))\ntoSetoid\u271d : Setoid X\nisOpen_setOf_rel\u271d : \u2200 (x : X), IsOpen (setOf (toSetoid\u271d x))\nx\u271d :\n  { toSetoid := toSetoid\u271d\u00b9, isOpen_setOf_rel := isOpen_setOf_rel\u271d\u00b9 }.toSetoid =\n    { toSetoid := toSetoid\u271d, isOpen_setOf_rel := isOpen_setOf_rel\u271d }.toSetoid\n\u22a2 { toSetoid := toSetoid\u271d\u00b9, isOpen_setOf_rel := isOpen_setOf_rel\u271d\u00b9 } =\n    { toSetoid := toSetoid\u271d, isOpen_setOf_rel := isOpen_setOf_rel\u271d }",["congr","aesop"]],["Topology/DiscreteQuotient.lean",147,"\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nS a : DiscreteQuotient X\n\u22a2 a \u2264 \u22a4",["tauto"]],["Topology/DiscreteQuotient.lean",177,"X : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : C(X, Y)\nA B : DiscreteQuotient Y\nh : A \u2264 B\n\u22a2 comap f A \u2264 comap f B",["tauto"]],["Topology/DiscreteQuotient.lean",262,"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : C(X, Y)\nA : DiscreteQuotient X\nB : DiscreteQuotient Y\ng : C(Y, Z)\nC : DiscreteQuotient Z\n\u22a2 LEComap g B C \u2192 LEComap f A B \u2192 LEComap (g.comp f) A C",["tauto"]],["CategoryTheory/MorphismProperty/TransfiniteComposition.lean",158,"C : Type u\ninst\u271d\u2079 : Category.{v, u} C\nD : Type u'\ninst\u271d\u2078 : Category.{v', u'} D\nW : MorphismProperty C\nJ : Type w\ninst\u271d\u2077 : LinearOrder J\ninst\u271d\u2076 : SuccOrder J\ninst\u271d\u2075 : OrderBot J\ninst\u271d\u2074 : WellFoundedLT J\nJ' : Type w'\ninst\u271d\u00b3 : LinearOrder J'\ninst\u271d\u00b2 : SuccOrder J'\ninst\u271d\u00b9 : OrderBot J'\ninst\u271d : WellFoundedLT J'\nX : C\n\u22a2 \u2200 (i : Fin 0), W ((ComposableArrows.mk\u2080 X).map (homOfLE \u22ef))",["simp"]],["CategoryTheory/MorphismProperty/TransfiniteComposition.lean",166,"case \u00ab0\u00bb\nC : Type u\ninst\u271d\u2079 : Category.{v, u} C\nD : Type u'\ninst\u271d\u2078 : Category.{v', u'} D\nW : MorphismProperty C\nJ : Type w\ninst\u271d\u2077 : LinearOrder J\ninst\u271d\u2076 : SuccOrder J\ninst\u271d\u2075 : OrderBot J\ninst\u271d\u2074 : WellFoundedLT J\nJ' : Type w'\ninst\u271d\u00b3 : LinearOrder J'\ninst\u271d\u00b2 : SuccOrder J'\ninst\u271d\u00b9 : OrderBot J'\ninst\u271d : WellFoundedLT J'\nX Y : C\nf : X \u27f6 Y\nhf : W f\n\u22a2 W ((ComposableArrows.mk\u2081 f).map (homOfLE \u22ef))",["assumption","aesop","congr","tauto"]],["Analysis/SpecialFunctions/ContinuousFunctionalCalculus/PosPart/Basic.lean",323,"A : Type u_1\ninst\u271d\u2075 : Ring A\ninst\u271d\u2074 : Algebra \u211d A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : TopologicalSpace A\ninst\u271d\u00b9 : ContinuousFunctionalCalculus \u211d IsSelfAdjoint\ninst\u271d : T2Space A\n\u22a2 cfc (fun x \u21a6 x\u207a) 1 = 1",["simp","aesop","norm_num"]],["RingTheory/NoetherNormalization.lean",119,"k : Type u_1\ninst\u271d : Field k\nn : \u2115\nf : MvPolynomial (Fin (n + 1)) k\nv w : Fin (n + 1) \u2192\u2080 \u2115\nhv : v \u2208 f.support\nhw : w \u2208 f.support\nneq : v \u2260 w\ni : Fin (n + 1)\n\u22a2 f.totalDegree < up\n```\n---\n```lean\nk : Type u_1\ninst\u271d : Field k\nn : \u2115\nf : MvPolynomial (Fin (n + 1)) k\nv w : Fin (n + 1) \u2192\u2080 \u2115\nhv : v \u2208 f.support\nhw : w \u2208 f.support\nneq : v \u2260 w\ni : Fin (n + 1)\n\u22a2 f.totalDegree < up",["omega","aesop","linarith","norm_num","simp"]],["Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean",255,"case e_f\nA : Type u_1\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : TopologicalSpace A\ninst\u271d\u00b9 : Algebra \u211d A\ninst\u271d : ContinuousFunctionalCalculus \u211d\u22650 fun a \u21a6 0 \u2264 a\na : A\nn : \u2115\nha : autoParam (0 \u2264 a) _auto\u271d\n\u22a2 (fun x \u21a6 x ^ \u2191n) = fun x \u21a6 x ^ n",["simp","aesop","norm_num"]],["AlgebraicGeometry/PullbackCarrier.lean",313,"case h.refine_1.intro\nX Y S : Scheme\nf : X \u27f6 S\ng : Y \u27f6 S\na : \u2191\u2191(pullback f g).toPresheafedSpace\n\u22a2 \u2203 y, (ConcreteCategory.hom f.base) y = (ConcreteCategory.hom (pullback.fst f g \u226b f).base) a",["simp","aesop","tauto","norm_num"]],["AlgebraicGeometry/PullbackCarrier.lean",145,"X Y S : Scheme\nf : X \u27f6 S\ng : Y \u27f6 S\nT : Triplet f g\np : \u2191\u2191(Spec T.tensor).toPresheafedSpace\n\u22a2 (ConcreteCategory.hom\n        (pullback.lift (Spec.map T.tensorInl \u226b X.fromSpecResidueField T.x)\n              (Spec.map T.tensorInr \u226b Y.fromSpecResidueField T.y) \u22ef \u226b\n            pullback.fst f g).base)\n      p =\n    T.x",["simp","aesop","norm_num"]],["Algebra/MvPolynomial/Monad.lean",343,"\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_3\nS : Type u_4\nT : Type u_5\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : CommSemiring T\nf : \u03c3 \u2192 MvPolynomial \u03c4 R\n\u22a2 \u2200 {\u03b1 \u03b2 : Type u_6} (f : \u03b1 \u2192 \u03b2) (x : MvPolynomial \u03b1 R),\n    (do\n        let a \u2190 x\n        pure (f a)) =\n      f <$> x",["aesop","tauto"]],["Algebra/Polynomial/UnitTrinomial.lean",186,"case refine_1.intro.intro.intro.intro.intro.intro.intro.intro\nk m n : \u2115\nhkm : k < m\nhmn : m < n\nu v w : \u2124\u02e3\n\u22a2 1 + (1 + 1) = 3",["decide","ring","omega","aesop","congr","linarith","tauto","norm_num","simp"]],["Topology/Sets/Closeds.lean",39,"case mk.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\ncarrier\u271d\u00b9 : Set \u03b1\nclosed'\u271d\u00b9 : IsClosed carrier\u271d\u00b9\ncarrier\u271d : Set \u03b1\nclosed'\u271d : IsClosed carrier\u271d\nh : { carrier := carrier\u271d\u00b9, closed' := closed'\u271d\u00b9 }.carrier = { carrier := carrier\u271d, closed' := closed'\u271d }.carrier\n\u22a2 { carrier := carrier\u271d\u00b9, closed' := closed'\u271d\u00b9 } = { carrier := carrier\u271d, closed' := closed'\u271d }",["congr","aesop"]],["Topology/Sets/Closeds.lean",266,"case mk.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\ncarrier\u271d\u00b9 : Set \u03b1\nisClopen'\u271d\u00b9 : IsClopen carrier\u271d\u00b9\ncarrier\u271d : Set \u03b1\nisClopen'\u271d : IsClopen carrier\u271d\nh :\n  (fun s \u21a6 s.carrier) { carrier := carrier\u271d\u00b9, isClopen' := isClopen'\u271d\u00b9 } =\n    (fun s \u21a6 s.carrier) { carrier := carrier\u271d, isClopen' := isClopen'\u271d }\n\u22a2 { carrier := carrier\u271d\u00b9, isClopen' := isClopen'\u271d\u00b9 } = { carrier := carrier\u271d, isClopen' := isClopen'\u271d }",["congr","aesop"]],["Topology/Sets/Closeds.lean",348,"case mk.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\ncarrier\u271d\u00b9 : Set \u03b1\nis_irreducible'\u271d\u00b9 : IsIrreducible carrier\u271d\u00b9\nis_closed'\u271d\u00b9 : IsClosed carrier\u271d\u00b9\ncarrier\u271d : Set \u03b1\nis_irreducible'\u271d : IsIrreducible carrier\u271d\nis_closed'\u271d : IsClosed carrier\u271d\nh :\n  { carrier := carrier\u271d\u00b9, is_irreducible' := is_irreducible'\u271d\u00b9, is_closed' := is_closed'\u271d\u00b9 }.carrier =\n    { carrier := carrier\u271d, is_irreducible' := is_irreducible'\u271d, is_closed' := is_closed'\u271d }.carrier\n\u22a2 { carrier := carrier\u271d\u00b9, is_irreducible' := is_irreducible'\u271d\u00b9, is_closed' := is_closed'\u271d\u00b9 } =\n    { carrier := carrier\u271d, is_irreducible' := is_irreducible'\u271d, is_closed' := is_closed'\u271d }",["congr","aesop"]],["Analysis/NormedSpace/OperatorNorm/NormedSpace.lean",196,"case inl\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nF : Type u_5\nG : Type u_7\ninst\u271d\u00b9\u2076 : NormedAddCommGroup F\ninst\u271d\u00b9\u2075 : NormedAddCommGroup G\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c\u2083 G\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_8\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_9\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Subsingleton F'\nthis : Subsingleton F\n\u22a2 \u2016f.comp g.toLinearIsometry.toContinuousLinearMap\u2016 = \u2016f\u2016",["simp","aesop","norm_num"]],["Analysis/NormedSpace/OperatorNorm/NormedSpace.lean",155,"\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\nE : Type u_4\nF : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] F\n\u22a2 \u2200 (x : E), \u2016f.toContinuousLinearMap x\u2016 = 1 * \u2016x\u2016",["simp","aesop","norm_num"]],["Analysis/NormedSpace/OperatorNorm/NormedSpace.lean",261,"case inl.h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\nE : Type u_4\nF : Type u_5\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedAddCommGroup F\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2081 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082\u2081\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\ne : E \u2243SL[\u03c3\u2081\u2082] F\n_i : Subsingleton E\n\u22a2 Subsingleton E",["infer_instance","aesop","congr","tauto","assumption"]],["Analysis/Fourier/RiemannLebesgueLemma.lean",139,"E : Type u_1\nV : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u2102 E\nf : V \u2192 E\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : MeasurableSpace V\ninst\u271d\u00b2 : BorelSpace V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nhf1 : Continuous f\nhf2 : HasCompactSupport f\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nR : \u211d\nhR_bd : \u2200 (x : V), R \u2264 \u2016x\u2016 \u2192 f x = 0\nA : Set V := {v | \u2016v\u2016 \u2264 R + 1}\nmA : MeasurableSet A\nB : \u211d\u22650\nhB_pos : 0 < B\nhB_vol : volume A \u2264 \u2191B\n\u03b4 : \u211d\nh\u03b41 : \u03b4 > 0\nh\u03b42 : \u2200 \u2983a b : V\u2984, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5 / \u2191B\nw : V\nhw_bd : 1 / 2 + 1 / (2 * \u03b4) \u2264 \u2016w\u2016\nhw_ne : w \u2260 0\nhw'_nm : \u2016i w\u2016 = 1 / (2 * \u2016w\u2016)\n\u22a2 \u20161 / 2\u2016 = 2\u207b\u00b9",["norm_num","aesop","simp"]],["Order/Filter/Ultrafilter/Defs.lean",70,"\u03b1 : Type u\nf : Filter \u03b1\nh\u2081 : f.NeBot\nh\u2082 : \u2200 (g : Filter \u03b1), g.NeBot \u2192 g \u2264 f \u2192 f \u2264 g\ng : Filter \u03b1\nneBot'\u271d : g.NeBot\nle_of_le\u271d : \u2200 (g_1 : Filter \u03b1), g_1.NeBot \u2192 g_1 \u2264 g \u2192 g \u2264 g_1\nx\u271d : \u2191{ toFilter := f, neBot' := h\u2081, le_of_le := h\u2082 } = \u2191{ toFilter := g, neBot' := neBot'\u271d, le_of_le := le_of_le\u271d }\n\u22a2 { toFilter := f, neBot' := h\u2081, le_of_le := h\u2082 } = { toFilter := g, neBot' := neBot'\u271d, le_of_le := le_of_le\u271d }",["congr","aesop"]],["Order/Antisymmetrization.lean",150,"\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 a \u2264 b \u2194 a \u2264 b \u2227 \u00acb \u2264 a \u2228 a \u2264 b \u2227 b \u2264 a",["tauto"]],["Analysis/Analytic/IteratedFDeriv.lean",168,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\np : FormalMultilinearSeries \ud835\udd5c E F\ns : Set E\nx : E\nr : \u211d\u22650\u221e\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : AnalyticOn \ud835\udd5c f s\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nn : \u2115\nv : Fin n \u2192 E\nh's : s \u2286 EMetric.ball x r\nI : insert x s \u2229 EMetric.ball x r = s\nfcont : ContDiffOn \ud835\udd5c (\u2191n) f s\ng : E \u2192 F := fun z \u21a6 (p n) fun x_1 \u21a6 z - x\ngcont : ContDiff \ud835\udd5c \u03c9 g\nq : FormalMultilinearSeries \ud835\udd5c E F := fun k \u21a6 if h : n = k then h \u25b8 p n else 0\nA : HasFiniteFPowerSeriesOnBall g q x (n + 1) r\nB : HasFPowerSeriesWithinOnBall g q s x r\n\u22a2 f = g + (f - g)",["abel","aesop","norm_num","simp"]],["Data/PNat/Factors.lean",45,"\u22a2 Repr (Multiset Nat.Primes)",["infer_instance","tauto"]],["Data/PNat/Factors.lean",117,"v : PrimeMultiset\n\u22a2 Multiset.map (Subtype.val \u2218 Coe.coe) v = Multiset.map Subtype.val v",["congr","aesop","tauto"]],["CategoryTheory/EqToHom.lean",127,"case refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nf g : \u03b2 \u2192 C\nz : (b : \u03b2) \u2192 f b \u27f6 g b\nj : \u03b2\n\u22a2 z j \u226b eqToHom \u22ef = eqToHom \u22ef \u226b z j",["simp","aesop"]],["CategoryTheory/EqToHom.lean",317,"case refl\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nX : C\n\u22a2 F.map (eqToHom \u22ef) = eqToHom \u22ef",["simp","aesop"]],["CategoryTheory/EqToHom.lean",67,"case refl.refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nW X : C\nf g : W \u27f6 X\n\u22a2 f = eqToHom \u22ef \u226b g \u226b eqToHom \u22ef \u2194 HEq f g",["simp","aesop"]],["CategoryTheory/EqToHom.lean",75,"C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y Y' : C\np : Y = Y'\nf : X \u27f6 Y\ng : X \u27f6 Y'\nh : f \u226b eqToHom p = g\n\u22a2 f = (f \u226b eqToHom p) \u226b eqToHom \u22ef",["simp","aesop"]],["CategoryTheory/EqToHom.lean",171,"case refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y : C\np : X \u27f6 Y\n\u22a2 cast \u22ef p = p \u226b eqToHom \u22ef",["simp","aesop"]],["CategoryTheory/EqToHom.lean",283,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : C \u2964 D\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\nhx : F.obj X = G.obj X\nhy : F.obj Y = G.obj Y\nhz : F.obj Z = G.obj Z\nhf : HEq (F.map f) (G.map f)\nhg : HEq (F.map g) (G.map g)\n\u22a2 HEq (F.map f \u226b F.map g) (G.map f \u226b G.map g)",["congr"]],["CategoryTheory/EqToHom.lean",297,"C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\nF G : C \u2964 D\nX Y : C\nf : X \u27f6 Y\nH : D \u2964 E\nhx : F.obj X = G.obj X\nhy : F.obj Y = G.obj Y\nhmap : HEq (F.map f) (G.map f)\n\u22a2 HEq (H.map (F.map f)) (H.map (G.map f))",["congr"]],["Analysis/CStarAlgebra/Module/Defs.lean",101,"A : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : NonUnitalRing A\ninst\u271d\u2079 : StarRing A\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \u2102 A\ninst\u271d\u2076 : Module \u2102 E\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b3 : Norm A\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : StarModule \u2102 A\nz : \u2102\nx y : E\n\u22a2 star (inner y (z \u2022> x)) = star z \u2022> inner x y",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/Module/Defs.lean",105,"A : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : NonUnitalRing A\ninst\u271d\u2079 : StarRing A\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \u2102 A\ninst\u271d\u2076 : Module \u2102 E\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b3 : Norm A\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : StarModule \u2102 A\nz : \u211d\nx y : E\n\u22a2 z \u2022> x = \u2191z \u2022> x",["simp","aesop","congr","tauto","abel","norm_num"]],["Analysis/CStarAlgebra/Module/Defs.lean",92,"A : Type u_1\nE : Type u_2\ninst\u271d\u2079 : NonUnitalRing A\ninst\u271d\u2078 : StarRing A\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : Module \u2102 A\ninst\u271d\u2075 : Module \u2102 E\ninst\u271d\u2074 : PartialOrder A\ninst\u271d\u00b3 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b2 : Norm A\ninst\u271d\u00b9 : Norm E\ninst\u271d : CStarModule A E\na : A\nx y : E\n\u22a2 star (inner y (x <\u2022 a)) = star a * inner x y",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/Module/Defs.lean",111,"A : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : NonUnitalRing A\ninst\u271d\u2079 : StarRing A\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \u2102 A\ninst\u271d\u2076 : Module \u2102 E\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b3 : Norm A\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : StarModule \u2102 A\nz : \u211d\nx y : E\n\u22a2 z \u2022> y = \u2191z \u2022> y",["simp","aesop","congr","tauto","abel","norm_num"]],["Analysis/CStarAlgebra/Module/Defs.lean",107,"A : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : NonUnitalRing A\ninst\u271d\u2079 : StarRing A\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \u2102 A\ninst\u271d\u2076 : Module \u2102 E\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b3 : Norm A\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : StarModule \u2102 A\nz : \u211d\nx y : E\nh\u2081 : z \u2022> x = \u2191z \u2022> x\n\u22a2 star (\u2191z \u2022> inner y x) = z \u2022> inner x y",["simp","aesop","norm_num"]],["Analysis/CStarAlgebra/Module/Defs.lean",298,"A : Type u_1\nE : Type u_2\ninst\u271d\u2076 : NonUnitalCStarAlgebra A\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : StarOrderedRing A\ninst\u271d\u00b3 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CStarModule A E\n\u22a2 Continuous fun x \u21a6 (innerSL x.1) x.2",["fun_prop","omega","tauto","infer_instance"]],["Analysis/CStarAlgebra/Module/Defs.lean",209,"A : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NonUnitalCStarAlgebra A\ninst\u271d\u2076 : PartialOrder A\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u2102 E\ninst\u271d\u00b3 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : StarOrderedRing A\nx y : E\nh : x \u2260 0\na : A\n\u22a2 0 \u2264 \u2016\u27eax, x\u27eb_A\u2016",["positivity","aesop","norm_num","simp"]],["Analysis/CStarAlgebra/Module/Defs.lean",268,"A : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NonUnitalCStarAlgebra A\ninst\u271d\u2076 : PartialOrder A\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u2102 E\ninst\u271d\u00b3 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : StarOrderedRing A\nv : E\ninstNACG : NormedAddCommGroup E := NormedAddCommGroup.ofCore \u22ef\ninstNS : NormedSpace \u2102 E := NormedSpace.ofCore \u22ef\n\u22a2 0 \u2264 \u2016v\u2016",["positivity","aesop","norm_num","simp"]],["Geometry/RingedSpace/PresheafedSpace.lean",246,"case w\nC : Type u_1\ninst\u271d : Category.{?u.33260, u_1} C\nX Y : PresheafedSpace C\nH : X \u2245 Y\nU : Opens \u2191\u2191Y\neq\u2081 :\n  H.inv.c.app (op ((Opens.map H.hom.base).obj U)) \u226b\n      H.hom.c.app (op ((Opens.map H.inv.base).obj (unop (op ((Opens.map H.hom.base).obj U))))) =\n    eqToHom \u22ef\neq\u2082 :\n  eqToHom \u22ef \u226b H.hom.c.app (op ((Opens.map ((forget C).map (\ud835\udfd9 Y))).obj U)) =\n    H.hom.c.app (op ((Opens.map ((forget C).map (H.inv \u226b H.hom))).obj U)) \u226b\n      ((Presheaf.pushforward C H.hom.base).obj X.presheaf).map (eqToHom \u22ef)\n\u22a2 eqToHom \u22ef \u226b ((Presheaf.pushforward C H.hom.base).obj X.presheaf).map (eqToHom \u22ef) =\n    \ud835\udfd9 (((Presheaf.pushforward C H.hom.base).obj X.presheaf).obj (op U))",["simp","aesop"]],["Geometry/RingedSpace/PresheafedSpace.lean",96,"case mk.mk\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nX Y : PresheafedSpace C\nbase\u271d\u00b9 : \u2191X \u27f6 \u2191Y\nc\u271d\u00b9 : Y.presheaf \u27f6 (Presheaf.pushforward C base\u271d\u00b9).obj X.presheaf\nbase\u271d : \u2191X \u27f6 \u2191Y\nc\u271d : Y.presheaf \u27f6 (Presheaf.pushforward C base\u271d).obj X.presheaf\nw : { base := base\u271d\u00b9, c := c\u271d\u00b9 }.base = { base := base\u271d, c := c\u271d }.base\nh : HEq { base := base\u271d\u00b9, c := c\u271d\u00b9 }.c { base := base\u271d, c := c\u271d }.c\n\u22a2 { base := base\u271d\u00b9, c := c\u271d\u00b9 } = { base := base\u271d, c := c\u271d }",["congr","aesop"]],["NumberTheory/Transcendental/Liouville/LiouvilleWith.lean",62,"x : \u211d\nn : \u2115\nhn : 0 < n\nhn' : 0 < \u2191n\nthis : x < \u2191(\u230ax * \u2191n\u230b + 1) / \u2191n\n\u22a2 x * \u2191n + 1 < x * \u2191n + 2",["linarith","aesop","norm_num","simp"]],["Algebra/Polynomial/BigOperators.lean",194,"case h.e'_2.h.e'_3.intro.intro.a\nR : Type u\ninst\u271d : CommSemiring R\nt : Multiset R[X]\nh : \u2200 f \u2208 t, f.Monic\na\u271d : Nontrivial R\ni : R[X]\nhi\u271d : i \u2208 t\nhi : i.leadingCoeff \u2208 Multiset.map (fun f \u21a6 f.leadingCoeff) t\n\u22a2 i \u2208 t",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Polynomial/BigOperators.lean",257,"R : Type u\ninst\u271d : CommRing R\nt : Multiset R\nht : 0 < t.card\na\u271d : Nontrivial R\n\u22a2 Multiset ?m.91294",["assumption","aesop","congr","tauto"]],["Algebra/Polynomial/BigOperators.lean",324,"case h.intro.intro\nR : Type u\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : NoZeroDivisors R\nt : Multiset R[X]\nh\u271d : 0 \u2209 t\na\u271d : Nontrivial R\nh : 0 \u2208 t\n\u22a2 False",["contradiction","aesop","tauto"]],["Analysis/InnerProductSpace/Orientation.lean",301,"case succ\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03c6 : E \u2243\u2097\u1d62[\u211d] F\nn : \u2115\n_i : Fact (finrank \u211d E = n + 1)\no : Orientation \u211d E (Fin (n + 1))\ninst\u271d : Fact (finrank \u211d F = n + 1)\nx : Fin (n + 1) \u2192 F\ne : OrthonormalBasis (Fin n.succ) \u211d E := Orientation.finOrthonormalBasis \u22ef \u22ef o\nhe : e.toBasis.orientation = o\nhe\u03c6 : (e.map \u03c6).toBasis.orientation = (map (Fin n.succ) \u03c6.toLinearEquiv) o\n\u22a2 (e.map \u03c6).toBasis.det x = e.toBasis.det (\u21d1\u03c6.symm \u2218 x)",["simp","aesop","congr","tauto","abel","norm_num"]],["Analysis/InnerProductSpace/Orientation.lean",76,"case mp\nE : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \u211d E\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne f : OrthonormalBasis \u03b9 \u211d E\nh : e.toBasis.det = f.toBasis.det\n\u22a2 rayOfNeZero \u211d e.toBasis.det \u22ef = rayOfNeZero \u211d f.toBasis.det \u22ef",["congr","aesop"]],["Analysis/InnerProductSpace/Orientation.lean",249,"case succ.h0\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nn : \u2115\n_i : Fact (finrank \u211d E = n + 1)\no : Orientation \u211d E (Fin (n + 1))\nv : Fin (n + 1) \u2192 E\nthis\u271d : FiniteDimensional \u211d E\nthis : finrank \u211d E = Fintype.card (Fin n.succ)\nb : OrthonormalBasis (Fin n.succ) \u211d E := gramSchmidtOrthonormalBasis this v\nhb : b.toBasis.det v = \u220f i : Fin n.succ, inner (b i) (v i)\ni : Fin n.succ\na\u271d : i \u2208 Finset.univ\n\u22a2 0 \u2264 |inner (b i) (v i)|",["positivity","aesop","norm_num","simp"]],["Topology/UnitInterval.lean",384,"\u22a2 Continuous fun i \u21a6 \u27e8\u2191i, \u22ef\u27e9",["fun_prop","omega","tauto","infer_instance"]],["CategoryTheory/FiberedCategory/Cocartesian.lean",358,"\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} \ud835\udcae\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} \ud835\udcb3\np : \ud835\udcb3 \u2964 \ud835\udcae\nR S S' : \ud835\udcae\na b b' : \ud835\udcb3\nf : R \u27f6 S\nf' : R \u27f6 S'\ng : S \u2245 S'\nh : f' = f \u226b g.hom\n\u03c6 : a \u27f6 b\n\u03c6' : a \u27f6 b'\ninst\u271d\u00b9 : p.IsStronglyCocartesian f \u03c6\ninst\u271d : p.IsStronglyCocartesian f' \u03c6'\n\u22a2 p.IsHomLift f \u03c6",["infer_instance","omega","tauto"]],["CategoryTheory/FiberedCategory/Cocartesian.lean",331,"\ud835\udcae : Type u\u2081\n\ud835\udcb3 : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} \ud835\udcae\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} \ud835\udcb3\np : \ud835\udcb3 \u2964 \ud835\udcae\nR S : \ud835\udcae\na b : \ud835\udcb3\nf : R \u27f6 S\n\u03c6 : a \u27f6 b\ninst\u271d\u00b9 : p.IsHomLift f \u03c6\ninst\u271d : IsIso \u03c6\n\u22a2 p.IsHomLift f (asIso \u03c6).hom",["aesop","congr","tauto","assumption"]],["Order/Interval/Set/UnorderedInterval.lean",249,"\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b c : \u03b1\n\u22a2 \u00ac(\u00aca \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 a \u2264 b) \u2194 a \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 \u00aca \u2264 b",["tauto"]],["LinearAlgebra/AffineSpace/Basis.lean",128,"case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AffineSpace V P\ninst\u271d\u00b9 : Ring k\ninst\u271d : Module k V\nb : AffineBasis \u03b9 k P\ne : \u03b9 \u2243 \u03b9'\ni : \u03b9'\nj : { j // j \u2260 i }\n\u22a2 ((b.reindex e).basisOf i) j = ((b.basisOf (e.symm i)).reindex (e.subtypeEquiv \u22ef)) j",["simp","aesop","norm_num"]],["LinearAlgebra/AffineSpace/Basis.lean",67,"case mk.mk\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nG : Type u_3\nG' : Type u_4\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AffineSpace V P\ninst\u271d\u00b9 : Ring k\ninst\u271d : Module k V\nb : AffineBasis \u03b9 k P\ns : Finset \u03b9\ni j : \u03b9\ne : \u03b9 \u2243 \u03b9'\ntoFun\u271d\u00b9 : \u03b9 \u2192 P\nind'\u271d\u00b9 : AffineIndependent k toFun\u271d\u00b9\ntot'\u271d\u00b9 : affineSpan k (range toFun\u271d\u00b9) = \u22a4\ntoFun\u271d : \u03b9 \u2192 P\nind'\u271d : AffineIndependent k toFun\u271d\ntot'\u271d : affineSpan k (range toFun\u271d) = \u22a4\nh : { toFun := toFun\u271d\u00b9, ind' := ind'\u271d\u00b9, tot' := tot'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, ind' := ind'\u271d, tot' := tot'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, ind' := ind'\u271d\u00b9, tot' := tot'\u271d\u00b9 } = { toFun := toFun\u271d, ind' := ind'\u271d, tot' := tot'\u271d }",["congr","aesop"]],["Data/Finset/Defs.lean",374,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Finset \u03b1\np : \u03b1 \u2192 Prop\n_hp : (a : \u03b1) \u2192 Decidable (p a)\n\u22a2 (\u2203 a, \u2203 (_ : a \u2208 s), p a) \u2194 \u2203 a \u2208 s, p a",["simp","omega","aesop","tauto"]],["Data/Finset/Defs.lean",210,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Finset \u03b1\n\u22a2 IsRefl (Finset \u03b1) fun x1 x2 \u21a6 x1 \u2264 x2",["infer_instance","tauto"]],["Algebra/Ring/Parity.lean",302,"F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nm n : \u2115\n\u22a2 \u00acEven 25394535",["decide","tauto"]],["Algebra/Algebra/Defs.lean",247,"case mk.mk.mk.mk\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_3\ninst\u271d : Semiring A\nalgebraMap\u271d\u00b9 : R \u2192+* A\ncommutes'\u271d\u00b9 : \u2200 (r : R) (x : A), algebraMap\u271d\u00b9 r * x = x * algebraMap\u271d\u00b9 r\nP : R \u2192 A \u2192 A\nsmul_def'\u271d\u00b9 : \u2200 (r : R) (x : A), r \u2022 x = algebraMap\u271d\u00b9 r * x\nalgebraMap\u271d : R \u2192+* A\ncommutes'\u271d : \u2200 (r : R) (x : A), algebraMap\u271d r * x = x * algebraMap\u271d r\nQ : R \u2192 A \u2192 A\nsmul_def'\u271d : \u2200 (r : R) (x : A), r \u2022 x = algebraMap\u271d r * x\nh : Algebra.algebraMap = Algebra.algebraMap\nh' : (fun x1 x2 \u21a6 x1 \u2022 x2) = fun x1 x2 \u21a6 x1 \u2022 x2\n\u22a2 mk algebraMap\u271d\u00b9 commutes'\u271d\u00b9 smul_def'\u271d\u00b9 = mk algebraMap\u271d commutes'\u271d smul_def'\u271d",["congr"]],["Analysis/Analytic/OfScalars.lean",310,"case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedRing E\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c E\nc : \u2115 \u2192 \ud835\udd5c\ninst\u271d : NormOneClass E\nr : \u211d\u22650\u221e\nhc' : Tendsto (fun n \u21a6 ENNReal.ofReal \u2016c n.succ\u2016 / ENNReal.ofReal \u2016c n\u2016) atTop (\ud835\udcdd r)\nhr : 0 < r.toReal\nhr' : r \u2260 0 \u2227 r \u2260 \u22a4\nhr'' : r.toNNReal \u2260 0\n\u22a2 \u2200 (a : \u2115),\n    ENNReal.ofReal \u2016c a.succ\u2016 / ENNReal.ofReal \u2016c a\u2016 \u2260 0 \u2192\n      ENNReal.ofReal \u2016c a.succ\u2016 / ENNReal.ofReal \u2016c a\u2016 \u2260 \u22a4 \u2192\n        (ENNReal.toReal \u2218 fun n \u21a6 ENNReal.ofReal \u2016c n.succ\u2016 / ENNReal.ofReal \u2016c n\u2016) a = \u2016c a.succ\u2016 / \u2016c a\u2016",["simp","omega","aesop","infer_instance","norm_num"]],["Algebra/Module/LinearMap/End.lean",333,"case inr.h\nR : Type u_1\nS : Type u_3\nM : Type u_4\nM\u2081 : Type u_5\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : AddCommMonoid M\u2081\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : Semiring S\ninst\u271d\u00b3 : Module R S\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : IsScalarTower R S M\nf : M\u2081 \u2192\u2097[R] S\nx : M\ninst\u271d : NoZeroSMulDivisors S M\nhx : x \u2260 0\nv : M\u2081\nh : f v = 0 \u2228 x = 0\n\u22a2 f v = 0 v",["tauto","aesop"]],["Algebra/Lie/OfAssociative.lean",266,"R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nx y : L\nz : M\n\u22a2 (\u03c6 x) \u2045y, z\u2046 = \u2045((ad R L) x) y, z\u2046 + \u2045y, (\u03c6 x) z\u2046",["simp","aesop","norm_num"]],["Algebra/Lie/OfAssociative.lean",307,"case h.h\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\nM\u2082 : Type w\u2081\ninst\u271d\u00b3 : AddCommGroup M\u2082\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : LieRingModule L M\u2082\ninst\u271d : LieModule R L M\u2082\nf : M \u2192\u2097\u2045R,L\u2046 M\u2082\nk : \u2115\nx : L\nx\u271d : M\n\u22a2 ((toEnd R L M\u2082) x \u2218\u2097 \u2191f) x\u271d = (\u2191f \u2218\u2097 (toEnd R L M) x) x\u271d",["simp","aesop","norm_num"]],["AlgebraicTopology/DoldKan/FunctorGamma.lean",89,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.6749, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK\u271d K' : ChainComplex C \u2115\nf : K\u271d \u27f6 K'\n\u0394\u271d \u0394'\u271d \u0394'' : SimplexCategory\nK : ChainComplex C \u2115\n\u0394' \u0394 : SimplexCategory\ni : \u0394' \u27f6 \u0394\ninst\u271d : Mono i\nh\u271d : \u0394 = \u0394'\n\u22a2 K.X \u0394.len = K.X \u0394'.len",["congr","aesop","tauto"]],["Data/Nat/Multiplicity.lean",220,"p : \u2115\nhp : Prime p\nn\u271d : \u2115\n\u22a2 emultiplicity p 0 \u2264 emultiplicity p (choose 0 (n\u271d + 1)) + emultiplicity p (n\u271d + 1)",["simp","aesop","norm_num"]],["Data/Real/Pi/Irrational.lean",76,"\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\nhu\u2081d : Continuous u\u2081'\nhv\u2081d : Continuous v\u2081'\nhu\u2082d : Continuous u\u2082'\nhv\u2082d : Continuous v\u2082'\n\u22a2 (1 - 1 ^ 2) ^ (n + 1) = 0",["simp","ring","aesop","norm_num"]],["Data/Real/Pi/Irrational.lean",77,"\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\nhu\u2081d : Continuous u\u2081'\nhv\u2081d : Continuous v\u2081'\nhu\u2082d : Continuous u\u2082'\nhv\u2082d : Continuous v\u2082'\nhu\u2081_eval_one : u\u2081 1 = 0\n\u22a2 (1 - (-1) ^ 2) ^ (n + 1) = 0",["simp","ring","aesop","norm_num"]],["Data/Real/Pi/Irrational.lean",286,"h' : \u00acIrrational (\u03c0 / 2)\na : \u2124\nb : \u2115\nhb : 0 < b\nh : \u03c0 / 2 = \u2191a / \u2191b\nha : 0 < \u2191a\nk : \u2200 (n : \u2115), 0 < \u2191a ^ (2 * n + 1) / \u2191n !\n\u22a2 0 < 1 / 2",["norm_num","aesop","linarith","positivity","simp"]],["Algebra/Lie/Engel.lean",175,"R : Type u\u2081\nL : Type u\u2082\nL\u2082 : Type u\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L\u2082\ninst\u271d : LieAlgebra R L\u2082\nf : L \u2192\u2097\u2045R\u2046 L\u2082\nhf : Surjective \u21d1f\nh : LieAlgebra.IsEngelian R L\nM : Type u\u2084\n_i1 : AddCommGroup M\n_i2 : Module R M\n_i3 : LieRingModule L\u2082 M\n_i4 : LieModule R L\u2082 M\nh' : \u2200 (x : L\u2082), IsNilpotent ((toEnd R L\u2082 M) x)\nthis\u271d\u00b9 : LieRingModule L M := LieRingModule.compLieHom M f\nthis\u271d : LieModule R L M := compLieHom M f\nhnp : \u2200 (x : L), IsNilpotent ((toEnd R L M) x)\nsurj_id : Surjective \u21d1LinearMap.id\nthis : LieModule.IsNilpotent L M\n\u22a2 \u2200 (x : L) (m : M), \u2045f x, LinearMap.id m\u2046 = LinearMap.id \u2045x, m\u2046",["aesop","tauto"]],["GroupTheory/Coxeter/Length.lean",284,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n\u22a2 cs.length (cs.simple i * w\u207b\u00b9)\u207b\u00b9 < cs.length w\u207b\u00b9 \u2194 cs.length (w * cs.simple i) < cs.length w",["simp","aesop","norm_num"]],["GroupTheory/Coxeter/Length.lean",156,"case h\u2082\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\nlength_lt_one : cs.length (cs.simple i) < 1\nthis\u271d : cs.lengthParity (cs.simple i) = Multiplicative.ofAdd 0\nthis : Multiplicative.ofAdd 0 = Multiplicative.ofAdd 1\n\u22a2 False",["contradiction","tauto"]],["GroupTheory/Coxeter/Length.lean",173,"case inl\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\neq : cs.length (w * cs.simple i) = cs.length w\nlength_mod_two : 0 = 1\neven : cs.length w % 2 = 0\n\u22a2 False",["contradiction","omega","aesop","linarith","tauto"]],["GroupTheory/Coxeter/Length.lean",175,"case inr\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\neq : cs.length (w * cs.simple i) = cs.length w\nlength_mod_two : 1 = 0\nodd : cs.length w % 2 = 1\n\u22a2 False",["contradiction"]],["GroupTheory/Coxeter/Length.lean",78,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\nthis : \u2203 \u03c9, \u03c9.length = Nat.find \u22ef \u2227 cs.wordProd \u03c9 = w\n\u22a2 \u2203 \u03c9, \u03c9.length = cs.length w \u2227 w = cs.wordProd \u03c9",["tauto","aesop"]],["GroupTheory/Coxeter/Length.lean",221,"case h\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n\u03c9 : List B\nh\u03c9 : \u03c9.length = cs.length (cs.wordProd \u03c9)\n\u22a2 cs.IsReduced \u03c9 \u2227 cs.wordProd \u03c9 = cs.wordProd \u03c9",["tauto"]],["GroupTheory/Coxeter/Length.lean",340,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n\u22a2 cs.length (cs.simple i * w) + 1 = cs.length w \u2194 cs.length w = cs.length (cs.simple i * w) + 1",["tauto","omega","aesop"]],["GroupTheory/Coxeter/Length.lean",345,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n\u22a2 cs.length (w * cs.simple i) + 1 = cs.length w \u2194 cs.length w = cs.length (w * cs.simple i) + 1",["tauto","omega","aesop"]],["CategoryTheory/Skeletal.lean",114,"C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\nX\u271d Y\u271d Z\u271d : C\nx\u271d\u00b9 : X\u271d \u27f6 Y\u271d\nx\u271d : Y\u271d \u27f6 Z\u271d\n\u22a2 { obj := toSkeleton, map := fun {X Y} f \u21a6 (preCounitIso X).hom \u226b f \u226b (preCounitIso Y).inv }.map (x\u271d\u00b9 \u226b x\u271d) =\n    { obj := toSkeleton, map := fun {X Y} f \u21a6 (preCounitIso X).hom \u226b f \u226b (preCounitIso Y).inv }.map x\u271d\u00b9 \u226b\n      { obj := toSkeleton, map := fun {X Y} f \u21a6 (preCounitIso X).hom \u226b f \u226b (preCounitIso Y).inv }.map x\u271d",["simp","aesop"]],["RingTheory/TwoSidedIdeal/Operations.lean",333,"R : Type u_1\ninst\u271d : CommRing R\nx\u271d\u00b9 : TwoSidedIdeal R\nx\u271d : R\n\u22a2 (\u2200 (I : TwoSidedIdeal R), \u2191(asIdeal x\u271d\u00b9) \u2286 \u2191I \u2192 x\u271d \u2208 I) \u2194 x\u271d \u2208 x\u271d\u00b9",["aesop","tauto"]],["Algebra/ContinuedFractions/Computation/Translations.lean",241,"case mk\nK : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nv : K\nn : \u2115\nb\u271d : \u2124\nfr\u271d : K\nstream_nth_eq : IntFractPair.stream v n = some { b := b\u271d, fr := fr\u271d }\nnth_fr_ne_zero : { b := b\u271d, fr := fr\u271d }.fr \u2260 0\na\u271d : fr\u271d = 0\n\u22a2 none = some (IntFractPair.of fr\u271d\u207b\u00b9)",["contradiction","aesop","tauto"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",228,"case neg.h.e_6.h.e_val.e_a.e_a\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u00ac\u2191x \u2264 1 / 2\nh\u271d\u00b2 : \u00ac\u2191x \u2264 1 / 4\nh\u271d\u00b9 : \u00ac1 / 2 * (\u2191x + 1) \u2264 1 / 2\nh\u271d : \u00ac2 * (1 / 2 * (\u2191x + 1)) - 1 \u2264 1 / 2\n\u22a2 \u2191x = 2 * (1 / 2 * (\u2191x + 1)) - 1",["ring","aesop","linarith","simp"]],["RingTheory/WittVector/Defs.lean",226,"case a.h.h\u2081\np : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nIH : \u2200 m < n, 0 < m \u2192 (bind\u2081 fun k \u21a6 1) (xInTermsOfW p \u211a m) = 0\nhn : 0 < n\na\u271d : \u00ac0 < n\n\u22a2 C \u2191p ^ 0 * (bind\u2081 fun k \u21a6 1) (xInTermsOfW p \u211a 0) ^ p ^ (n - 0) = 0",["contradiction","omega","aesop","linarith","tauto"]],["AlgebraicGeometry/Noetherian.lean",313,"X : Scheme\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsNoetherianRing R\nthis : IsNoetherianRing \u2191(CommRingCat.of R)\n\u22a2 IsNoetherian (Spec (CommRingCat.of R))",["infer_instance","omega","tauto"]],["AlgebraicGeometry/Noetherian.lean",315,"X : Scheme\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsNoetherianRing R\n\u22a2 IsNoetherianRing R",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["Topology/Algebra/Nonarchimedean/Bases.lean",155,"A : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Ring A\ninst\u271d : Nonempty \u03b9\nB : \u03b9 \u2192 AddSubgroup A\nhB : RingSubgroupsBasis B\na : A\ns : Set A\ni : \u03b9\nhi : (fun y \u21a6 a + y) '' \u2191(B i) \u2286 s\nh : {b | b - a \u2208 B i} = (fun y \u21a6 a + y) '' \u2191(B i)\n\u22a2 (fun y \u21a6 a + y) '' \u2191(B i) \u2286 s",["assumption","aesop","congr","gcongr","tauto"]],["Data/Nat/Choose/Multinomial.lean",68,"\u03b1 : Type u_1\na : \u03b1\nf : \u03b1 \u2192 \u2115\n\u22a2 (f a + \u2211 i \u2208 \u2205, f i).choose (f a) * multinomial \u2205 f = 1",["simp","aesop","norm_num"]],["SetTheory/Nimber/Field.lean",277,"case h\na\u271d\u00b9 b c a x : Nimber\nhx : x \u2208 a.invSet\na' : Nimber\nha : a' < a\na\u271d : a' \u2260 0\nl : List (toOrdinal a).toType\n\u22a2 (Ordinal.toNimber \u2191((toOrdinal a).enumIsoToType.symm ((toOrdinal a).enumIsoToType \u27e8toOrdinal a', ha\u27e9))).invAux *\n      (1 +\n        (a + Ordinal.toNimber \u2191((toOrdinal a).enumIsoToType.symm ((toOrdinal a).enumIsoToType \u27e8toOrdinal a', ha\u27e9))) *\n          Nimber.List.toNimber l) =\n    a'.invAux * (1 + (a + a') * Nimber.List.toNimber l)",["simp","aesop","norm_num"]],["SetTheory/Nimber/Field.lean",74,"case h.e'_2.h.e'_3.h\na b x\u271d : Nimber\n\u22a2 (\u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = x\u271d) \u2194\n    \u2203 a_1 b_1, (a_1 < a \u2227 b_1 < b) \u2227 a_1 * b + a * b_1 + a_1 * b_1 = x\u271d",["tauto","aesop"]],["SetTheory/Nimber/Field.lean",85,"a b c : Nimber\nh : \u2200 a' < a, \u2200 b' < b, a' * b + a * b' + a' * b' \u2260 c\nh' : c < a * b\nthis : \u2203 a' < a, \u2203 b' < b, a' * b + a * b' + a' * b' = c\n\u22a2 False",["tauto","aesop"]],["Analysis/Convex/Radon.lean",127,"\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nn k : \u2115\nh_card : finrank \ud835\udd5c E + 1 \u2264 k\nhk :\n  \u2200 {\u03b9 : Type u_1} {F : \u03b9 \u2192 Set E} {s : Finset \u03b9},\n    (\u2200 i \u2208 s, Convex \ud835\udd5c (F i)) \u2192\n      (\u2200 I \u2286 s, #I \u2264 finrank \ud835\udd5c E + 1 \u2192 (\u22c2 i \u2208 I, F i).Nonempty) \u2192 #s = k \u2192 (\u22c2 i \u2208 s, F i).Nonempty\n\u03b9 : Type u_1\nF : \u03b9 \u2192 Set E\ns : Finset \u03b9\nh_convex : \u2200 i \u2208 s, Convex \ud835\udd5c (F i)\nh_inter : \u2200 I \u2286 s, #I \u2264 finrank \ud835\udd5c E + 1 \u2192 (\u22c2 i \u2208 I, F i).Nonempty\nhn : #s = k + 1\na : { x // x \u2208 s } \u2192 E := fun i \u21a6 \u22ef.some\nh_ind : \u00acAffineIndependent \ud835\udd5c a\nI : Set { x // x \u2208 s }\np : E\nhp_I : p \u2208 (convexHull \ud835\udd5c) (a '' I)\nhp_Ic : p \u2208 (convexHull \ud835\udd5c) (a '' I\u1d9c)\ni\u271d : \u03b9\nhi\u271d : i\u271d \u2208 Membership.mem s.val\ni : { x // x \u2208 s } := \u27e8i\u271d, hi\u271d\u27e9\nJ : Set { x // x \u2208 s }\nhi : i \u2208 J\nv : E\nj : { x // x \u2208 s }\nhj : j \u2208 J\u1d9c\nhj_v : a j = v\nh : \u2191i \u2208 s.erase \u2191j\n\u22a2 \u2191i \u2208 Membership.mem (s.val.erase \u2191j)",["assumption","congr","tauto"]],["Analysis/Convex/Radon.lean",251,"case a\n\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u2075 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : FiniteDimensional \ud835\udd5c E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T2Space E\nF : Set (Set E)\nh_convex : \u2200 X \u2208 F, Convex \ud835\udd5c X\nh_compact : \u2200 X \u2208 F, IsCompact X\nh_inter : \u2200 (G : Finset (Set E)), \u2191G \u2286 F \u2192 #G \u2264 finrank \ud835\udd5c E + 1 \u2192 (\u22c2\u2080 \u2191G).Nonempty\nG : Finset \u2191F\na\u271d : #G \u2264 finrank \ud835\udd5c E + 1\nG' : Finset (Set E) := Finset.image Subtype.val G\n\u22a2 #G \u2264 finrank \ud835\udd5c E + 1",["assumption","omega","aesop","congr","linarith","gcongr","tauto"]],["Analysis/Convex/Radon.lean",179,"\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nF : Finset (Set E)\nh_card : finrank \ud835\udd5c E + 1 \u2264 #F\nh_convex : \u2200 X \u2208 F, Convex \ud835\udd5c X\nh_inter : \u2200 G \u2286 F, #G = finrank \ud835\udd5c E + 1 \u2192 (\u22c2\u2080 \u2191G).Nonempty\nI : Finset (Set E)\nhI_ss : I \u2286 F\nhI_card : #I \u2264 finrank \ud835\udd5c E + 1\nJ : Finset (Set E)\nleft\u271d : I \u2286 J\nhJ_ss : J \u2286 F\nhJ_card : #J = finrank \ud835\udd5c E + 1\nthis : \u22c2\u2080 \u2191J \u2286 \u22c2\u2080 \u2191I\n\u22a2 #J = finrank \ud835\udd5c E + 1",["omega","aesop","congr","linarith","gcongr","tauto","assumption"]],["CategoryTheory/Comma/Arrow.lean",116,"T : Type u\ninst\u271d : Category.{v, u} T\nX Y Y' : T\nf : X \u27f6 Y\nh : Y = Y'\n\u22a2 (mk (f \u226b eqToHom h)).hom = eqToHom \u22ef \u226b (mk f).hom \u226b eqToHom \u22ef",["simp","aesop"]],["CategoryTheory/Comma/Arrow.lean",197,"T : Type u\ninst\u271d\u00b9 : Category.{v, u} T\nf g : Arrow T\nsq : f \u27f6 g\ninst\u271d : IsIso sq\n\u22a2 (\ud835\udfd9 f).left = \ud835\udfd9 f.left \u2227 (\ud835\udfd9 g).left = \ud835\udfd9 g.left",["simp","aesop","tauto"]],["CategoryTheory/Comma/Arrow.lean",121,"T : Type u\ninst\u271d : Category.{v, u} T\nX' X Y : T\nf : X \u27f6 Y\nh : X' = X\n\u22a2 (mk (eqToHom h \u226b f)).hom = eqToHom h \u226b (mk f).hom \u226b eqToHom \u22ef",["simp","aesop"]],["CategoryTheory/Comma/Arrow.lean",111,"T : Type u\ninst\u271d : Category.{v, u} T\nf g : Arrow T\nh\u2081 : f.left = g.left\nh\u2082 : f.right = g.right\nh\u2083 : f.hom = eqToHom h\u2081 \u226b g.hom \u226b eqToHom \u22ef\n\u22a2 \u2203 hX hY, f.hom = eqToHom hX \u226b g.hom \u226b eqToHom \u22ef",["aesop","tauto"]],["CategoryTheory/Products/Basic.lean",70,"case mpr.intro.mk.intro.intro.mk.intro.intro.refine_1.right\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nP Q : C\nS T : D\nf : (P, S) \u27f6 (Q, T)\ng\u2081 : (Q, T).1 \u27f6 (P, S).1\nhfg\u2081 : f.1 \u226b g\u2081 = \ud835\udfd9 P\nhgf\u2081 : g\u2081 \u226b f.1 = \ud835\udfd9 Q\ng\u2082 : (Q, T).2 \u27f6 (P, S).2\nhfg\u2082 : f.2 \u226b g\u2082 = \ud835\udfd9 S\nhgf\u2082 : g\u2082 \u226b f.2 = \ud835\udfd9 T\n\u22a2 f.2 \u226b g\u2082 = \ud835\udfd9 S\n```\n---\n```lean\ncase mpr.intro.mk.intro.intro.mk.intro.intro.refine_2.right\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nP Q : C\nS T : D\nf : (P, S) \u27f6 (Q, T)\ng\u2081 : (Q, T).1 \u27f6 (P, S).1\nhfg\u2081 : f.1 \u226b g\u2081 = \ud835\udfd9 P\nhgf\u2081 : g\u2081 \u226b f.1 = \ud835\udfd9 Q\ng\u2082 : (Q, T).2 \u27f6 (P, S).2\nhfg\u2082 : f.2 \u226b g\u2082 = \ud835\udfd9 S\nhgf\u2082 : g\u2082 \u226b f.2 = \ud835\udfd9 T\n\u22a2 g\u2082 \u226b f.2 = \ud835\udfd9 T",["assumption","omega","aesop","congr","gcongr","tauto"]],["Analysis/Calculus/Gradient/Basic.lean",271,"\ud835\udd5c : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c F\ninst\u271d : CompleteSpace F\nf : F \u2192 \ud835\udd5c\nf' x : F\ns : Set F\nf\u2081 : F \u2192 \ud835\udd5c\nh : HasGradientWithinAt f f' s x\nhs : \u2200 x \u2208 s, f\u2081 x = f x\nhx : f\u2081 x = f x\n\u22a2 s \u2286 s",["tauto","aesop","norm_num","simp"]],["CategoryTheory/Category/Basic.lean",268,"case h.e'_1.h.e'_3.h\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : Epi f\nh : Y \u27f6 Y\n\u22a2 f = f \u226b \ud835\udfd9 Y",["simp","aesop"]],["CategoryTheory/Category/Basic.lean",272,"case h.e'_1.h.e'_3.h\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : Mono f\ng : X \u27f6 X\n\u22a2 f = \ud835\udfd9 X \u226b f",["simp","aesop"]],["CategoryTheory/Category/Basic.lean",338,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u\ninst\u271d : SmallCategory D\n\u22a2 LargeCategory (ULift.{u + 1, u} D)",["infer_instance","omega","aesop","tauto"]],["Combinatorics/SimpleGraph/Turan.lean",120,"case neg\nV : Type u_1\ninst\u271d : Fintype V\nr : \u2115\nhr : 0 < r\nc : Set (SimpleGraph V) := {H | H.CliqueFree (r + 1)}\ncn : c.toFinset.Nonempty\nS : SimpleGraph V\nSm : S \u2208 c\nSl : \u2200 x' \u2208 c.toFinset, #x'.edgeFinset \u2264 #S.edgeFinset\nI : SimpleGraph V\nx\u271d : DecidableRel I.Adj\ncf : I.CliqueFree (r + 1)\nIm : I \u2209 c\n\u22a2 #I.edgeFinset \u2264 #S.edgeFinset",["contradiction","aesop","tauto"]],["NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean",212,"case intro.intro.intro.refine_1.refine_2\nFq : Type u_1\ninst\u271d\u00b9 : Fintype Fq\ninst\u271d : Field Fq\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nb : Fq[X]\nhb : b \u2260 0\nhb\u03b5 : 0 < cardPowDegree b \u2022 \u03b5\nn : \u2115\nih :\n  \u2200 (A : Fin n \u2192 Fq[X]),\n    \u2203 t, \u2200 (i\u2080 i\u2081 : Fin n), t i\u2080 = t i\u2081 \u2194 \u2191(cardPowDegree (A i\u2081 % b - A i\u2080 % b)) < cardPowDegree b \u2022 \u03b5\nA : Fin (n + 1) \u2192 Fq[X]\nanti_archim' :\n  \u2200 {i j k : Fin (n + 1)} {\u03b5 : \u211d},\n    \u2191(cardPowDegree (A i % b - A j % b)) < \u03b5 \u2192\n      \u2191(cardPowDegree (A j % b - A k % b)) < \u03b5 \u2192 \u2191(cardPowDegree (A i % b - A k % b)) < \u03b5\nt' : Fin n \u2192 Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)\nht' : \u2200 (i\u2080 i\u2081 : Fin n), t' i\u2080 = t' i\u2081 \u2194 \u2191(cardPowDegree (Fin.tail A i\u2081 % b - Fin.tail A i\u2080 % b)) < cardPowDegree b \u2022 \u03b5\nhg :\n  \u2200 (j : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)),\n    \u2203 i, t' i = j \u2227 cardPowDegree b \u2022 \u03b5 \u2264 \u2191(cardPowDegree (A 0 % b - A i.succ % b))\nj\u2080 j\u2081\u271d : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a).succ\nj\u2081 : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)\nj_ne : 0 \u2260 j\u2081.succ\napprox : \u00accardPowDegree b \u2022 \u03b5 \u2264 \u2191(cardPowDegree (A 0 % b - A (Classical.choose \u22ef).succ % b))\nthis : cardPowDegree b \u2022 \u03b5 \u2264 \u2191(cardPowDegree (A 0 % b - A (Classical.choose \u22ef).succ % b))\n\u22a2 False",["contradiction","linarith","tauto"]],["NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean",215,"case intro.intro.intro.refine_2.refine_1\nFq : Type u_1\ninst\u271d\u00b9 : Fintype Fq\ninst\u271d : Field Fq\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nb : Fq[X]\nhb : b \u2260 0\nhb\u03b5 : 0 < cardPowDegree b \u2022 \u03b5\nn : \u2115\nih :\n  \u2200 (A : Fin n \u2192 Fq[X]),\n    \u2203 t, \u2200 (i\u2080 i\u2081 : Fin n), t i\u2080 = t i\u2081 \u2194 \u2191(cardPowDegree (A i\u2081 % b - A i\u2080 % b)) < cardPowDegree b \u2022 \u03b5\nA : Fin (n + 1) \u2192 Fq[X]\nanti_archim' :\n  \u2200 {i j k : Fin (n + 1)} {\u03b5 : \u211d},\n    \u2191(cardPowDegree (A i % b - A j % b)) < \u03b5 \u2192\n      \u2191(cardPowDegree (A j % b - A k % b)) < \u03b5 \u2192 \u2191(cardPowDegree (A i % b - A k % b)) < \u03b5\nt' : Fin n \u2192 Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)\nht' : \u2200 (i\u2080 i\u2081 : Fin n), t' i\u2080 = t' i\u2081 \u2194 \u2191(cardPowDegree (Fin.tail A i\u2081 % b - Fin.tail A i\u2080 % b)) < cardPowDegree b \u2022 \u03b5\nhg :\n  \u2200 (j : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)),\n    \u2203 i, t' i = j \u2227 cardPowDegree b \u2022 \u03b5 \u2264 \u2191(cardPowDegree (A 0 % b - A i.succ % b))\nj\u2080\u271d j\u2081 : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a).succ\nj\u2080 : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)\nj_ne : j\u2080.succ \u2260 0\napprox : \u00accardPowDegree b \u2022 \u03b5 \u2264 \u2191(cardPowDegree (A 0 % b - A (Classical.choose \u22ef).succ % b))\nthis : cardPowDegree b \u2022 \u03b5 \u2264 \u2191(cardPowDegree (A 0 % b - A (Classical.choose \u22ef).succ % b))\n\u22a2 False",["contradiction","linarith","tauto"]],["NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean",221,"case intro.intro.intro.refine_2.refine_2\nFq : Type u_1\ninst\u271d\u00b9 : Fintype Fq\ninst\u271d : Field Fq\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nb : Fq[X]\nhb : b \u2260 0\nhb\u03b5 : 0 < cardPowDegree b \u2022 \u03b5\nn : \u2115\nih :\n  \u2200 (A : Fin n \u2192 Fq[X]),\n    \u2203 t, \u2200 (i\u2080 i\u2081 : Fin n), t i\u2080 = t i\u2081 \u2194 \u2191(cardPowDegree (A i\u2081 % b - A i\u2080 % b)) < cardPowDegree b \u2022 \u03b5\nA : Fin (n + 1) \u2192 Fq[X]\nanti_archim' :\n  \u2200 {i j k : Fin (n + 1)} {\u03b5 : \u211d},\n    \u2191(cardPowDegree (A i % b - A j % b)) < \u03b5 \u2192\n      \u2191(cardPowDegree (A j % b - A k % b)) < \u03b5 \u2192 \u2191(cardPowDegree (A i % b - A k % b)) < \u03b5\nt' : Fin n \u2192 Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)\nht' : \u2200 (i\u2080 i\u2081 : Fin n), t' i\u2080 = t' i\u2081 \u2194 \u2191(cardPowDegree (Fin.tail A i\u2081 % b - Fin.tail A i\u2080 % b)) < cardPowDegree b \u2022 \u03b5\nhg :\n  \u2200 (j : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)),\n    \u2203 i, t' i = j \u2227 cardPowDegree b \u2022 \u03b5 \u2264 \u2191(cardPowDegree (A 0 % b - A i.succ % b))\nj\u2080\u271d j\u2081\u271d : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a).succ\nj\u2080 j\u2081 : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)\nj_ne : \u00acj\u2080 = j\u2081\napprox : \u2191(cardPowDegree (A (Classical.choose \u22ef).succ % b - A (Classical.choose \u22ef).succ % b)) < cardPowDegree b \u2022 \u03b5\nthis : j\u2080 = j\u2081\n\u22a2 False",["contradiction","omega","aesop","tauto"]],["NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean",233,"case neg\nFq : Type u_1\ninst\u271d\u00b9 : Fintype Fq\ninst\u271d : Field Fq\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nb : Fq[X]\nhb : b \u2260 0\nhb\u03b5 : 0 < cardPowDegree b \u2022 \u03b5\nn : \u2115\nih :\n  \u2200 (A : Fin n \u2192 Fq[X]),\n    \u2203 t, \u2200 (i\u2080 i\u2081 : Fin n), t i\u2080 = t i\u2081 \u2194 \u2191(cardPowDegree (A i\u2081 % b - A i\u2080 % b)) < cardPowDegree b \u2022 \u03b5\nA : Fin (n + 1) \u2192 Fq[X]\nanti_archim' :\n  \u2200 {i j k : Fin (n + 1)} {\u03b5 : \u211d},\n    \u2191(cardPowDegree (A i % b - A j % b)) < \u03b5 \u2192\n      \u2191(cardPowDegree (A j % b - A k % b)) < \u03b5 \u2192 \u2191(cardPowDegree (A i % b - A k % b)) < \u03b5\nt' : Fin n \u2192 Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)\nht' : \u2200 (i\u2080 i\u2081 : Fin n), t' i\u2080 = t' i\u2081 \u2194 \u2191(cardPowDegree (Fin.tail A i\u2081 % b - Fin.tail A i\u2080 % b)) < cardPowDegree b \u2022 \u03b5\nj : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a)\nhj : \u2200 (i : Fin n), t' i = j \u2192 \u2191(cardPowDegree (A 0 % b - A i.succ % b)) < cardPowDegree b \u2022 \u03b5\nexists_nonempty_j :\n  \u00ac\u2203 j, (\u2203 i, t' i = j) \u2227 \u2200 (i : Fin n), t' i = j \u2192 \u2191(cardPowDegree (A 0 % b - A i.succ % b)) < cardPowDegree b \u2022 \u03b5\ni : Fin n\nhi : \u2191(cardPowDegree (A 0 % b - A i.succ % b)) < cardPowDegree b \u2022 \u03b5\nthis : False\n\u22a2 t' i = j",["contradiction","aesop","tauto"]],["Combinatorics/SimpleGraph/Triangle/Basic.lean",260,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b3 : LinearOrderedField \ud835\udd5c\nG : SimpleGraph \u03b1\n\u03b5 : \ud835\udd5c\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty \u03b1\nhG : G.FarFromTriangleFree \u03b5\nh\u03b5 : 1 \u2264 \u03b5 * 2\nh\u03b5\u2080 : 0 < \u03b5\n\u22a2 1 \u2264 \u03b5 * 2",["assumption","aesop","congr","gcongr","tauto"]],["Combinatorics/SimpleGraph/Triangle/Basic.lean",255,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b3 : LinearOrderedField \ud835\udd5c\nG : SimpleGraph \u03b1\n\u03b5 : \ud835\udd5c\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty \u03b1\nhG : G.FarFromTriangleFree \u03b5\nh\u03b5 : 2\u207b\u00b9 \u2264 \u03b5\n\u22a2 0 < 2\u207b\u00b9",["norm_num","aesop","positivity","simp"]],["Algebra/Order/Antidiag/Nat.lean",40,"divisorsAntidiagonal : \u2115+ \u2192 Finset (\u2115+ \u00d7 \u2115+) :=\n  fun n \u21a6 map { toFun := fun x \u21a6 (\u27e8(\u2191x).1, \u22ef\u27e9, \u27e8(\u2191x).2, \u22ef\u27e9), inj' := \u22ef } (\u2191n).divisorsAntidiagonal.attach\nn : \u2115+\nx : \u2115+ \u00d7 \u2115+\n\u22a2 (\u2203 a, \u2203 (h : a \u2208 (\u2191n).divisorsAntidiagonal), \u2191\u27e8a.1, \u22ef\u27e9 = \u2191x.1 \u2227 \u2191\u27e8a.2, \u22ef\u27e9 = \u2191x.2) \u2194 \u2191(x.1 * x.2) = \u2191n",["aesop","norm_num","simp"]],["Computability/Ackermann.lean",91,"n : \u2115\nIH : ack 3 n = 2 ^ (n + 3) - 3\n\u22a2 2 * 3 \u2264 2 * 2 ^ 3",["norm_num","omega","decide","aesop","linarith","simp"]],["Computability/Ackermann.lean",319,"f\u271d f g : \u2115 \u2192 \u2115\nhf : Nat.Primrec f\nhg : Nat.Primrec g\na : \u2115\nha : \u2200 (n : \u2115), f n < ack a n\nb : \u2115\nhb : \u2200 (n : \u2115), g n < ack b n\nm n : \u2115\nIH : rec (f m) (fun y IH \u21a6 g (pair m (pair y IH))) n < ack (a \u2294 b + 9) (m + n)\nh\u2081 : pair n (rec (f m) (fun y IH \u21a6 g (pair m (pair y IH))) n) < m\n\u22a2 4 \u2264 9",["norm_num","omega","decide","aesop","linarith","tauto","infer_instance","simp"]],["Computability/Ackermann.lean",248,"m n : \u2115\n\u22a2 m + 1 \u2264 m + 3 + 1",["omega","aesop","linarith","tauto","norm_num","simp"]],["Computability/Ackermann.lean",263,"m n : \u2115\n\u22a2 m \u2264 m + 2",["omega","aesop","linarith","tauto","norm_num","simp"]],["Computability/Ackermann.lean",312,"f\u271d f g : \u2115 \u2192 \u2115\nhf : Nat.Primrec f\nhg : Nat.Primrec g\na : \u2115\nha : \u2200 (n : \u2115), f n < ack a n\nb : \u2115\nhb : \u2200 (n : \u2115), g n < ack b n\nm : \u2115\n\u22a2 a \u2294 b < a \u2294 b + 9",["omega","aesop","linarith","norm_num","simp"]],["CategoryTheory/Monoidal/Center.lean",87,"case mk.mk\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\nX Y : Center C\nf\u271d\u00b9 : X.fst \u27f6 Y.fst\ncomm\u271d\u00b9 : \u2200 (U : C), f\u271d\u00b9 \u25b7 U \u226b (Y.snd.\u03b2 U).hom = (X.snd.\u03b2 U).hom \u226b U \u25c1 f\u271d\u00b9\nf\u271d : X.fst \u27f6 Y.fst\ncomm\u271d : \u2200 (U : C), f\u271d \u25b7 U \u226b (Y.snd.\u03b2 U).hom = (X.snd.\u03b2 U).hom \u226b U \u25c1 f\u271d\nw : { f := f\u271d\u00b9, comm := comm\u271d\u00b9 }.f = { f := f\u271d, comm := comm\u271d }.f\n\u22a2 { f := f\u271d\u00b9, comm := comm\u271d\u00b9 } = { f := f\u271d, comm := comm\u271d }",["congr","aesop"]],["RingTheory/Polynomial/HilbertPoly.lean",120,"F : Type u_1\ninst\u271d : Field F\nd k : \u2115\n\u22a2 (match d + 1 with\n    | 0 => 0\n    | d.succ => \u2211 i \u2208 (X ^ k).support, (X ^ k).coeff i \u2022 preHilbertPoly F d i) =\n    preHilbertPoly F d k",["simp","aesop","norm_num"]],["Order/Filter/CountableInter.lean",247,"case mp.superset\n\u03b1 : Type u_2\ng : Set (Set \u03b1)\ns s\u271d t\u271d : Set \u03b1\na\u271d\u00b9 : CountableGenerateSets g s\u271d\na\u271d : s\u271d \u2286 t\u271d\nih : \u2203 S \u2286 g, S.Countable \u2227 \u22c2\u2080 S \u2286 s\u271d\nS : Set (Set \u03b1)\n\u22a2 S \u2286 g \u2227 S.Countable \u2227 \u22c2\u2080 S \u2286 s\u271d \u2192 S \u2286 g \u2227 S.Countable \u2227 \u22c2\u2080 S \u2286 t\u271d",["tauto","omega","infer_instance"]],["Data/Prod/Basic.lean",128,"\u03b1 : Type u_1\n\u03b2 : Type u_2\np\u2081 : \u03b1\np\u2082 : \u03b2\nq\u2081 : \u03b1\nq\u2082 : \u03b2\n\u22a2 (p\u2081, p\u2082) = (q\u2081, q\u2082) \u2194 (p\u2081, p\u2082).fst = (q\u2081, q\u2082).fst \u2227 (p\u2081, p\u2082).snd = (q\u2081, q\u2082).snd",["simp","aesop"]],["Data/Prod/Basic.lean",60,"\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u2081 a\u2082 : \u03b1\nb\u2081 b\u2082 : \u03b2\n\u22a2 (a\u2081, b\u2081) = (a\u2082, b\u2082) \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082",["simp","aesop"]],["Algebra/Lie/Abelian.lean",203,"case h\nR : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf g : \u21a5(maxTrivSubmodule R L (M \u2192\u2097[R] N))\nm\u271d : M\n\u22a2 ((fun f \u21a6 { toLinearMap := \u2191f, map_lie' := \u22ef }) (f + g)) m\u271d =\n    ((fun f \u21a6 { toLinearMap := \u2191f, map_lie' := \u22ef }) f + (fun f \u21a6 { toLinearMap := \u2191f, map_lie' := \u22ef }) g) m\u271d",["simp","aesop","congr","tauto","abel","norm_num"]],["Algebra/Lie/Abelian.lean",204,"case h\nR : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nF : R\nG : \u21a5(maxTrivSubmodule R L (M \u2192\u2097[R] N))\nm\u271d : M\n\u22a2 ({ toFun := fun f \u21a6 { toLinearMap := \u2191f, map_lie' := \u22ef }, map_add' := \u22ef }.toFun (F \u2022 G)) m\u271d =\n    ((RingHom.id R) F \u2022 { toFun := fun f \u21a6 { toLinearMap := \u2191f, map_lie' := \u22ef }, map_add' := \u22ef }.toFun G) m\u271d",["simp"]],["Data/Real/ConjExponents.lean",149,"p q : \u211d\u22650\n\u22a2 1 < p \u2192 (p\u207b\u00b9 + q\u207b\u00b9 = 1 \u2194 p\u207b\u00b9 + q\u207b\u00b9 = 1)",["simp","aesop","tauto","norm_num"]],["Data/Real/ConjExponents.lean",292,"case bc\np q : \u211d\u22650\u221e\nh : p.IsConjExponent q\n\u22a2 0 \u2264 q\u207b\u00b9",["positivity","aesop","norm_num","simp"]],["Algebra/Homology/Monoidal.lean",103,"C : Type u_1\ninst\u271d\u2078 : Category.{u_3, u_1} C\ninst\u271d\u2077 : MonoidalCategory C\ninst\u271d\u2076 : Preadditive C\ninst\u271d\u2075 : HasZeroObject C\ninst\u271d\u2074 : (curriedTensor C).Additive\ninst\u271d\u00b3 : \u2200 (X\u2081 : C), ((curriedTensor C).obj X\u2081).Additive\nI : Type u_2\ninst\u271d\u00b2 : AddMonoid I\nc : ComplexShape I\ninst\u271d\u00b9 : c.TensorSigns\nK\u2081 K\u2082 : HomologicalComplex C c\ninst\u271d : GradedObject.HasTensor K\u2081.X K\u2082.X\n\u22a2 K\u2081.HasTensor K\u2082",["assumption","aesop","congr","tauto"]],["Computability/Language.lean",174,"\u03b1 : Type u_1\nl\u2081 l\u2082 m\u2081 m\u2082 : Language \u03b1\nh\u2081 : l\u2081 \u2264 m\u2081\nh\u2082 : l\u2082 \u2264 m\u2082\nx : List \u03b1\nhx : \u2203 a \u2208 l\u2081, \u2203 b \u2208 l\u2082, a ++ b = x\n\u22a2 \u2203 a \u2208 m\u2081, \u2203 b \u2208 m\u2082, a ++ b = x",["tauto","aesop"]],["Analysis/SpecialFunctions/ExpDeriv.lean",80,"x : \u2102\n\u22a2 1 < 2",["norm_num","omega","decide","aesop","linarith","tauto","simp"]],["Analysis/Complex/AbelLimit.lean",223,"f : \u2115 \u2192 \u2102\nl : \u2102\nh : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, f i) atTop (\ud835\udcdd l)\nM : \u211d\nhM : 1 < M\ns : \u2115 \u2192 \u2102 := fun n \u21a6 \u2211 i \u2208 range n, f i\ng : \u2102 \u2192 \u2102 := fun z \u21a6 \u2211' (n : \u2115), f n * z ^ n\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nB\u2081 : \u2115\nhB\u2081 : \u2200 n \u2265 B\u2081, \u2016\u2211 i \u2208 range n, f i - l\u2016 < \u03b5 / 4 / M\nF : \u211d := \u2211 i \u2208 range B\u2081, \u2016l - s (i + 1)\u2016\nz : \u2102\nzn : \u2016z\u2016 < 1\nzm : \u20161 - z\u2016 < M * (1 - \u2016z\u2016)\nzd : \u2016z - 1\u2016 < \u03b5 / 4 / (F + 1)\nB\u2082 : \u2115\nhB\u2082 : \u2016l - \u2211' (n : \u2115), f n * z ^ n - (1 - z) * \u2211 i \u2208 range (B\u2081 \u2294 B\u2082), (l - \u2211 j \u2208 range (i + 1), f j) * z ^ i\u2016 < \u03b5 / 2\nS\u2081 : \u20161 - z\u2016 * \u2211 i \u2208 range B\u2081, \u2016l - s (i + 1)\u2016 * \u2016z\u2016 ^ i < \u03b5 / 4\nx\u271d\u00b9 : \u2115\nx\u271d : x\u271d\u00b9 \u2209 Ico B\u2081 (B\u2081 \u2294 B\u2082)\n\u22a2 0 \u2264 \u2016z\u2016 ^ x\u271d\u00b9",["positivity","aesop","norm_num","simp"]],["RingTheory/DedekindDomain/PID.lean",59,"case pos.refine_1\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDedekindDomain R\nx : R\nthis : DecidableEq (Ideal R) := Classical.decEq (Ideal R)\nhx0 : x \u2260 0\nhspan0 : span {x} \u2260 \u22a5\nQ : Ideal R\nhP : Q.IsPrime\nx_mem : x \u2208 Q\nhxP2 : x \u2209 Q ^ 2\nhxQ : \u2200 (Q_1 : Ideal R), Q_1.IsPrime \u2192 Q_1 \u2260 Q \u2192 x \u2209 Q_1\nhP0 : \u00acQ = \u22a5\nspan_le : span {x} \u2264 Q\n\u22a2 x \u2208 Q\n```\n---\n```lean\ncase pos.refine_2\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDedekindDomain R\nx : R\nthis : DecidableEq (Ideal R) := Classical.decEq (Ideal R)\nhx0 : x \u2260 0\nhspan0 : span {x} \u2260 \u22a5\nQ : Ideal R\nhP : Q.IsPrime\nx_mem : x \u2208 Q\nhxP2 : x \u2209 Q ^ 2\nhxQ : \u2200 (Q_1 : Ideal R), Q_1.IsPrime \u2192 Q_1 \u2260 Q \u2192 x \u2209 Q_1\nhP0 : \u00acQ = \u22a5\nspan_le : span {x} \u2264 Q\n\u22a2 x \u2209 Q ^ (1 + 1)",["assumption","aesop","congr","tauto"]],["CategoryTheory/Sites/Equivalence.lean",67,"case h.h.h.a.h.e'_5.h.h\nC : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nK : GrothendieckTopology D\ne : C \u224c D\nG : D \u2964 C\nA : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} A\nX : C\nS : Sieve X\ne_1\u271d : Sieve X = Sieve ((\ud835\udfed C).obj X)\nY : C\nf : Y \u27f6 X\n\u22a2 S.arrows f \u2194\n    (Sieve.pullback (e.unit.app X) (Sieve.functorPushforward e.inverse (Sieve.functorPushforward e.functor S))).arrows f",["simp","aesop"]],["Topology/Bornology/Basic.lean",75,"case mk.mk\n\u03b1 : Type u_2\ncobounded'\u271d\u00b9 : Filter \u03b1\nle_cofinite'\u271d\u00b9 : cobounded'\u271d\u00b9 \u2264 cofinite\ncobounded'\u271d : Filter \u03b1\nle_cofinite'\u271d : cobounded'\u271d \u2264 cofinite\nh_cobounded : cobounded \u03b1 = cobounded \u03b1\n\u22a2 { cobounded' := cobounded'\u271d\u00b9, le_cofinite' := le_cofinite'\u271d\u00b9 } =\n    { cobounded' := cobounded'\u271d, le_cofinite' := le_cofinite'\u271d }",["congr","aesop"]],["RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean",137,"case inr\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nk : \u2115\nt : Finset \u03c3 \u00d7 \u03c3\nh : #t.1 \u2264 k \u2227 (#t.1 = k \u2192 t.2 \u2208 t.1)\nh2 : \u2200 (n : \u2115), -(-1) ^ n = (-1) ^ (n + 1)\nh1 : t.2 \u2209 t.1\n\u22a2 (\u220f a \u2208 t.1, X a) * (X t.2 ^ (k - #t.1) * -(-1) ^ (#t.1 + 1)) +\n      (\u220f a \u2208 t.1, X a) * (X t.2 ^ (k - #t.1) * (-1) ^ (#t.1 + 1)) =\n    0",["simp","norm_num"]],["RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean",130,"case inl\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nk : \u2115\nt : Finset \u03c3 \u00d7 \u03c3\nh : #t.1 \u2264 k \u2227 (#t.1 = k \u2192 t.2 \u2208 t.1)\nh2 : \u2200 (n : \u2115), -(-1) ^ n = (-1) ^ (n + 1)\nh1 : t.2 \u2208 t.1\nh3 : 1 \u2264 #t.1\n\u22a2 (-1) ^ #t.1 * ((\u220f a \u2208 t.1.erase t.2, X a) * X t.2 ^ (k - (#t.1 - 1))) +\n      -(-1) ^ #t.1 * ((\u220f a \u2208 t.1.erase t.2, X a) * X t.2 ^ (k - (#t.1 - 1))) =\n    0",["simp","norm_num"]],["RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean",185,"\u03c3 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nk : \u2115\na : Finset \u03c3 \u00d7 \u03c3\nha : a \u2208 univ \u2227 #a.1 \u2264 k \u2227 (#a.1 = k \u2192 a.2 \u2208 a.1)\nhacard : #a.1 < k \u2228 #a.1 = k\n\u22a2 a \u2208 univ \u2227 ((#a.1 \u2264 k \u2227 (#a.1 = k \u2192 a.2 \u2208 a.1)) \u2227 #a.1 < k \u2228 (#a.1 \u2264 k \u2227 (#a.1 = k \u2192 a.2 \u2208 a.1)) \u2227 #a.1 = k)",["tauto","aesop"]],["Analysis/ConstantSpeed.lean",202,"case h.e'_4.h.h.e'_5\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\n\u03c6 : \u211d \u2192 \u211d\n\u03c6m : MonotoneOn \u03c6 s\nhf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s 1\nhf : HasConstantSpeedOnWith f (\u03c6 '' s) 1\nx : \u211d\nxs : x \u2208 s\nx\u271d : \u211d\n\u22a2 x\u271d - x = \u21911 / \u21911 * (x\u271d - x)",["norm_num","aesop","simp"]],["Combinatorics/SimpleGraph/Triangle/Tripartite.lean",87,"case intro.mk.mk.intro.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 ((a, b, c).1, (a, b, c).2.1, ?intro.mk.mk.intro.intro.c) \u2208 t\n```\n---\n```lean\ncase intro.mk.mk.intro.intro.c\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 \u03b3",["assumption","aesop","congr","gcongr","tauto"]],["Combinatorics/SimpleGraph/Triangle/Tripartite.lean",91,"case intro.mk.mk.intro.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 ((a, b, c).1, (a, b, c).2.1, ?intro.mk.mk.intro.intro.c) \u2208 t\n```\n---\n```lean\ncase intro.mk.mk.intro.intro.c\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 \u03b3",["assumption","aesop","congr","gcongr","tauto"]],["Combinatorics/SimpleGraph/Triangle/Tripartite.lean",95,"case intro.mk.mk.intro.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 ((a, b, c).1, ?intro.mk.mk.intro.intro.b, (a, b, c).2.2) \u2208 t\n```\n---\n```lean\ncase intro.mk.mk.intro.intro.b\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 \u03b2",["assumption","aesop","congr","gcongr","tauto"]],["Combinatorics/SimpleGraph/Triangle/Tripartite.lean",99,"case intro.mk.mk.intro.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 ((a, b, c).1, ?intro.mk.mk.intro.intro.b, (a, b, c).2.2) \u2208 t\n```\n---\n```lean\ncase intro.mk.mk.intro.intro.b\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 \u03b2",["assumption","aesop","congr","gcongr","tauto"]],["Combinatorics/SimpleGraph/Triangle/Tripartite.lean",103,"case intro.mk.mk.intro.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 (?intro.mk.mk.intro.intro.a, (a, b, c).2.1, (a, b, c).2.2) \u2208 t\n```\n---\n```lean\ncase intro.mk.mk.intro.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 \u03b1",["assumption","aesop","congr","gcongr","tauto"]],["Combinatorics/SimpleGraph/Triangle/Tripartite.lean",107,"case intro.mk.mk.intro.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 (?intro.mk.mk.intro.intro.a, (a, b, c).2.1, (a, b, c).2.2) \u2208 t\n```\n---\n```lean\ncase intro.mk.mk.intro.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\na : \u03b1\nb : \u03b2\nc : \u03b3\nh : (a, b, c) \u2208 t\n\u22a2 \u03b1",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/MvPolynomial/Rename.lean",301,"case intro.intro\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_4\ninst\u271d : CommSemiring R\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\nu : \u03c3 \u2192\u2080 \u2115\nh : coeff u \u03c6 = 0\nhu : \u00ac\u03c6 u = 0\n\u22a2 False",["contradiction","tauto"]],["Analysis/Normed/Unbundled/SeminormFromConst.lean",248,"case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\nn : \u2115\n\u22a2 n \u2264 n + 1",["omega","aesop","linarith","tauto","norm_num","simp"]],["GroupTheory/GroupExtension/Defs.lean",247,"N : Type u_1\nE : Type u_2\nG : Type u_3\ninst\u271d\u00b2 : Group N\ninst\u271d\u00b9 : Group E\ninst\u271d : Group G\nS : GroupExtension N E G\nx\u271d\u00b2 x\u271d\u00b9 : S.Section\ntoFun\u271d\u00b9 : G \u2192 E\nrightInverse_rightHom\u271d\u00b9 : Function.RightInverse toFun\u271d\u00b9 \u21d1S.rightHom\ntoFun\u271d : G \u2192 E\nrightInverse_rightHom\u271d : Function.RightInverse toFun\u271d \u21d1S.rightHom\nx\u271d :\n  { toFun := toFun\u271d\u00b9, rightInverse_rightHom := rightInverse_rightHom\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, rightInverse_rightHom := rightInverse_rightHom\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, rightInverse_rightHom := rightInverse_rightHom\u271d\u00b9 } =\n    { toFun := toFun\u271d, rightInverse_rightHom := rightInverse_rightHom\u271d }",["congr","aesop"]],["Algebra/BigOperators/Intervals.lean",169,"case e_s.h\n\u03b1 : Type u_3\ninst\u271d : CommGroup \u03b1\nf : \u2115 \u2192 \u03b1\nn m : \u2115\nhnm : n \u2264 m\n\u22a2 \u2200 (a : \u2115), n \u2264 a \u2227 a < m \u2194 a < m \u2227 n \u2264 a",["tauto","omega","aesop"]],["NumberTheory/FLT/Basic.lean",62,"x\u271d\u2075 x\u271d\u2074 x\u271d\u00b3 : \u2115\nx\u271d\u00b2 : x\u271d\u2075 \u2260 0\nx\u271d\u00b9 : x\u271d\u2074 \u2260 0\nx\u271d : x\u271d\u00b3 \u2260 0\n\u22a2 x\u271d\u2075 ^ 0 + x\u271d\u2074 ^ 0 \u2260 x\u271d\u00b3 ^ 0",["norm_num","aesop","linarith","simp"]],["NumberTheory/FLT/Basic.lean",65,"h : FermatLastTheoremFor 1\n\u22a2 1 ^ 1 + 1 ^ 1 = 2 ^ 1",["norm_num","ring","omega","decide","aesop","linarith","tauto","abel","simp"]],["NumberTheory/FLT/Basic.lean",68,"h : FermatLastTheoremFor 2\n\u22a2 3 ^ 2 + 4 ^ 2 = 5 ^ 2",["norm_num","ring","omega","decide","aesop","linarith","tauto","abel","simp"]],["SetTheory/Nimber/Basic.lean",312,"case a.h\u2081.inl.intro.intro.h\na b c y : Nimber\nhy : y < a\nhx : y + b < a + b\n\u22a2 y < a\n```\n---\n```lean\ncase a.h\u2081.inr.intro.intro.h\na b c y : Nimber\nhy : y < b\nhx : a + y < a + b\n\u22a2 y < b\n```\n---\n```lean\ncase a.h\u2082.h\na b c x : Nimber\nhx : x < c\n\u22a2 x < c\n```\n---\n```lean\ncase a.h\u2081.h\na b c x : Nimber\nhx : x < a\n\u22a2 x < a\n```\n---\n```lean\ncase a.h\u2082.inl.intro.intro.h\na b c y : Nimber\nhy : y < b\nhx : y + c < b + c\n\u22a2 y < b\n```\n---\n```lean\ncase a.h\u2082.inr.intro.intro.h\na b c y : Nimber\nhy : y < c\nhx : b + y < b + c\n\u22a2 y < c",["assumption","aesop","congr","gcongr","tauto"]],["SetTheory/Nimber/Basic.lean",244,"a b c : Nimber\nh\u2081 : \u2200 a' < a, a' + b \u2260 c\nh\u2082 : \u2200 b' < b, a + b' \u2260 c\nh : c < a + b\nthis : (\u2203 a' < a, a' + b = c) \u2228 \u2203 b' < b, a + b' = c\n\u22a2 False",["tauto","aesop"]],["Topology/MetricSpace/Holder.lean",273,"case refine_1\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace X\ninst\u271d : MetricSpace Y\nr : \u211d\u22650\nf : X \u2192 Y\nx\u2081 x\u2082 : X\nh : f x\u2081 = f x\u2082\n\u22a2 f x\u2081 = f x\u2082",["assumption","aesop","congr","gcongr","tauto"]],["NumberTheory/FLT/Four.lean",193,"a b c : \u2124\nh : Minimal a b c\nha2 : a % 2 = 1\nhc : 0 < c\nht : PythagoreanTriple (a ^ 2) (b ^ 2) c\nh2 : (a ^ 2).gcd (b ^ 2) = 1\nha22 : a ^ 2 % 2 = 1\nn : \u2124\nh3 : a.gcd n = 1\nht1 : a ^ 2 = 0 ^ 2 - n ^ 2\nht2 : b ^ 2 = 2 * 0 * n\nht3 : c = 0 ^ 2 + n ^ 2\nht4 : Int.gcd 0 n = 1\nht5 : 0 % 2 = 0 \u2227 n % 2 = 1 \u2228 0 % 2 = 1 \u2227 n % 2 = 0\nht6 : 0 \u2264 0\nhtt : PythagoreanTriple a n 0\n\u22a2 2 * 0 * n \u2260 0 \u2192 False",["simp","omega","aesop","norm_num"]],["NumberTheory/FLT/Four.lean",31,"a b c : \u2124\n\u22a2 a \u2260 0 \u2227 b \u2260 0 \u2227 b ^ 4 + a ^ 4 = c ^ 2 \u2194 b \u2260 0 \u2227 a \u2260 0 \u2227 b ^ 4 + a ^ 4 = c ^ 2",["tauto","omega","aesop"]],["NumberTheory/FLT/Four.lean",123,"case intro.intro.intro.inl.inl\na b c : \u2124\nh : Fermat42 a b c\na0 b0 c0 : \u2124\nhf : Minimal a0 b0 c0\nhap : a0 % 2 = 0\nhbp : b0 % 2 = 0\n\u22a2 2 \u2223 \u21911 \u2192 False",["decide","omega","aesop","tauto","norm_num","simp"]],["NumberTheory/FLT/Four.lean",172,"a b c : \u2124\nh : Minimal a b c\nha2 : a % 2 = 1\nhc : 0 < c\nht : PythagoreanTriple (a ^ 2) (b ^ 2) c\nh2 : (a ^ 2).gcd (b ^ 2) = 1\n\u22a2 1 * 1 % 2 = 1",["decide","ring","omega","aesop","congr","tauto","abel","norm_num","simp"]],["Data/Matroid/Dual.lean",108,"\u03b1 : Type u_1\nM\u271d : Matroid \u03b1\nI B X : Set \u03b1\nM : Matroid \u03b1\n\u22a2 \u2200 (I : Set \u03b1), (fun I \u21a6 I \u2286 M.E \u2227 \u2203 B, M.IsBase B \u2227 Disjoint I B) I \u2192 I \u2286 M.E",["tauto","aesop"]],["Analysis/Normed/Unbundled/FiniteExtension.lean",196,"K : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : NormedField K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nhfd : FiniteDimensional K L\nhna : IsNonarchimedean norm\nh1 : LinearIndependent K fun (x : \u2191{1}) \u21a6 \u2191x := LinearIndepOn.id_singleton K one_ne_zero\n\u03b9 : Type u_2 := { x // x \u2208 LinearIndepOn.extend h1 \u22ef }\nB : Basis \u03b9 K L := Basis.extend h1\nhfin : Fintype \u03b9 := FiniteDimensional.fintypeBasisIndex B\nhem : Nonempty \u03b9\nh1L : 1 \u2208 LinearIndepOn.extend h1 \u22ef\nhB1 : B \u27e81, h1L\u27e9 = 1\ng : L \u2192 \u211d := B.norm\nhg0 : g 0 = 0\nx : L\n\u22a2 0 \u2264 univ.sup' \u22ef fun i \u21a6 \u2016(B.repr x) i\u2016",["aesop","norm_num","simp"]],["CategoryTheory/Monoidal/Free/Coherence.lean",174,"case mk.mk.up.up\nC : Type u\nZ : F C\nas\u271d : NormalMonoidalObject C\n\u22a2 ((tensorFunc C).obj Z).map { down := { down := \u22ef } } = inclusion.map { down := { down := \u22ef } } \u25b7 Z",["simp","aesop"]],["CategoryTheory/Monoidal/Free/Coherence.lean",86,"C : Type u\nX Y : (Discrete \u2218 NormalMonoidalObject) C\ndown\u271d : X.as = Y.as\n\u22a2 Discrete.as ?m.5556 = Discrete.as ?m.5557",["assumption","aesop","congr","gcongr","tauto"]],["Probability/ProbabilityMassFunction/Monad.lean",267,"case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : PMF \u03b1\nf : (a : \u03b1) \u2192 a \u2208 p.support \u2192 PMF \u03b2\ng : (b : \u03b2) \u2192 b \u2208 (p.bindOnSupport f).support \u2192 PMF \u03b3\na : \u03b3\na' : \u03b1\nb : \u03b2\nh : \u00acp a' = 0\nh_1 : \u2200 (i : \u03b1), (p i * if h : p i = 0 then 0 else (f i h) b) = 0\n_ : \u00ac(f a' h) b = 0\nthis : (f a' \u22ef) b = 0\n\u22a2 p a' * (f a' h) b * 0 = p a' * ((f a' h) b * (g b \u22ef) a)",["contradiction","aesop","tauto"]],["MeasureTheory/Measure/MutuallySingular.lean",190,"\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nh : Disjoint \u03bc \u03bd\n\u03b5 : \u211d\u22650\nh\u03b5 : 0 < \u03b5\nh\u2081 : sInf {m | \u2203 t, m = \u03bc t + \u03bd t\u1d9c} = 0\nt : \u2115 \u2192 Set \u03b1\nht\u2082 : \u2200 (n : \u2115), \u03bc (t n) + \u03bd (t n)\u1d9c < \u2191\u03b5 * (1 / 2) ^ n\n\u22a2 1 / 2 < 1",["norm_num","aesop","simp"]],["NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean",155,"a b c : \u2115\nhb0 : 0 < b\nhc : a / b \u2264 c\nx : \u2115\nthis : x * b \u2264 a \u2192 x \u2264 c\n\u22a2 x * b \u2264 a \u2192 1 \u2264 x \u2192 x \u2264 c",["tauto","omega","aesop"]],["NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean",211,"p q : \u2115\nhp : Fact (Nat.Prime p)\nhq0 : \u2191q \u2260 0\nhswap :\n  #(filter (fun x \u21a6 x.2 * q \u2264 x.1 * p) (Ico 1 (q / 2).succ \u00d7\u02e2 Ico 1 (p / 2).succ)) =\n    #(filter (fun x \u21a6 x.1 * q \u2264 x.2 * p) (Ico 1 (p / 2).succ \u00d7\u02e2 Ico 1 (q / 2).succ))\nhdisj :\n  Disjoint (filter (fun x \u21a6 x.2 * p \u2264 x.1 * q) (Ico 1 (p / 2).succ \u00d7\u02e2 Ico 1 (q / 2).succ))\n    (filter (fun x \u21a6 x.1 * q \u2264 x.2 * p) (Ico 1 (p / 2).succ \u00d7\u02e2 Ico 1 (q / 2).succ))\nx : \u2115 \u00d7 \u2115\nthis : x.2 * p \u2264 x.1 * q \u2228 x.1 * q \u2264 x.2 * p\n\u22a2 ((1 \u2264 x.1 \u2227 x.1 < (p / 2).succ) \u2227 1 \u2264 x.2 \u2227 x.2 < (q / 2).succ) \u2227 x.2 * p \u2264 x.1 * q \u2228\n      ((1 \u2264 x.1 \u2227 x.1 < (p / 2).succ) \u2227 1 \u2264 x.2 \u2227 x.2 < (q / 2).succ) \u2227 x.1 * q \u2264 x.2 * p \u2194\n    (1 \u2264 x.1 \u2227 x.1 < (p / 2).succ) \u2227 1 \u2264 x.2 \u2227 x.2 < (q / 2).succ",["tauto","omega","aesop"]],["Algebra/ContinuedFractions/Computation/CorrectnessTerminating.lean",150,"K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\nv : K\nn\u271d : \u2115\ninst\u271d : FloorRing K\ng : GenContFract K := of v\nn : \u2115\nifp_succ_n : IntFractPair K\nsucc_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n\nifp_n : IntFractPair K\nnth_stream_eq : IntFractPair.stream v n = some ifp_n\nnth_fract_ne_zero : ifp_n.fr \u2260 0\nconts : Pair K := g.contsAux (n + 2)\npconts : Pair K := g.contsAux (n + 1)\npconts_eq : pconts = g.contsAux (n + 1)\nppconts : Pair K := g.contsAux n\nIH : \u2200 {ifp_n : IntFractPair K}, IntFractPair.stream v n = some ifp_n \u2192 v = compExactValue ppconts pconts ifp_n.fr\nppconts_eq : ppconts = g.contsAux n\nifp_succ_n_fr_ne_zero : ifp_succ_n.fr \u2260 0\nthis\u271d : compExactValue ppconts pconts ifp_n.fr = compExactValue pconts conts ifp_succ_n.fr\nthis : v = compExactValue ppconts pconts ifp_n.fr\n\u22a2 compExactValue ppconts pconts ifp_n.fr = compExactValue pconts ((of v).contsAux (n + 1 + 1)) ifp_succ_n.fr",["assumption","congr","linarith","gcongr","tauto"]],["Data/Finset/Union.lean",88,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 Finset (Set \u03b2)\nI : Finset \u03b1\nhf : (\u2191I).PairwiseDisjoint f\nx\u271d : \u03b2\n\u22a2 (\u2203 t, (\u2203 i \u2208 I, t \u2208 f i) \u2227 x\u271d \u2208 t) \u2194 \u2203 i \u2208 I, \u2203 t \u2208 f i, x\u271d \u2208 t",["tauto","aesop"]],["Data/Finset/Union.lean",173,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 Finset \u03b2\nt : Finset \u03b2\nx : \u03b2\n\u22a2 (\u2203 a \u2208 s, x \u2208 f a) \u2227 x \u2208 t \u2194 \u2203 a \u2208 s, x \u2208 f a \u2227 x \u2208 t",["tauto","aesop"]],["Data/Finset/Union.lean",233,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 Finset \u03b2\ns : Finset \u03b1\nb a : \u03b2\n\u22a2 (\u00aca = b \u2227 \u2203 a_1 \u2208 s, a \u2208 f a_1) \u2194 \u2203 a_1 \u2208 s, \u00aca = b \u2227 a \u2208 f a_1",["tauto","aesop"]],["Topology/Homotopy/Path.lean",216,"X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np q : Path x\u2080 x\u2081\nF : p.Homotopy q\nf : C(X, Y)\n\u22a2 \u2200 (x : \u2191I), { toFun := \u21d1f \u2218 \u21d1F, continuous_toFun := \u22ef }.toFun (0, x) = (p.map \u22ef).toContinuousMap x",["simp","aesop","norm_num"]],["Topology/Homotopy/Path.lean",71,"X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np\u2080 p\u2081 : Path x\u2080 x\u2081\nF : p\u2080.Homotopy p\u2081\nt : \u2191I\n\u22a2 { toFun := \u21d1(F.curry t), continuous_toFun := \u22ef }.toFun 0 = x\u2080",["simp","aesop","norm_num"]],["Topology/Homotopy/Path.lean",169,"X : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 : X\np\u2080 q\u2080 : Path x\u2080 x\u2081\np\u2081 q\u2081 : Path x\u2081 x\u2082\nF : p\u2080.Homotopy q\u2080\nG : p\u2081.Homotopy q\u2081\nt : \u2191I\n\u22a2 (if \u2191(t, \u27e81 / 2, \u22ef\u27e9).2 \u2264 1 / 2 then (F.eval (t, \u27e81 / 2, \u22ef\u27e9).1).extend (2 * \u2191(t, \u27e81 / 2, \u22ef\u27e9).2)\n    else (G.eval (t, \u27e81 / 2, \u22ef\u27e9).1).extend (2 * \u2191(t, \u27e81 / 2, \u22ef\u27e9).2 - 1)) =\n    x\u2081",["norm_num","aesop","simp"]],["Topology/Homotopy/Path.lean",181,"X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nf : \u2191I \u2192 \u2191I\nhf : Continuous f\nhf\u2080 : f 0 = 0\nhf\u2081 : f 1 = 1\nx : \u2191I\n\u22a2 { toFun := fun x \u21a6 p \u27e8\u2191(\u03c3 x.1) * \u2191x.2 + \u2191x.1 * \u2191(f x.2), \u22ef\u27e9, continuous_toFun := \u22ef }.toFun (0, x) = p.toContinuousMap x",["norm_num","aesop","infer_instance","simp"]],["Topology/Homotopy/Path.lean",182,"X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nf : \u2191I \u2192 \u2191I\nhf : Continuous f\nhf\u2080 : f 0 = 0\nhf\u2081 : f 1 = 1\nx : \u2191I\n\u22a2 { toFun := fun x \u21a6 p \u27e8\u2191(\u03c3 x.1) * \u2191x.2 + \u2191x.1 * \u2191(f x.2), \u22ef\u27e9, continuous_toFun := \u22ef }.toFun (1, x) =\n    (p.reparam f hf hf\u2080 hf\u2081).toContinuousMap x",["norm_num","aesop","infer_instance","simp"]],["Order/Defs/LinearOrder.lean",188,"case h\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nd\u271d : \u03b1\na\u271d\u00b9 : d\u271d \u2264 a\na\u271d : d\u271d \u2264 b\n\u22a2 d\u271d \u2264 a",["assumption","congr"]],["Order/Defs/LinearOrder.lean",215,"case h\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : b \u2264 a\nd\u271d : \u03b1\na\u271d\u00b9 : a \u2264 d\u271d\na\u271d : b \u2264 d\u271d\n\u22a2 a \u2264 d\u271d",["assumption","congr"]],["FieldTheory/AxGrothendieck.lean",152,"\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Finite \u03b1\nK : Type u_3\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : CompatibleRing K\ninst\u271d : Finite \u03b9\n\u03c6 : ring.Formula (\u03b1 \u2295 \u03b9)\nmons : \u03b9 \u2192 Finset (\u03b9 \u2192\u2080 \u2115)\n\u22a2 \u2200 {S : Set (\u03b9 \u2192 K)} (f : (\u03b9 \u2192 K) \u2192 \u03b9 \u2192 K),\n    (\u2200 \u2983x\u2081 : \u03b9 \u2192 K\u2984, x\u2081 \u2208 S \u2192 \u2200 \u2983x\u2082 : \u03b9 \u2192 K\u2984, x\u2082 \u2208 S \u2192 f x\u2081 = f x\u2082 \u2192 x\u2081 = x\u2082) \u2194\n      \u2200 (x y : \u03b9 \u2192 K), x \u2208 S \u2192 y \u2208 S \u2192 f x = f y \u2192 x = y",["tauto","aesop"]],["Algebra/Lie/Weights/Linear.lean",194,"case a\nk : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : LieAlgebra R L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieModule R L M\ninst\u271d\u00b9 : LieRing.IsNilpotent L\n\u03c7 : L \u2192 R\ninst\u271d : LinearWeights R L M\nt : R\nx : L\nm : \u21a5(shiftedGenWeightSpace R L M \u03c7)\na\u271d : Nontrivial \u21a5(shiftedGenWeightSpace R L M \u03c7)\n\u22a2 t \u2022 (\u2045x, \u2191m\u2046 - \u03c7 x \u2022 \u2191m) = t \u2022 \u2191\u2045x, m\u2046",["congr","aesop","tauto","abel","norm_num","simp"]],["Algebra/Lie/Weights/Linear.lean",201,"case a\nk : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : LieAlgebra R L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieModule R L M\ninst\u271d\u00b9 : LieRing.IsNilpotent L\n\u03c7 : L \u2192 R\ninst\u271d : LinearWeights R L M\nt : R\nx : L\nm : \u21a5(shiftedGenWeightSpace R L M \u03c7)\na\u271d : Nontrivial \u21a5(shiftedGenWeightSpace R L M \u03c7)\n\u22a2 t \u2022 (\u2045x, \u2191m\u2046 - \u03c7 x \u2022 \u2191m) = t \u2022 \u2191\u2045x, m\u2046",["congr","aesop","tauto","abel","norm_num","simp"]],["NumberTheory/LSeries/HurwitzZetaValues.lean",128,"k : \u2115\nx : \u211d\nhk : k \u2260 0\nhx : x \u2208 Icc 0 1\nh1 : \u2200 (n : \u2115), 2 * \u2191k \u2260 -\u2191n\n\u22a2 \u00ac2 * k = 1",["simp","omega","aesop","norm_num"]],["Computability/RegularExpressions.lean",297,"case mpr.intro.intro.cons.cons.cons.refine_2.a\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nP : RegularExpression \u03b1\na : \u03b1\nx : List \u03b1\nIH :\n  \u2200 (t : List \u03b1),\n    t.length < (a :: x).length \u2192 (P.star.rmatch t = true \u2194 \u2203 S, t = S.flatten \u2227 \u2200 t \u2208 S, t \u2260 [] \u2227 P.rmatch t = true)\nU : List (List \u03b1)\nb : \u03b1\nt\u271d : List \u03b1\nhelem : \u2200 t \u2208 (b :: t\u271d) :: U, t \u2260 [] \u2227 P.rmatch t = true\nhsum : a = b \u2227 x = t\u271d ++ U.flatten\nhwf : U.flatten.length < (a :: x).length\nt : List \u03b1\nh : t \u2208 U\n\u22a2 Mem t U",["assumption","aesop","congr","tauto"]],["Computability/RegularExpressions.lean",258,"case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nP : RegularExpression \u03b1\nIH :\n  \u2200 (t : List \u03b1),\n    t.length < [].length \u2192 (P.star.rmatch t = true \u2194 \u2203 S, t = S.flatten \u2227 \u2200 t \u2208 S, t \u2260 [] \u2227 P.rmatch t = true)\n_h : P.star.rmatch [] = true\n\u22a2 [] = [] \u2227 \u2200 t \u2208 [], \u00act = [] \u2227 P.rmatch t = true",["tauto","aesop","simp"]],["Computability/RegularExpressions.lean",306,"case zero\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx : List \u03b1\n\u22a2 false = true \u2194 x \u2208 matches' 0",["tauto","aesop","simp"]],["Computability/RegularExpressions.lean",317,"case comp\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nP Q : RegularExpression \u03b1\nih\u2081 : \u2200 (x : List \u03b1), P.rmatch x = true \u2194 x \u2208 P.matches'\nih\u2082 : \u2200 (x : List \u03b1), Q.rmatch x = true \u2194 x \u2208 Q.matches'\nx : List \u03b1\n\u22a2 (\u2203 t u, x = t ++ u \u2227 t \u2208 P.matches' \u2227 u \u2208 Q.matches') \u2194 \u2203 a \u2208 P.matches', \u2203 b \u2208 Q.matches', a ++ b = x",["tauto"]],["Order/Interval/Finset/Nat.lean",195,"a n : \u2115\nih : Set.InjOn (fun x \u21a6 x % a) \u2191(Ico n (n + a))\nk : \u2115\nha : 0 < a\nhkn : k \u2260 n\nhk : k \u2208 Ico n (n + a)\nhkl : k % a = n % a\nhln : n + a \u2260 n\nthis : k = n\n\u22a2 k = n + a",["contradiction","omega","aesop","tauto"]],["Data/Fintype/Basic.lean",196,"\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b1 : Type ?u.20631\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Fintype \u03b1\n\u22a2 \u2203 x, x \u2208 univ.val",["simp","aesop"]],["Data/Fintype/Basic.lean",45,"case h\nn : \u2115\na\u271d : Fin n\n\u22a2 a\u271d \u2208 (finRange n).toFinset \u2194 a\u271d \u2208 univ",["simp","aesop"]],["Data/Fintype/Basic.lean",190,"\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b1 : Type ?u.19786\ns : Multiset \u03b1\nl : List \u03b1\nh : \u2203 x, x \u2208 \u27e6l\u27e7\nx\u271d : \u2203 x, x \u2208 \u27e6[]\u27e7\n\u22a2 False",["tauto","aesop"]],["Analysis/Meromorphic/Order.lean",174,"case left.inl\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nU : Set \ud835\udd5c\nhf : MeromorphicOn f U\nz : \u2191U\nhz : z \u2208 {u | \u22ef.order = \u22a4}\u1d9c\nh : \u22ef.order = \u22a4\n\u22a2 \u2203 t \u2286 {u | \u22ef.order = \u22a4}\u1d9c, IsOpen t \u2227 z \u2208 t",["tauto","aesop","contradiction"]],["Analysis/Meromorphic/Order.lean",205,"case pos\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nU : Set \ud835\udd5c\nhf : MeromorphicOn f U\nz : \u2191U\nt' : Set \ud835\udd5c\nh\u2081t' : \u2200 y \u2208 t', y \u2208 {\u2191z}\u1d9c \u2192 f y = 0\nh\u2082t' : IsOpen t'\nh\u2083t' : \u2191z \u2208 t'\nw : \u2191U\nhw : w \u2208 Subtype.val \u207b\u00b9' t'\nh\u2081w : w = z\n\u22a2 \u2203 t, (\u2200 y \u2208 t, \u00acy = \u2191z \u2192 f y = 0) \u2227 IsOpen t \u2227 \u2191z \u2208 t",["tauto","aesop"]],["Analysis/Meromorphic/Order.lean",224,"case mp.inl\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nU : Set \ud835\udd5c\nhf : MeromorphicOn f U\nhU : IsConnected U\nh\u2082f : \u2203 u, \u22ef.order \u2260 \u22a4\nthis\u271d : PreconnectedSpace \u2191U\nh : {u | \u22ef.order = \u22a4} = \u2205\nu : \u2191U\nthis : u \u2209 {u | \u22ef.order = \u22a4}\n\u22a2 \u22ef.order \u2260 \u22a4",["tauto","congr","assumption"]],["Analysis/Meromorphic/Order.lean",228,"case mp.inr.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nU : Set \ud835\udd5c\nhf : MeromorphicOn f U\nhU\u271d : IsConnected U\nthis\u271d : PreconnectedSpace \u2191U\nh : {u | \u22ef.order = \u22a4} = univ\nu : \u2191U\nhU : \u22ef.order \u2260 \u22a4\nthis : u \u2208 {u | \u22ef.order = \u22a4}\n\u22a2 \u2200 (u : \u2191U), \u22ef.order \u2260 \u22a4",["tauto","contradiction"]],["LinearAlgebra/RootSystem/Basic.lean",144,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : CharZero R\ninst\u271d : NoZeroSMulDivisors R M\np : PerfectPairing R M N\nroot : \u03b9 \u21aa M\ncoroot : \u03b9 \u21aa N\nhp : \u2200 (i : \u03b9), (p (root i)) (coroot i) = 2\nhr : \u2200 (i : \u03b9), MapsTo (\u21d1(preReflection (root i) (p.flip (coroot i)))) (range \u21d1root) (range \u21d1root)\nhc : \u2200 (i : \u03b9), MapsTo (\u21d1(preReflection (coroot i) (p (root i)))) (range \u21d1coroot) (range \u21d1coroot)\ni j k : \u03b9\n\u03b1 : M := root i\n\u03b2 : M := root j\n\u03b1' : N := coroot i\n\u03b2' : N := coroot j\ns\u03b1 : End R M := preReflection \u03b1 (p.flip \u03b1')\nhk : root k = s\u03b1 \u03b2\ns\u03b2 : End R M := preReflection \u03b2 (p.flip \u03b2')\ns\u03b1' : End R N := preReflection \u03b1' (p \u03b1)\nhij : preReflection (s\u03b1 \u03b2) (p.flip (s\u03b1' \u03b2')) = s\u03b1 \u2218\u2097 s\u03b2 \u2218\u2097 s\u03b1\nhk\u2080 : root k \u2260 0\nl : \u03b9\nhl : coroot l = (preReflection (coroot i) (p (root i))) (coroot j)\n\u22a2 2 - (p (root j)) (coroot i) * (p (root i)) (coroot j) -\n      ((p (root j)) (coroot i) * (p (root i)) (coroot j) -\n        ((p (root j)) (coroot i) * (p (root i)) (coroot j) + (p (root j)) (coroot i) * (p (root i)) (coroot j))) =\n    2",["abel","ring","aesop","norm_num","simp"]],["NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean",276,"case neg\nF : Type u_1\ninst\u271d\u00b9 : Field F\ninst\u271d : Fintype F\nhF : \u00acringChar F = 2\nh\u2081 : Fintype.card F % 2 = 1\n\u22a2 (if 1 = 0 then 0 else if Fintype.card F % 4 = 1 then 1 else -1) = 1 \u2194 Fintype.card F % 4 \u2260 3",["omega","tauto","infer_instance"]],["Analysis/Meromorphic/Divisor/Basic.lean",231,"\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nU : Set \ud835\udd5c\nD\u2081 D\u2082 : DivisorOn U\nx : \ud835\udd5c\n\u22a2 D\u2081 x \u2264 (D\u2081 \u2294 D\u2082) x",["simp","aesop","norm_num"]],["Analysis/Meromorphic/Divisor/Basic.lean",99,"case h.mpr\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nU : Set \ud835\udd5c\nD : DivisorOn U\nx : \ud835\udd5c\nhx : \u00acD x = 0 \u2227 x \u2208 U\n\u22a2 x \u2208 Function.support \u21d1D",["tauto","aesop"]],["Probability/Kernel/Composition/Prod.lean",135,"case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03b7 : Kernel \u03b1 \u03b3\ninst\u271d : IsZeroOrMarkovKernel \u03b7\nh : IsZeroOrMarkovKernel 0\n\u22a2 IsZeroOrMarkovKernel 0",["infer_instance","tauto"]],["Probability/Kernel/Composition/Prod.lean",137,"case inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\nh\u271d : IsZeroOrMarkovKernel \u03ba\nh : IsMarkovKernel \u03ba\ninst\u271d : IsZeroOrMarkovKernel 0\n\u22a2 IsZeroOrMarkovKernel 0",["infer_instance","tauto"]],["Analysis/InnerProductSpace/LinearMap.lean",86,"case mp.h\nV : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u2102 V\nT : V \u2192\u2097[\u2102] V\nhT : \u2200 (x : V), \u27eaT x, x\u27eb_\u2102 = 0\nx : V\n\u22a2 (0 - 0 + Complex.I * 0 - Complex.I * 0) / 4 = 0",["norm_num","ring","aesop","simp"]],["Combinatorics/Schnirelmann.lean",145,"A : Set \u2115\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 A\nx : \u211d\n\u22a2 (\u00ac\u2200 (n : \u2115), 0 < n \u2192 x \u2264 \u2191(#(filter (fun a \u21a6 a \u2208 A) (Ioc 0 n))) / \u2191n) \u2194\n    \u2203 n, 0 < n \u2227 \u2191(#(filter (fun a \u21a6 a \u2208 A) (Ioc 0 n))) / \u2191n < x",["simp","aesop","norm_num"]],["Combinatorics/Schnirelmann.lean",224,"case inl\nhm : 0 \u2260 1\n\u22a2 {n | n % 0 = 1}.Finite",["simp","aesop","norm_num"]],["Algebra/Homology/HomotopyCategory/DegreewiseSplit.lean",190,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.177784, u_1} C\ninst\u271d\u00b9 : Preadditive C\nS : ShortComplex (CochainComplex C \u2124)\n\u03c3 : (n : \u2124) \u2192 (S.map (eval C (ComplexShape.up \u2124) n)).Splitting\ninst\u271d : HasBinaryBiproducts C\nK L : CochainComplex C \u2124\n\u03c6 : K \u27f6 L\nn : \u2124\n\u22a2 n + 1 + -1 = n",["omega","aesop","linarith","abel","norm_num","simp"]],["Combinatorics/Extremal/RuzsaSzemeredi.lean",200,"\u22a2 (\u21912 / 3 - 2) * \u2191(rothNumberNat ((2 - 3) / 6)) \u2264 \u2191(ruzsaSzemerediNumberNat 2)",["simp","aesop","linarith","norm_num"]],["Combinatorics/Extremal/RuzsaSzemeredi.lean",178,"n : \u2115\n\u03b1 : Type := Fin (2 * n + 1)\n\u22a2 Coprime 2 (2 * n + 1)",["simp","aesop","norm_num"]],["Combinatorics/Extremal/RuzsaSzemeredi.lean",247,"\u22a2 3\u207b\u00b9 \u2260 0",["norm_num","aesop","linarith","positivity","simp"]],["Combinatorics/Extremal/RuzsaSzemeredi.lean",74,"case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : \u03b1 \u21aa \u03b2\nG : SimpleGraph \u03b1\nw\u271d : DecidableRel G.Adj\nhG : G.LocallyLinear\n\u22a2 3 \u2260 1",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["Data/Int/Cast/Lemmas.lean",64,"case negSucc\n\u03b1 : Type u_3\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na\u271d : \u2115\nh : a\u271d + 1 = 0\n\u22a2 -[a\u271d+1] = 0",["contradiction","omega","aesop","tauto"]],["LinearAlgebra/Matrix/SemiringInverse.lean",43,"n : Type u_1\nR : Type u_3\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommSemiring R\n\u03c3 : Perm n\nh\u03c3 : \u03c3 = 1\n\u22a2 \u00ac1 = -1",["decide","tauto"]],["Data/Real/Pi/Bounds.lean",39,"n : \u2115\n\u22a2 0 \u2264 2 ^ (n + 2)",["positivity","aesop","norm_num","simp"]],["Data/Real/Pi/Bounds.lean",29,"case h.ha\nn : \u2115\n\u22a2 0 < 2\n```\n---\n```lean\ncase ha\nn : \u2115\n\u22a2 0 < 2",["norm_num","aesop","linarith","positivity","simp"]],["Data/Real/Pi/Bounds.lean",31,"case h\nn : \u2115\nthis : \u221a(2 - sqrtTwoAddSeries 0 n) / 2 * 2 ^ (n + 2) < \u03c0\n\u22a2 2 \u2260 0",["norm_num","aesop","linarith","positivity","simp"]],["Combinatorics/SimpleGraph/Bipartite.lean",125,"V : Type u_1\nG : SimpleGraph V\ns t : Set V\nh : G.IsBipartiteWith s t\nv w : V\nhadj : v \u2208 s \u2227 w \u2208 t \u2228 v \u2208 t \u2227 w \u2208 s\n\u22a2 v \u2208 s \u222a t",["tauto","aesop"]],["Tactic/Peel.lean",86,"p q r : Prop\nh : r \u2192 p \u2192 q\n\u22a2 r \u2227 p \u2192 r \u2227 q",["tauto","aesop"]],["Data/PNat/Basic.lean",168,"p : \u2115+ \u2192 Sort u_1\none : p 1\nsucc : (n : \u2115+) \u2192 p n \u2192 p (n + 1)\nh : 0 < 0\n\u22a2 \u00ac0 < 0",["decide","omega","aesop","tauto","contradiction","simp"]],["Logic/Denumerable.lean",147,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Denumerable \u03b1\ninst\u271d : Denumerable \u03b2\nn : \u2115\n\u22a2 ofNat (\u03b1 \u00d7 \u03b2) n = (ofNat \u03b1 (unpair n).1, ofNat \u03b2 (unpair n).2)",["simp","aesop"]],["Logic/Denumerable.lean",94,"\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Denumerable \u03b1\ne : \u03b2 \u2243 \u03b1\nn : \u2115\nthis : Denumerable \u03b2 := ofEquiv \u03b1 e\n\u22a2 Option.map (\u21d1e.symm) (decode n) = some (e.symm (ofNat \u03b1 n))",["simp","aesop"]],["Logic/Denumerable.lean",275,"s : Set \u2115\ninst\u271d\u00b9 : Infinite \u2191s\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 s\nn : \u2115\nih : Nat.Subtype.toFunAux (ofNat s n) = n\n\u22a2 \u2191(ofNat s n) \u2209 filter (fun x \u21a6 x \u2208 s) (range \u2191(ofNat s n))",["simp","aesop"]],["Algebra/Squarefree/Basic.lean",259,"case pos.inr\nR : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero R\ninst\u271d\u00b9 : UniqueFactorizationMonoid R\ninst\u271d : NormalizationMonoid R\nx : R\nx0 : x \u2260 0\nthis\u271d : Nontrivial R\nh\u271d : \u2200 (x_1 : R), emultiplicity x_1 x \u2264 1 \u2228 IsUnit x_1\na : R\nhmem : a \u2208 normalizedFactors x\nha : Irreducible a\nh : IsUnit a\nthis : \u00acIsUnit a\n\u22a2 Multiset.count a (normalizedFactors x) \u2264 1",["contradiction","aesop","tauto"]],["NumberTheory/Cyclotomic/Discriminant.lean",39,"n : \u2115+\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : CharZero K\n\u03b6 : K\nce : IsCyclotomicExtension {n} \u211a K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u2191n\nthis : NumberField K\nH\u2081 : (aeval (IsPrimitiveRoot.powerBasis \u211a h\u03b6).gen) (X - 1) = (subOnePowerBasis \u211a h\u03b6).gen\n\u22a2 (aeval (subOnePowerBasis \u211a h\u03b6).gen) (X + 1) = (IsPrimitiveRoot.powerBasis \u211a h\u03b6).gen",["simp","aesop","norm_num"]],["NumberTheory/Cyclotomic/Discriminant.lean",38,"n : \u2115+\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : CharZero K\n\u03b6 : K\nce : IsCyclotomicExtension {n} \u211a K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u2191n\nthis : NumberField K\n\u22a2 (aeval (IsPrimitiveRoot.powerBasis \u211a h\u03b6).gen) (X - 1) = (subOnePowerBasis \u211a h\u03b6).gen",["simp","aesop","norm_num"]],["NumberTheory/Cyclotomic/Discriminant.lean",197,"p : \u2115+\nK : Type u\nL : Type v\n\u03b6 : L\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsCyclotomicExtension {p} K L\nhp : Fact (Nat.Prime \u2191p)\nh\u03b6 : IsPrimitiveRoot \u03b6 \u2191p\nhirr : Irreducible (cyclotomic (\u2191p) K)\nhodd : p \u2260 2\n\u22a2 IsCyclotomicExtension {p} K L",["infer_instance","omega","aesop","congr","gcongr","tauto","assumption"]],["NumberTheory/Cyclotomic/Discriminant.lean",141,"case zero\np : \u2115+\nK : Type u\nL : Type v\n\u03b6 : L\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nhp : Fact (Nat.Prime \u2191p)\nhcycl : IsCyclotomicExtension {p ^ 0} K L\nh\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ 0)\nhirr : Irreducible (cyclotomic (\u2191(p ^ 0)) K)\nh\u03b6one : \u03b6 = 1\n\u22a2 Matrix.of (fun i j \u21a6 \u03c6 \u2191(p ^ 0) \u2022 1) default default = 1 * \u2191\u2191p ^ (\u2191p ^ (0 - 1) * (0 - 1))",["norm_num","aesop","simp"]],["NumberTheory/Cyclotomic/Discriminant.lean",173,"case pos.intro.convert_2\nK : Type u\nL : Type v\n\u03b6 : L\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\ncoe_two : 2 = \u21912\nhp : Fact (Nat.Prime \u21912)\nhcycl\u271d : IsCyclotomicExtension {2 ^ (0 + 1)} K L\nhcycl : IsCyclotomicExtension {2} K L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191(2 ^ (0 + 1))\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21912\nhirr : Irreducible (cyclotomic (\u2191(2 ^ (0 + 1))) K)\nthis : (minpoly K \u03b6).natDegree = 1\ne : Fin (minpoly K \u03b6).natDegree \u2243 Fin 1\n\u22a2 \u03c6 \u2191(2 ^ (0 + 1)) \u2022 1 = 1",["norm_num","aesop","simp"]],["NumberTheory/Harmonic/GammaDeriv.lean",110,"case hc.hs\nh_diff : \u2200 {s : \u211d}, 0 < s \u2192 DifferentiableAt \u211d Gamma s\nh_diff' : \u2200 {s : \u211d}, 0 < s \u2192 DifferentiableAt \u211d (fun s \u21a6 Gamma (2 * s)) s\n\u22a2 0 < 1 / 2",["norm_num","aesop","linarith","positivity","simp"]],["NumberTheory/Harmonic/GammaDeriv.lean",134,"case e_a.e_a.e_a.hh\u2082.hs\nh_diff : \u2200 {s : \u211d}, 0 < s \u2192 DifferentiableAt \u211d Gamma s\nh_diff' : \u2200 {s : \u211d}, 0 < s \u2192 DifferentiableAt \u211d (fun s \u21a6 Gamma (2 * s)) s\n\u22a2 0 < 2 * (1 / 2)",["norm_num","aesop","linarith","positivity","simp"]],["Algebra/MvPolynomial/Variables.lean",170,"case insert\nR : Type u\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\nt : Finset \u03b9\n\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R\ninst\u271d : DecidableEq \u03c3\na\u271d : \u03b9\ns\u271d : Finset \u03b9\nhas : a\u271d \u2209 s\u271d\nhsum : (\u2211 i \u2208 s\u271d, \u03c6 i).vars \u2286 s\u271d.biUnion fun i \u21a6 (\u03c6 i).vars\n\u22a2 (\u2211 x \u2208 s\u271d, \u03c6 x).vars \u2286 s\u271d.biUnion fun i \u21a6 (\u03c6 i).vars",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/MvPolynomial/Variables.lean",187,"case insert.intro.intro\nR : Type u\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\nt : Finset \u03b9\n\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R\ninst\u271d : DecidableEq \u03c3\na\u271d : \u03b9\ns\u271d : Finset \u03b9\nhas : a\u271d \u2209 s\u271d\nhsum : (\u2211 i \u2208 s\u271d, \u03c6 i).vars = s\u271d.biUnion fun i \u21a6 (\u03c6 i).vars\nh : \u2200 \u2983i j : \u03b9\u2984, i \u2260 j \u2192 \u2200 a \u2208 (\u03c6 i).vars, \u2200 b \u2208 (\u03c6 j).vars, a \u2260 b\nv : \u03c3\nhv : v \u2208 (\u03c6 a\u271d).vars\nv2 : \u03c3\nhis : a\u271d \u2208 s\u271d\nhi : v2 \u2208 (\u03c6 a\u271d).vars\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/MvPolynomial/Variables.lean",240,"case neg.h\u2081\nR : Type u\nS : Type v\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\ng : \u03c3 \u2192 S\np : MvPolynomial \u03c3 R\nhp : \u2200 i \u2208 p.vars, g i = 0\nh0 : 0 \u2208 p.support\na\u271d : 0 \u2209 p.support\n\u22a2 (f (coeff 0 p) * Finsupp.prod 0 fun i k \u21a6 g i ^ k) = 0",["contradiction","aesop","tauto"]],["Algebra/MvPolynomial/Variables.lean",246,"R : Type u\nS : Type v\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\ng : \u03c3 \u2192 S\np : MvPolynomial \u03c3 R\nhp : \u2200 i \u2208 p.vars, g i = 0\nh0 : 0 \u2209 p.support\nhd : 0 \u2208 p.support\n\u22a2 False\n```\n---\n```lean\nR : Type u\nS : Type v\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\ng : \u03c3 \u2192 S\np : MvPolynomial \u03c3 R\nhp : \u2200 i \u2208 p.vars, g i = 0\nh0 : \u00ac0 \u2209 p.support\nhd : 0 \u2208 p.support\nhd0 : 0 \u2260 0\n\u22a2 False",["contradiction"]],["RingTheory/Polynomial/ScaleRoots.lean",94,"case a\nR : Type u_1\ninst\u271d : Semiring R\np : R[X]\nn\u271d : \u2115\n\u22a2 (p.scaleRoots 1).coeff n\u271d = p.coeff n\u271d",["simp","aesop","norm_num"]],["RingTheory/Polynomial/ScaleRoots.lean",42,"case a\nR : Type u_1\ninst\u271d : Semiring R\ns : R\nn\u271d : \u2115\n\u22a2 (scaleRoots 0 s).coeff n\u271d = coeff 0 n\u271d",["simp","aesop","congr","tauto","abel","norm_num"]],["RingTheory/Polynomial/ScaleRoots.lean",50,"R : Type u_1\ninst\u271d : Semiring R\np : R[X]\nhp : p \u2260 0\ns : R\nh : p.scaleRoots s = 0\nthis\u271d : p.coeff p.natDegree \u2260 0\nthis : p.leadingCoeff = 0\n\u22a2 False",["contradiction","aesop","tauto"]],["RingTheory/Polynomial/ScaleRoots.lean",74,"case neg\nR : Type u_1\ninst\u271d : Semiring R\np : R[X]\ns : R\nthis\u271d : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\nh : p.leadingCoeff = 0\nthis : p = 0\n\u22a2 False",["contradiction","aesop","tauto"]],["Topology/Order/Hom/Esakia.lean",113,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b3\ninst\u271d : Preorder \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmonotone'\u271d\u00b9 : Monotone toFun\u271d\u00b9\nexists_map_eq_of_map_le'\u271d\u00b9 :\n  \u2200 \u2983a : \u03b1\u2984 \u2983b : \u03b2\u2984,\n    { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 }.toFun a \u2264 b \u2192\n      \u2203 c, a \u2264 c \u2227 { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 }.toFun c = b\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmonotone'\u271d : Monotone toFun\u271d\nexists_map_eq_of_map_le'\u271d :\n  \u2200 \u2983a : \u03b1\u2984 \u2983b : \u03b2\u2984,\n    { toFun := toFun\u271d, monotone' := monotone'\u271d }.toFun a \u2264 b \u2192\n      \u2203 c, a \u2264 c \u2227 { toFun := toFun\u271d, monotone' := monotone'\u271d }.toFun c = b\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, exists_map_eq_of_map_le' := exists_map_eq_of_map_le'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, monotone' := monotone'\u271d, exists_map_eq_of_map_le' := exists_map_eq_of_map_le'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, exists_map_eq_of_map_le' := exists_map_eq_of_map_le'\u271d\u00b9 } =\n    { toFun := toFun\u271d, monotone' := monotone'\u271d, exists_map_eq_of_map_le' := exists_map_eq_of_map_le'\u271d }",["congr","aesop"]],["Topology/Order/Hom/Esakia.lean",218,"case mk.mk.mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2077 : TopologicalSpace \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b2\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b3\ninst\u271d\u00b2 : Preorder \u03b3\ninst\u271d\u00b9 : TopologicalSpace \u03b4\ninst\u271d : Preorder \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmonotone'\u271d\u00b9 : Monotone toFun\u271d\u00b9\ncontinuous_toFun\u271d\u00b9 : Continuous { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 }.toFun\nexists_map_eq_of_map_le'\u271d\u00b9 :\n  \u2200 \u2983a : \u03b1\u2984 \u2983b : \u03b2\u2984,\n    { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun a \u2264 b \u2192\n      \u2203 c, a \u2264 c \u2227 { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun c = b\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmonotone'\u271d : Monotone toFun\u271d\ncontinuous_toFun\u271d : Continuous { toFun := toFun\u271d, monotone' := monotone'\u271d }.toFun\nexists_map_eq_of_map_le'\u271d :\n  \u2200 \u2983a : \u03b1\u2984 \u2983b : \u03b2\u2984,\n    { toFun := toFun\u271d, monotone' := monotone'\u271d, continuous_toFun := continuous_toFun\u271d }.toFun a \u2264 b \u2192\n      \u2203 c, a \u2264 c \u2227 { toFun := toFun\u271d, monotone' := monotone'\u271d, continuous_toFun := continuous_toFun\u271d }.toFun c = b\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9,\n        exists_map_eq_of_map_le' := exists_map_eq_of_map_le'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d, monotone' := monotone'\u271d, continuous_toFun := continuous_toFun\u271d,\n        exists_map_eq_of_map_le' := exists_map_eq_of_map_le'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9,\n      exists_map_eq_of_map_le' := exists_map_eq_of_map_le'\u271d\u00b9 } =\n    { toFun := toFun\u271d, monotone' := monotone'\u271d, continuous_toFun := continuous_toFun\u271d,\n      exists_map_eq_of_map_le' := exists_map_eq_of_map_le'\u271d }",["congr","aesop"]],["LinearAlgebra/RootSystem/Finite/Nondegenerate.lean",189,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Field R\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d : P.IsAnisotropic\nx\u271d : M\n\u22a2 x\u271d \u2208 P.RootForm.orthogonal \u22a4 \u2192 x\u271d \u2208 P.RootForm.orthogonal P.rootSpan",["aesop","tauto"]],["Combinatorics/SimpleGraph/Connectivity/WalkDecomp.lean",231,"case case2\nV : Type u\nG : SimpleGraph V\nv u : V\ninst\u271d : DecidableEq V\nw x : V\np : G.Walk u v\nw\u271d v\u271d : V\nq : G.Walk v\u271d w\u271d\nhadj : G.Adj x v\u271d\nhu' : x \u2208 (cons hadj q).support\nhx : x \u2208 ((cons hadj q).takeUntil x hu').support\n\u22a2 ((cons hadj q).takeUntil x hu').takeUntil x hx = (cons hadj q).takeUntil x \u22ef",["simp","aesop"]],["Data/Nat/Prime/Basic.lean",171,"case inl.a\nx y p : \u2115\nhp : Prime p\nhx\u271d : x \u2260 1\nhy : y \u2260 1\nh : x * y = p ^ 2\npdvdxy : p \u2223 x * y\nthis : \u2200 (x' y' : \u2115), x' \u2260 1 \u2192 y' \u2260 1 \u2192 x' * y' = p ^ 2 \u2192 p \u2223 x' \u2192 x' = p \u2227 y' = p\nhx : p \u2223 x\n\u22a2 x \u2260 1\n```\n---\n```lean\ncase inl.a\nx y p : \u2115\nhp : Prime p\nhx\u271d : x \u2260 1\nhy : y \u2260 1\nh : x * y = p ^ 2\npdvdxy : p \u2223 x * y\nthis : \u2200 (x' y' : \u2115), x' \u2260 1 \u2192 y' \u2260 1 \u2192 x' * y' = p ^ 2 \u2192 p \u2223 x' \u2192 x' = p \u2227 y' = p\nhx : p \u2223 x\n\u22a2 y \u2260 1\n```\n---\n```lean\ncase inl.a\nx y p : \u2115\nhp : Prime p\nhx\u271d : x \u2260 1\nhy : y \u2260 1\nh : x * y = p ^ 2\npdvdxy : p \u2223 x * y\nthis : \u2200 (x' y' : \u2115), x' \u2260 1 \u2192 y' \u2260 1 \u2192 x' * y' = p ^ 2 \u2192 p \u2223 x' \u2192 x' = p \u2227 y' = p\nhx : p \u2223 x\n\u22a2 x * y = p ^ 2\n```\n---\n```lean\ncase inl.a\nx y p : \u2115\nhp : Prime p\nhx\u271d : x \u2260 1\nhy : y \u2260 1\nh : x * y = p ^ 2\npdvdxy : p \u2223 x * y\nthis : \u2200 (x' y' : \u2115), x' \u2260 1 \u2192 y' \u2260 1 \u2192 x' * y' = p ^ 2 \u2192 p \u2223 x' \u2192 x' = p \u2227 y' = p\nhx : p \u2223 x\n\u22a2 p \u2223 x\n```\n---\n```lean\ncase inr.a\nx y p : \u2115\nhp : Prime p\nhx : x \u2260 1\nhy\u271d : y \u2260 1\nh : y * x = p ^ 2\npdvdxy : p \u2223 y * x\nthis : \u2200 (x' y' : \u2115), x' \u2260 1 \u2192 y' \u2260 1 \u2192 x' * y' = p ^ 2 \u2192 p \u2223 x' \u2192 x' = p \u2227 y' = p\nhy : p \u2223 y\n\u22a2 y \u2260 1\n```\n---\n```lean\ncase inr.a\nx y p : \u2115\nhp : Prime p\nhx : x \u2260 1\nhy\u271d : y \u2260 1\nh : y * x = p ^ 2\npdvdxy : p \u2223 y * x\nthis : \u2200 (x' y' : \u2115), x' \u2260 1 \u2192 y' \u2260 1 \u2192 x' * y' = p ^ 2 \u2192 p \u2223 x' \u2192 x' = p \u2227 y' = p\nhy : p \u2223 y\n\u22a2 x \u2260 1\n```\n---\n```lean\ncase inr.a\nx y p : \u2115\nhp : Prime p\nhx : x \u2260 1\nhy\u271d : y \u2260 1\nh : y * x = p ^ 2\npdvdxy : p \u2223 y * x\nthis : \u2200 (x' y' : \u2115), x' \u2260 1 \u2192 y' \u2260 1 \u2192 x' * y' = p ^ 2 \u2192 p \u2223 x' \u2192 x' = p \u2227 y' = p\nhy : p \u2223 y\n\u22a2 y * x = p ^ 2\n```\n---\n```lean\ncase inr.a\nx y p : \u2115\nhp : Prime p\nhx : x \u2260 1\nhy\u271d : y \u2260 1\nh : y * x = p ^ 2\npdvdxy : p \u2223 y * x\nthis : \u2200 (x' y' : \u2115), x' \u2260 1 \u2192 y' \u2260 1 \u2192 x' * y' = p ^ 2 \u2192 p \u2223 x' \u2192 x' = p \u2227 y' = p\nhy : p \u2223 y\n\u22a2 p \u2223 y",["assumption","omega","aesop","congr","tauto"]],["Topology/Category/TopCat/Limits/Basic.lean",247,"J : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : J \u2964 TopCat\nc : Cocone F\nhc : IsColimit c\nX : Type w\ninst\u271d : TopologicalSpace X\nf : \u2191c.pt \u2192 X\n\u22a2 (\u2200 (s : Set X), IsOpen s \u2192 \u2200 (j : J), IsOpen (\u21d1(ConcreteCategory.hom (c.\u03b9.app j)) \u207b\u00b9' (f \u207b\u00b9' s))) \u2194\n    \u2200 (j : J) (s : Set X), IsOpen s \u2192 IsOpen (f \u2218 \u21d1(ConcreteCategory.hom (c.\u03b9.app j)) \u207b\u00b9' s)",["tauto","aesop"]],["LinearAlgebra/Matrix/FixedDetMatrices.lean",35,"case mk.mk\nn : Type u_1\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nR : Type u_2\ninst\u271d : CommRing R\nm : R\nval\u271d\u00b9 : Matrix n n R\nproperty\u271d\u00b9 : val\u271d\u00b9.det = m\nval\u271d : Matrix n n R\nproperty\u271d : val\u271d.det = m\nh : \u2191\u27e8val\u271d\u00b9, property\u271d\u00b9\u27e9 = \u2191\u27e8val\u271d, property\u271d\u27e9\n\u22a2 \u27e8val\u271d\u00b9, property\u271d\u00b9\u27e9 = \u27e8val\u271d, property\u271d\u27e9",["congr","aesop"]],["Combinatorics/SimpleGraph/Regularity/Bound.lean",47,"n : \u2115\n\u22a2 0 < 4 ^ n",["positivity","aesop","norm_num","simp"]],["Combinatorics/SimpleGraph/Regularity/Bound.lean",189,"\u03b5 : \u211d\nl : \u2115\n\u22a2 0 < 16 ^ stepBound^[\u230a4 / \u03b5 ^ 5\u230b\u208a] (initialBound \u03b5 l)",["positivity","aesop","norm_num","simp"]],["Combinatorics/SimpleGraph/Regularity/Bound.lean",259,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nP : Finpartition univ\nu : Finset \u03b1\n\u03b5\u271d \u03b5 : \u211d\nl : \u2115\n\u22a2 0 < bound \u03b5 l",["positivity","omega","aesop","tauto","infer_instance"]],["Combinatorics/SimpleGraph/Regularity/Bound.lean",130,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nP : Finpartition univ\n\u22a2 1 \u2264 4",["norm_num","omega","decide","aesop","linarith","tauto","simp"]],["Combinatorics/SimpleGraph/Regularity/Bound.lean",179,"\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nl : \u2115\n\u22a2 1 < 4",["norm_num","aesop","linarith","simp"]],["RingTheory/PiTensorProduct.lean",160,"\u03b9 : Type u_1\nR' : Type u_2\nR : Type u_3\nA : \u03b9 \u2192 Type u_4\ninst\u271d\u2076 : CommSemiring R'\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : (i : \u03b9) \u2192 Semiring (A i)\ninst\u271d\u00b3 : Algebra R' R\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Algebra R (A i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Algebra R' (A i)\ninst\u271d : \u2200 (i : \u03b9), IsScalarTower R' R (A i)\n\u22a2 (\u2191{ toFun := fun x \u21a6 x \u2022 1, map_one' := \u22ef, map_mul' := \u22ef }).toFun 0 = 0",["simp","aesop","norm_num"]],["Analysis/Distribution/AEEqOfIntegralContDiff.lean",107,"",["assumption","ring","omega","decide","aesop","congr","linarith","positivity","gcongr","tauto","infer_instance","abel","norm_num","contradiction","simp","fun_prop"]],["Computability/EpsilonNFA.lean",164,"case cons.nil\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\ns t : \u03c3\na : Option \u03b1\na\u271d : t \u2208 M.step s a\n\u22a2 t \u2208 M.step s a",["assumption","aesop","congr","gcongr","tauto"]],["Computability/EpsilonNFA.lean",122,"case append_singleton\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nS : Set \u03c3\nl\u271d : List \u03b1\na\u271d : \u03b1\nih : \u2200 {s : \u03c3}, s \u2208 M.evalFrom S l\u271d \u2194 \u2203 t \u2208 S, s \u2208 M.evalFrom {t} l\u271d\ns : \u03c3\n\u22a2 (\u2203 t, (\u2203 t_1 \u2208 S, t \u2208 M.evalFrom {t_1} l\u271d) \u2227 s \u2208 M.\u03b5Closure (M.step t (some a\u271d))) \u2194\n    \u2203 t \u2208 S, \u2203 t_1 \u2208 M.evalFrom {t} l\u271d, s \u2208 M.\u03b5Closure (M.step t_1 (some a\u271d))",["tauto","aesop"]],["Computability/EpsilonNFA.lean",165,"\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\ns t : \u03c3\na : Option \u03b1\n\u22a2 t \u2208 M.step s a \u2192 M.IsPath s t [a]",["tauto"]],["Computability/EpsilonNFA.lean",174,"case nil\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nu : \u03c3\ny : List (Option \u03b1)\ns : \u03c3\n\u22a2 M.IsPath s u y \u2192 \u2203 t, M.IsPath s t [] \u2227 M.IsPath t u y",["tauto","aesop","norm_num","simp"]],["Computability/EpsilonNFA.lean",177,"case cons.cons\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nu : \u03c3\ny : List (Option \u03b1)\nx : Option \u03b1\na : List (Option \u03b1)\nih : \u2200 {s : \u03c3}, M.IsPath s u (a ++ y) \u2192 \u2203 t, M.IsPath s t a \u2227 M.IsPath t u y\ns t : \u03c3\na\u271d : t \u2208 M.step s x\nh : \u2203 t_1, M.IsPath t t_1 a \u2227 M.IsPath t_1 u y\n\u22a2 \u2203 t, M.IsPath s t (x :: a) \u2227 M.IsPath t u y",["tauto"]],["Computability/EpsilonNFA.lean",192,"case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\ns\u2081 s\u2082 s\u271d t\u271d : \u03c3\na\u271d\u00b9 : t\u271d \u2208 M.step s\u271d none\na\u271d : M.\u03b5Closure {s\u2081} s\u271d\nn : \u2115\nh\u271d : M.IsPath s\u2081 s\u271d (List.replicate n none)\n\u22a2 \u2203 t, M.IsPath s\u2081 t (List.replicate n none) \u2227 M.IsPath t t\u271d (List.replicate 1 none)",["tauto","aesop"]],["Computability/EpsilonNFA.lean",225,"case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\ns\u2081 : \u03c3\nx : List \u03b1\na : \u03b1\nih : \u2200 {s\u2082 : \u03c3}, s\u2082 \u2208 M.evalFrom {s\u2081} x \u2194 \u2203 x', x'.reduceOption = x \u2227 M.IsPath s\u2081 s\u2082 x'\ns\u2082 t : \u03c3\nht : t \u2208 M.evalFrom {s\u2081} x\nx' : List (Option \u03b1)\nleft\u271d\u00b9 : x'.reduceOption = x\nright\u271d : M.IsPath s\u2081 t x'\nu : \u03c3\nleft\u271d : u \u2208 M.step t (some a)\nn : \u2115\nh\u271d : M.IsPath u s\u2082 (List.replicate n none)\n\u22a2 x'.reduceOption ++ [a] = x ++ [a] \u2227 \u2203 t, M.IsPath s\u2081 t x' \u2227 M.IsPath t s\u2082 (some a :: List.replicate n none)",["tauto"]],["Computability/EpsilonNFA.lean",234,"case h\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\ns\u2081 : \u03c3\nx : List \u03b1\na : \u03b1\nih : \u2200 {s\u2082 : \u03c3}, s\u2082 \u2208 M.evalFrom {s\u2081} x \u2194 \u2203 x', x'.reduceOption = x \u2227 M.IsPath s\u2081 s\u2082 x'\ns\u2082 : \u03c3\nx' : List (Option \u03b1)\nleft\u271d\u00b9 : x'.reduceOption = x\nn : \u2115\nt : \u03c3\nleft\u271d : M.IsPath s\u2081 t x'\nu : \u03c3\na\u271d\u00b9 : u \u2208 M.step t (some a)\na\u271d : M.IsPath u s\u2082 (List.replicate n none)\n\u22a2 (\u2203 x', x'.reduceOption = x \u2227 M.IsPath s\u2081 t x') \u2227 \u2203 t_1 \u2208 M.step t (some a), \u2203 n, M.IsPath t_1 s\u2082 (List.replicate n none)",["tauto"]],["Computability/EpsilonNFA.lean",244,"case intro.intro\n\u03b1 : Type u\n\u03c3 : Type v\nM : \u03b5NFA \u03b1 \u03c3\nx : List \u03b1\ns\u2082 : \u03c3\nleft\u271d\u00b9 : s\u2082 \u2208 M.accept\ns\u2081 : \u03c3\nleft\u271d : s\u2081 \u2208 M.start\nh : \u2203 x', x'.reduceOption = x \u2227 M.IsPath s\u2081 s\u2082 x'\n\u22a2 \u2203 s\u2081 s\u2082 x', s\u2081 \u2208 M.start \u2227 s\u2082 \u2208 M.accept \u2227 x'.reduceOption = x \u2227 M.IsPath s\u2081 s\u2082 x'",["tauto","aesop"]],["Data/Rat/Cast/Defs.lean",150,"case intro\n\u03b1 : Type u_3\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : n.natAbs.Coprime d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\nk : \u2124\nke : b = \u2191d * k\nthis : \u2191b = 0\n\u22a2 False",["contradiction","aesop","tauto"]],["AlgebraicTopology/SimplicialSet/StdSimplex.lean",252,"n : \u2115\nS : Finset (Fin (n + 1))\nm : \u2115\ne : Fin (m + 1) \u2243o { x // x \u2208 S }\nX\u271d X'\u271d : SimplexCategory\nf : X\u271d \u27f6 X'\u271d\ng : X'\u271d \u27f6 \u298bm\u298c\n\u22a2 (fun {j} \u21a6\n        {\n          toFun := fun f \u21a6\n            \u27e8objMk\n                ((OrderHom.Subtype.val \u2191S).comp (e.toOrderEmbedding.toOrderHom.comp (SimplexCategory.Hom.toOrderHom f))),\n              \u22ef\u27e9,\n          invFun := fun x \u21a6\n            match x with\n            | \u27e8x, hx\u27e9 =>\n              SimplexCategory.Hom.mk\n                { toFun := fun i \u21a6 e.symm \u27e8(SimplexCategory.Hom.toOrderHom (objEquiv x)) i, \u22ef\u27e9, monotone' := \u22ef },\n          left_inv := \u22ef, right_inv := \u22ef })\n      (f \u226b g) =\n    (Subpresheaf.toPresheaf (face S)).map f.op\n      ((fun {j} \u21a6\n          {\n            toFun := fun f \u21a6\n              \u27e8objMk\n                  ((OrderHom.Subtype.val \u2191S).comp\n                    (e.toOrderEmbedding.toOrderHom.comp (SimplexCategory.Hom.toOrderHom f))),\n                \u22ef\u27e9,\n            invFun := fun x \u21a6\n              match x with\n              | \u27e8x, hx\u27e9 =>\n                SimplexCategory.Hom.mk\n                  { toFun := fun i \u21a6 e.symm \u27e8(SimplexCategory.Hom.toOrderHom (objEquiv x)) i, \u22ef\u27e9, monotone' := \u22ef },\n            left_inv := \u22ef, right_inv := \u22ef })\n        g)",["aesop","congr","tauto"]],["Analysis/SpecialFunctions/Stirling.lean",220,"a : \u211d\nhane : a \u2260 0\nha : Tendsto stirlingSeq atTop (\ud835\udcdd a)\n\u22a2 2 < 4",["norm_num","omega","decide","aesop","linarith","tauto","simp"]],["Algebra/Polynomial/RingDivision.lean",247,"R : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : DecidableEq R\np : R[X]\nhp : p \u2260 0\nthis : Decidable (\u2203 x, p.IsRoot x)\nh : \u2203 x, p.IsRoot x\nx : R\nhx : p.IsRoot x\nhpd : 0 < p.degree\nhd0 : p /\u2098 (X - C x) \u2260 0\n\u22a2 0 < 1",["decide","aesop","positivity","norm_num","simp"]],["LinearAlgebra/RootSystem/Base.lean",158,"case intro.intro.intro\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommGroup N\ninst\u271d\u2074 : Module R N\nP : RootPairing \u03b9 R M N\nb : P.Base\ninst\u271d\u00b3 : Finite \u03b9\ninst\u271d\u00b2 : CharZero R\ninst\u271d\u00b9 : NoZeroSMulDivisors \u2124 M\ninst\u271d : NoZeroSMulDivisors \u2124 N\ni : \u03b9\nh : i \u2208 b.support\nt : R\nz : \u2124\nhz : \u2191z * t = 1\ns : R\nhs : s * t = 1\nht : s \u2022 P.coroot i \u2208 range \u21d1P.coroot\nw : \u2124\nhw : \u2191w * s = 1\nthis : z = 1 \u2227 w = 1 \u2228 z = -1 \u2227 w = -1\n\u22a2 z = 1 \u2228 z = -1",["tauto","omega","aesop"]],["Topology/Category/Stonean/Basic.lean",59,"X : CompHaus\ninst\u271d\u2076 : Projective X\nA B : Type u\ninst\u271d\u2075 : TopologicalSpace A\ninst\u271d\u2074 : TopologicalSpace B\ninst\u271d\u00b3 : CompactSpace A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : CompactSpace B\ninst\u271d : T2Space B\nf : \u2191X.toTop \u2192 B\ng : A \u2192 B\nhf : Continuous f\nhg : Continuous g\nhsurj : Function.Surjective g\nA' : CompHaus := of A\nB' : CompHaus := of B\nf' : X \u27f6 B' := CompHausLike.ofHom (fun x \u21a6 True) { toFun := f, continuous_toFun := hf }\ng' : A' \u27f6 B' := CompHausLike.ofHom (fun x \u21a6 True) { toFun := g, continuous_toFun := hg }\n\u22a2 Function.Surjective \u21d1(ConcreteCategory.hom g')",["assumption","aesop","congr","tauto"]],["AlgebraicTopology/SimplicialSet/Coskeletal.lean",118,"case intro.zero\nX : SSet\ninst\u271d : X.StrictSegal\nn : \u2115\ns : Cone (proj (op \u298bn\u298c) (inclusion 2).op \u22d9 (inclusion 2).op \u22d9 X)\nx : s.pt\ni : \u2115\nhij : i \u2264 i\nhj : i \u2264 n\nthis : mkOfLe \u27e8i, \u22ef\u27e9 \u27e8i, \u22ef\u27e9 \u22ef = \u298b1\u298c.const \u298b0\u298c 0 \u226b \u298b0\u298c.const \u298bn\u298c \u27e8i, \u22ef\u27e9\n\u03b1 : strArrowMk\u2082 (\u298b0\u298c.const \u298bn\u298c \u27e8i, \u22ef\u27e9) \u22ef \u27f6 strArrowMk\u2082 (\u298b1\u298c.const \u298b0\u298c 0 \u226b \u298b0\u298c.const \u298bn\u298c \u27e8i, \u22ef\u27e9) \u22ef :=\n  homMk (\u298b1\u298c.const \u298b0\u298c 0).op \u22ef\nnat :\n  s.\u03c0.app (strArrowMk\u2082 (\u298b1\u298c.const \u298b0\u298c 0 \u226b \u298b0\u298c.const \u298bn\u298c \u27e8i, \u22ef\u27e9) \u22ef) x =\n    X.map ((inclusion 2).map \u03b1.right.unop).op (s.\u03c0.app (strArrowMk\u2082 (\u298b0\u298c.const \u298bn\u298c \u27e8i, \u22ef\u27e9) \u22ef) x)\n\u22a2 {\n          vertex := fun i \u21a6\n            s.\u03c0.app\n              (StructuredArrow.mk\n                (((inclusion 2).obj (unop (op { obj := \u298b0\u298c, property := lift.proof_1 }))).const \u298bn\u298c i).op)\n              x,\n          arrow := fun i \u21a6 s.\u03c0.app (StructuredArrow.mk (mkOfLe i.castSucc i.succ \u22ef).op) x, arrow_src := \u22ef,\n          arrow_tgt := \u22ef }.vertex\n      \u27e8i, \u22ef\u27e9 =\n    s.\u03c0.app (StructuredArrow.mk (\u298b0\u298c.const \u298bn\u298c \u27e8i, \u22ef\u27e9).op) x",["congr","aesop","tauto"]],["GroupTheory/SpecificGroups/Alternating/Centralizer.lean",80,"case neg.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u2115\nhm : \u00acEven (m.sum + m.card)\ng : Perm \u03b1\nhg : g.cycleType = m\nhs : Even (m.sum + m.card)\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/MvPolynomial/SchwartzZippel.lean",190,"R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : DecidableEq R\nn : \u2115\np : MvPolynomial (Fin n) R\nhp : p \u2260 0\nS : Finset R\n\u22a2 \u2191(#(filter (fun f \u21a6 (eval f) p = 0) (piFinset fun x \u21a6 S))) / \u2191(#S) ^ n =\n    \u2191(#(filter (fun f \u21a6 (eval f) p = 0) (piFinset fun x \u21a6 S))) / \u220f i : Fin n, \u2191(#S)",["simp","aesop","norm_num"]],["Algebra/MvPolynomial/SchwartzZippel.lean",108,"R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : DecidableEq R\nn : \u2115\np : MvPolynomial (Fin (n + 1)) R\nhp : p \u2260 0\nS : Fin (n + 1) \u2192 Finset R\np' : Polynomial (MvPolynomial (Fin n) R) := (finSuccEquiv R n) p\nhp' : p' = (finSuccEquiv R n) p\nk : \u2115 := p'.natDegree\nhk : k = p'.natDegree\np\u2096 : MvPolynomial (Fin n) R := p'.leadingCoeff\nhp\u2096 : p\u2096 = p'.leadingCoeff\nhp'\u2080 : p' \u2260 0\nhp\u2096\u2080 : p\u2096 \u2260 0\n\u22a2 0 \u2264 \u2191(#(filter (fun x\u209c \u21a6 (eval x\u209c) p\u2096 = 0) (piFinset fun i \u21a6 tail S i))) / \u220f i : Fin n, \u2191(#(S i.succ))",["positivity","aesop","norm_num","simp"]],["NumberTheory/EulerProduct/DirichletLSeries.lean",33,"s : \u2102\nhs : s \u2260 0\n\u22a2 { toFun := fun n \u21a6 \u2191n ^ (-s), map_zero' := \u22ef }.toFun 1 = 1",["simp","aesop","norm_num"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",205,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nb : P.Base\ni j k : \u03b9\nhij : i \u2260 j\nhi : i \u2208 b.support\nhj : j \u2208 b.support\nhkj : k \u2260 j\nhk' : P.root k + P.root i \u2208 range \u21d1P.root\nhm : P.pairingIn \u2124 j k \u2264 0\nl : \u03b9\nhl : P.root l = P.root k + P.root i - P.root j\nhli : l \u2260 i\nhkl : P.pairingIn \u2124 l k \u2264 0\nhki : P.pairingIn \u2124 k i = -1\n\u22a2 (algebraMap \u2124 R) (-1) = -1",["simp","aesop","norm_num"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",145,"case neg.inr.inl\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ni j : \u03b9\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nh : 0 < P.pairingIn \u2124 i j\nh' : i \u2260 j\n_i : NoZeroSMulDivisors \u2124 M\nhli : \u00acLinearIndependent R ![P.root i, P.root j]\nhij : i = j\n\u22a2 P.root i - P.root j \u2208 range \u21d1P.root",["contradiction"]],["CategoryTheory/Quotient.lean",119,"C : Type ?u.8055\ninst\u271d : Category.{?u.8059, ?u.8055} C\nr : HomRel C\nX\u271d Y\u271d : Quotient r\nf : X\u271d \u27f6 Y\u271d\n\u22a2 \u2200 (a : X\u271d.as \u27f6 Y\u271d.as), Quot.mk (CompClosure r) a \u226b \ud835\udfd9 Y\u271d = Quot.mk (CompClosure r) a",["simp","aesop"]],["CategoryTheory/Quotient.lean",200,"case h_map\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\nr : HomRel C\nD : Type u_3\ninst\u271d : Category.{u_4, u_3} D\nF : C \u2964 D\nH : \u2200 (x y : C) (f\u2081 f\u2082 : x \u27f6 y), r f\u2081 f\u2082 \u2192 F.map f\u2081 = F.map f\u2082\nX Y : C\nf : X \u27f6 Y\n\u22a2 (Quot.mk (CompClosure r) f).liftOn (fun f \u21a6 F.map f) \u22ef = \ud835\udfd9 (F.obj X) \u226b F.map f \u226b \ud835\udfd9 (F.obj Y)",["simp","aesop"]],["CategoryTheory/Quotient.lean",242,"C : Type u_2\ninst\u271d\u00b9 : Category.{u_1, u_2} C\nr : HomRel C\nD : Type u_4\ninst\u271d : Category.{u_3, u_4} D\nF : C \u2964 D\nH : \u2200 (x y : C) (f\u2081 f\u2082 : x \u27f6 y), r f\u2081 f\u2082 \u2192 F.map f\u2081 = F.map f\u2082\nX Y : C\nf : X \u27f6 Y\n\u22a2 (Quot.mk (CompClosure r) f).liftOn (fun f \u21a6 F.map f) \u22ef =\n    \ud835\udfd9 (F.obj X) \u226b (Quot.mk (CompClosure r) f).liftOn (fun f \u21a6 F.map f) \u22ef \u226b \ud835\udfd9 (F.obj Y)",["simp","aesop"]],["CategoryTheory/Quotient.lean",207,"case h_obj\nC : Type u_3\ninst\u271d\u00b9 : Category.{u_1, u_3} C\nr : HomRel C\nD : Type u_4\ninst\u271d : Category.{u_2, u_4} D\n\u03a6 : Quotient r \u2964 D\nH : \u2200 (x y : C) (f\u2081 f\u2082 : x \u27f6 y), r f\u2081 f\u2082 \u2192 (functor r \u22d9 \u03a6).map f\u2081 = (functor r \u22d9 \u03a6).map f\u2082\nX : Quotient r\n\u22a2 \u03a6.obj X = \u03a6.obj ((functor r).obj X.as)",["congr","aesop","tauto"]],["CategoryTheory/Quotient.lean",212,"case h_map\nC : Type u_3\ninst\u271d\u00b9 : Category.{u_1, u_3} C\nr : HomRel C\nD : Type u_4\ninst\u271d : Category.{u_2, u_4} D\n\u03a6 : Quotient r \u2964 D\nH : \u2200 (x y : C) (f\u2081 f\u2082 : x \u27f6 y), r f\u2081 f\u2082 \u2192 (functor r \u22d9 \u03a6).map f\u2081 = (functor r \u22d9 \u03a6).map f\u2082\nX\u271d Y\u271d : Quotient r\nf : X\u271d \u27f6 Y\u271d\nx\u271d : X\u271d.as \u27f6 Y\u271d.as\n\u22a2 \u03a6.map (Quot.mk (CompClosure r) x\u271d) = (Quot.mk (CompClosure r) x\u271d).liftOn (fun f \u21a6 \u03a6.map ((functor r).map f)) \u22ef",["congr"]],["NumberTheory/LSeries/RiemannZeta.lean",217,"x\u271d\u00b9 : \u211d\nx\u271d : x\u271d\u00b9 \u2208 Ioi 1\n\u22a2 \u2191x\u271d\u00b9 \u2208 {s | 1 < s.re}",["aesop","omega","congr","tauto","infer_instance","assumption"]],["Algebra/Homology/HomotopyCategory/Triangulated.lean",197,"C : Type u_1\ninst\u271d\u00b3 : Category.{u_2, u_1} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasBinaryBiproducts C\nX\u2081\u271d X\u2082\u271d X\u2083\u271d : CochainComplex C \u2124\nf : X\u2081\u271d \u27f6 X\u2082\u271d\ng : X\u2082\u271d \u27f6 X\u2083\u271d\ninst\u271d : HasZeroObject C\nX\u2081 X\u2082 X\u2083 : CochainComplex C \u2124\nu\u2081\u2082 : X\u2081 \u27f6 X\u2082\nu\u2082\u2083 : X\u2082 \u27f6 X\u2083\n\u03b1 : mappingCone.triangle u\u2081\u2082 \u27f6 mappingCone.triangle (u\u2081\u2082 \u226b u\u2082\u2083) := mappingCone.triangleMap u\u2081\u2082 (u\u2081\u2082 \u226b u\u2082\u2083) (\ud835\udfd9 X\u2081) u\u2082\u2083 \u22ef\n\u03b2 : mappingCone.triangle (u\u2081\u2082 \u226b u\u2082\u2083) \u27f6 mappingCone.triangle u\u2082\u2083 := mappingCone.triangleMap (u\u2081\u2082 \u226b u\u2082\u2083) u\u2082\u2083 u\u2081\u2082 (\ud835\udfd9 X\u2083) \u22ef\n\u22a2 ((quotient C (ComplexShape.up \u2124)).map (mappingCone.triangle u\u2081\u2082).mor\u2083 \u226b\n        ((quotient C (ComplexShape.up \u2124)).commShiftIso 1).hom.app X\u2081) \u226b\n      (CategoryTheory.shiftFunctor (HomotopyCategory C (ComplexShape.up \u2124)) 1).map\n        ((quotient C (ComplexShape.up \u2124)).map (\ud835\udfd9 X\u2081)) =\n    (quotient C (ComplexShape.up \u2124)).map (mappingCone.triangle u\u2081\u2082).mor\u2083 \u226b\n      ((quotient C (ComplexShape.up \u2124)).commShiftIso 1).hom.app X\u2081",["simp","aesop","norm_num"]],["Algebra/Homology/HomotopyCategory/Triangulated.lean",202,"C : Type u_1\ninst\u271d\u00b3 : Category.{u_2, u_1} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasBinaryBiproducts C\nX\u2081\u271d X\u2082\u271d X\u2083\u271d : CochainComplex C \u2124\nf : X\u2081\u271d \u27f6 X\u2082\u271d\ng : X\u2082\u271d \u27f6 X\u2083\u271d\ninst\u271d : HasZeroObject C\nX\u2081 X\u2082 X\u2083 : CochainComplex C \u2124\nu\u2081\u2082 : X\u2081 \u27f6 X\u2082\nu\u2082\u2083 : X\u2082 \u27f6 X\u2083\n\u03b1 : mappingCone.triangle u\u2081\u2082 \u27f6 mappingCone.triangle (u\u2081\u2082 \u226b u\u2082\u2083) := mappingCone.triangleMap u\u2081\u2082 (u\u2081\u2082 \u226b u\u2082\u2083) (\ud835\udfd9 X\u2081) u\u2082\u2083 \u22ef\n\u03b2 : mappingCone.triangle (u\u2081\u2082 \u226b u\u2082\u2083) \u27f6 mappingCone.triangle u\u2082\u2083 := mappingCone.triangleMap (u\u2081\u2082 \u226b u\u2082\u2083) u\u2082\u2083 u\u2081\u2082 (\ud835\udfd9 X\u2083) \u22ef\n\u22a2 (quotient C (ComplexShape.up \u2124)).map (mappingCone.map u\u2081\u2082 (u\u2081\u2082 \u226b u\u2082\u2083) (\ud835\udfd9 X\u2081) u\u2082\u2083 \u22ef) \u226b\n      \ud835\udfd9 ((quotient C (ComplexShape.up \u2124)).obj (mappingCone (u\u2081\u2082 \u226b u\u2082\u2083))) =\n    \ud835\udfd9 ((quotient C (ComplexShape.up \u2124)).obj (mappingCone u\u2081\u2082)) \u226b\n      (quotient C (ComplexShape.up \u2124)).map (mappingCone.map u\u2081\u2082 (u\u2081\u2082 \u226b u\u2082\u2083) (\ud835\udfd9 X\u2081) u\u2082\u2083 \u22ef)",["simp"]],["Algebra/Homology/HomotopyCategory/Triangulated.lean",198,"C : Type u_1\ninst\u271d\u00b3 : Category.{u_2, u_1} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasBinaryBiproducts C\nX\u2081\u271d X\u2082\u271d X\u2083\u271d : CochainComplex C \u2124\nf : X\u2081\u271d \u27f6 X\u2082\u271d\ng : X\u2082\u271d \u27f6 X\u2083\u271d\ninst\u271d : HasZeroObject C\nX\u2081 X\u2082 X\u2083 : CochainComplex C \u2124\nu\u2081\u2082 : X\u2081 \u27f6 X\u2082\nu\u2082\u2083 : X\u2082 \u27f6 X\u2083\n\u03b1 : mappingCone.triangle u\u2081\u2082 \u27f6 mappingCone.triangle (u\u2081\u2082 \u226b u\u2082\u2083) := mappingCone.triangleMap u\u2081\u2082 (u\u2081\u2082 \u226b u\u2082\u2083) (\ud835\udfd9 X\u2081) u\u2082\u2083 \u22ef\n\u03b2 : mappingCone.triangle (u\u2081\u2082 \u226b u\u2082\u2083) \u27f6 mappingCone.triangle u\u2082\u2083 := mappingCone.triangleMap (u\u2081\u2082 \u226b u\u2082\u2083) u\u2082\u2083 u\u2081\u2082 (\ud835\udfd9 X\u2083) \u22ef\n\u22a2 (quotient C (ComplexShape.up \u2124)).map (\ud835\udfd9 X\u2083) \u226b (quotient C (ComplexShape.up \u2124)).map (mappingCone.inr u\u2082\u2083) =\n    (quotient C (ComplexShape.up \u2124)).map (mappingCone.inr u\u2082\u2083)",["simp"]],["Algebra/Homology/HomotopyCategory/Triangulated.lean",99,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.104390, u_1} C\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 X\u2083 : CochainComplex C \u2124\nf : X\u2081 \u27f6 X\u2082\ng : X\u2082 \u27f6 X\u2083\n\u22a2 -1 + 1 = 0",["decide","omega","aesop","congr","linarith","tauto","abel","norm_num","simp"]],["Algebra/Homology/HomotopyCategory/Triangulated.lean",101,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.104390, u_1} C\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : HasBinaryBiproducts C\nX\u2081 X\u2082 X\u2083 : CochainComplex C \u2124\nf : X\u2081 \u27f6 X\u2082\ng : X\u2082 \u27f6 X\u2083\n\u22a2 -2 + 1 = -1",["decide"]],["Analysis/Meromorphic/NormalFormAt.lean",73,"case pos\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : AnalyticAt \ud835\udd5c f x\nh\u2082f : \u2200\u1da0 (z : \ud835\udd5c) in \ud835\udcdd x, f z = 0\n\u22a2 MeromorphicNFAt f x",["tauto"]],["Analysis/Meromorphic/NormalFormAt.lean",247,"case neg.h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nx z : \ud835\udd5c\nhz : z = x\nh\u2080f : MeromorphicNFAt f x\nn : \u2124\ng : \ud835\udd5c \u2192 E\nh\u2081g : AnalyticAt \ud835\udd5c g x\nh\u2082g : g x \u2260 0\nh\u2083g : f =\u1da0[\ud835\udcdd x] (fun x_1 \u21a6 x_1 - x) ^ n \u2022 g\nthis : \u22ef.order = \u21910\nh\u2083f : \u00ac\u22ef.order = 0\nhn : n = 0\n\u22a2 False",["tauto","aesop","contradiction"]],["Data/Matroid/Constructions.lean",214,"\u03b1 : Type u_1\nI E : Set \u03b1\n\u22a2 \u2200 I_1 \u2286 E, I_1 \u2286 I \u2227 I_1 \u2286 E \u2194 I_1 \u2286 I",["tauto","aesop"]],["Data/Matroid/Constructions.lean",250,"\u03b1 : Type u_1\nI E R : Set \u03b1\n\u22a2 \u2200 \u2983I_1 : Set \u03b1\u2984, I_1 \u2286 R \u2192 ((I_1 \u2286 I \u2227 I_1 \u2286 E) \u2227 I_1 \u2286 R \u2194 ((I_1 \u2286 I \u2227 I_1 \u2286 R) \u2227 I_1 \u2286 E) \u2227 I_1 \u2286 R)",["tauto","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",47,"x y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 rexp y * -(x - y) = rexp y * (y - x)",["ring","aesop","linarith","abel","norm_num","simp"]],["Analysis/Convex/SpecificFunctions/Basic.lean",89,"x y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\nhxy' : 0 < x / y\nhxy'' : x / y \u2260 1\n\u22a2 -(log x - log y) = log y - log x",["ring","aesop","linarith","abel","norm_num","simp"]],["SetTheory/Game/Short.lean",88,"case mk\n\u03b1 \u03b2 : Type u\nL : \u03b1 \u2192 PGame\nR : \u03b2 \u2192 PGame\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nx\u271d\u00b9 : (i : \u03b1) \u2192 (L i).Short\nx\u271d : (j : \u03b2) \u2192 (R j).Short\n\u22a2 Fintype \u03b1",["assumption","aesop","congr","tauto","infer_instance"]],["SetTheory/Game/Short.lean",93,"case mk\n\u03b1\u271d \u03b2\u271d : Type ?u.7979\nL\u271d : \u03b1\u271d \u2192 PGame\nR\u271d : \u03b2\u271d \u2192 PGame\nx\u271d\u00b9 : (i : \u03b1\u271d) \u2192 (L\u271d i).Short\nx\u271d : (j : \u03b2\u271d) \u2192 (R\u271d j).Short\ninst\u271d\u00b9 : Fintype \u03b1\u271d\ninst\u271d : Fintype \u03b2\u271d\n\u22a2 Fintype (mk \u03b1\u271d \u03b2\u271d L\u271d R\u271d).LeftMoves",["assumption","aesop","congr","tauto"]],["SetTheory/Game/Short.lean",99,"case mk\n\u03b1 \u03b2 : Type u\nL : \u03b1 \u2192 PGame\nR : \u03b2 \u2192 PGame\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nx\u271d\u00b9 : (i : \u03b1) \u2192 (L i).Short\nx\u271d : (j : \u03b2) \u2192 (R j).Short\n\u22a2 Fintype \u03b2",["assumption","aesop","congr","tauto","infer_instance"]],["SetTheory/Game/Short.lean",104,"case mk\n\u03b1\u271d \u03b2\u271d : Type ?u.8473\nL\u271d : \u03b1\u271d \u2192 PGame\nR\u271d : \u03b2\u271d \u2192 PGame\nx\u271d\u00b9 : (i : \u03b1\u271d) \u2192 (L\u271d i).Short\nx\u271d : (j : \u03b2\u271d) \u2192 (R\u271d j).Short\ninst\u271d\u00b9 : Fintype \u03b1\u271d\ninst\u271d : Fintype \u03b2\u271d\n\u22a2 Fintype (mk \u03b1\u271d \u03b2\u271d L\u271d R\u271d).RightMoves",["assumption","aesop","congr","tauto"]],["SetTheory/Game/Short.lean",275,"",["decide"]],["SetTheory/Game/Short.lean",276,"",["decide"]],["MeasureTheory/Function/Egorov.lean",141,"case hf_nonneg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MetricSpace \u03b2\n\u03bc : Measure \u03b1\ns : Set \u03b1\n\u03b5 : \u211d\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : SemilatticeSup \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : Countable \u03b9\nh\u03b5 : 0 < \u03b5\nhf : \u2200 (n : \u03b9), StronglyMeasurable (f n)\nhg : StronglyMeasurable g\nhsm : MeasurableSet s\nhs : \u03bc s \u2260 \u22a4\nhfg : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 Tendsto (fun n \u21a6 f n x) atTop (\ud835\udcdd (g x))\nn : \u2115\n\u22a2 0 \u2264 2\u207b\u00b9 ^ n",["positivity","aesop","norm_num","simp"]],["CategoryTheory/NatIso.lean",225,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF G : C \u2964 D\napp' : (X : C) \u2192 F.obj X \u2245 G.obj X\nnaturality : \u2200 {X Y : C} (f : X \u27f6 Y), F.map f \u226b (app' Y).hom = (app' X).hom \u226b G.map f\nX : C\n\u22a2 (ofComponents app' naturality).app X = app' X",["aesop","congr","tauto"]],["NumberTheory/SumTwoSquares.lean",123,"n : \u2115\nhn : Squarefree n\nhelp : \u2200 (a b : ZMod 4), a \u2260 3 \u2192 b \u2260 3 \u2192 a * b \u2260 3\nH : \u2200 {q : \u2115}, Nat.Prime q \u2192 q \u2223 n \u2192 q % 4 \u2260 3\nx\u271d : 0 \u2223 n\n\u22a2 0 % 4 \u2260 3",["norm_num","omega","decide","aesop","positivity","tauto","simp"]],["NumberTheory/SumTwoSquares.lean",124,"n : \u2115\nhn : Squarefree n\nhelp : \u2200 (a b : ZMod 4), a \u2260 3 \u2192 b \u2260 3 \u2192 a * b \u2260 3\nH : \u2200 {q : \u2115}, Nat.Prime q \u2192 q \u2223 n \u2192 q % 4 \u2260 3\nx\u271d : 1 \u2223 n\n\u22a2 1 % 4 \u2260 3",["norm_num","omega","decide","aesop","tauto","simp"]],["NumberTheory/SumTwoSquares.lean",118,"n : \u2115\nhn : Squarefree n\n\u22a2 \u2200 (a b : ZMod 4), a \u2260 3 \u2192 b \u2260 3 \u2192 a * b \u2260 3",["decide"]],["Data/Matrix/Basis.lean",179,"m : Type u_2\nn : Type u_3\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Zero \u03b1\ni : m\nj : n\nc : \u03b1\ni' : m\nj' : n\nh : \u00ac(i = i' \u2227 j = j')\n\u22a2 i = i' \u2192 j = j' \u2192 c = 0",["tauto","aesop"]],["RingTheory/Coalgebra/Hom.lean",270,"case h\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : AddCommMonoid B\ninst\u271d\u00b3 : Module R A\ninst\u271d\u00b2 : Module R B\ninst\u271d\u00b9 : Coalgebra R A\ninst\u271d : Coalgebra R B\nx\u271d : A\n\u22a2 (counit \u2218\u2097 __src\u271d) x\u271d = counit x\u271d",["simp","aesop","congr","tauto","abel","norm_num"]],["RingTheory/Coalgebra/Hom.lean",171,"case h\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid A\ninst\u271d\u00b9 : Module R A\ninst\u271d : CoalgebraStruct R A\nf g : R \u2192\u2097c[R] A\nh : f 1 = g 1\n\u22a2 ((fun x \u21a6 \u2191x) f) 1 = ((fun x \u21a6 \u2191x) g) 1",["assumption","aesop","tauto"]],["LinearAlgebra/AffineSpace/ContinuousAffineEquiv.lean",63,"case mk.mk\nk : Type u_1\nP\u2081 : Type u_2\nP\u2082 : Type u_3\nV\u2081 : Type u_6\nV\u2082 : Type u_7\ninst\u271d\u2078 : Ring k\ninst\u271d\u2077 : AddCommGroup V\u2081\ninst\u271d\u2076 : Module k V\u2081\ninst\u271d\u2075 : AddTorsor V\u2081 P\u2081\ninst\u271d\u2074 : TopologicalSpace P\u2081\ninst\u271d\u00b3 : AddCommGroup V\u2082\ninst\u271d\u00b2 : Module k V\u2082\ninst\u271d\u00b9 : AddTorsor V\u2082 P\u2082\ninst\u271d : TopologicalSpace P\u2082\ne : P\u2081 \u2243\u1d43[k] P\u2082\necont : Continuous e.toFun\neinv_cont : Continuous e.invFun\ne' : P\u2081 \u2243\u1d43[k] P\u2082\ne'cont : Continuous e'.toFun\ne'inv_cont : Continuous e'.invFun\nH :\n  { toAffineEquiv := e, continuous_toFun := econt, continuous_invFun := einv_cont }.toAffineEquiv =\n    { toAffineEquiv := e', continuous_toFun := e'cont, continuous_invFun := e'inv_cont }.toAffineEquiv\n\u22a2 { toAffineEquiv := e, continuous_toFun := econt, continuous_invFun := einv_cont } =\n    { toAffineEquiv := e', continuous_toFun := e'cont, continuous_invFun := e'inv_cont }",["congr","aesop"]],["LinearAlgebra/AffineSpace/ContinuousAffineEquiv.lean",80,"case mk\nk : Type u_1\nP\u2081 : Type u_2\nP\u2082 : Type u_3\nV\u2081 : Type u_6\nV\u2082 : Type u_7\ninst\u271d\u2078 : Ring k\ninst\u271d\u2077 : AddCommGroup V\u2081\ninst\u271d\u2076 : Module k V\u2081\ninst\u271d\u2075 : AddTorsor V\u2081 P\u2081\ninst\u271d\u2074 : TopologicalSpace P\u2081\ninst\u271d\u00b3 : AddCommGroup V\u2082\ninst\u271d\u00b2 : Module k V\u2082\ninst\u271d\u00b9 : AddTorsor V\u2082 P\u2082\ninst\u271d : TopologicalSpace P\u2082\ne' : P\u2081 \u2243\u1d43L[k] P\u2082\ntoAffineEquiv\u271d : P\u2081 \u2243\u1d43[k] P\u2082\ncontinuous_toFun\u271d : Continuous toAffineEquiv\u271d.toFun\ncontinuous_invFun\u271d : Continuous toAffineEquiv\u271d.invFun\nH :\n  \u2191{ toAffineEquiv := toAffineEquiv\u271d, continuous_toFun := continuous_toFun\u271d, continuous_invFun := continuous_invFun\u271d } =\n    \u2191e'\n\u22a2 { toAffineEquiv := toAffineEquiv\u271d, continuous_toFun := continuous_toFun\u271d, continuous_invFun := continuous_invFun\u271d } = e'",["congr","aesop"]],["NumberTheory/SumFourSquares.lean",59,"case h\nhp : Fact (Nat.Prime 2)\n\u22a2 0 < 1 \u2227 1 < 2 \u2227 1 ^ 2 + 0 ^ 2 + 1 = 1 * 2",["simp","omega","decide","aesop","tauto","norm_num"]],["NumberTheory/SumFourSquares.lean",87,"m a b c d : \u2124\nh : a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = 2 * m\n\u22a2 \u2200 (f : Fin 4 \u2192 ZMod 2),\n    f 0 ^ 2 + f 1 ^ 2 + f 2 ^ 2 + f 3 ^ 2 = 0 \u2192\n      \u2203 i, f i ^ 2 + f ((swap i 0) 1) ^ 2 = 0 \u2227 f ((swap i 0) 2) ^ 2 + f ((swap i 0) 3) ^ 2 = 0",["decide"]],["Topology/Homotopy/HSpaces.lean",171,"t : \u2191I\nh\u271d : \u2191t \u2264 1 / 2\n\u22a2 \u2191t \u2264 1 / 2",["tauto","aesop","congr","linarith","gcongr","assumption"]],["LinearAlgebra/RootSystem/Reduced.lean",155,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommGroup N\ninst\u271d\u2074 : Module R N\nP : RootPairing \u03b9 R M N\ni j : \u03b9\ninst\u271d\u00b3 : Finite \u03b9\ninst\u271d\u00b2 : CharZero R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nh2 : IsSMulRegular R 2\n_i\u271d : NoZeroSMulDivisors \u2124 M\n_i : NoZeroSMulDivisors \u2124 N\nx\u271d : P.pairing i j = 1 \u2227 P.pairing j i = 4\nh\u2081 : P.pairing i j = 1\nh\u2082 : P.pairing j i = 4\n\u22a2 1 * 4 = 4",["norm_num","ring","aesop","simp"]],["Analysis/SpecialFunctions/Trigonometric/Bounds.lean",47,"case inr\nx : \u211d\nh : 0 < x\nh' : x \u2264 1\nhx : |x| = x\nthis : sin x \u2264 x - x ^ 3 / 6 + x ^ 4 * (5 / 96)\n\u22a2 3 \u2264 4",["norm_num","omega","decide","aesop","linarith","tauto","simp"]],["Analysis/SpecialFunctions/Trigonometric/Bounds.lean",155,"x : \u211d\nh : 0 < x\nh' : x \u2264 1\nhx : |x| = x\nthis\u271d : -(x ^ 4 * (5 / 96)) + (x - x ^ 3 / 6) \u2264 sin x\nthis : x ^ 3 / 4 - x ^ 3 / 6 = x ^ 3 * 12\u207b\u00b9\n\u22a2 3 \u2264 4",["norm_num","omega","decide","aesop","linarith","tauto","simp"]],["Analysis/Convex/Exposed.lean",117,"case inl.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : TopologicalSpace \ud835\udd5c\ninst\u271d\u2074 : OrderedRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Nontrivial \ud835\udd5c\nA : Set E\nhAB : IsExposed \ud835\udd5c A \u2205\nx : E\nh : 1 \u2264 0\nthis : \u00ac1 \u2264 0\n\u22a2 False",["contradiction","aesop","tauto"]],["GroupTheory/Divisible.lean",190,"\ud835\udd5c : Type ?u.9526\ninst\u271d\u00b9 : DivisionRing \ud835\udd5c\ninst\u271d : CharZero \ud835\udd5c\nq : \ud835\udd5c\n\u22a2 (fun q n \u21a6 q / \u2191n) q 0 = 0",["norm_num","aesop","simp"]],["Algebra/Module/CharacterModule.lean",76,"R : Type uR\ninst\u271d\u2076 : CommRing R\nA : Type uA\ninst\u271d\u2075 : AddCommGroup A\nA' : Type u_1\ninst\u271d\u2074 : AddCommGroup A'\nB : Type uB\ninst\u271d\u00b3 : AddCommGroup B\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : Module R A'\ninst\u271d : Module R B\nf : A \u2192\u2097[R] B\n\u22a2 \u2200 (x y : CharacterModule B),\n    (fun L \u21a6 AddMonoidHom.comp L f.toAddMonoidHom) (x + y) =\n      (fun L \u21a6 AddMonoidHom.comp L f.toAddMonoidHom) x + (fun L \u21a6 AddMonoidHom.comp L f.toAddMonoidHom) y",["aesop","tauto"]],["Algebra/Module/CharacterModule.lean",139,"R : Type uR\ninst\u271d\u2076 : CommRing R\nA : Type uA\ninst\u271d\u2075 : AddCommGroup A\nA' : Type u_1\ninst\u271d\u2074 : AddCommGroup A'\nB : Type uB\ninst\u271d\u00b3 : AddCommGroup B\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : Module R A'\ninst\u271d : Module R B\n\u22a2 curry \u2218\u2097 uncurry = LinearMap.id",["aesop","congr","tauto","abel"]],["Analysis/Convex/Visible.lean",92,"\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ns : Set V\nx : V\n\u03b9 : Type u_4\nt : Finset \u03b9\na : \u03b9 \u2192 V\nw : \u03b9 \u2192 \ud835\udd5c\nhw\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nhw\u2081 : \u2211 i \u2208 t, w i = 1\nha : \u2200 i \u2208 t, a i \u2208 s\nhx : x \u2209 (convexHull \ud835\udd5c) s\nhw : IsVisible \ud835\udd5c ((convexHull \ud835\udd5c) s) x (\u2211 i \u2208 t, w i \u2022 a i)\ni : \u03b9\nhi : i \u2208 t\nhwi\u271d\u00b9 : 0 < w i\nhwi\u271d : w i < 1\n\u03b5 : \ud835\udd5c\nh\u03b5 : (lineMap x (a i)) \u03b5 \u2208 (convexHull \ud835\udd5c) s\nh : (lineMap x (a i)) \u03b5 \u2260 x \u2227 (lineMap x (a i)) \u03b5 \u2260 a i\nh\u03b5\u2080 : 0 < \u03b5\nh\u03b5\u2081 : \u03b5 < 1\nthis : 0 < 1 - \u03b5\nhwi : 0 < 1 - w i\n\u22a2 (1 - w i) / w i = 0 + (1 - w i) / w i + 0",["simp","ring","aesop","linarith","abel","norm_num"]],["Topology/DiscreteSubset.lean",190,"case neg\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\ns U : Set X\nh : \u2200 z \u2208 U, \u2203 t \u2208 \ud835\udcdd[\u2260] z, t \u2229 (U \\ s) = \u2205\nz : X\nh\u2081z : z \u2208 U\nt : Set X\nh\u2081t : t \u2208 \ud835\udcdd[\u2260] z\nh\u2082t : t \u2229 (U \\ s) = \u2205\nhz : z \u2209 U \\ s\n\u22a2 \u2205.Finite",["simp","aesop"]],["Topology/DiscreteSubset.lean",108,"case a.h.h'.h.e'_2.h.h.e'_2.h.e'_2.h.a\nX : Type u_1\ninst\u271d : TopologicalSpace X\nS T : Set X\nx : X\nu : Set X\ny : X\n\u22a2 y \u2208 u \u2227 y \u2208 T \u2227 y \u2209 {x} \u2192 y \u2208 S \u2194 y \u2208 u \u2227 y \u2209 {x} \u2192 \u00ac(y \u2208 T \u2227 y \u2209 S)",["tauto","aesop"]],["Data/List/Infix.lean",57,"case intro\n\u03b1 : Type u_1\nl\u2081 l : List (List \u03b1)\n\u22a2 l\u2081.flatten <+: (l\u2081 ++ l).flatten",["simp","aesop"]],["Data/List/Infix.lean",185,"\u03b1 : Type u_1\na : \u03b1\nl : List \u03b1\n\u22a2 (a :: l).tails = (a :: l) :: l.tails",["simp","aesop","congr","tauto"]],["Data/List/Infix.lean",196,"\u03b1 : Type u_1\n\u22a2 ([] ++ []).tails = map (fun l \u21a6 l ++ []) [].tails ++ [].tails.tail",["simp","aesop","congr","tauto"]],["Data/List/Infix.lean",197,"\u03b1 : Type u_1\na : \u03b1\nt : List \u03b1\n\u22a2 ([] ++ a :: t).tails = map (fun l \u21a6 l ++ a :: t) [].tails ++ (a :: t).tails.tail",["simp"]],["Algebra/Group/Subgroup/Finite.lean",202,"\u03b7 : Type u_3\nf : \u03b7 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b7) \u2192 Group (f i)\ninst\u271d : DecidableEq \u03b7\nH : Subgroup ((i : \u03b7) \u2192 f i)\nI : Finset \u03b7\nx : (i : \u03b7) \u2192 f i\nj : \u03b7\nhj : j \u2208 I\nhnmem : j \u2209 I\nh1 : \u2200 i \u2209 insert j I, x i = 1\nh2 : \u2200 i \u2208 insert j I, Pi.mulSingle i (x i) \u2208 H\n\u22a2 False",["contradiction","aesop","tauto"]],["MeasureTheory/Measure/Dirac.lean",28,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\ns : Set \u03b1\na\u271d a : \u03b1\n\u22a2 inst\u271d\u00b9 \u2264 (OuterMeasure.dirac a).caratheodory",["simp","aesop","norm_num"]],["Data/List/Destutter.lean",102,"\u03b1 : Type u_1\nl : List \u03b1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel R\na : \u03b1\nh : destutter' R a l = a :: l\nthis : Chain' R (a :: l)\n\u22a2 Chain R a l",["assumption","aesop","congr","tauto"]],["Control/Traversable/Basic.lean",147,"F : Type u \u2192 Type v\ninst\u271d\u00b9 : Applicative F\nG : Type u \u2192 Type w\ninst\u271d : Applicative G\n\u22a2 \u2200 {\u03b1 : Type u} (x : \u03b1), (fun x \u21a6 id) \u03b1 (pure x) = pure x",["simp"]],["Control/Traversable/Basic.lean",111,"case mk.mk\nF : Type u \u2192 Type v\ninst\u271d\u00b9 : Applicative F\nG : Type u \u2192 Type w\ninst\u271d : Applicative G\napp\u271d\u00b9 : (\u03b1 : Type u) \u2192 F \u03b1 \u2192 G \u03b1\npreserves_pure'\u271d\u00b9 : \u2200 {\u03b1 : Type u} (x : \u03b1), app\u271d\u00b9 \u03b1 (pure x) = pure x\npreserves_seq'\u271d\u00b9 : \u2200 {\u03b1 \u03b2 : Type u} (x : F (\u03b1 \u2192 \u03b2)) (y : F \u03b1), app\u271d\u00b9 \u03b2 (x <*> y) = app\u271d\u00b9 (\u03b1 \u2192 \u03b2) x <*> app\u271d\u00b9 \u03b1 y\napp\u271d : (\u03b1 : Type u) \u2192 F \u03b1 \u2192 G \u03b1\npreserves_pure'\u271d : \u2200 {\u03b1 : Type u} (x : \u03b1), app\u271d \u03b1 (pure x) = pure x\npreserves_seq'\u271d : \u2200 {\u03b1 \u03b2 : Type u} (x : F (\u03b1 \u2192 \u03b2)) (y : F \u03b1), app\u271d \u03b2 (x <*> y) = app\u271d (\u03b1 \u2192 \u03b2) x <*> app\u271d \u03b1 y\nh :\n  (fun {\u03b1} \u21a6 { app := app\u271d\u00b9, preserves_pure' := preserves_pure'\u271d\u00b9, preserves_seq' := preserves_seq'\u271d\u00b9 }.app \u03b1) = fun {\u03b1} \u21a6\n    { app := app\u271d, preserves_pure' := preserves_pure'\u271d, preserves_seq' := preserves_seq'\u271d }.app \u03b1\n\u22a2 { app := app\u271d\u00b9, preserves_pure' := preserves_pure'\u271d\u00b9, preserves_seq' := preserves_seq'\u271d\u00b9 } =\n    { app := app\u271d, preserves_pure' := preserves_pure'\u271d, preserves_seq' := preserves_seq'\u271d }",["congr"]],["Algebra/Group/Action/Pointwise/Finset.lean",268,"F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ns : Set \u2115\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 s\na n : \u2115\n\u22a2 (\u2203 y \u2208 s, a + y = n) \u2194 a \u2264 n \u2227 n - a \u2208 s",["aesop","omega","tauto","infer_instance"]],["Data/PFunctor/Multivariate/W.lean",172,"n : \u2115\nP : MvPFunctor.{u} (n + 1)\n\u03b1 : TypeVec.{u} n\nC : Type u_1\ng : (a : P.A) \u2192 P.drop.B a \u27f9 \u03b1 \u2192 (P.last.B a \u2192 P.W \u03b1) \u2192 (P.last.B a \u2192 C) \u2192 C\na : P.A\nf' : P.drop.B a \u27f9 \u03b1\nf : P.last.B a \u2192 P.W \u03b1\n\u22a2 (g a f' (fun i \u21a6 \u27e8(f i).fst, (f i).snd\u27e9) fun i \u21a6\n      P.wpRec (fun a f h h' \u21a6 g a (P.wPathDestLeft h) (fun i \u21a6 \u27e8f i, P.wPathDestRight h i\u27e9) h') (f i).fst (f i).snd) =\n    g a f' f fun i \u21a6 P.wRec g (f i)",["congr","aesop","tauto"]],["Algebra/Order/Ring/Abs.lean",261,"n : \u2115\nhn : Odd n\nhm : 2 \u2223 n\n\u22a2 \u00acOdd 2",["decide","omega","aesop","tauto","infer_instance","simp"]],["Algebra/Order/CauSeq/BigOperators.lean",214,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f m.succ) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), n.succ \u2264 m \u2192 m = k + n.succ \u2192 abv (f m) \u2264 abv (f n.succ) * r\u207b\u00b9 ^ n.succ * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f m.succ) \u2264 r * abv (f m)\nm : \u2115\nhmn : n.succ \u2264 m\nhk : m = k + 1 + n.succ\n\u22a2 n.succ \u2264 0 + n.succ",["simp","omega","aesop","linarith","norm_num"]],["Data/Real/Cardinality.lean",122,"case zero\nc : \u211d\nh1 : 0 < c\nh2 : c < 1 / 2\nh3 : c < 1\nf g : \u2115 \u2192 Bool\nhn\u271d : \u2200 k < 0, f k = g k\nfn : f 0 = false\ngn : g 0 = true\nf_max : \u2115 \u2192 Bool := fun n \u21a6 rec false (fun x x \u21a6 true) n\nhn : false = true\n\u22a2 f_max 0 = true",["contradiction","aesop","congr","tauto","assumption"]],["RingTheory/Bialgebra/Hom.lean",195,"case h\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : CoalgebraStruct R A\nf g : R \u2192\u2090c[R] A\nh : f 1 = g 1\n\u22a2 ((fun x \u21a6 \u2191x) f) 1 = ((fun x \u21a6 \u2191x) g) 1",["assumption","aesop","tauto","norm_num","simp"]],["Probability/Kernel/Disintegration/Basic.lean",220,"case disintegrate.h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03a9 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03a9 : MeasurableSpace \u03a9\n\u03ba\u271d : Kernel \u03b1 (\u03b2 \u00d7 \u03a9)\n\u03baCond\u271d : Kernel (\u03b1 \u00d7 \u03b2) \u03a9\ninst\u271d\u00b3 : Countable \u03b1\n\u03baCond : \u03b1 \u2192 Kernel \u03b2 \u03a9\ninst\u271d\u00b2 : \u2200 (a : \u03b1), IsMarkovKernel (\u03baCond a)\nh_atom : \u2200 (x y : \u03b1), x \u2208 measurableAtom y \u2192 \u03baCond x = \u03baCond y\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03a9)\ninst\u271d\u00b9 : IsSFiniteKernel \u03ba\ninst\u271d : \u2200 (a : \u03b1), (\u03ba a).IsCondKernel (\u03baCond a)\na : \u03b1\ns : Set (\u03b2 \u00d7 \u03a9)\nhs : MeasurableSet s\n\u22a2 \u222b\u207b (b : \u03b2), ((\u03baCond a) b) (Prod.mk b \u207b\u00b9' s) \u2202\u03ba.fst a = \u222b\u207b (b : \u03b2), ((\u03baCond a) b) (Prod.mk b \u207b\u00b9' s) \u2202(\u03ba a).fst",["congr","omega","aesop","tauto","infer_instance","abel"]],["Data/Nat/Bits.lean",284,"",["norm_num","ring","omega","decide","aesop","congr","linarith","positivity","gcongr","tauto","infer_instance","assumption","abel","contradiction","simp","fun_prop"]],["Data/Nat/Bits.lean",112,"n : \u2115\n\u22a2 0 < 2",["decide","omega","simp"]],["CategoryTheory/Limits/Shapes/SequentialProduct.lean",192,"case pos.e_a.le_succ_of_le\nC : Type u_1\nM N : \u2115 \u2192 C\ninst\u271d\u00b9 : Category.{?u.224057, u_1} C\nf : (n : \u2115) \u2192 M n \u27f6 N n\ninst\u271d : HasProductsOfShape \u2115 C\ns : Cone (Functor.ofOpSequence (functorMap f))\nn\u271d m n : \u2115\nhh : m + 1 \u2264 n\nih :\n  \u2200 (h : m < n),\n    (Functor.ofOpSequence (functorMap f)).map (homOfLE hh).op \u226b\n        Pi.\u03c0 (fun i \u21a6 if i < m + 1 then M i else N i) m \u226b eqToHom \u22ef =\n      Pi.\u03c0 (fun m \u21a6 if m < n then M m else N m) m\nh : m < n + 1\nthis : homOfLE \u22ef = homOfLE hh \u226b homOfLE \u22ef\nh\u2081 : (if x : m < m + 1 then M m else N m) = if x : m < n then M m else N m\nh\u2082 : (if x : m < n then M m else N m) = if x : m < n + 1 then M m else N m\n\u22a2 limit.\u03c0 (Discrete.functor fun m \u21a6 if m < n + 1 then M m else N m) { as := m } \u226b eqToHom \u22ef \u226b eqToHom h\u2082 =\n    limit.\u03c0 (Discrete.functor fun m \u21a6 if m < n + 1 then M m else N m) { as := m }",["simp","aesop"]],["CategoryTheory/Limits/Shapes/SequentialProduct.lean",76,"C : Type u_1\nM N : \u2115 \u2192 C\ninst\u271d\u00b9 : Category.{u_2, u_1} C\nf : (n : \u2115) \u2192 M n \u27f6 N n\ninst\u271d : HasProductsOfShape \u2115 C\nn m\u271d k m : \u2115\nh : n \u2264 m\nih :\n  \u2200 (hh : \u00ack < m),\n    (Functor.ofOpSequence (functorMap f)).map (homOfLE h).op \u226b\n        Pi.\u03c0 (fun m \u21a6 if x : m < Opposite.unop (Opposite.op n) then M m else N m) k \u226b eqToHom \u22ef =\n      Pi.\u03c0 (fun i \u21a6 if x : i < m then M i else N i) k \u226b eqToHom \u22ef\nhh : \u00ack < m + 1\n\u22a2 \u00ack < m",["omega","tauto"]],["CategoryTheory/Limits/Shapes/SequentialProduct.lean",171,"C : Type u_1\nM N : \u2115 \u2192 C\ninst\u271d\u00b9 : Category.{?u.224057, u_1} C\nf : (n : \u2115) \u2192 M n \u27f6 N n\ninst\u271d : HasProductsOfShape \u2115 C\ns : Cone (Functor.ofOpSequence (functorMap f))\nn m : \u2115\nh : m < n\n\u22a2 m + 1 \u2264 n",["omega","aesop","congr","tauto","assumption"]],["Analysis/Convex/Mul.lean",159,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedCommRing \ud835\udd5c\nn : \u2115\nx : \ud835\udd5c\nx\u271d\u00b9 : x \u2208 univ\ny : \ud835\udd5c\nx\u271d : y \u2208 univ\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 0 \u2264 a * b * (x - y) ^ 2",["positivity","ring","omega","decide","aesop","congr","linarith","gcongr","tauto","infer_instance","assumption","abel","norm_num","contradiction","simp","fun_prop"]],["Data/Multiset/FinsetOps.lean",113,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns t : Multiset \u03b1\n\u22a2 a \u2209 s \u2227 _root_.Disjoint t s \u2194 a \u2209 s \u2227 _root_.Disjoint s t",["tauto"]],["MeasureTheory/Measure/LogLikelihoodRatio.lean",63,"case h\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : SigmaFinite \u03bc\ninst\u271d : SigmaFinite \u03bd\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nx : \u03b1\nhx : (\u03bc.rnDeriv \u03bd)\u207b\u00b9 x = \u03bd.rnDeriv \u03bc x\n\u22a2 log (\u03bc.rnDeriv \u03bd x)\u207b\u00b9.toReal = log (\u03bd.rnDeriv \u03bc x).toReal",["congr","aesop","tauto"]],["Order/ConditionallyCompleteLattice/Finset.lean",78,"\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\nh : \u2203 x \u2208 s, f x \u2264 sInf \u2205\nh' : autoParam (image f s).Nonempty _auto\u271d\n\u22a2 (image (fun i \u21a6 OrderDual.toDual (f i)) s).max' \u22ef = (image (\u21d1OrderDual.toDual \u2218 f) s).max' \u22ef",["congr","aesop","tauto"]],["Combinatorics/SimpleGraph/Metric.lean",237,"V : Type u_1\nG : SimpleGraph V\nu v : V\n\u22a2 1 \u2260 0",["decide","omega","aesop","tauto","infer_instance","simp"]],["Order/Comparable.lean",179,"\u03b1 : Type u_1\na b : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 IncompRel r\u1d9c a b \u2194 AntisymmRel r a b",["simp","aesop"]],["Order/Comparable.lean",251,"\u03b1 : Type u_1\na b : \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 \u00acb \u2264 a \u2194 a \u2264 b \u2227 \u00acb \u2264 a \u2228 \u00aca \u2264 b \u2227 \u00acb \u2264 a",["tauto"]],["Order/Comparable.lean",257,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 a \u2264 b \u2227 \u00acb \u2264 a \u2228 AntisymmRel (fun x1 x2 \u21a6 x1 \u2264 x2) a b \u2228 b \u2264 a \u2227 \u00aca \u2264 b \u2228 IncompRel (fun x1 x2 \u21a6 x1 \u2264 x2) a b",["tauto"]],["Analysis/Convex/Cone/Proper.lean",57,"case mk.mk\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : OrderedSemiring \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : Module \ud835\udd5c E\ntoSubmodule\u271d\u00b9 : Submodule { c // 0 \u2264 c } E\nisClosed'\u271d\u00b9 : IsClosed toSubmodule\u271d\u00b9.carrier\ntoSubmodule\u271d : Submodule { c // 0 \u2264 c } E\nisClosed'\u271d : IsClosed toSubmodule\u271d.carrier\nh :\n  \u2191{ toSubmodule := toSubmodule\u271d\u00b9, isClosed' := isClosed'\u271d\u00b9 } = \u2191{ toSubmodule := toSubmodule\u271d, isClosed' := isClosed'\u271d }\n\u22a2 { toSubmodule := toSubmodule\u271d\u00b9, isClosed' := isClosed'\u271d\u00b9 } = { toSubmodule := toSubmodule\u271d, isClosed' := isClosed'\u271d }",["congr","aesop"]],["Analysis/Convex/Cone/Proper.lean",189,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : InnerProductSpace \u211d E\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \u211d F\nG : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : InnerProductSpace \u211d G\ng : F \u2192L[\u211d] G\nf : E \u2192L[\u211d] F\nS : ProperCone \u211d G\n\u22a2 \u2191(comap f (comap g S)) = \u2191(comap (g.comp f) S)",["congr","aesop","tauto"]],["Analysis/Convex/Cone/Proper.lean",170,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nK : ProperCone \u211d E\ny : E\n\u22a2 y \u2208 K.dual \u2194 \u2200 \u2983x : E\u2984, x \u2208 K \u2192 0 \u2264 \u27eax, y\u27eb_\u211d",["aesop","tauto"]],["Analysis/BoxIntegral/Partition/Additive.lean",63,"case mk.mk\n\u03b9 : Type u_1\nM : Type u_2\nn : \u2115\nN : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : AddCommMonoid N\nI\u2080 : WithTop (Box \u03b9)\nI : Box \u03b9\ni : \u03b9\ntoFun\u271d\u00b9 : Box \u03b9 \u2192 M\nsum_partition_boxes'\u271d\u00b9 :\n  \u2200 (J : Box \u03b9), \u2191J \u2264 I\u2080 \u2192 \u2200 (\u03c0 : Prepartition J), \u03c0.IsPartition \u2192 \u2211 Ji \u2208 \u03c0.boxes, toFun\u271d\u00b9 Ji = toFun\u271d\u00b9 J\ntoFun\u271d : Box \u03b9 \u2192 M\nsum_partition_boxes'\u271d :\n  \u2200 (J : Box \u03b9), \u2191J \u2264 I\u2080 \u2192 \u2200 (\u03c0 : Prepartition J), \u03c0.IsPartition \u2192 \u2211 Ji \u2208 \u03c0.boxes, toFun\u271d Ji = toFun\u271d J\nh :\n  { toFun := toFun\u271d\u00b9, sum_partition_boxes' := sum_partition_boxes'\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, sum_partition_boxes' := sum_partition_boxes'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, sum_partition_boxes' := sum_partition_boxes'\u271d\u00b9 } =\n    { toFun := toFun\u271d, sum_partition_boxes' := sum_partition_boxes'\u271d }",["congr","aesop"]],["Analysis/BoxIntegral/Partition/Additive.lean",192,"case refine_1\n\u03b9 : Type u_1\nM : Type u_2\nn : \u2115\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : AddCommMonoid N\nI\u2080\u271d : WithTop (Box \u03b9)\nI : Box \u03b9\ni\u271d : \u03b9\nG : Type u\ninst\u271d : AddCommGroup G\nI\u2080 : Box (Fin (n + 1))\ni : Fin (n + 1)\nf : \u211d \u2192 Box (Fin n) \u2192 G\nfb : \u2191(Set.Icc (I\u2080.lower i) (I\u2080.upper i)) \u2192 Fin n \u2192\u1d47\u1d43[\u2191(I\u2080.face i)] G\nhf : \u2200 (x : \u211d) (hx : x \u2208 Set.Icc (I\u2080.lower i) (I\u2080.upper i)) (J : Box (Fin n)), f x J = (fb \u27e8x, hx\u27e9) J\nJ : Box (Fin (n + 1))\nhJ : J \u2264 I\u2080\nj : Fin (n + 1)\nx : \u211d\nhx : x \u2208 Set.Ioo (J.lower i) (J.upper i)\n\u22a2 f x { lower := fun x \u21a6 J.lower (i.succAbove x), upper := fun x \u21a6 J.upper (i.succAbove x), lower_lt_upper := \u22ef } -\n        f (J.lower i)\n          { lower := fun x \u21a6 J.lower (i.succAbove x), upper := fun x \u21a6 J.upper (i.succAbove x), lower_lt_upper := \u22ef } +\n      (f (J.upper i)\n          { lower := fun x \u21a6 J.lower (i.succAbove x), upper := fun x \u21a6 J.upper (i.succAbove x), lower_lt_upper := \u22ef } -\n        f x { lower := fun x \u21a6 J.lower (i.succAbove x), upper := fun x \u21a6 J.upper (i.succAbove x), lower_lt_upper := \u22ef }) =\n    f (J.upper i)\n        { lower := fun x \u21a6 J.lower (i.succAbove x), upper := fun x \u21a6 J.upper (i.succAbove x), lower_lt_upper := \u22ef } -\n      f (J.lower i)\n        { lower := fun x \u21a6 J.lower (i.succAbove x), upper := fun x \u21a6 J.upper (i.succAbove x), lower_lt_upper := \u22ef }",["abel","aesop","norm_num","simp"]],["Combinatorics/SetFamily/LYM.lean",125,"\u03b1 : Type u_2\ninst\u271d : DecidableEq \u03b1\nk : \u2115\n\ud835\udc9c : Finset (Finset \u03b1)\ns : Finset \u03b1\n\u22a2 (\u2203 i \u2208 \ud835\udc9c, s \u2286 i \u2227 #s = k) \u2194 (\u2203 t \u2208 \ud835\udc9c, s \u2286 t) \u2227 #s = k",["aesop","tauto"]],["CategoryTheory/Bicategory/Coherence.lean",90,"B : Type u\ninst\u271d : Quiver B\na b : B\nf g : Discrete (Path a b)\ndown\u271d : f.as = g.as\n\u22a2 Discrete.as ?m.4824 = Discrete.as ?m.4825",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Star/CHSH.lean",125,"R : Type u\ninst\u271d\u2074 : OrderedCommRing R\ninst\u271d\u00b3 : StarRing R\ninst\u271d\u00b2 : StarOrderedRing R\ninst\u271d\u00b9 : Algebra \u211d R\ninst\u271d : OrderedSMul \u211d R\nA\u2080 A\u2081 B\u2080 B\u2081 : R\nT : IsCHSHTuple A\u2080 A\u2081 B\u2080 B\u2081\nP : R := 2 - A\u2080 * B\u2080 - A\u2080 * B\u2081 - A\u2081 * B\u2080 + A\u2081 * B\u2081\nidem : P * P = 4 * P\nh : 4 * P = 4 \u2022 P\n\u22a2 P = (1 / 4 * 4) \u2022 P",["norm_num","aesop","simp"]],["Algebra/Star/CHSH.lean",159,"\u22a2 (\u221a2 * \u221a2)\u207b\u00b9 = 2\u207b\u00b9",["norm_num","aesop","simp"]],["Topology/Perfect.lean",239,"case intro.intro.intro.intro.left\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nC : Set \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nhclosed : IsClosed C\nV : Set \u03b1\nhunc : \u00acV.Countable\nD : Set \u03b1\nVct : V.Countable\nDperf : Perfect D\nVD : C = V\nh : D = \u2205\n\u22a2 False",["contradiction","aesop","tauto","infer_instance"]],["Analysis/Analytic/Order.lean",85,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nz\u2080 : \ud835\udd5c\nhf : AnalyticAt \ud835\udd5c f z\u2080\n\u22a2 f z\u2080 = 0 \u2192 \u00achf.order = \u22a4 \u2192 f z\u2080 = 0",["tauto","aesop"]],["Analysis/Analytic/Order.lean",119,"case right.left\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nz\u2080 : \ud835\udd5c\nf g : \ud835\udd5c \u2192 \ud835\udd5c\nhf : AnalyticAt \ud835\udd5c f z\u2080\nhg : AnalyticAt \ud835\udd5c g z\u2080\nh\u2082f : \u00achf.order = \u22a4\nh\u2082g : \u00achg.order = \u22a4\ng\u2081 : \ud835\udd5c \u2192 \ud835\udd5c\nh\u2081g\u2081 : AnalyticAt \ud835\udd5c g\u2081 z\u2080\nh\u2082g\u2081 : g\u2081 z\u2080 \u2260 0\nh\u2083g\u2081 : f =\u1da0[\ud835\udcdd z\u2080] fun z \u21a6 (z - z\u2080) ^ hf.order.toNat \u2022 g\u2081 z\ng\u2082 : \ud835\udd5c \u2192 \ud835\udd5c\nh\u2081g\u2082 : AnalyticAt \ud835\udd5c g\u2082 z\u2080\nh\u2082g\u2082 : g\u2082 z\u2080 \u2260 0\nh\u2083g\u2082 : g =\u1da0[\ud835\udcdd z\u2080] fun z \u21a6 (z - z\u2080) ^ hg.order.toNat \u2022 g\u2082 z\n\u22a2 \u00acg\u2081 z\u2080 = 0 \u2227 \u00acg\u2082 z\u2080 = 0",["tauto","aesop"]],["Analysis/Analytic/Order.lean",153,"case left.inl\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nU : Set \ud835\udd5c\nhf : AnalyticOnNhd \ud835\udd5c f U\nz : \u2191U\nhz : z \u2208 {u | \u22ef.order = \u22a4}\u1d9c\nh : \u22ef.order = \u22a4\n\u22a2 \u2203 t \u2286 {u | \u22ef.order = \u22a4}\u1d9c, IsOpen t \u2227 z \u2208 t",["tauto","aesop","contradiction"]],["Analysis/Analytic/Order.lean",181,"case pos\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nU : Set \ud835\udd5c\nhf : AnalyticOnNhd \ud835\udd5c f U\nz : \u2191U\nt' : Set \ud835\udd5c\nh\u2081t' : \u2200 y \u2208 t', f y = 0\nh\u2082t' : IsOpen t'\nh\u2083t' : \u2191z \u2208 t'\nw : \u2191U\nhw : w \u2208 Subtype.val \u207b\u00b9' t'\nh\u2081w : w = z\n\u22a2 \u2203 t, (\u2200 y \u2208 t, f y = 0) \u2227 IsOpen t \u2227 \u2191z \u2208 t",["tauto","aesop"]],["Analysis/Analytic/Order.lean",193,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nU : Set \ud835\udd5c\nhf : AnalyticOnNhd \ud835\udd5c f U\nhU : IsConnected U\nthis\u271d : ConnectedSpace \u2191U\nv : \u2191U\nthis : (\u2200 (u : \u2191U), \u22ef.order \u2260 \u22a4) \u2228 \u2200 (u : \u2191U), \u22ef.order = \u22a4\n\u22a2 (\u2203 u, \u22ef.order \u2260 \u22a4) \u2194 \u2200 (u : \u2191U), \u22ef.order \u2260 \u22a4",["tauto","aesop"]],["CategoryTheory/Limits/Shapes/FunctorToTypes.lean",78,"C : Type u\ninst\u271d : Category.{v, u} C\nF G : C \u2964 Type w\nx\u271d\u00b9 : Cone (pair F G)\nx\u271d : x\u271d\u00b9.pt \u27f6 (binaryProductCone F G).pt\nh : \u2200 (j : Discrete WalkingPair), x\u271d \u226b (binaryProductCone F G).\u03c0.app j = x\u271d\u00b9.\u03c0.app j\n\u22a2 x\u271d =\n    prod.lift (x\u271d \u226b (binaryProductCone F G).\u03c0.app { as := WalkingPair.left })\n      (x\u271d \u226b (binaryProductCone F G).\u03c0.app { as := WalkingPair.right })",["congr","aesop","tauto"]],["CategoryTheory/Limits/Shapes/FunctorToTypes.lean",54,"case h\nC : Type u\ninst\u271d : Category.{v, u} C\nF G F\u2081 F\u2082 : C \u2964 Type w\n\u03c4\u2081 : F \u27f6 F\u2081\n\u03c4\u2082 : F \u27f6 F\u2082\nx\u271d\u00b2 x\u271d\u00b9 : C\nx\u271d : x\u271d\u00b2 \u27f6 x\u271d\u00b9\na : F.obj x\u271d\u00b2\n\u22a2 (F\u2081.map x\u271d (\u03c4\u2081.app x\u271d\u00b2 a), F\u2082.map x\u271d (\u03c4\u2082.app x\u271d\u00b2 a)) = (prod F\u2081 F\u2082).map x\u271d (\u03c4\u2081.app x\u271d\u00b2 a, \u03c4\u2082.app x\u271d\u00b2 a)",["aesop","congr","tauto"]],["CategoryTheory/Limits/Shapes/FunctorToTypes.lean",241,"C : Type u\ninst\u271d : Category.{v, u} C\nF G : C \u2964 Type w\n\u22a2 BinaryCofan.inr (binaryCoproductColimitCocone F G).cocone = coprod.inr",["aesop","congr","tauto"]],["CategoryTheory/Idempotents/FunctorExtension.lean",241,"case e_a.e_a\nC : Type u_1\nD : Type u_2\ninst\u271d\u00b2 : Category.{u_4, u_1} C\ninst\u271d\u00b9 : Category.{u_5, u_2} D\ninst\u271d : IsIdempotentComplete D\nF G : Karoubi C \u2964 D\n\u03c4 : toKaroubi C \u22d9 F \u27f6 toKaroubi C \u22d9 G\nP : Karoubi C\n\u22a2 (((whiskeringLeft C (Karoubi C) D).obj (toKaroubi C)).preimage \u03c4).app { X := P.X, p := \ud835\udfd9 P.X, idem := \u22ef } =\n    (((whiskeringLeft C (Karoubi C) D).obj (toKaroubi C)).preimage \u03c4).app ((toKaroubi C).obj P.X)",["congr","aesop","tauto"]],["Algebra/Order/BigOperators/Expect.lean",81,"\u03b9 : Type u_1\nM : Type u_4\nN : Type u_5\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module \u211a\u22650 M\ninst\u271d\u00b2 : OrderedAddCommMonoid N\ninst\u271d\u00b9 : Module \u211a\u22650 N\ninst\u271d : PosSMulMono \u211a\u22650 N\nf : \u03b9 \u2192 M\ns : Finset \u03b9\nm : M \u2192 N\nh_mul : \u2200 (a b : M), m (a + b) \u2264 m a + m b\nh_div : \u2200 (n : \u2115) (a : M), m ((\u2191n)\u207b\u00b9 \u2022 a) = (\u2191n)\u207b\u00b9 \u2022 m a\nhs : s.Nonempty\n\u22a2 \u2200 i \u2208 s, (fun x \u21a6 True) (f i)",["simp","aesop","tauto","norm_num"]],["Algebra/Order/BigOperators/Expect.lean",38,"\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Module \u211a\u22650 \u03b1\ns : Finset \u03b9\nf g : \u03b9 \u2192 \u03b1\ninst\u271d : PosSMulMono \u211a\u22650 \u03b1\nhfg : \u2200 i \u2208 s, f i \u2264 g i\n\u22a2 0 \u2264 (\u2191(#s))\u207b\u00b9",["positivity","aesop","norm_num","simp"]],["Algebra/Order/BigOperators/Expect.lean",73,"\u03b9 : Type u_1\nM : Type u_4\nN : Type u_5\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module \u211a\u22650 M\ninst\u271d\u00b2 : OrderedAddCommMonoid N\ninst\u271d\u00b9 : Module \u211a\u22650 N\ninst\u271d : PosSMulMono \u211a\u22650 N\nm : M \u2192 N\np : M \u2192 Prop\nf : \u03b9 \u2192 M\ns : Finset \u03b9\nh_add : \u2200 (a b : M), p a \u2192 p b \u2192 m (a + b) \u2264 m a + m b\nhp_add : \u2200 (a b : M), p a \u2192 p b \u2192 p (a + b)\nh_div : \u2200 (n : \u2115) (a : M), p a \u2192 m ((\u2191n)\u207b\u00b9 \u2022 a) = (\u2191n)\u207b\u00b9 \u2022 m a\nhs_nonempty : s.Nonempty\nhs : \u2200 i \u2208 s, p (f i)\n\u22a2 0 \u2264 (\u2191(#s))\u207b\u00b9",["positivity","aesop","norm_num","simp"]],["Analysis/Calculus/FDeriv/Norm.lean",164,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nh : DifferentiableAt \u211d (fun x \u21a6 \u2016x\u2016) x\nthis : \u2200 (t : \u211d), \u2016x + t \u2022 x\u2016 = |1 + t| * \u2016x\u2016\n\u22a2 1 + 0 \u2260 0",["norm_num","aesop","linarith","positivity","simp"]],["Topology/Sheaves/SheafCondition/OpensLeCover.lean",154,"case mk.mk\nC : Type u\ninst\u271d : Category.{v, u} C\nX : TopCat\nF : Presheaf C X\n\u03b9 : Type w\nU : \u03b9 \u2192 Opens \u2191X\nY : Opens \u2191X\nhY : Y = iSup U\nleft\u271d : Opens \u2191X\nright\u271d : Discrete PUnit.{1}\nhom\u271d : (\ud835\udfed (Opens \u2191X)).obj left\u271d \u27f6 (Functor.fromPUnit Y).obj right\u271d\nproperty\u271d : (Sieve.generate (presieveOfCoveringAux U Y)).arrows { left := left\u271d, right := right\u271d, hom := hom\u271d }.hom\n\u22a2 { obj := { left := left\u271d, right := right\u271d, hom := hom\u271d }, property := property\u271d } =\n    (generateEquivalenceOpensLe_inverse' U hY).obj\n      ((generateEquivalenceOpensLe_functor' U).obj\n        { obj := { left := left\u271d, right := right\u271d, hom := hom\u271d }, property := property\u271d })",["congr","aesop","tauto"]],["NumberTheory/Fermat.lean",182,"case intro.intro\nk n : \u2115\nhn : 1 < n + succ 1\nhp : Prime (k * 2 ^ (n + succ 1 + 1) + 1)\nhpdvd : k * 2 ^ (n + succ 1 + 1) + 1 \u2223 (n + succ 1).fermatNumber\nthis : Fact (Prime (k * 2 ^ (n + succ 1 + 1) + 1))\nhp2 : k * 2 ^ (n + succ 1 + 1) + 1 \u2260 2\n\u22a2 (k * 2 ^ n % 8 * (2 ^ (succ 1 + 1) % 8) % 8 + 1) % 8 = 1",["norm_num","ring","aesop","congr","tauto","abel","simp"]],["Computability/DFA.lean",215,"\u03b1 : Type u\n\u03c3 : Type v\nM\u271d : DFA \u03b1 \u03c3\n\u03b1' : Type u_1\n\u03c3' : Type u_2\ng : \u03c3 \u2243 \u03c3'\nM : DFA \u03b1 \u03c3\n\u22a2 (fun M \u21a6 { step := fun s a \u21a6 g.symm (M.step (g s) a), start := g.symm M.start, accept := \u21d1g \u207b\u00b9' M.accept })\n      ((fun M \u21a6 { step := fun s a \u21a6 g (M.step (g.symm s) a), start := g M.start, accept := \u21d1g.symm \u207b\u00b9' M.accept }) M) =\n    M",["simp","aesop","norm_num"]],["Computability/DFA.lean",109,"\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\ninst\u271d : Fintype \u03c3\nx : List \u03b1\ns t : \u03c3\nhlen : Fintype.card \u03c3 \u2264 x.length\nhx : M.evalFrom s x = t\n\u22a2 Fintype.card \u03c3 < Fintype.card (Fin (Fintype.card \u03c3 + 1))",["norm_num","aesop","simp"]],["NumberTheory/Zsqrtd/GaussianInt.lean",131,"case mk\nre\u271d im\u271d : \u2124\n\u22a2 \u2191({ re := re\u271d, im := im\u271d }.re * { re := re\u271d, im := im\u271d }.re -\n        -1 * { re := re\u271d, im := im\u271d }.im * { re := re\u271d, im := im\u271d }.im) =\n    \u2191({ toFun := fun z \u21a6 z.re * z.re + z.im * z.im, map_zero' := normSq.proof_1, map_one' := normSq.proof_2,\n          map_mul' := normSq.proof_3 }\n        (toComplex { re := re\u271d, im := im\u271d }))",["simp","aesop","norm_num"]],["NumberTheory/Zsqrtd/GaussianInt.lean",188,"x y : \u2124[i]\n\u22a2 0 \u2264 2\u207b\u00b9",["norm_num","aesop","linarith","positivity","simp"]],["Analysis/Fourier/Inversion.lean",149,"case h.e_f.h.e_a.e_a.e_z\nV : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : InnerProductSpace \u211d V\ninst\u271d\u2075 : MeasurableSpace V\ninst\u271d\u2074 : BorelSpace V\ninst\u271d\u00b3 : FiniteDimensional \u211d V\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nf : V \u2192 E\ninst\u271d : CompleteSpace E\nhf : Integrable f volume\nv : V\nh'f : ContinuousAt f v\n\u03c6 : V \u2192 \u211d := fun w \u21a6 \u03c0 ^ (\u2191(finrank \u211d V) / 2) * rexp (-\u03c0 ^ 2 * \u2016w\u2016 ^ 2)\nA : Tendsto (fun c \u21a6 \u222b (w : V), (c ^ finrank \u211d V * \u03c6 (c \u2022 (v - w))) \u2022 f w) atTop (\ud835\udcdd (f v))\nB : Tendsto (fun c \u21a6 \u222b (w : V), ((c ^ (1 / 2)) ^ finrank \u211d V * \u03c6 (c ^ (1 / 2) \u2022 (v - w))) \u2022 f w) atTop (\ud835\udcdd (f v))\nc : \u211d\nhc : 0 < c\nw : V\n\u22a2 \u03c0 ^ \u21912 * (c ^ (2\u207b\u00b9 * \u21912) * \u2016v - w\u2016 ^ \u21912) = \u03c0 ^ \u21912 * (c * \u2016v - w\u2016 ^ \u21912)",["norm_num","aesop","simp"]],["NumberTheory/Cyclotomic/Three.lean",82,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\n\u22a2 0 - 3 * (algebraMap (\ud835\udcde K) K) \u2191\u03b7 = -3 * (algebraMap (\ud835\udcde K) K) \u2191\u03b7",["ring","aesop","norm_num","simp"]],["NumberTheory/Cyclotomic/Three.lean",159,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nx : \ud835\udcde K\n\u22a2 x ^ 3 - x ^ 2 * 0 + x * 0 - 1 = x ^ 3 - 1",["ring","aesop","norm_num","simp"]],["NumberTheory/Cyclotomic/Three.lean",67,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nu : (\ud835\udcde K)\u02e3\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nhrank : rank K = 0\nx : \u21a5(torsion K)\ne : Fin (rank K) \u2192 \u2124\nhxu : u = \u2191x\nn : \u2115\nhnpos : 0 < n\nhn : (algebraMap (\ud835\udcde K) K) \u2191u ^ \u2191\u27e8n, hnpos\u27e9 = 1\n\u22a2 Odd \u21913",["decide"]],["NumberTheory/Cyclotomic/Three.lean",81,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\n\u22a2 0 < \u21913",["decide","aesop","linarith","positivity","tauto","norm_num","simp"]],["NumberTheory/Cyclotomic/Three.lean",87,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\n\u22a2 0 < \u21913",["decide","aesop","linarith","positivity","tauto","norm_num","simp"]],["NumberTheory/Cyclotomic/Three.lean",105,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u21913\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nh\u03b6 : IsPrimitiveRoot (zeta 3 \u211a K) \u21913\nhcong : \u2203 n, 3 \u2223 \u2191(-\u22ef.unit) - \u2191n\n\u22a2 3 \u2260 2",["decide","aesop","tauto","norm_num","simp"]],["NumberTheory/Cyclotomic/Three.lean",114,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u21913\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nh\u03b6 : IsPrimitiveRoot (zeta 3 \u211a K) \u21913\nhcong : \u2203 n, 3 \u2223 \u2191(-\u22ef.unit ^ 2) - \u2191n\n\u22a2 3 \u2260 2",["decide","aesop","tauto","norm_num","simp"]],["NumberTheory/Cyclotomic/Three.lean",127,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nx : \ud835\udcde K\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\n\u22a2 1 < 3",["decide","aesop","tauto","norm_num","simp"]],["Logic/Unique.lean",257,"\u03b1 : Sort u_1\ny : \u03b1\nx\u271d : { x // x = y }\nx : \u03b1\nhx : x = y\n\u22a2 \u27e8x, hx\u27e9 = default",["congr","omega","infer_instance"]],["Logic/Unique.lean",261,"\u03b1 : Sort u_1\ny : \u03b1\nx\u271d : { x // y = x }\n\u22a2 \u27e8y, \u22ef\u27e9 = default",["congr","omega","infer_instance","simp"]],["Analysis/Complex/Polynomial/Basic.lean",67,"p : \u211a[X]\nhp : p = 0\n\u22a2 IsEmpty \u2191\u2205",["infer_instance","aesop","norm_num","simp"]],["Analysis/Complex/Polynomial/Basic.lean",108,"case neg.refine_2.refine_2.refine_2\np : \u211a[X]\nhp : \u00acp = 0\ninj : Function.Injective \u21d1(IsScalarTower.toAlgHom \u211a \u211d \u2102)\na : Finset \u2102 := (p.rootSet \u2102).toFinset\nb : Finset \u2102 := Finset.image (\u21d1(IsScalarTower.toAlgHom \u211a \u211d \u2102)) (p.rootSet \u211d).toFinset\nc : Finset \u2102 :=\n  Finset.image (fun a \u21a6 \u2191a) ((galActionHom p \u2102) ((restrict p \u2102) (AlgEquiv.restrictScalars \u211a conjAe))).support\nha : \u2200 (z : \u2102), z \u2208 a \u2194 (aeval z) p = 0\nhb : \u2200 (z : \u2102), z \u2208 b \u2194 (aeval z) p = 0 \u2227 z.im = 0\nhc0 :\n  \u2200 (w : \u2191(p.rootSet \u2102)), ((galActionHom p \u2102) ((restrict p \u2102) (AlgEquiv.restrictScalars \u211a conjAe))) w = w \u2194 (\u2191w).im = 0\nhc : \u2200 (z : \u2102), z \u2208 c \u2194 (aeval z) p = 0 \u2227 z.im \u2260 0\n\u22a2 \u2200 (a : \u2102), (aeval a) p = 0 \u2194 (aeval a) p = 0 \u2227 a.im = 0 \u2228 (aeval a) p = 0 \u2227 a.im \u2260 0",["tauto"]],["Analysis/Complex/Polynomial/Basic.lean",112,"case neg.refine_2.refine_2.refine_2\np : \u211a[X]\nhp : \u00acp = 0\ninj : Function.Injective \u21d1(IsScalarTower.toAlgHom \u211a \u211d \u2102)\na : Finset \u2102 := (p.rootSet \u2102).toFinset\nb : Finset \u2102 := Finset.image (\u21d1(IsScalarTower.toAlgHom \u211a \u211d \u2102)) (p.rootSet \u211d).toFinset\nc : Finset \u2102 :=\n  Finset.image (fun a \u21a6 \u2191a) ((galActionHom p \u2102) ((restrict p \u2102) (AlgEquiv.restrictScalars \u211a conjAe))).support\nha : \u2200 (z : \u2102), z \u2208 a \u2194 (aeval z) p = 0\nhb : \u2200 (z : \u2102), z \u2208 b \u2194 (aeval z) p = 0 \u2227 z.im = 0\nhc0 :\n  \u2200 (w : \u2191(p.rootSet \u2102)), ((galActionHom p \u2102) ((restrict p \u2102) (AlgEquiv.restrictScalars \u211a conjAe))) w = w \u2194 (\u2191w).im = 0\nhc : \u2200 (z : \u2102), z \u2208 c \u2194 (aeval z) p = 0 \u2227 z.im \u2260 0\nz : \u2102\n\u22a2 (aeval z) p = 0 \u2227 z.im = 0 \u2192 \u00ac((aeval z) p = 0 \u2227 z.im \u2260 0)",["tauto","aesop"]],["Algebra/Polynomial/Lifts.lean",215,"case a\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\np : R[X]\nn\u271d : \u2115\n\u22a2 (p.sum fun e a \u21a6 C ((algebraMap R S) a) * X ^ e).coeff n\u271d =\n    (p.sum fun e a \u21a6 (\u21d1C \u2218 \u21d1(algebraMap R S)) a * X ^ e).coeff n\u271d",["congr","omega","aesop","tauto","infer_instance","abel","norm_num","simp"]],["Combinatorics/Additive/ApproximateSubgroup.lean",205,"G : Type u_1\ninst\u271d : Group G\nA : Set G\nhA : IsApproximateSubgroup 1 A\nx : G\nhx : A * A \u2286 x \u2022 A\nhx' : x\u207b\u00b9 \u2022 (A * A) \u2286 A\nhx_inv : x\u207b\u00b9 \u2208 A\nhx_sq : x * x \u2208 A\n\u22a2 A * A \u2286 x \u2022 A",["assumption","aesop","congr","gcongr","tauto"]],["Combinatorics/Additive/ApproximateSubgroup.lean",88,"G : Type u_1\ninst\u271d\u00b9 : Group G\nK : \u211d\ninst\u271d : DecidableEq G\nA : Finset G\nhA : IsApproximateSubgroup K \u2191A\nn : \u2115\nF : Finset G\nhF : \u2191(#F) \u2264 K\nhSF : \u2191A ^ 2 \u2286 \u2191F \u2022 \u2191A\n\u22a2 n + 2 \u2260 0",["omega","aesop","linarith","positivity","tauto","norm_num","simp"]],["Analysis/Analytic/Within.lean",176,"\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : CompleteSpace F\nf : E \u2192 F\ns : Set E\nx : E\n\u22a2 (\u2203 p g, f =\u1da0[\ud835\udcdd[insert x s] x] g \u2227 HasFPowerSeriesAt g p x) \u2194 \u2203 g, f =\u1da0[\ud835\udcdd[insert x s] x] g \u2227 \u2203 p, HasFPowerSeriesAt g p x",["tauto","aesop"]],["Data/Fintype/Pi.lean",169,"case h\n\u03b1 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : (a : \u03b1) \u2192 Fintype (\u03b2 a)\na\u271d : (a : \u03b1) \u2192 a \u2208 univ \u2192 \u03b2 a\n\u22a2 (a\u271d \u2208 univ.pi fun a \u21a6 univ) \u2194 a\u271d \u2208 univ",["simp","aesop"]],["Algebra/GroupWithZero/Hom.lean",94,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nM\u2080 : Type u_6\ninst\u271d\u00b3 : MulZeroOneClass \u03b1\ninst\u271d\u00b2 : MulZeroOneClass \u03b2\ninst\u271d\u00b9 : MulZeroOneClass \u03b3\ninst\u271d : MulZeroOneClass \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmap_zero'\u271d\u00b9 : toFun\u271d\u00b9 0 = 0\nmap_one'\u271d\u00b9 : { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9 }.toFun 1 = 1\nmap_mul'\u271d\u00b9 :\n  \u2200 (x y : \u03b1),\n    { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9 }.toFun (x * y) =\n      { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9 }.toFun x * { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9 }.toFun y\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmap_zero'\u271d : toFun\u271d 0 = 0\nmap_one'\u271d : { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun 1 = 1\nmap_mul'\u271d :\n  \u2200 (x y : \u03b1),\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun (x * y) =\n      { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun x * { toFun := toFun\u271d, map_zero' := map_zero'\u271d }.toFun y\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, map_one' := map_one'\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, map_zero' := map_zero'\u271d\u00b9, map_one' := map_one'\u271d\u00b9, map_mul' := map_mul'\u271d\u00b9 } =\n    { toFun := toFun\u271d, map_zero' := map_zero'\u271d, map_one' := map_one'\u271d, map_mul' := map_mul'\u271d }",["congr","aesop"]],["Order/Interval/Set/OrdConnectedComponent.lean",126,"case h\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns : Set \u03b1\nx : \u03b1\u1d52\u1d48\n\u22a2 (\u2203 a, \u2203 (h : a \u2208 s), \u22ef.some = x) \u2194 \u2203 a, \u2203 (h : a \u2208 s), \u22ef.some = ofDual x",["tauto","aesop"]],["Data/Nat/Lattice.lean",92,"case h\ns : Set \u2115\nh : 0 < sInf s\ncontra : s = \u2205\nh' : sInf s \u2260 0\n\u22a2 s = \u2205",["assumption","aesop","congr","gcongr","tauto"]],["GroupTheory/Solvable.lean",218,"x : Perm (Fin 5) := { toFun := ![1, 2, 0, 3, 4], invFun := ![2, 0, 1, 3, 4], left_inv := \u22ef, right_inv := \u22ef }\ny : Perm (Fin 5) := { toFun := ![3, 4, 2, 0, 1], invFun := ![3, 4, 2, 0, 1], left_inv := \u22ef, right_inv := \u22ef }\nz : Perm (Fin 5) := { toFun := ![0, 3, 2, 1, 4], invFun := ![0, 3, 2, 1, 4], left_inv := \u22ef, right_inv := \u22ef }\n\u22a2 { toFun := ![1, 2, 0, 3, 4], invFun := ![2, 0, 1, 3, 4], left_inv := \u22ef, right_inv := \u22ef } =\n    { toFun := ![0, 3, 2, 1, 4], invFun := ![0, 3, 2, 1, 4], left_inv := \u22ef, right_inv := \u22ef } *\n        \u2045{ toFun := ![1, 2, 0, 3, 4], invFun := ![2, 0, 1, 3, 4], left_inv := \u22ef, right_inv := \u22ef },\n          { toFun := ![3, 4, 2, 0, 1], invFun := ![3, 4, 2, 0, 1], left_inv := \u22ef, right_inv := \u22ef } *\n              { toFun := ![1, 2, 0, 3, 4], invFun := ![2, 0, 1, 3, 4], left_inv := \u22ef, right_inv := \u22ef } *\n            { toFun := ![3, 4, 2, 0, 1], invFun := ![3, 4, 2, 0, 1], left_inv := \u22ef, right_inv := \u22ef }\u207b\u00b9\u2046 *\n      { toFun := ![0, 3, 2, 1, 4], invFun := ![0, 3, 2, 1, 4], left_inv := \u22ef, right_inv := \u22ef }\u207b\u00b9",["decide"]],["Topology/Order/LawsonTopology.lean",210,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\nL S : TopologicalSpace \u03b1\ninst\u271d\u00b9 : IsLawson \u03b1\ninst\u271d : IsScott \u03b1 univ\ns : Set \u03b1\nh : IsLowerSet s\n\u22a2 IsLowerSet s \u2227 DirSupClosed s \u2194 DirSupClosed s",["aesop","tauto"]],["Combinatorics/Additive/Corner/Roth.lean",87,"G : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Fintype G\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhG : \u230a(triangleRemovalBound (\u03b5 / 9) * 27)\u207b\u00b9\u230b\u208a < Fintype.card G\nA : Finset (G \u00d7 G)\nhA\u03b5 : \u03b5 * \u2191(Fintype.card G) ^ 2 \u2264 \u2191(#A)\nhA : IsCornerFree \u2191A\nthis : \u03b5 * (\u2191(Fintype.card G) * \u2191(Fintype.card G)) \u2264 \u2191(Fintype.card G) * \u2191(Fintype.card G)\n\u22a2 0 < \u2191(Fintype.card G) * \u2191(Fintype.card G)",["positivity","aesop","norm_num","simp"]],["Analysis/Calculus/Deriv/Abs.lean",87,"case h.e'_12.h\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\nx : E\nhf : HasStrictFDerivAt f f' x\nh\u2080 : 0 < f x\ny : E\n\u22a2 f' y = ((ContinuousLinearMap.smulRight 1 1).comp f') y",["simp","aesop","norm_num"]],["Analysis/Calculus/Deriv/Abs.lean",75,"case h.e'_12.h\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\nx : E\nhf : HasStrictFDerivAt f f' x\nh\u2080 : f x < 0\ny : E\n\u22a2 (-f') y = ((ContinuousLinearMap.smulRight 1 (-1)).comp f') y",["simp","aesop","norm_num"]],["Analysis/Calculus/Deriv/Abs.lean",119,"case h.e'_12\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\ns : Set E\nx : E\nhf : HasFDerivWithinAt f f' s x\nh\u2080 : f x < 0\n\u22a2 -f' = -1 \u2022 f'",["simp","aesop","norm_num"]],["Analysis/Calculus/Deriv/Abs.lean",93,"case h.e'_12.h\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\nx : E\nhf : HasFDerivAt f f' x\nh\u2080 : 0 < f x\ny : E\n\u22a2 f' y = ((ContinuousLinearMap.smulRight 1 1).comp f') y",["simp","aesop","norm_num"]],["Data/Finset/Filter.lean",148,"case h\n\u03b1 : Type u_1\nh : DecidablePred fun x \u21a6 True\ns : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 filter (fun x \u21a6 True) s \u2194 a\u271d \u2208 s",["simp","aesop"]],["Data/Finset/Filter.lean",145,"\u03b1 : Type u_1\ns : Finset \u03b1\np : \u03b1 \u2192 Prop\nh inst\u271d : DecidablePred p\n\u22a2 filter p s = filter p s",["congr","aesop"]],["Data/Finset/Filter.lean",210,"case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt u : Finset \u03b1\nx : \u03b1\nhx : x \u2208 u\nhi hj : u \u2264 (fun x \u21a6 filter (fun x_1 \u21a6 f x_1 = x) t) (f x)\nh : f x \u2260 f x\n\u22a2 x \u2208 \u22a5",["contradiction","omega","aesop","tauto","infer_instance"]],["Algebra/Homology/HomotopyCategory/ShiftSequence.lean",138,"C : Type u_1\ninst\u271d\u00b3 : Category.{u_2, u_1} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : CategoryWithHomology C\nK L : CochainComplex C \u2124\n\u03c6 : K \u27f6 L\nn : \u2124\ninst\u271d : QuasiIso \u03c6\n\u22a2 QuasiIso \u03c6",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["GroupTheory/CommutingProbability.lean",142,"\u22a2 0 \u2260 0 \u2192 0 \u2260 1 \u2192 0 / 4 + 1 < 0\n```\n---\n```lean\n\u22a2 1 \u2260 0 \u2192 1 \u2260 1 \u2192 1 / 4 + 1 < 1\n```\n---\n```lean\n\u22a2 2 \u2260 0 \u2192 2 \u2260 1 \u2192 2 / 4 + 1 < 2\n```\n---\n```lean\n\u22a2 3 \u2260 0 \u2192 3 \u2260 1 \u2192 3 / 4 + 1 < 3",["decide","omega","aesop","tauto","norm_num","simp"]],["Data/Vector/Defs.lean",78,"\u03b1 : Type u_1\nn : \u2115\nh : [].length = n.succ\n\u22a2 cons (head \u27e8[], h\u27e9) (tail \u27e8[], h\u27e9) = \u27e8[], h\u27e9",["contradiction","tauto"]],["Data/List/OfFn.lean",40,"\u03b1 : Type u\n\u03b2 : Type u_1\nn : \u2115\nf : Fin n \u2192 \u03b1\ng : \u03b1 \u2192 \u03b2\ni : \u2115\nh : i < (map g (ofFn f)).length\nh' : i < (ofFn (g \u2218 f)).length\n\u22a2 (map g (ofFn f)).get \u27e8i, h\u27e9 = (ofFn (g \u2218 f)).get \u27e8i, h'\u27e9",["simp","aesop"]],["Data/List/OfFn.lean",33,"\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni : Fin (ofFn f).length\n\u22a2 f \u27e8\u2191i, \u22ef\u27e9 = f (Fin.cast \u22ef i)",["congr","aesop","tauto"]],["Data/List/OfFn.lean",54,"case succ\n\u03b1 : Type u\nn : \u2115\nIH : \u2200 (f : Fin n.succ \u2192 \u03b1), ofFn f = (ofFn fun i \u21a6 f i.castSucc).concat (f (Fin.last n))\nf : Fin (n + 1).succ \u2192 \u03b1\n\u22a2 f 0 :: (ofFn fun i \u21a6 f i.castSucc.succ).concat (f (Fin.last n).succ) =\n    f 0 :: (ofFn fun i \u21a6 f i.succ.castSucc).concat (f (Fin.last (n + 1)))",["congr","aesop","tauto"]],["Algebra/Polynomial/Module/AEval.lean",139,"case a.h\nR : Type ?u.120663\nA : Type ?u.120666\nM : Type ?u.120693\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\na : A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module A M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsScalarTower R A M\np : \u21a5((Algebra.lsmul R R M) a).invtSubmodule\nx\u271d : M\n\u22a2 x\u271d \u2208\n      \u2191((fun q \u21a6 \u27e8(Submodule.orderIsoMapComap (of R M a)).symm (Submodule.restrictScalars R q), \u22ef\u27e9)\n          ((fun p \u21a6 { toAddSubmonoid := AddSubmonoid.map (of R M a) (\u2191p).toAddSubmonoid, smul_mem' := \u22ef }) p)) \u2194\n    x\u271d \u2208 \u2191p",["simp","aesop","norm_num"]],["Geometry/Manifold/Algebra/LeftInvariantDerivation.lean",57,"case mk.mk\n\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2074 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nG : Type u_4\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : ChartedSpace H G\ninst\u271d\u00b9 : Monoid G\ninst\u271d : ContMDiffMul I \u221e G\ntoDerivation\u271d\u00b9 : Derivation \ud835\udd5c C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef\nleft_invariant''\u271d\u00b9 : \u2200 (g : G), (\ud835\udc85\u2095 \u22ef) ((Derivation.evalAt 1) toDerivation\u271d\u00b9) = (Derivation.evalAt g) toDerivation\u271d\u00b9\ntoDerivation\u271d : Derivation \ud835\udd5c C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef\nleft_invariant''\u271d : \u2200 (g : G), (\ud835\udc85\u2095 \u22ef) ((Derivation.evalAt 1) toDerivation\u271d) = (Derivation.evalAt g) toDerivation\u271d\nh :\n  \u2191{ toDerivation := toDerivation\u271d\u00b9, left_invariant'' := left_invariant''\u271d\u00b9 } =\n    \u2191{ toDerivation := toDerivation\u271d, left_invariant'' := left_invariant''\u271d }\n\u22a2 { toDerivation := toDerivation\u271d\u00b9, left_invariant'' := left_invariant''\u271d\u00b9 } =\n    { toDerivation := toDerivation\u271d, left_invariant'' := left_invariant''\u271d }",["congr","aesop"]],["Data/Prod/Lex.lean",82,"case mp.left.right.left\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u2081 x\u2082 : Lex (\u03b1 \u00d7 \u03b2)\na\u2081 : \u03b1\nb\u2081 : \u03b2\na\u2082 : \u03b1\nb\u2082 : \u03b2\nhlt : a\u2081 < a\u2082\nh\u271d : a\u2082 < a\u2081\n\u22a2 a\u2082 < a\u2081",["assumption","aesop","congr","gcongr","tauto"]],["Data/Prod/Lex.lean",90,"case mp.right.right.left\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u2081 x\u2082 : Lex (\u03b1 \u00d7 \u03b2)\na\u2081 : \u03b1\nb\u2081 b\u2082 : \u03b2\nhlt : b\u2081 < b\u2082\nh\u271d : a\u2081 < a\u2081\n\u22a2 a\u2081 < a\u2081",["assumption"]],["Data/Prod/Lex.lean",93,"case mp.right.right.right\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u2081 x\u2082 : Lex (\u03b1 \u00d7 \u03b2)\na\u2081 : \u03b1\nb\u2081 b\u2082 : \u03b2\nhlt : b\u2081 \u2264 b\u2082 \u2227 \u00acb\u2082 \u2264 b\u2081\nh\u271d : b\u2082 \u2264 b\u2081\n\u22a2 b\u2082 \u2264 b\u2081",["assumption"]],["Data/Prod/Lex.lean",96,"case mpr.intro.left.h\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nx\u2081 x\u2082 : Lex (\u03b1 \u00d7 \u03b2)\na\u2081 : \u03b1\nb\u2081 : \u03b2\na\u2082 : \u03b1\nb\u2082 : \u03b2\nh\u2082r : \u00ac(a\u2082, b\u2082) \u2264 (a\u2081, b\u2081)\nh\u271d : a\u2081 < a\u2082\n\u22a2 a\u2081 < a\u2082",["assumption"]],["Data/Prod/Lex.lean",119,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 x.1 \u2264 y.1 \u2227 \u00acy.1 \u2264 x.1 \u2228 (x.1 \u2264 y.1 \u2227 y.1 \u2264 x.1) \u2227 x.2 \u2264 y.2 \u2194 x.1 \u2264 y.1 \u2227 (x.1 \u2264 y.1 \u2227 y.1 \u2264 x.1 \u2192 x.2 \u2264 y.2)",["tauto"]],["Data/Prod/Lex.lean",125,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\nx y : \u03b1 \u00d7 \u03b2\n\u22a2 x.1 \u2264 y.1 \u2227 \u00acy.1 \u2264 x.1 \u2228 (x.1 \u2264 y.1 \u2227 y.1 \u2264 x.1) \u2227 x.2 \u2264 y.2 \u2227 \u00acy.2 \u2264 x.2 \u2194\n    x.1 \u2264 y.1 \u2227 (x.1 \u2264 y.1 \u2227 y.1 \u2264 x.1 \u2192 x.2 \u2264 y.2 \u2227 \u00acy.2 \u2264 x.2)",["tauto"]],["Topology/Baire/Lemmas.lean",80,"X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\np : X \u2192 Prop\n\u22a2 (\u2203 t, (\u2200 x \u2208 t, p x) \u2227 IsG\u03b4 t \u2227 Dense t) \u2194 \u2203 t, IsG\u03b4 t \u2227 Dense t \u2227 \u2200 x \u2208 t, p x",["tauto","aesop"]],["Topology/Sheaves/Alexandrov.lean",157,"case op.mk.intro.w.mk.e_a\nX\u271d : Type v\ninst\u271d\u2076 : TopologicalSpace X\u271d\ninst\u271d\u2075 : Preorder X\u271d\ninst\u271d\u2074 : Topology.IsUpperSet X\u271d\nC : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasLimits C\nF\u271d : X\u271d \u2964 C\nX : TopCat\ninst\u271d\u00b9 : Preorder \u2191X\ninst\u271d : Topology.IsUpperSet \u2191X\nF : \u2191X \u2964 C\n\u03b1 : Type v\nUs : \u03b1 \u2192 Opens \u2191X\nS : Cone ((fullSubcategoryInclusion fun V \u21a6 \u2203 i, V \u2264 Us i).op \u22d9 principalsKanExtension F)\nV : Opens \u2191X\ni : \u03b1\nhV : V \u2264 Us i\nleft\u271d : Discrete PUnit.{1}\nx : \u2191X\nf : (fromPUnit (Opposite.op V)).obj left\u271d \u27f6 (principals \u2191X).obj x\ne : principalOpen x \u2264 V\nVV : FullSubcategory fun V \u21a6 \u2203 i, V \u2264 Us i := { obj := V, property := \u22ef }\nxx : FullSubcategory fun V \u21a6 \u2203 i, V \u2264 Us i := { obj := principalOpen x, property := \u22ef }\nee : xx \u27f6 VV := e.hom\n\u22a2 limit.\u03c0 (StructuredArrow.proj (Opposite.op V) (principals \u2191X) \u22d9 F)\n      ((StructuredArrow.map ee.op).obj\n        { left := { as := PUnit.unit }, right := x, hom := \ud835\udfd9 (Opposite.op (principalOpen x)) }) =\n    limit.\u03c0 (StructuredArrow.proj (Opposite.op V) (principals \u2191X) \u22d9 F) { left := left\u271d, right := x, hom := f }",["congr","aesop","tauto"]],["Topology/Sheaves/Alexandrov.lean",172,"case w.mk\nX\u271d : Type v\ninst\u271d\u2076 : TopologicalSpace X\u271d\ninst\u271d\u2075 : Preorder X\u271d\ninst\u271d\u2074 : Topology.IsUpperSet X\u271d\nC : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasLimits C\nF\u271d : X\u271d \u2964 C\nX : TopCat\ninst\u271d\u00b9 : Preorder \u2191X\ninst\u271d : Topology.IsUpperSet \u2191X\nF : \u2191X \u2964 C\n\u03b1 : Type v\nUs : \u03b1 \u2192 Opens \u2191X\nS : Cone ((fullSubcategoryInclusion fun V \u21a6 \u2203 i, V \u2264 Us i).op \u22d9 principalsKanExtension F)\nm : S.pt \u27f6 ((principalsKanExtension F).mapCone (opensLeCoverCocone Us).op).pt\nhm\u271d :\n  \u2200 (j : (FullSubcategory fun V \u21a6 \u2203 i, V \u2264 Us i)\u1d52\u1d56),\n    m \u226b ((principalsKanExtension F).mapCone (opensLeCoverCocone Us).op).\u03c0.app j = S.\u03c0.app j\nleft\u271d : Discrete PUnit.{1}\nx : \u2191X\nf : (fromPUnit (Opposite.op (iSup Us))).obj left\u271d \u27f6 (principals \u2191X).obj x\nhm :\n  m \u226b\n      ((principalsKanExtension F).mapCone (opensLeCoverCocone Us).op).\u03c0.app\n        (Opposite.op { obj := principalOpen x, property := \u22ef }) =\n    S.\u03c0.app (Opposite.op { obj := principalOpen x, property := \u22ef })\n\u22a2 m \u226b\n      limit.\u03c0 (StructuredArrow.proj (Opposite.op (opensLeCoverCocone Us).pt) (principals \u2191X) \u22d9 F)\n        ((StructuredArrow.map ((opensLeCoverCocone Us).\u03b9.app { obj := principalOpen x, property := \u22ef }).op).obj\n          { left := { as := PUnit.unit }, right := x, hom := \ud835\udfd9 (Opposite.op (principalOpen x)) }) =\n    m \u226b limit.\u03c0 (generator (iSup Us) \u22d9 F) { left := left\u271d, right := x, hom := f }",["congr","aesop","tauto"]],["Topology/Sheaves/Alexandrov.lean",202,"X : Type v\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : Preorder X\ninst\u271d\u00b3 : Topology.IsUpperSet X\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasLimits C\nF : X \u2964 C\nP : (Opens X)\u1d52\u1d56 \u2964 C\n\u03b7 : principals X \u22d9 P \u27f6 F\ninst\u271d : P.IsRightKanExtension \u03b7\n\u03b3 : principals X \u22d9 principalsKanExtension F \u27f6 F := (principals X).pointwiseRightKanExtensionCounit F\nx\u271d : (principalsKanExtension F).IsRightKanExtension \u03b3 := inferInstance\n\u22a2 (principalsKanExtension F).IsRightKanExtension ?m.88450",["assumption","aesop","congr","gcongr","tauto"]],["MeasureTheory/OuterMeasure/Basic.lean",184,"\u03b1 : Type u_1\nm : OuterMeasure \u03b1\ns : \u2115 \u2192 Set \u03b1\nh_mono : \u2200 (n : \u2115), s n \u2286 s (n + 1)\nh0 : \u2211' (k : \u2115), m (s (k + 1) \\ s k) \u2260 \u22a4\nn : \u2115\nh' : Monotone s\nx : \u03b1\nthis : \u2203 i, x \u2208 s i\nj : \u2115\nhj : x \u2208 s j\nhlt : \u2200 m < j, x \u2209 s m\nhnj : n < j\n\u22a2 j - (n + 1) + n + 1 = j",["omega","tauto","infer_instance"]],["LinearAlgebra/Projectivization/Subspace.lean",94,"case of.a\nK : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nA : Set (\u2119 K V)\nB : Subspace K V\nh : A \u2264 \u2191B\nx x\u271d : \u2119 K V\nhx\u271d : x\u271d \u2208 A\n\u22a2 x\u271d \u2208 A",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Lie/InvariantForm.lean",174,"case a.h\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra K L\ninst\u271d : Module.Finite K L\n\u03a6 : LinearMap.BilinForm K L\nh\u03a6_nondeg : \u03a6.Nondegenerate\nh\u03a6_inv : LinearMap.BilinForm.lieInvariant L \u03a6\nh\u03a6_refl : \u03a6.IsRefl\nhL : \u2200 (I : LieIdeal K L), IsAtom I \u2192 \u00acIsLieAbelian \u21a5I\nI : LieIdeal K L\nhI : \u00acI = \u22a5\nJ : LieIdeal K L\nhJ : IsAtom J\nhJI : J \u2264 I\nJ' : LieSubmodule K L L := orthogonal \u03a6 h\u03a6_inv J\nthis : I \u2264 J \u2294 J' \u2293 I\n\u22a2 \u2200 (a : LieIdeal K L), IsAtom a \u2192 a \u2264 J' \u2192 a \u2264 I \u2192 IsAtom a \u2227 a \u2264 I",["tauto","aesop"]],["Combinatorics/SimpleGraph/Operations.lean",203,"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : DecidableEq V\n\u22a2 Fintype \u2191(fromEdgeSet {s(s, t)}).edgeSet",["infer_instance","omega","tauto"]],["Combinatorics/SimpleGraph/Operations.lean",153,"V : Type u_1\ns t v w : V\n\u22a2 \u00acv = w \u2192 (v = s \u2227 w = t \u2228 v = t \u2227 w = s \u2194 s = v \u2227 t = w \u2228 s = w \u2227 t = v)",["tauto","aesop"]],["Analysis/SpecialFunctions/Log/NegMulLog.lean",108,"\u22a2 Disjoint (\ud835\udcdd (deriv (fun x \u21a6 x * log x) 0)) Filter.atBot",["simp","aesop","norm_num"]],["Combinatorics/Derangements/Basic.lean",58,"case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf : Perm (Subtype p)\nhf : f \u2208 derangements (Subtype p)\na : \u03b1\nha : p a\nhfa : \u2191(f \u27e8a, ha\u27e9) = a\n\u22a2 \u2191(f \u27e8a, ha\u27e9) = \u2191\u27e8a, ha\u27e9",["assumption","aesop","congr","gcongr","tauto"]],["Combinatorics/Additive/SmallTripling.lean",184,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nm : \u2115\nhm : 3 \u2264 m\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\nhAsymm : A\u207b\u00b9 = A\nthis : \u2200 (\u03b5 : \u2124), |\u03b5| = 1 \u2192 A ^ \u03b5 = A\n\u22a2 Fin m \u2192 |1| = 1",["simp","aesop","tauto","norm_num"]],["Combinatorics/Additive/SmallTripling.lean",182,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nm : \u2115\nhm : 3 \u2264 m\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\nhAsymm : A\u207b\u00b9 = A\nthis : \u2200 (\u03b5 : \u2124), |\u03b5| = 1 \u2192 A ^ \u03b5 = A\n\u22a2 \u2191(#(A ^ m)) = \u2191(#(List.map (fun i \u21a6 A ^ 1) (finRange m)).prod)",["simp","aesop","norm_num"]],["Probability/Kernel/Composition/Comp.lean",202,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b7 : Kernel \u03b2 \u03b3\ninst\u271d\u00b9 : IsSFiniteKernel \u03b7\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel (Kernel.sum fun i \u21a6 Kernel.sum fun i_1 \u21a6 \u03b7.seq i \u2218\u2096 \u03ba.seq i_1)",["infer_instance","omega","aesop","tauto"]],["Probability/Kernel/Composition/Comp.lean",140,"case h.h\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\na : \u03b1\ns : Set (\u03b1 \u00d7 \u03b1)\nhs : MeasurableSet s\n\u22a2 s.indicator 1 (a, a).swap = s.indicator 1 (a, a)",["congr","aesop","tauto","abel","norm_num","simp"]],["MeasureTheory/Covering/DensityTheorem.lean",121,"\u03b1 : Type u_1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : IsUnifLocDoublingMeasure \u03bc\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nK : \u211d\nx : \u03b1\n\u03b9 : Type u_2\nl : Filter \u03b9\nw : \u03b9 \u2192 \u03b1\n\u03b4 : \u03b9 \u2192 \u211d\nxmem : \u2200\u1da0 (j : \u03b9) in l, x \u2208 closedBall (w j) (K * \u03b4 j)\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh : l.NeBot\nhK : 0 \u2264 K\n\u03b4pos : \u2200\u1da0 (i : \u03b9) in l, \u03b4 i \u2208 Ioi 0\n\u03b4lim : Tendsto \u03b4 l (\ud835\udcdd 0)\n\u22a2 0 < K + 1",["linarith","ring","omega","decide","aesop","congr","positivity","gcongr","tauto","infer_instance","assumption","abel","norm_num","contradiction","simp","fun_prop"]],["Analysis/Convex/Body.lean",60,"case mk.mk\nV : Type u_1\ninst\u271d\u00b2 : TopologicalSpace V\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \u211d V\ncarrier\u271d\u00b9 : Set V\nconvex'\u271d\u00b9 : Convex \u211d carrier\u271d\u00b9\nisCompact'\u271d\u00b9 : IsCompact carrier\u271d\u00b9\nnonempty'\u271d\u00b9 : carrier\u271d\u00b9.Nonempty\ncarrier\u271d : Set V\nconvex'\u271d : Convex \u211d carrier\u271d\nisCompact'\u271d : IsCompact carrier\u271d\nnonempty'\u271d : carrier\u271d.Nonempty\nh :\n  { carrier := carrier\u271d\u00b9, convex' := convex'\u271d\u00b9, isCompact' := isCompact'\u271d\u00b9, nonempty' := nonempty'\u271d\u00b9 }.carrier =\n    { carrier := carrier\u271d, convex' := convex'\u271d, isCompact' := isCompact'\u271d, nonempty' := nonempty'\u271d }.carrier\n\u22a2 { carrier := carrier\u271d\u00b9, convex' := convex'\u271d\u00b9, isCompact' := isCompact'\u271d\u00b9, nonempty' := nonempty'\u271d\u00b9 } =\n    { carrier := carrier\u271d, convex' := convex'\u271d, isCompact' := isCompact'\u271d, nonempty' := nonempty'\u271d }",["congr","aesop"]],["Analysis/Convex/Body.lean",218,"V : Type u_1\ninst\u271d\u00b2 : SeminormedAddCommGroup V\ninst\u271d\u00b9 : NormedSpace \u211d V\ninst\u271d : T2Space V\nu : \u2115 \u2192 \u211d\u22650\nK : ConvexBody V\nh_zero : 0 \u2208 K\nhu : Tendsto u atTop (\ud835\udcdd 0)\nx : V\nh : x \u2208 \u2191K\nn : \u2115\n\u22a2 0 \u2264 \u2191(u n)",["positivity","aesop","norm_num","simp"]],["Combinatorics/Digraph/Basic.lean",71,"case h.Adj.h.h.a\nV : Type u_1\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype V\nG : Digraph V\nv w : V\n\u22a2 (Digraph.mk' fun v w \u21a6 decide (G.Adj v w)).Adj v w \u2194 G.Adj v w",["simp","aesop"]],["Combinatorics/Digraph/Basic.lean",182,"\u03b9 : Sort u_1\nV : Type u_2\nG\u271d : Digraph V\na b : V\nG : Digraph V\nv w : V\nx\u271d : \u22a4.Adj v w\n\u22a2 (G \u2294 G\u1d9c).Adj v w",["tauto"]],["Algebra/Regular/SMul.lean",125,"R : Type u_1\nM : Type u_3\ninst\u271d\u00b9 : Monoid R\ninst\u271d : MulAction R M\na b : M\nab : a = b\n\u22a2 a = b",["assumption","aesop","congr","gcongr"]],["Topology/MetricSpace/Defs.lean",45,"case mk.mk.e_toPseudoMetricSpace.h\n\u03b1 : Type u_3\ntoPseudoMetricSpace\u271d\u00b9 : PseudoMetricSpace \u03b1\neq_of_dist_eq_zero\u271d\u00b9 : \u2200 {x y : \u03b1}, dist x y = 0 \u2192 x = y\ntoPseudoMetricSpace\u271d : PseudoMetricSpace \u03b1\neq_of_dist_eq_zero\u271d : \u2200 {x y : \u03b1}, dist x y = 0 \u2192 x = y\nh : PseudoMetricSpace.toDist = PseudoMetricSpace.toDist\n\u22a2 PseudoMetricSpace.toDist = PseudoMetricSpace.toDist",["assumption","aesop","congr","gcongr","tauto"]],["AlgebraicTopology/SimplicialSet/Horn.lean",63,"n : \u2115\ni : Fin (n + 3)\nj : \u0394[n + 2] _\u298b0\u298c\nS : Finset (Fin (n + 3)) := {i, j 0}\nhS : S = Finset.univ\nthis\u271d : n + 3 \u2264 {i, j 0}.card\nthis : n + 3 \u2264 2\n\u22a2 False",["omega","aesop","linarith","tauto","contradiction"]],["AlgebraicTopology/SimplicialSet/Horn.lean",138,"case refine_2.inl\n\u22a2 \u2200 {i : Fin (2 + 1)} (j : Fin 2), 0 < \u2191i \u2192 \u2191i < 2 \u2192 #{i, j.castSucc, j.succ} \u2264 2",["decide"]],["Logic/Hydra.lean",139,"\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na a\u2081 a\u2082 : \u03b1\nh\u2081 : r a\u2081 a\nh\u2082 : r a\u2082 a\n\u22a2 r a\u2081 a \u2227 r a\u2082 a",["tauto","aesop"]],["Order/KonigLemma.lean",133,"\u03b1 : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : Finite (\u03b1 0)\ninst\u271d : \u2200 (i : \u2115), Nonempty (\u03b1 i)\n\u03c0 : {i j : \u2115} \u2192 i \u2264 j \u2192 \u03b1 j \u2192 \u03b1 i\n\u03c0_refl : \u2200 \u2983i : \u2115\u2984 (a : \u03b1 i), \u03c0 \u22ef a = a\n\u03c0_trans : \u2200 \u2983i j k : \u2115\u2984 (hij : i \u2264 j) (hjk : j \u2264 k) (a : \u03b1 k), \u03c0 hij (\u03c0 hjk a) = \u03c0 \u22ef a\nhfin : \u2200 (i : \u2115) (a : \u03b1 i), {b | \u03c0 \u22ef b = a}.Finite\n\u03b1s : Type u_1 := (i : \u2115) \u00d7 \u03b1 i\nx\u271d : PartialOrder \u03b1s := PartialOrder.mk \u22ef\ni : \u2115\nb : \u03b1 (i + 1)\nh : i \u2264 i + 1\nhij : i \u2264 i\nhji : i \u2264 i + 1\nhcb : \u03c0 hij (\u03c0 hji b) = \u03c0 h b\nhne : \u00ac\u27e8i, \u03c0 hji b\u27e9 = \u27e8i, \u03c0 h b\u27e9\n\u22a2 False",["contradiction","aesop","tauto"]],["NumberTheory/ADEInequality.lean",150,"p q r : \u2115+\nhpq : p \u2264 q\nhqr : q \u2264 r\nH : 1 < sumInv {p, q, r}\n\u22a2 0 < 3",["norm_num","decide","aesop","congr","positivity","tauto","simp"]],["NumberTheory/ADEInequality.lean",172,"q r : \u2115+\nhqr : q \u2264 r\nH : 1 < sumInv {2, q, r}\n\u22a2 0 < 4",["norm_num","decide","aesop","congr","positivity","tauto","simp"]],["NumberTheory/ADEInequality.lean",189,"r : \u2115+\nH : 1 < sumInv {2, 3, r}\n\u22a2 0 < 6",["norm_num","decide","aesop","congr","positivity","tauto","simp"]],["Data/Matroid/Loop.lean",159,"\u03b1 : Type u_1\nM : Matroid \u03b1\ne : \u03b1\nR : Set \u03b1\n\u22a2 e \u2208 M.closure \u2205 \u2227 e \u2208 R \u2228 e \u2208 R \u2227 e \u2209 M.E \u2194 e \u2208 R \u2227 (e \u2208 M.loops \u2228 e \u2209 M.E)",["tauto","aesop"]],["Data/Nat/Sqrt.lean",152,"n : \u2115\nh : n.sqrt = 1\n\u22a2 1 < 2",["decide","omega","simp"]],["Analysis/Normed/Affine/Simplex.lean",184,"R : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : PseudoMetricSpace P\ninst\u271d\u00b9 : Module R V\ninst\u271d : NormedAddTorsor V P\nt : Triangle R P\n\u22a2 1 \u2260 2",["decide","omega","aesop","tauto","infer_instance","simp"]],["Algebra/Group/Action/Equidecomp.lean",101,"X : Type u_1\nG : Type u_2\ninst\u271d : SMul G X\ntoPartialEquiv\u271d : PartialEquiv X X\nw\u271d : Finset G\nh\u271d : IsDecompOn (\u2191toPartialEquiv\u271d) toPartialEquiv\u271d.source w\u271d\na\u2082\u271d : Equidecomp X G\na\u271d : { toPartialEquiv := toPartialEquiv\u271d, isDecompOn' := \u22ef }.toPartialEquiv = a\u2082\u271d.toPartialEquiv\n\u22a2 { toPartialEquiv := toPartialEquiv\u271d, isDecompOn' := \u22ef } = a\u2082\u271d",["congr","aesop"]],["GroupTheory/Coxeter/Matrix.lean",159,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn m : \u2115\n\u22a2 \u2200 (i i' : Fin 2), i \u2260 i' \u2192 Matrix.of (fun i j \u21a6 if i = j then 1 else m + 2) i i' \u2260 1",["simp","aesop"]],["GroupTheory/Coxeter/Matrix.lean",158,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn m : \u2115\n\u22a2 \u2200 (i : Fin 2), Matrix.of (fun i j \u21a6 if i = j then 1 else m + 2) i i = 1",["simp","omega","aesop"]],["GroupTheory/Coxeter/Matrix.lean",107,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn : \u2115\n\u22a2 \u2200 (i : Fin n), Matrix.of (fun i j \u21a6 if i = j then 1 else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2) i i = 1",["simp","aesop"]],["Algebra/Polynomial/Sequence.lean",74,"R : Type u_1\ninst\u271d : Semiring R\nS : Sequence R\nx\u271d\u00b9 x\u271d : \u2115\n\u22a2 x\u271d\u00b9 < x\u271d \u2192 (natDegree \u2218 \u2191S) x\u271d\u00b9 < (natDegree \u2218 \u2191S) x\u271d",["simp","aesop","norm_num"]],["Analysis/Normed/Ring/Lemmas.lean",202,"case h.e'_5\nthis : Isometry (Prod.map toReal toReal)\n\u22a2 2 = 1 * 1 + 1 * 1",["norm_num","ring","omega","tauto","infer_instance"]],["Algebra/Homology/Double.lean",183,"C : Type u_1\ninst\u271d\u00b3 : Category.{?u.38309, u_1} C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasZeroObject C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\ni : \u03b9\ninst\u271d : DecidableEq \u03b9\nhi : \u2200 (j : \u03b9), \u00acc.Rel i j\nX : C\n\u22a2 \u2200 {Y Y' : HomologicalComplex C c} (g : Y \u27f6 Y') (f : (single C c i).obj X \u27f6 Y),\n    (fun {K} \u21a6\n          { toFun := fun g \u21a6 (singleObjXSelf c i X).inv \u226b g.f i, invFun := fun f \u21a6 mkHomFromSingle f \u22ef, left_inv := \u22ef,\n            right_inv := \u22ef })\n        (f \u226b g) =\n      (eval C c i \u22d9 coyoneda.obj (op X)).map g\n        ((fun {K} \u21a6\n            { toFun := fun g \u21a6 (singleObjXSelf c i X).inv \u226b g.f i, invFun := fun f \u21a6 mkHomFromSingle f \u22ef, left_inv := \u22ef,\n              right_inv := \u22ef })\n          f)",["simp","aesop"]],["Algebra/Homology/Double.lean",165,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.30093, u_1} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\nX\u2080 X\u2081 : C\nf : X\u2080 \u27f6 X\u2081\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\ni\u2080 i\u2081 : \u03b9\nhi\u2080\u2081 : c.Rel i\u2080 i\u2081\nh : i\u2080 \u2260 i\u2081\nX : C\nY\u271d Y'\u271d : HomologicalComplex C c\nx\u271d\u00b9 : Y\u271d \u27f6 Y'\u271d\nx\u271d : double (\ud835\udfd9 X) hi\u2080\u2081 \u27f6 Y\u271d\n\u22a2 (fun {K} \u21a6\n        { toFun := fun g \u21a6 (doubleXIso\u2080 (\ud835\udfd9 X) hi\u2080\u2081).inv \u226b g.f i\u2080,\n          invFun := fun \u03c6\u2080 \u21a6 mkHomFromDouble hi\u2080\u2081 h \u03c6\u2080 (\u03c6\u2080 \u226b K.d i\u2080 i\u2081) \u22ef \u22ef, left_inv := \u22ef, right_inv := \u22ef })\n      (x\u271d \u226b x\u271d\u00b9) =\n    (eval C c i\u2080 \u22d9 coyoneda.obj (op X)).map x\u271d\u00b9\n      ((fun {K} \u21a6\n          { toFun := fun g \u21a6 (doubleXIso\u2080 (\ud835\udfd9 X) hi\u2080\u2081).inv \u226b g.f i\u2080,\n            invFun := fun \u03c6\u2080 \u21a6 mkHomFromDouble hi\u2080\u2081 h \u03c6\u2080 (\u03c6\u2080 \u226b K.d i\u2080 i\u2081) \u22ef \u22ef, left_inv := \u22ef, right_inv := \u22ef })\n        x\u271d)",["simp","aesop"]],["Algebra/Homology/Double.lean",79,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\nX\u2080 X\u2081 : C\nf : X\u2080 \u27f6 X\u2081\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\ni\u2080 i\u2081 : \u03b9\nhi\u2080\u2081 : c.Rel i\u2080 i\u2081\na b : \u03b9\nha : a \u2260 i\u2080\n\u22a2 \u00ac(a = i\u2080 \u2227 b = i\u2081 \u2227 i\u2080 \u2260 i\u2081)",["tauto","aesop"]],["Algebra/Homology/Double.lean",83,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\nX\u2080 X\u2081 : C\nf : X\u2080 \u27f6 X\u2081\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\ni\u2080 i\u2081 : \u03b9\nhi\u2080\u2081 : c.Rel i\u2080 i\u2081\na b : \u03b9\nhb : b \u2260 i\u2081\n\u22a2 \u00ac(a = i\u2080 \u2227 b = i\u2081 \u2227 i\u2080 \u2260 i\u2081)",["tauto","aesop"]],["Combinatorics/SimpleGraph/Regularity/Lemma.lean",104,"case intro.intro.intro.intro.refine_1.bc.hab\n\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nl : \u2115\nh\u03b5 : 0 < \u03b5\nhl : l \u2264 Fintype.card \u03b1\nh\u03b1 : bound \u03b5 l \u2264 Fintype.card \u03b1\nt : \u2115 := initialBound \u03b5 l\nht\u03b1 : t \u2264 #univ\ndum : Finpartition univ\nhdum\u2081 : dum.IsEquipartition\nhdum\u2082 : #dum.parts = initialBound \u03b5 l\nh\u03b5\u2081 : \u03b5 \u2264 1\nthis : Nonempty \u03b1\nh :\n  \u2200 (i : \u2115),\n    \u2203 P,\n      P.IsEquipartition \u2227 t \u2264 #P.parts \u2227 #P.parts \u2264 stepBound^[i] t \u2227 (P.IsUniform G \u03b5 \u2228 \u03b5 ^ 5 / 4 * \u2191i \u2264 \u2191(P.energy G))\nP : Finpartition univ\nhP\u2081 : P.IsEquipartition\nhP\u2082 : t \u2264 #P.parts\nhP\u2083 : #P.parts \u2264 stepBound^[\u230a4 / \u03b5 ^ 5\u230b\u208a + 1] t\nhP\u2084 : P.IsUniform G \u03b5 \u2228 \u03b5 ^ 5 / 4 * \u2191(\u230a4 / \u03b5 ^ 5\u230b\u208a + 1) \u2264 \u2191(P.energy G)\n\u22a2 4 \u2264 16",["norm_num","omega","decide","aesop","linarith","simp"]],["Combinatorics/SimpleGraph/Regularity/Lemma.lean",107,"\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nl : \u2115\nh\u03b5 : 0 < \u03b5\nhl : l \u2264 Fintype.card \u03b1\nh\u03b1 : bound \u03b5 l \u2264 Fintype.card \u03b1\nt : \u2115 := initialBound \u03b5 l\nht\u03b1 : t \u2264 #univ\ndum : Finpartition univ\nhdum\u2081 : dum.IsEquipartition\nhdum\u2082 : #dum.parts = initialBound \u03b5 l\nh\u03b5\u2081 : \u03b5 \u2264 1\nthis : Nonempty \u03b1\nh :\n  \u2200 (i : \u2115),\n    \u2203 P,\n      P.IsEquipartition \u2227 t \u2264 #P.parts \u2227 #P.parts \u2264 stepBound^[i] t \u2227 (P.IsUniform G \u03b5 \u2228 \u03b5 ^ 5 / 4 * \u2191i \u2264 \u2191(P.energy G))\nP : Finpartition univ\nhP\u2081 : P.IsEquipartition\nhP\u2082 : t \u2264 #P.parts\nhP\u2083 : #P.parts \u2264 stepBound^[\u230a4 / \u03b5 ^ 5\u230b\u208a + 1] t\nhP\u2084 : P.IsUniform G \u03b5 \u2228 \u03b5 ^ 5 / 4 * \u2191(\u230a4 / \u03b5 ^ 5\u230b\u208a + 1) \u2264 \u2191(P.energy G)\nhPenergy : \u03b5 ^ 5 / 4 * \u2191(\u230a4 / \u03b5 ^ 5\u230b\u208a + 1) \u2264 \u2191(P.energy G)\n\u22a2 1 = 4 / 4",["norm_num","ring","aesop","linarith","simp"]],["Data/Nat/Cast/Defs.lean",198,"case h\nR : Type u_1\ninst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 = 2",["decide","omega","congr","infer_instance","simp"]],["Data/Nat/Cast/Defs.lean",203,"case h\nR : Type u_1\ninst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 + 1 = 3",["decide","omega","congr","infer_instance","simp"]],["Data/Nat/Cast/Defs.lean",209,"case h\nR : Type u_1\ninst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 + 1 + 1 = 4",["decide","omega","congr","infer_instance","simp"]],["Data/Finset/Density.lean",86,"\u03b1 : Type u_2\ninst\u271d : Fintype \u03b1\ns t : Finset \u03b1\nh : s \u2286 t\n\u22a2 0 \u2264 \u2191(Fintype.card \u03b1)",["positivity","aesop","norm_num","simp"]],["Algebra/Polynomial/Inductions.lean",118,"R : Type u\ninst\u271d : Semiring R\np : R[X]\nhp0 : p \u2260 0\nthis\u271d : Nontrivial R\nh : \u00acp.degree \u2264 0\nhXp0 : p.divX \u2260 0\nthis : p.divX.leadingCoeff * X.leadingCoeff \u2260 0\n\u22a2 0 < 1",["decide","aesop","positivity","norm_num","simp"]],["MeasureTheory/Measure/Comap.lean",101,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u03bc : Measure \u03b2\nhfi : Injective f\nhf : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 NullMeasurableSet (f '' s) \u03bc\ns t : Set \u03b1\nhst : (comap f \u03bc) {a | \u00acs a = t a} = 0\nx : \u03b1\n\u22a2 \u00ac(s x \u2194 t x) \u2194 x \u2208 s \u2227 x \u2209 t \u2228 x \u2208 t \u2227 x \u2209 s",["tauto"]],["MeasureTheory/Measure/Comap.lean",105,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u03bc : Measure \u03b2\nhfi : Injective f\nhf : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 NullMeasurableSet (f '' s) \u03bc\ns t : Set \u03b1\nhst : (comap f \u03bc) {a | \u00acs a = t a} = 0\nh_eq_\u03b1 : {a | \u00acs a = t a} = s \\ t \u222a t \\ s\nx : \u03b2\n\u22a2 \u00ac((f '' s) x \u2194 (f '' t) x) \u2194 x \u2208 f '' s \u2227 x \u2209 f '' t \u2228 x \u2208 f '' t \u2227 x \u2209 f '' s",["tauto"]],["Analysis/NormedSpace/ENormedSpace.lean",64,"case mk.mk\n\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ntoFun\u271d\u00b9 : V \u2192 \u211d\u22650\u221e\neq_zero'\u271d\u00b9 : \u2200 (x : V), toFun\u271d\u00b9 x = 0 \u2192 x = 0\nmap_add_le'\u271d\u00b9 : \u2200 (x y : V), toFun\u271d\u00b9 (x + y) \u2264 toFun\u271d\u00b9 x + toFun\u271d\u00b9 y\nmap_smul_le'\u271d\u00b9 : \u2200 (c : \ud835\udd5c) (x : V), toFun\u271d\u00b9 (c \u2022 x) \u2264 \u2191\u2016c\u2016\u208a * toFun\u271d\u00b9 x\ntoFun\u271d : V \u2192 \u211d\u22650\u221e\neq_zero'\u271d : \u2200 (x : V), toFun\u271d x = 0 \u2192 x = 0\nmap_add_le'\u271d : \u2200 (x y : V), toFun\u271d (x + y) \u2264 toFun\u271d x + toFun\u271d y\nmap_smul_le'\u271d : \u2200 (c : \ud835\udd5c) (x : V), toFun\u271d (c \u2022 x) \u2264 \u2191\u2016c\u2016\u208a * toFun\u271d x\nh :\n  \u2191{ toFun := toFun\u271d\u00b9, eq_zero' := eq_zero'\u271d\u00b9, map_add_le' := map_add_le'\u271d\u00b9, map_smul_le' := map_smul_le'\u271d\u00b9 } =\n    \u2191{ toFun := toFun\u271d, eq_zero' := eq_zero'\u271d, map_add_le' := map_add_le'\u271d, map_smul_le' := map_smul_le'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, eq_zero' := eq_zero'\u271d\u00b9, map_add_le' := map_add_le'\u271d\u00b9, map_smul_le' := map_smul_le'\u271d\u00b9 } =\n    { toFun := toFun\u271d, eq_zero' := eq_zero'\u271d, map_add_le' := map_add_le'\u271d, map_smul_le' := map_smul_le'\u271d }",["congr","aesop"]],["Analysis/NormedSpace/ENormedSpace.lean",90,"\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ne : ENormedSpace \ud835\udd5c V\n\u22a2 \u2191\u20160\u2016\u208a * \u2191e 0 = 0",["norm_num","aesop","simp"]],["Analysis/NormedSpace/ENormedSpace.lean",131,"\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ne : ENormedSpace \ud835\udd5c V\nc : \ud835\udd5c\nx : V\nhx : \u00acx = 0\nhcx : c = 0 \u2228 x = 0\n\u22a2 c = 0",["tauto","aesop"]],["Order/Fin/Tuple.lean",183,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nn\u271d\u00b9 : \u2115\nf : Fin (n\u271d\u00b9 + 1) \u2192 \u03b1\na : \u03b1\nn\u271d n m : \u2115\nh : n \u2264 m\nx\u271d : { i // \u2191i < n }\n\u22a2 (fun i \u21a6 \u27e8castLE h i, \u22ef\u27e9) ((fun i \u21a6 \u27e8\u2191\u2191i, \u22ef\u27e9) x\u271d) = x\u271d",["simp","aesop","congr","tauto"]],["Order/Fin/Tuple.lean",153,"case h.h.h\nn : \u2115\n\u03b1 : Type u_2\ninst\u271d : LE \u03b1\nx\u271d\u00b9 : \u03b1 \u00d7 (Fin n \u2192 \u03b1)\nx\u271d : Fin (n + 1)\n\u22a2 (insertNthOrderIso (fun x \u21a6 \u03b1) (last n)) x\u271d\u00b9 x\u271d = (snocOrderIso fun x \u21a6 \u03b1) x\u271d\u00b9 x\u271d",["simp","aesop"]],["Order/Fin/Tuple.lean",99,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nn : \u2115\nf : Fin (n + 1) \u2192 \u03b1\na : \u03b1\n\u22a2 Monotone ![1, 2, 2, 3]",["decide","aesop","simp"]],["LinearAlgebra/BilinearForm/TensorProduct.lean",80,"R : Type uR\nA : Type uA\nM\u2081 : Type uM\u2081\nM\u2082 : Type uM\u2082\nN\u2081 : Type uN\u2081\nN\u2082 : Type uN\u2082\ninst\u271d\u00b9\u2076 : CommSemiring R\ninst\u271d\u00b9\u2075 : CommSemiring A\ninst\u271d\u00b9\u2074 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u00b2 : AddCommMonoid N\u2081\ninst\u271d\u00b9\u00b9 : AddCommMonoid N\u2082\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : Module R M\u2081\ninst\u271d\u2078 : Module A M\u2081\ninst\u271d\u2077 : Module R N\u2081\ninst\u271d\u2076 : Module A N\u2081\ninst\u271d\u2075 : SMulCommClass R A M\u2081\ninst\u271d\u2074 : IsScalarTower R A M\u2081\ninst\u271d\u00b3 : SMulCommClass R A N\u2081\ninst\u271d\u00b2 : IsScalarTower R A N\u2081\ninst\u271d\u00b9 : Module R M\u2082\ninst\u271d : Module R N\u2082\nB\u2081 : BilinMap A M\u2081 N\u2081\nB\u2082 : BilinMap R M\u2082 N\u2082\nhB\u2081 : \u2200 (x y : M\u2081), (B\u2081 x) y = (B\u2081 y) x\nhB\u2082 : \u2200 (x y : M\u2082), (B\u2082 x) y = (B\u2082 y) x\n\u22a2 B\u2081.tmul B\u2082 = flip (B\u2081.tmul B\u2082)",["aesop","congr"]],["InformationTheory/KullbackLeibler/KLFun.lean",85,"case h.e'_9\nx : \u211d\nhx : x \u2260 0\n\u22a2 log x = log x + 1 + 0 - 1",["ring","aesop","linarith","abel","norm_num","simp"]],["AlgebraicTopology/DoldKan/Homotopies.lean",94,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.2653, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq n m : \u2115\nhnm : c.Rel m n\n\u22a2 X _\u298bn + 1\u298c = K[X].X m",["congr","aesop","tauto"]],["AlgebraicTopology/DoldKan/Homotopies.lean",110,"case neg\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq n a m : \u2115\nha : n = a + q\nhnm : c.Rel m n\nh\u271d : \u00acn < q\nh' : n - q = a\n\u22a2 ((-1) ^ (n - q) \u2022 X.\u03c3 \u27e8n - q, \u22ef\u27e9) \u226b eqToHom \u22ef = ((-1) ^ a \u2022 X.\u03c3 \u27e8a, \u22ef\u27e9) \u226b eqToHom \u22ef",["congr"]],["AlgebraicTopology/DoldKan/Homotopies.lean",180,"C : Type u_1\ninst\u271d\u2074 : Category.{u_4, u_1} C\ninst\u271d\u00b3 : Preadditive C\nD : Type u_2\ninst\u271d\u00b2 : Category.{u_3, u_2} D\ninst\u271d\u00b9 : Preadditive D\nG : C \u2964 D\ninst\u271d : G.Additive\nX : SimplicialObject C\nq n : \u2115\neq : G.map ((nullHomotopicMap' (h\u03c3' q)).f n) = (nullHomotopicMap' fun i j hij \u21a6 h\u03c3' q i j hij).f n\nh : ((whiskering C D).obj G \u22d9 alternatingFaceMapComplex D).obj X =\n  (alternatingFaceMapComplex C \u22d9 G.mapHomologicalComplex (ComplexShape.down \u2115)).obj X :=\n  Eq.symm (Functor.congr_obj (map_alternatingFaceMapComplex G) X)\n\u22a2 (nullHomotopicMap' (h\u03c3' q)).f n = (nullHomotopicMap' fun i j hij \u21a6 h\u03c3' q i j hij).f n",["congr"]],["Order/Partition/Equipartition.lean",59,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nP : Finpartition s\nhP : P.IsEquipartition\nht : t \u2208 P.parts\na : #t = #s / #P.parts \u2228 #t = #s / #P.parts + 1\nb : \u00ac(#t = #s / #P.parts \u2227 #t = #s / #P.parts + 1)\n\u22a2 #t = #s / #P.parts \u2194 #t \u2260 #s / #P.parts + 1",["tauto","omega","aesop"]],["Data/Matrix/PEquiv.lean",84,"case a\nm : Type u_3\nn : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243. n\ni\u271d : n\nj\u271d : m\n\u22a2 (if i\u271d \u2208 f j\u271d then 1 else 0) = of (fun x y \u21a6 if x \u2208 f y then 1 else 0) i\u271d j\u271d",["congr","aesop","tauto","simp"]],["Combinatorics/Quiver/Symmetric.lean",63,"case mpr\nV : Type u_2\ninst\u271d : Quiver V\nh\u271d : HasInvolutiveReverse V\na b : V\nf g : a \u27f6 b\nh : f = g\n\u22a2 reverse f = reverse g",["congr","tauto"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Integral.lean",74,"X : Type u_1\n\ud835\udd5c : Type u_2\nA : Type u_3\np : A \u2192 Prop\ninst\u271d\u00b9\u2070 : RCLike \ud835\udd5c\ninst\u271d\u2079 : MeasurableSpace X\n\u03bc : Measure X\ninst\u271d\u2078 : NormedRing A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : NormedAlgebra \ud835\udd5c A\ninst\u271d\u2075 : NormedAlgebra \u211d A\ninst\u271d\u2074 : CompleteSpace A\ninst\u271d\u00b3 : ContinuousFunctionalCalculus \ud835\udd5c p\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : OpensMeasurableSpace X\nf : X \u2192 \ud835\udd5c \u2192 \ud835\udd5c\nbound : X \u2192 \u211d\na : A\ninst\u271d : SecondCountableTopologyEither X C(\u2191(spectrum \ud835\udd5c a), \ud835\udd5c)\nhf\u2081 : \u2200 (x : X), ContinuousOn (f x) (spectrum \ud835\udd5c a)\nhf\u2082 : Continuous fun x \u21a6 { toFun := (spectrum \ud835\udd5c a).restrict (f x), continuous_toFun := \u22ef }\nhbound : \u2200 (x : X), \u2200 z \u2208 spectrum \ud835\udd5c a, \u2016f x z\u2016 \u2264 \u2016bound x\u2016\nhbound_finite_integral : HasFiniteIntegral bound \u03bc\nha : autoParam (p a) _auto\u271d\nfc : X \u2192 C(\u2191(spectrum \ud835\udd5c a), \ud835\udd5c) := fun x \u21a6 { toFun := (spectrum \ud835\udd5c a).restrict (f x), continuous_toFun := \u22ef }\nfc_integrable : Integrable fc \u03bc\nh_int_fc : ((spectrum \ud835\udd5c a).restrict fun x \u21a6 \u222b (x_1 : X), f x_1 x \u2202\u03bc) = \u21d1(\u222b (x : X), fc x \u2202\u03bc)\nhcont\u2082 : ContinuousOn (fun r \u21a6 \u222b (x : X), f x r \u2202\u03bc) (spectrum \ud835\udd5c a)\n\u22a2 (cfcHom ha) { toFun := (spectrum \ud835\udd5c a).restrict fun r \u21a6 \u222b (x : X), f x r \u2202\u03bc, continuous_toFun := \u22ef } =\n    (cfcHom ha) (\u222b (x : X), fc x \u2202\u03bc)",["congr","aesop"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Integral.lean",130,"X : Type u_1\n\ud835\udd5c : Type u_2\nA : Type u_3\np : A \u2192 Prop\ninst\u271d\u00b9\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9\u00b9 : MeasurableSpace X\n\u03bc : Measure X\ninst\u271d\u00b9\u2070 : NonUnitalNormedRing A\ninst\u271d\u2079 : StarRing A\ninst\u271d\u2078 : CompleteSpace A\ninst\u271d\u2077 : NormedSpace \ud835\udd5c A\ninst\u271d\u2076 : NormedSpace \u211d A\ninst\u271d\u2075 : IsScalarTower \ud835\udd5c A A\ninst\u271d\u2074 : SMulCommClass \ud835\udd5c A A\ninst\u271d\u00b3 : NonUnitalContinuousFunctionalCalculus \ud835\udd5c p\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : OpensMeasurableSpace X\nf : X \u2192 \ud835\udd5c \u2192 \ud835\udd5c\nbound : X \u2192 \u211d\na : A\ninst\u271d : SecondCountableTopologyEither X C(\u2191(quasispectrum \ud835\udd5c a), \ud835\udd5c)\u2080\nhf\u2081 : \u2200 (x : X), ContinuousOn (f x) (quasispectrum \ud835\udd5c a)\nhf\u2082 : \u2200 (x : X), f x 0 = 0\nhf\u2083 : Continuous fun x \u21a6 { toFun := (quasispectrum \ud835\udd5c a).restrict (f x), continuous_toFun := \u22ef, map_zero' := \u22ef }\nhbound : \u2200 (x : X), \u2200 z \u2208 quasispectrum \ud835\udd5c a, \u2016f x z\u2016 \u2264 \u2016bound x\u2016\nhbound_finite_integral : HasFiniteIntegral bound \u03bc\nha : autoParam (p a) _auto\u271d\nfc : X \u2192 C(\u2191(quasispectrum \ud835\udd5c a), \ud835\udd5c)\u2080 :=\n  fun x \u21a6 { toFun := (quasispectrum \ud835\udd5c a).restrict (f x), continuous_toFun := \u22ef, map_zero' := \u22ef }\nfc_integrable : Integrable fc \u03bc\nh_int_fc : ((quasispectrum \ud835\udd5c a).restrict fun x \u21a6 \u222b (x_1 : X), f x_1 x \u2202\u03bc) = \u21d1(\u222b (x : X), fc x \u2202\u03bc)\nhcont\u2082 : ContinuousOn (fun r \u21a6 \u222b (x : X), f x r \u2202\u03bc) (quasispectrum \ud835\udd5c a)\n\u22a2 (cfc\u2099Hom ha)\n      { toFun := (quasispectrum \ud835\udd5c a).restrict fun r \u21a6 \u222b (x : X), f x r \u2202\u03bc, continuous_toFun := \u22ef, map_zero' := \u22ef } =\n    (cfc\u2099Hom ha) (\u222b (x : X), fc x \u2202\u03bc)",["congr","aesop"]],["NumberTheory/Harmonic/EulerMascheroni.lean",117,"case inr.h.h\nm n r : \u2115\nhr : 0 < r\n\u22a2 \u2191r < \u2191r + 1",["linarith","aesop","norm_num","simp"]],["NumberTheory/Harmonic/EulerMascheroni.lean",149,"\u22a2 1 + 0 \u2260 0",["positivity","omega","aesop","linarith","infer_instance","norm_num","simp"]],["CategoryTheory/Functor/FunctorHom.lean",53,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF\u271d G\u271d : C \u2964 D\nF G A : C \u2964 Type w\nx\u271d : F.HomObj G A\n\u22a2 (fun a \u21a6 { app := fun X y x \u21a6 a.app X (x, y), naturality := \u22ef })\n      ((fun a \u21a6\n          {\n            app := fun X x \u21a6\n              match x with\n              | (x, y) => a.app X y x,\n            naturality := \u22ef })\n        x\u271d) =\n    x\u271d",["aesop","congr","tauto","simp"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",148,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 (f \u226b g) \u226b \ud835\udfd9 Z = f \u226b g",["simp"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",141,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 f \u226b g = \ud835\udfd9 X \u226b f \u226b g",["simp"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",185,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 (-kernel.\u03b9 g) \u226b (snakeInput f g).L\u2082.f = (kernel.\u03b9 g \u226b biprod.inr) \u226b (snakeInput f g).v\u2081\u2082.\u03c4\u2082",["aesop","omega","decide","congr","gcongr","tauto","infer_instance","assumption","abel","norm_num","contradiction","simp"]],["AlgebraicGeometry/FunctionField.lean",150,"X : Scheme\ninst\u271d\u00b9 : IsIntegral X\nU : X.Opens\nhU : IsAffineOpen U\ninst\u271d : Nonempty \u2191\u2191(\u2191U).toPresheafedSpace\nthis : IsAffine \u2191U\n\u22a2 IsDomain \u2191\u0393(X, U)",["infer_instance","tauto"]],["Topology/Algebra/Group/GroupTopology.lean",67,"case mk.mk\n\u03b1 : Type u\ninst\u271d : Group \u03b1\ntoTopologicalSpace\u271d\u00b9 : TopologicalSpace \u03b1\ntoIsTopologicalGroup\u271d\u00b9 : IsTopologicalGroup \u03b1\ntoTopologicalSpace\u271d : TopologicalSpace \u03b1\ntoIsTopologicalGroup\u271d : IsTopologicalGroup \u03b1\nh :\n  { toTopologicalSpace := toTopologicalSpace\u271d\u00b9, toIsTopologicalGroup := toIsTopologicalGroup\u271d\u00b9 }.toTopologicalSpace =\n    { toTopologicalSpace := toTopologicalSpace\u271d, toIsTopologicalGroup := toIsTopologicalGroup\u271d }.toTopologicalSpace\n\u22a2 { toTopologicalSpace := toTopologicalSpace\u271d\u00b9, toIsTopologicalGroup := toIsTopologicalGroup\u271d\u00b9 } =\n    { toTopologicalSpace := toTopologicalSpace\u271d, toIsTopologicalGroup := toIsTopologicalGroup\u271d }",["congr","aesop"]],["SetTheory/Game/Domineering.lean",136,"b : Domineering.Board\n\u22a2 (ofState b).Short",["infer_instance","omega","tauto"]],["SetTheory/Game/Domineering.lean",146,"\u22a2 (domineering [0, (0, 1)].toFinset).Short",["infer_instance","omega","tauto"]],["SetTheory/Game/Domineering.lean",148,"\u22a2 (domineering [(0, 2), (0, 1), 0, (1, 0)].toFinset).Short",["infer_instance","omega","tauto"]],["SetTheory/Game/Domineering.lean",159,"",["decide"]],["SetTheory/Game/Domineering.lean",160,"",["decide"]],["SetTheory/Game/Domineering.lean",161,"",["decide"]],["SetTheory/Game/Domineering.lean",162,"",["decide"]],["SetTheory/Game/Domineering.lean",164,"",["decide"]],["SetTheory/Game/Domineering.lean",168,"",["decide"]],["Algebra/Order/Chebyshev.lean",168,"\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedSemifield \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.Nonempty\n\u22a2 0 \u2264 \u2191(#s)",["positivity","omega","aesop","norm_num","simp"]],["Data/PSigma/Order.lean",61,"case mk.mk.mk.left.right.a\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03b1 i)\na\u2081 : \u03b9\nb\u2081 : \u03b1 a\u2081\na\u2082 : \u03b9\nb\u2082 : \u03b1 a\u2082\na\u271d\u00b9 : a\u2081 < a\u2082\nb\u2082\u271d : \u03b1 a\u2082\na\u271d : b\u2082 \u2264 b\u2082\u271d\n\u22a2 a\u2081 < a\u2082",["assumption","aesop","congr","gcongr"]],["Data/PSigma/Order.lean",63,"case mk.mk.mk.right.left.a\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03b1 i)\na\u2081 : \u03b9\nb\u2081 : \u03b1 a\u2081\na\u2083 : \u03b9\nb\u2083 : \u03b1 a\u2083\nb\u2082\u271d : \u03b1 a\u2081\na\u271d\u00b9 : b\u2081 \u2264 b\u2082\u271d\na\u271d : a\u2081 < a\u2083\n\u22a2 a\u2081 < a\u2083",["assumption"]],["RingTheory/TwoSidedIdeal/Basic.lean",69,"case h.e'_4\nR : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx y : R\nh : I.ringCon x y\n\u22a2 0 = y - y",["abel","aesop","norm_num","simp"]],["RingTheory/Polynomial/Vieta.lean",67,"case h\nR : Type u_1\ninst\u271d : CommSemiring R\n\u03c3 : Type u_2\ns : Multiset \u03c3\nr : \u03c3 \u2192 R\nk : \u2115\nh : k \u2264 s.card\n\u22a2 k \u2264 s.card",["assumption","omega","aesop","congr","linarith","gcongr","tauto"]],["NumberTheory/FactorisationProperties.lean",78,"\u22a2 12 < \u2211 i \u2208 {1, 2, 3, 4, 6}, i",["norm_num","decide","aesop","tauto","simp"]],["Algebra/Module/Presentation/Differentials.lean",84,"R : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npres : Presentation R S\n\u22a2 \u2200 (x y : pres.rels \u2192\u2080 S), (hom\u2081 pres) (x + y) = (hom\u2081 pres) x + (hom\u2081 pres) y",["simp","aesop","norm_num"]],["Data/Bool/Basic.lean",63,"\u22a2 (false = true) = False",["simp","decide"]],["Data/Bool/Basic.lean",193,"case isFalse.isTrue\nn : \u2115\nhn : \u00acn = 0\nh\u271d : n \u2264 0\nh : n = 0\n\u22a2 (!decide (n = 0)) \u2264 !decide (0 = 0)",["contradiction","omega"]],["Data/Bool/Basic.lean",29,"\u22a2 \u00actrue = false",["decide","simp"]],["Data/Bool/Basic.lean",31,"\u22a2 \u00acfalse = true",["decide","simp"]],["Data/Bool/Basic.lean",109,"\u22a2 \u2200 {a b : Bool}, (a && b) = true \u2192 a = true",["decide","simp"]],["Data/Bool/Basic.lean",111,"\u22a2 \u2200 {a b : Bool}, a = true \u2192 b = true \u2192 (a && b) = true",["decide","simp"]],["Data/Bool/Basic.lean",113,"\u22a2 \u2200 {a b : Bool}, (a && b) = true \u2192 b = true",["decide","simp"]],["Data/Bool/Basic.lean",115,"\u22a2 \u2200 {a b : Bool}, a = !b \u2194 a \u2260 b",["decide","simp"]],["Data/Bool/Basic.lean",117,"\u22a2 \u2200 {a b : Bool}, (!decide (a = b)) = true \u2194 a \u2260 b",["decide","simp"]],["Data/Bool/Basic.lean",122,"\u22a2 \u2200 (b : Bool), (!b) \u2260 b",["decide","simp"]],["Data/Bool/Basic.lean",124,"\u22a2 \u2200 (b : Bool), b \u2260 !b",["decide","simp"]],["Data/Bool/Basic.lean",126,"\u22a2 \u2200 (a b : Bool), a = b \u2228 a = !b",["decide","simp"]],["Data/Bool/Basic.lean",137,"case h.h\n\u22a2 \u2200 (a b : Bool), (a != b) = (a ^^ b)",["decide","simp"]],["Data/Bool/Basic.lean",141,"\u22a2 \u2200 {x y : Bool}, (x ^^ y) = true \u2194 x \u2260 y",["decide","simp"]],["Data/Bool/Basic.lean",146,"\u22a2 \u2200 (a : Bool), a \u2264 a",["decide","simp"]],["Data/Bool/Basic.lean",147,"\u22a2 \u2200 (a b c : Bool), a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c",["decide"]],["Data/Bool/Basic.lean",148,"\u22a2 \u2200 (a b : Bool), a \u2264 b \u2192 b \u2264 a \u2192 a = b",["decide"]],["Data/Bool/Basic.lean",149,"\u22a2 \u2200 (a b : Bool), a \u2264 b \u2228 b \u2264 a",["decide"]],["Data/Bool/Basic.lean",153,"\u22a2 \u2200 (a b : Bool), a < b \u2194 a \u2264 b \u2227 \u00acb \u2264 a",["decide"]],["Data/Bool/Basic.lean",154,"\u22a2 \u2200 (a b : Bool), max a b = if a \u2264 b then b else a",["decide"]],["Data/Bool/Basic.lean",155,"\u22a2 \u2200 (a b : Bool), min a b = if a \u2264 b then a else b",["decide"]],["Data/Bool/Basic.lean",157,"\u22a2 \u2200 {x y : Bool}, x < y \u2194 x = false \u2227 y = true",["decide"]],["Data/Bool/Basic.lean",163,"\u22a2 \u2200 {x y : Bool}, x \u2264 y \u2194 x = true \u2192 y = true",["decide"]],["Data/Bool/Basic.lean",165,"\u22a2 \u2200 (x y : Bool), (x && y) \u2264 x",["decide","simp"]],["Data/Bool/Basic.lean",167,"\u22a2 \u2200 (x y : Bool), (x && y) \u2264 y",["decide","simp"]],["Data/Bool/Basic.lean",169,"\u22a2 \u2200 {x y z : Bool}, x \u2264 y \u2192 x \u2264 z \u2192 x \u2264 (y && z)",["decide","simp"]],["Data/Bool/Basic.lean",171,"\u22a2 \u2200 (x y : Bool), x \u2264 (x || y)",["decide","simp"]],["Data/Bool/Basic.lean",173,"\u22a2 \u2200 (x y : Bool), y \u2264 (x || y)",["decide","simp"]],["Data/Bool/Basic.lean",175,"\u22a2 \u2200 {x y z : Bool}, x \u2264 z \u2192 y \u2264 z \u2192 (x || y) \u2264 z",["decide","simp"]],["Analysis/Normed/Unbundled/AlgebraNorm.lean",147,"case mk.mk.mk.mk\nR : outParam (Type u_1)\nS : outParam (Type u_2)\ninst\u271d\u00b2 : SeminormedCommRing R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Algebra R S\nf : AlgebraNorm R S\ntoMulRingSeminorm\u271d\u00b9 : MulRingSeminorm S\neq_zero_of_map_eq_zero'\u271d\u00b9 : \u2200 (x : S), toMulRingSeminorm\u271d\u00b9.toFun x = 0 \u2192 x = 0\nsmul'\u271d\u00b9 :\n  \u2200 (a : R) (x : S),\n    { toMulRingSeminorm := toMulRingSeminorm\u271d\u00b9, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d\u00b9 }.toFun (a \u2022 x) =\n      \u2016a\u2016 * { toMulRingSeminorm := toMulRingSeminorm\u271d\u00b9, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d\u00b9 }.toFun x\ntoMulRingSeminorm\u271d : MulRingSeminorm S\neq_zero_of_map_eq_zero'\u271d : \u2200 (x : S), toMulRingSeminorm\u271d.toFun x = 0 \u2192 x = 0\nsmul'\u271d :\n  \u2200 (a : R) (x : S),\n    { toMulRingSeminorm := toMulRingSeminorm\u271d, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d }.toFun (a \u2022 x) =\n      \u2016a\u2016 * { toMulRingSeminorm := toMulRingSeminorm\u271d, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d }.toFun x\nh :\n  { toMulRingSeminorm := toMulRingSeminorm\u271d\u00b9, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d\u00b9,\n        smul' := smul'\u271d\u00b9 }.toMulRingSeminorm =\n    { toMulRingSeminorm := toMulRingSeminorm\u271d, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d,\n        smul' := smul'\u271d }.toMulRingSeminorm\n\u22a2 { toMulRingSeminorm := toMulRingSeminorm\u271d\u00b9, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d\u00b9, smul' := smul'\u271d\u00b9 } =\n    { toMulRingSeminorm := toMulRingSeminorm\u271d, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'\u271d, smul' := smul'\u271d }",["congr","aesop"]],["Algebra/Lie/Normalizer.lean",81,"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nN N' : LieSubmodule R L M\n\u22a2 (\u2200 x \u2208 \u22a4, \u2200 m \u2208 N, \u2045x, m\u2046 \u2208 N') \u2194 N \u2264 N'.normalizer",["tauto"]],["Algebra/QuaternionBasis.lean",59,"case mk.mk.e_k\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nc\u2081 c\u2082 c\u2083 : R\ni\u271d\u00b9 j\u271d\u00b9 k\u271d\u00b9 : A\ni_mul_i\u271d\u00b9 : i\u271d\u00b9 * i\u271d\u00b9 = c\u2081 \u2022 1 + c\u2082 \u2022 i\u271d\u00b9\nj_mul_j\u271d\u00b9 : j\u271d\u00b9 * j\u271d\u00b9 = c\u2083 \u2022 1\nq\u2081_i_mul_j : i\u271d\u00b9 * j\u271d\u00b9 = k\u271d\u00b9\nj_mul_i\u271d\u00b9 : j\u271d\u00b9 * i\u271d\u00b9 = c\u2082 \u2022 j\u271d\u00b9 - k\u271d\u00b9\ni\u271d j\u271d k\u271d : A\ni_mul_i\u271d : i\u271d * i\u271d = c\u2081 \u2022 1 + c\u2082 \u2022 i\u271d\nj_mul_j\u271d : j\u271d * j\u271d = c\u2083 \u2022 1\nq\u2082_i_mul_j : i\u271d * j\u271d = k\u271d\nj_mul_i\u271d : j\u271d * i\u271d = c\u2082 \u2022 j\u271d - k\u271d\nhi :\n  { i := i\u271d\u00b9, j := j\u271d\u00b9, k := k\u271d\u00b9, i_mul_i := i_mul_i\u271d\u00b9, j_mul_j := j_mul_j\u271d\u00b9, i_mul_j := q\u2081_i_mul_j,\n        j_mul_i := j_mul_i\u271d\u00b9 }.i =\n    { i := i\u271d, j := j\u271d, k := k\u271d, i_mul_i := i_mul_i\u271d, j_mul_j := j_mul_j\u271d, i_mul_j := q\u2082_i_mul_j, j_mul_i := j_mul_i\u271d }.i\nhj :\n  { i := i\u271d\u00b9, j := j\u271d\u00b9, k := k\u271d\u00b9, i_mul_i := i_mul_i\u271d\u00b9, j_mul_j := j_mul_j\u271d\u00b9, i_mul_j := q\u2081_i_mul_j,\n        j_mul_i := j_mul_i\u271d\u00b9 }.j =\n    { i := i\u271d, j := j\u271d, k := k\u271d, i_mul_i := i_mul_i\u271d, j_mul_j := j_mul_j\u271d, i_mul_j := q\u2082_i_mul_j, j_mul_i := j_mul_i\u271d }.j\n\u22a2 i\u271d\u00b9 * j\u271d\u00b9 = i\u271d * j\u271d",["congr","aesop"]],["RingTheory/PowerSeries/Trunc.lean",135,"R : Type u_1\ninst\u271d : Semiring R\n\u22a2 trunc 1 X = 0",["simp","aesop","norm_num"]],["RingTheory/PowerSeries/Trunc.lean",83,"case pos\nR : Type u_1\ninst\u271d : Semiring R\nf : R\u27e6X\u27e7\nn N\u271d : \u2115\na\u271d : n < N\u271d\nh : \u00acn < N\u271d\n\u22a2 (coeff R N\u271d) f = 0",["contradiction","omega","aesop","linarith","tauto"]],["RingTheory/PowerSeries/Trunc.lean",94,"case pos\nR : Type u_1\ninst\u271d : Semiring R\nf : R\u27e6X\u27e7\nn m\u271d : \u2115\na\u271d : n \u2264 m\u271d\nh : \u00acn \u2264 m\u271d\n\u22a2 (coeff R m\u271d) f = 0",["contradiction","omega","aesop","linarith","tauto"]],["Data/Multiset/DershowitzManna.lean",146,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nz : \u03b1\nZ : Multiset \u03b1\nih :\n  \u2200 {M N : Multiset \u03b1} (X Y : Multiset \u03b1),\n    Z \u2260 \u2205 \u2192 M = X + Y \u2192 N = X + Z \u2192 (\u2200 y \u2208 Y, \u2203 z \u2208 Z, y < z) \u2192 TransGen Multiset.OneStep M N\nM N X Y : Multiset \u03b1\nhZ\u271d : z ::\u2098 Z \u2260 \u2205\nhM : M = X + Y\nhN : N = X + z ::\u2098 Z\nhYZ : \u2200 y \u2208 Y, \u2203 z_1 \u2208 z ::\u2098 Z, y < z_1\nhZ : Z \u2260 0\nY' : Multiset \u03b1 := filter (fun x \u21a6 x < z) Y\ny : \u03b1\nhy : y \u2208 Y \u2227 \u00acy < z\n\u22a2 y \u2208 Y",["aesop","tauto"]],["Order/BooleanGenerators.lean",149,"case intro.intro.intro.intro.intro.intro.hab.e_a.h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CompleteLattice \u03b1\nS : Set \u03b1\ninst\u271d : IsCompactlyGenerated \u03b1\nhS : BooleanGenerators S\nh : sSup S = \u22a4\nTa : Set \u03b1\nhTa : Ta \u2286 S\nTb : Set \u03b1\nhTb : Tb \u2286 S\nTc : Set \u03b1\nhTc : Tc \u2286 S\nx\u271d : \u03b1\n\u22a2 (x\u271d \u2208 Ta \u2228 x\u271d \u2208 Tb) \u2227 (x\u271d \u2208 Ta \u2228 x\u271d \u2208 Tc) \u2194 x\u271d \u2208 Ta \u2228 x\u271d \u2208 Tb \u2227 x\u271d \u2208 Tc\n```\n---\n```lean\ncase intro.intro.intro.intro.intro.intro.hab.hT\u2081\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CompleteLattice \u03b1\nS : Set \u03b1\ninst\u271d : IsCompactlyGenerated \u03b1\nhS : BooleanGenerators S\nh : sSup S = \u22a4\nTa : Set \u03b1\nhTa : Ta \u2286 S\nTb : Set \u03b1\nhTb : Tb \u2286 S\nTc : Set \u03b1\nhTc : Tc \u2286 S\n\u22a2 Ta \u2286 S \u2227 Tb \u2286 S\n```\n---\n```lean\ncase intro.intro.intro.intro.intro.intro.hab.hT\u2082\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CompleteLattice \u03b1\nS : Set \u03b1\ninst\u271d : IsCompactlyGenerated \u03b1\nhS : BooleanGenerators S\nh : sSup S = \u22a4\nTa : Set \u03b1\nhTa : Ta \u2286 S\nTb : Set \u03b1\nhTb : Tb \u2286 S\nTc : Set \u03b1\nhTc : Tc \u2286 S\n\u22a2 Ta \u2286 S \u2227 Tc \u2286 S",["tauto","aesop"]],["NumberTheory/ModularForms/SlashInvariantForms.lean",41,"case mk.mk\nF : Type u_1\n\u0393 : outParam (Subgroup SL(2, \u2124))\nk : outParam \u2124\ntoFun\u271d\u00b9 : \u210d \u2192 \u2102\nslash_action_eq'\u271d\u00b9 : \u2200 \u03b3 \u2208 \u0393, toFun\u271d\u00b9 \u2223[k] \u03b3 = toFun\u271d\u00b9\ntoFun\u271d : \u210d \u2192 \u2102\nslash_action_eq'\u271d : \u2200 \u03b3 \u2208 \u0393, toFun\u271d \u2223[k] \u03b3 = toFun\u271d\nh :\n  { toFun := toFun\u271d\u00b9, slash_action_eq' := slash_action_eq'\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, slash_action_eq' := slash_action_eq'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, slash_action_eq' := slash_action_eq'\u271d\u00b9 } =\n    { toFun := toFun\u271d, slash_action_eq' := slash_action_eq'\u271d }",["congr","aesop"]],["MeasureTheory/Measure/Haar/InnerProductSpace.lean",151,"case intro.intro\nE : Type u_2\nF : Type u_3\ninst\u271d\u2079 : NormedAddCommGroup F\ninst\u271d\u2078 : InnerProductSpace \u211d F\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : InnerProductSpace \u211d E\ninst\u271d\u2075 : MeasurableSpace E\ninst\u271d\u2074 : BorelSpace E\ninst\u271d\u00b3 : MeasurableSpace F\ninst\u271d\u00b2 : BorelSpace F\ninst\u271d\u00b9 : FiniteDimensional \u211d E\ninst\u271d : FiniteDimensional \u211d F\nf : E \u2243\u2097\u1d62[\u211d] F\nw : Finset E\nb : OrthonormalBasis { x // x \u2208 w } \u211d E\n_hw : \u21d1b = Subtype.val\n\u22a2 (b.toBasis.map f.toContinuousLinearEquiv.toLinearEquiv).addHaar = (b.map f).toBasis.addHaar",["congr","omega","aesop","tauto","infer_instance","abel"]],["CategoryTheory/Abelian/Projective/Dimension.lean",186,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Abelian C\nX Y : C\nn : \u2115\ninst\u271d\u00b9 : HasProjectiveDimensionLT X n\ninst\u271d : HasProjectiveDimensionLT Y n\n\u22a2 HasProjectiveDimensionLT (ShortComplex.mk biprod.inl biprod.snd \u22ef).X\u2083 n",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["CategoryTheory/Abelian/Projective/Dimension.lean",101,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\nX : C\nn : \u2115\ninst\u271d : HasProjectiveDimensionLT X n\nk : \u2115\n\u22a2 n \u2264 n + k",["omega","aesop","linarith","norm_num","simp"]],["CategoryTheory/Abelian/Projective/Dimension.lean",105,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\nX : C\nn : \u2115\ninst\u271d : HasProjectiveDimensionLT X n\nk : \u2115\n\u22a2 n \u2264 k + n",["omega","aesop","linarith","norm_num","simp"]],["CategoryTheory/Action/Concrete.lean",121,"case h.h.h\nG : Type u_1\ninst\u271d\u00b2 : Group G\nH N : Subgroup G\ninst\u271d\u00b9 : Fintype (G \u29f8 N)\ninst\u271d : N.Normal\nx : G\n\u22a2 ((fun v \u21a6 { hom := Quotient.lift (fun \u03c3 \u21a6 \u27e6\u03c3 * v\u207b\u00b9\u27e7) \u22ef, comm := \u22ef }) 1).hom \u27e6x\u27e7 = Hom.hom 1 \u27e6x\u27e7",["simp","aesop"]],["CategoryTheory/Action/Concrete.lean",29,"G H : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : MulAction G H\n\u22a2 MulAction G H",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["CategoryTheory/Action/Concrete.lean",85,"G : Type u\nH : FintypeCat\ninst\u271d\u00b9 : Monoid G\ninst\u271d : MulAction G H.carrier\n\u22a2 MulAction G H.carrier",["assumption","aesop","congr","gcongr","tauto","infer_instance"]],["Analysis/Complex/Liouville.lean",132,"E : Type u\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u2102 E\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u2102 F\ninst\u271d : Nontrivial E\nf : E \u2192 F\nhf : Differentiable \u2102 f\nc : F\nhb : Tendsto f (cocompact E) (\ud835\udcdd c)\ns : Set E\nhs : s \u2208 cocompact E\nhs_bdd : Bornology.IsBounded (f '' s)\nt : Set E\nht : IsCompact t\nhts : t\u1d9c \u2286 s\n\u22a2 t \u222a t\u1d9c \u2286 t \u222a s",["gcongr","tauto"]],["Data/Real/GoldenRatio.lean",121,"\u22a2 Nat.Prime 5",["norm_num","decide"]],["Data/Real/GoldenRatio.lean",129,"\u22a2 Nat.Prime 5",["norm_num","decide"]],["Data/Real/GoldenRatio.lean",190,"case \u00ab1\u00bb\n\u22a2 \u221a5 \u2260 0",["norm_num","aesop","positivity","simp"]],["Data/Real/GoldenRatio.lean",210,"n : \u2115\n\u22a2 \u221a5 \u2260 0",["norm_num","aesop","positivity","simp"]],["AlgebraicTopology/DoldKan/Projections.lean",66,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq : \u2115\n\u22a2 P q + (\ud835\udfd9 K[X] - P q) = \ud835\udfd9 K[X]",["abel","aesop","norm_num","simp"]],["Data/String/Basic.lean",78,"case nil.nil\n\u22a2 (if { s := { data := [] }, i := 0 }.hasNext = true then\n        if { s := { data := [] }, i := 0 }.hasNext = true then\n          if { s := { data := [] }, i := 0 }.curr = { s := { data := [] }, i := 0 }.curr then\n            ltb { s := { data := [] }, i := 0 }.next { s := { data := [] }, i := 0 }.next\n          else decide ({ s := { data := [] }, i := 0 }.curr < { s := { data := [] }, i := 0 }.curr)\n        else true\n      else false) =\n      true \u2194\n    [] < []",["decide","tauto"]],["NumberTheory/LegendreSymbol/ZModChar.lean",44,"\u22a2 \u2200 (x y : ZMod 4),\n    {\n            toFun := fun a \u21a6\n              match a with\n              | 0 => 0\n              | 2 => 0\n              | 1 => 1\n              | 3 => -1,\n            map_one' := \u22ef }.toFun\n        (x * y) =\n      {\n              toFun := fun a \u21a6\n                match a with\n                | 0 => 0\n                | 2 => 0\n                | 1 => 1\n                | 3 => -1,\n              map_one' := \u22ef }.toFun\n          x *\n        {\n              toFun := fun a \u21a6\n                match a with\n                | 0 => 0\n                | 2 => 0\n                | 1 => 1\n                | 3 => -1,\n              map_one' := \u22ef }.toFun\n          y",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",45,"\u22a2 \u2200 (a : ZMod 4),\n    \u00acIsUnit a \u2192\n      (\u2191{\n                toFun := fun a \u21a6\n                  match a with\n                  | 0 => 0\n                  | 2 => 0\n                  | 1 => 1\n                  | 3 => -1,\n                map_one' := \u22ef, map_mul' := \u22ef }).toFun\n          a =\n        0",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",50,"\u22a2 \u2200 (a : ZMod 4), \u03c7\u2084 a = 0 \u2228 \u03c7\u2084 a = 1 \u2228 \u03c7\u2084 a = -1",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",64,"n : \u2124\n\u22a2 \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 4 \u2192 \u03c7\u2084 \u2191m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",80,"n : \u2115\nhn : n % 2 = 1\n\u22a2 \u2200 m < 4, m % 2 = 1 \u2192 (if m = 1 then 1 else -1) = (-1) ^ (m / 2)",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",121,"\u22a2 \u2200 (x y : ZMod 8),\n    {\n            toFun := fun a \u21a6\n              match a with\n              | 0 => 0\n              | 2 => 0\n              | 4 => 0\n              | 6 => 0\n              | 1 => 1\n              | 7 => 1\n              | 3 => -1\n              | 5 => -1,\n            map_one' := \u22ef }.toFun\n        (x * y) =\n      {\n              toFun := fun a \u21a6\n                match a with\n                | 0 => 0\n                | 2 => 0\n                | 4 => 0\n                | 6 => 0\n                | 1 => 1\n                | 7 => 1\n                | 3 => -1\n                | 5 => -1,\n              map_one' := \u22ef }.toFun\n          x *\n        {\n              toFun := fun a \u21a6\n                match a with\n                | 0 => 0\n                | 2 => 0\n                | 4 => 0\n                | 6 => 0\n                | 1 => 1\n                | 7 => 1\n                | 3 => -1\n                | 5 => -1,\n              map_one' := \u22ef }.toFun\n          y",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",122,"\u22a2 \u2200 (a : ZMod 8),\n    \u00acIsUnit a \u2192\n      (\u2191{\n                toFun := fun a \u21a6\n                  match a with\n                  | 0 => 0\n                  | 2 => 0\n                  | 4 => 0\n                  | 6 => 0\n                  | 1 => 1\n                  | 7 => 1\n                  | 3 => -1\n                  | 5 => -1,\n                map_one' := \u22ef, map_mul' := \u22ef }).toFun\n          a =\n        0",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",127,"\u22a2 \u2200 (a : ZMod 8), \u03c7\u2088 a = 0 \u2228 \u03c7\u2088 a = 1 \u2228 \u03c7\u2088 a = -1",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",142,"n : \u2124\n\u22a2 \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u03c7\u2088 \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 7 then 1 else -1",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",160,"\u22a2 \u2200 (x y : ZMod 8),\n    {\n            toFun := fun a \u21a6\n              match a with\n              | 0 => 0\n              | 2 => 0\n              | 4 => 0\n              | 6 => 0\n              | 1 => 1\n              | 3 => 1\n              | 5 => -1\n              | 7 => -1,\n            map_one' := \u22ef }.toFun\n        (x * y) =\n      {\n              toFun := fun a \u21a6\n                match a with\n                | 0 => 0\n                | 2 => 0\n                | 4 => 0\n                | 6 => 0\n                | 1 => 1\n                | 3 => 1\n                | 5 => -1\n                | 7 => -1,\n              map_one' := \u22ef }.toFun\n          x *\n        {\n              toFun := fun a \u21a6\n                match a with\n                | 0 => 0\n                | 2 => 0\n                | 4 => 0\n                | 6 => 0\n                | 1 => 1\n                | 3 => 1\n                | 5 => -1\n                | 7 => -1,\n              map_one' := \u22ef }.toFun\n          y",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",161,"\u22a2 \u2200 (a : ZMod 8),\n    \u00acIsUnit a \u2192\n      (\u2191{\n                toFun := fun a \u21a6\n                  match a with\n                  | 0 => 0\n                  | 2 => 0\n                  | 4 => 0\n                  | 6 => 0\n                  | 1 => 1\n                  | 3 => 1\n                  | 5 => -1\n                  | 7 => -1,\n                map_one' := \u22ef, map_mul' := \u22ef }).toFun\n          a =\n        0",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",166,"\u22a2 \u2200 (a : ZMod 8), \u03c7\u2088' a = 0 \u2228 \u03c7\u2088' a = 1 \u2228 \u03c7\u2088' a = -1",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",173,"n : \u2124\n\u22a2 \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u03c7\u2088' \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 3 then 1 else -1",["decide"]],["NumberTheory/LegendreSymbol/ZModChar.lean",183,"\u22a2 \u2200 (a : ZMod 8), \u03c7\u2088' a = \u03c7\u2084 a.cast * \u03c7\u2088 a",["decide"]],["Analysis/NormedSpace/Extend.lean",136,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\n\u22a2 NormedSpace \ud835\udd5c F",["infer_instance","aesop","congr","gcongr","tauto","assumption"]],["Analysis/Convex/StrictConvexBetween.lean",112,"case inl\nE : Type u_3\nPE : Type u_5\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : StrictConvexSpace \u211d E\ninst\u271d\u00b9 : MetricSpace PE\ninst\u271d : NormedAddTorsor E PE\nr : \u211d\ny : PE\nhxy : dist y y = r * dist y y\nhyz : dist y y = (1 - r) * dist y y\nthis : y -\u1d65 y \u2208 [0 -[\u211d] y -\u1d65 y]\n\u22a2 y = (AffineMap.lineMap y y) r",["simp","aesop","norm_num"]],["Analysis/Convex/StrictConvexBetween.lean",41,"V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : NormedSpace \u211d V\ninst\u271d\u00b2 : StrictConvexSpace \u211d V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np p\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2083 : p\u2081 -\u1d65 p \u2260 p\u2083 -\u1d65 p\nhp\u2082p\u2081 : p\u2082 \u2260 p\u2081\nhp\u2082p\u2083 : p\u2082 \u2260 p\u2083\nr : \u211d\nhr : (1 - r) \u2022 (p\u2081 -\u1d65 p) + r \u2022 (p\u2083 -\u1d65 p) = p\u2082 -\u1d65 p\nhr0 : 0 < r\nhr1 : r < 1\n\u22a2 1 - r + r = 1",["abel","ring","aesop","linarith","norm_num","simp"]],["Algebra/Homology/Embedding/Boundary.lean",173,"case mp.succ\np : \u2124\nn : \u2115\nh : (embeddingUpIntGE p).BoundaryGE (n + 1)\nthis : \u00acp + \u2191n + 1 = p + \u2191(n + 1)\n\u22a2 n + 1 = 0",["omega","tauto","infer_instance"]],["Algebra/Homology/Embedding/Boundary.lean",189,"case mp.succ\np : \u2124\nn : \u2115\nh : (embeddingUpIntGE p).BoundaryGE (n + 1)\nthis : \u00acp + \u2191n + 1 = p + \u2191(n + 1)\n\u22a2 n + 1 = 0",["omega","tauto","infer_instance"]],["GroupTheory/PresentedGroup.lean",91,"\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), of j \u2208 H\nx\u271d : \u03b1\na\u271d : (mk rels) (pure x\u271d) \u2208 H\n\u22a2 ?m.4449 \u2208 H",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Homology/ShortComplex/ModuleCat.lean",50,"R : Type u\ninst\u271d : Ring R\nS : ShortComplex (ModuleCat R)\n\u22a2 (\u2200 (x\u2082 : \u2191S.X\u2082), (ConcreteCategory.hom S.g) x\u2082 = 0 \u2192 \u2203 x\u2081, (ConcreteCategory.hom S.f) x\u2081 = x\u2082) \u2194\n    LinearMap.ker (ModuleCat.Hom.hom S.g) \u2264 LinearMap.range (ModuleCat.Hom.hom S.f)",["aesop","tauto"]],["Algebra/Homology/ShortComplex/ModuleCat.lean",76,"R : Type u\ninst\u271d : Ring R\nS : ShortComplex (ModuleCat R)\n\u22a2 LinearMap.range (ModuleCat.Hom.hom S.f) = LinearMap.ker (ModuleCat.Hom.hom S.g) \u2194\n    LinearMap.ker (ConcreteCategory.hom S.g) = LinearMap.range (ConcreteCategory.hom S.f)",["tauto","aesop"]],["Topology/ContinuousMap/CocompactMap.lean",79,"case mk.mk.mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d\u00b9 : Continuous toFun\u271d\u00b9\ncocompact_tendsto'\u271d\u00b9 :\n  Tendsto { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun (cocompact \u03b1) (cocompact \u03b2)\ntoFun\u271d : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d : Continuous toFun\u271d\ncocompact_tendsto'\u271d :\n  Tendsto { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }.toFun (cocompact \u03b1) (cocompact \u03b2)\nh :\n  (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, cocompact_tendsto' := cocompact_tendsto'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun)\n      { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, cocompact_tendsto' := cocompact_tendsto'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, cocompact_tendsto' := cocompact_tendsto'\u271d\u00b9 } =\n    { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, cocompact_tendsto' := cocompact_tendsto'\u271d }",["congr","aesop"]],["Analysis/Normed/Affine/MazurUlam.lean",138,"E : Type u_1\nPE : Type u_2\nF : Type u_3\nPF : Type u_4\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : MetricSpace PE\ninst\u271d\u2074 : NormedAddTorsor E PE\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \u211d F\ninst\u271d\u00b9 : MetricSpace PF\ninst\u271d : NormedAddTorsor F PF\nf : PE \u2243\u1d62 PF\np : PE\n\u22a2 f p =\n    ((vaddConst (Classical.arbitrary PE)).trans\n            (f.trans (vaddConst (f (Classical.arbitrary PE))).symm)).toRealLinearIsometryEquiv\n        (p -\u1d65 Classical.arbitrary PE) +\u1d65\n      f (Classical.arbitrary PE)",["simp","aesop","norm_num"]],["Combinatorics/Enumerative/InclusionExclusion.lean",86,"case neg\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nG : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddCommGroup G\ns : Finset \u03b9\nS : \u03b9 \u2192 Finset \u03b1\nf : \u03b1 \u2192 G\na\u271d : \u2205 \u2208 s.powerset\nht : \u00ac\u2205.Nonempty\n\u22a2 (-1) ^ #\u2205 \u2022 \u2211 a \u2208 s.biUnion S, f a =\n    \u2211 x \u2208 s.biUnion S, ((-1) ^ #\u2205 * ((\u220f i \u2208 s \\ \u2205, 1) * \u220f i \u2208 \u2205, (\u2191(S i)).indicator 1 x)) \u2022 f x",["simp","aesop"]],["Algebra/Prime/Defs.lean",73,"case zero\nM : Type u_1\ninst\u271d : CommMonoidWithZero M\np : M\nhp : Prime p\na : M\nh : p \u2223 1\nthis\u271d : IsUnit p\nthis : \u00acIsUnit p\n\u22a2 p \u2223 a",["contradiction","aesop","tauto"]],["Data/PFunctor/Univariate/Basic.lean",177,"case mp.intro.mk\nP : PFunctor.{u}\n\u03b1 : Type u\np : \u03b1 \u2192 Prop\nx : \u2191P \u03b1\ny : \u2191P (Subtype p)\nhy : Subtype.val <$> y = x\na : P.A\nf : P.B a \u2192 Subtype p\nh : y = \u27e8a, f\u27e9\n\u22a2 \u27e8a, Subtype.val \u2218 f\u27e9 = \u27e8a, fun i \u21a6 \u2191(f i)\u27e9",["congr","aesop","tauto"]],["Data/PFunctor/Univariate/Basic.lean",187,"case mp.intro.intro.intro.refl\nP : PFunctor.{u}\n\u03b1 : Type u\np : \u03b1 \u2192 Prop\na : P.A\nf : P.B a \u2192 \u03b1\nh' : \u2200 (i : P.B a), p (f i)\n\u22a2 \u2200 (i : P.B a), p (f i)",["assumption","aesop","congr","tauto"]],["Data/PFunctor/Univariate/Basic.lean",224,"case h.mpr.intro\nP : PFunctor.{u}\n\u03b1 : Type u\na : P.A\nf : P.B a \u2192 \u03b1\nw\u271d : P.B a\n\u22a2 \u2200 \u2983p : \u03b1 \u2192 Prop\u2984, (\u2200 (i : P.B a), p (f i)) \u2192 p (f w\u271d)",["tauto","aesop"]],["Algebra/Category/BialgebraCat/Basic.lean",86,"R : Type u\ninst\u271d : CommRing R\nV W : BialgebraCat R\nx\u271d\u00b2 x\u271d\u00b9 : V.Hom W\nf g : V.carrier \u2192\u2090c[R] W.carrier\nx\u271d : { toBialgHom' := f }.toBialgHom = { toBialgHom' := g }.toBialgHom\n\u22a2 { toBialgHom' := f } = { toBialgHom' := g }",["congr","aesop","tauto"]],["Data/Nat/Pairing.lean",91,"\u22a2 (if 0 - sqrt 0 * sqrt 0 < sqrt 0 then (0 - sqrt 0 * sqrt 0, sqrt 0) else (sqrt 0, 0 - sqrt 0 * sqrt 0 - sqrt 0)) = 0",["simp","decide","aesop","congr","tauto"]],["Data/Nat/Pairing.lean",118,"case neg.h\u2082.h\na\u2081 a\u2082 b : \u2115\nh : a\u2081 < a\u2082\nh\u2081 : b \u2264 a\u2081\n\u22a2 a\u2081 < a\u2082",["assumption","omega","aesop","congr","gcongr","tauto"]],["Topology/MetricSpace/Kuratowski.lean",51,"case h.e'_3.h.e'_1\n\u03b1 : Type u\ninst\u271d : MetricSpace \u03b1\nx : \u2115 \u2192 \u03b1\na b : \u03b1\nn : \u2115\n\u22a2 dist a (x n) - dist (x 0) (x n) - (dist b (x n) - dist (x 0) (x n)) = dist a (x n) - dist b (x n)",["ring","aesop","linarith","abel","norm_num","simp"]],["Combinatorics/SimpleGraph/Diam.lean",97,"case inr.h\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : \u00acG.Preconnected\nh\u271d : Nonempty \u03b1\n\u22a2 \u00ac(G.Preconnected \u2227 Nonempty \u03b1)",["tauto","aesop"]],["Topology/Algebra/Valued/ValuationTopology.lean",38,"case h\nR : Type u\ninst\u271d\u00b9 : Ring R\n\u0393\u2080 : Type v\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\n\u03b3\u2080 \u03b3\u2081 : \u0393\u2080\u02e3\n\u22a2 \u2200 (a : R), v a < \u2191\u03b3\u2080 \u2192 v a < \u2191\u03b3\u2081 \u2192 v a < \u2191\u03b3\u2080",["tauto","aesop"]],["Topology/Spectral/Hom.lean",105,"case mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nspectral'\u271d\u00b9 : IsSpectralMap toFun\u271d\u00b9\ntoFun\u271d : \u03b1 \u2192 \u03b2\nspectral'\u271d : IsSpectralMap toFun\u271d\nh : { toFun := toFun\u271d\u00b9, spectral' := spectral'\u271d\u00b9 }.toFun = { toFun := toFun\u271d, spectral' := spectral'\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, spectral' := spectral'\u271d\u00b9 } = { toFun := toFun\u271d, spectral' := spectral'\u271d }",["congr","aesop"]],["Data/PFunctor/Multivariate/Basic.lean",154,"case mp.intro.intro.intro.refl\nn : \u2115\nP : MvPFunctor.{u} n\n\u03b1 : TypeVec.{u} n\np : \u2983i : Fin2 n\u2984 \u2192 \u03b1 i \u2192 Prop\na : P.A\nf : P.B a \u27f9 \u03b1\nright\u271d : \u2200 (i : Fin2 n) (j : P.B a i), p (f i j)\n\u22a2 \u2200 (i : Fin2 n) (x : P.B a i), p (f i x)",["assumption","aesop","congr","tauto"]],["Data/PFunctor/Multivariate/Basic.lean",192,"case h.mpr.intro\nn : \u2115\nP : MvPFunctor.{u} n\n\u03b1 : TypeVec.{u} n\na : P.A\nf : P.B a \u27f9 \u03b1\ni : Fin2 n\nw\u271d : P.B a i\n\u22a2 \u2200 \u2983P_1 : (i : Fin2 n) \u2192 \u03b1 i \u2192 Prop\u2984, (\u2200 (i : Fin2 n) (x : P.B a i), P_1 i (f i x)) \u2192 P_1 i (f i w\u271d)",["tauto","omega","aesop","infer_instance"]],["CategoryTheory/Sites/Preserves.lean",84,"C : Type u\ninst\u271d : Category.{v, u} C\nF : C\u1d52\u1d56 \u2964 Type w\n\u03b1 : Type\nX : \u03b1 \u2192 C\nc : Cofan X\nhc : IsColimit c\nthis : HasCoproduct X\n\u22a2 (Pi.lift fun i \u21a6 F.map (c.inj i).op) = F.map (Pi.lift fun i \u21a6 (c.inj i).op) \u226b piComparison F fun i \u21a6 op (X i)",["simp","aesop"]],["CategoryTheory/Sites/Preserves.lean",52,"C : Type u\ninst\u271d : Category.{v, u} C\nI : C\nF : C\u1d52\u1d56 \u2964 Type w\nhF : IsSheafFor F (ofArrows Empty.elim fun a \u21a6 Empty.instIsEmpty.elim a)\nY : Type w\n\u22a2 FamilyOfElements.Compatible fun \u2983Y\u2984 f a \u21a6 \u22ef.elim",["tauto"]],["Data/Multiset/Basic.lean",39,"\u03b1 : Type u_1\ns : Multiset \u03b1\n\u22a2 s.toList.isEmpty = true \u2194 s = 0",["simp","aesop"]],["CategoryTheory/Subpresheaf/Basic.lean",57,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\nG G' x\u271d\u00b2 x\u271d\u00b9 : Subpresheaf F\nx\u271d : C\u1d52\u1d56\n\u22a2 x\u271d\u00b9.obj x\u271d \u2264 ((fun F_1 G \u21a6 { obj := fun U \u21a6 F_1.obj U \u2294 G.obj U, map := \u22ef }) x\u271d\u00b2 x\u271d\u00b9).obj x\u271d",["simp","aesop","tauto"]],["CategoryTheory/Subpresheaf/Basic.lean",193,"case mp\nC : Type u\ninst\u271d : Category.{v, u} C\nF : C\u1d52\u1d56 \u2964 Type w\n\u22a2 IsIso \u22a4.\u03b9",["infer_instance","omega","aesop","tauto"]],["Combinatorics/SimpleGraph/Circulant.lean",76,"\u22a2 \u2200 (x x_1 : Fin 2), (cycleGraph 2).Adj x x_1 = \u22a4.Adj x x_1",["decide"]],["Combinatorics/SimpleGraph/Circulant.lean",80,"\u22a2 \u2200 (x x_1 : Fin 3), (cycleGraph 3).Adj x x_1 = \u22a4.Adj x x_1",["decide"]],["Control/Traversable/Instances.lean",119,"\u03b1' \u03b2' : Type u\nf : \u03b1' \u2192 Set \u03b2'\n\u22a2 [] \u2208 traverse f [] \u2194 Forall\u2082 (fun b a \u21a6 b \u2208 f a) [] []",["simp","aesop","tauto"]],["Control/Traversable/Instances.lean",120,"\u03b1' \u03b2' : Type u\nf : \u03b1' \u2192 Set \u03b2'\na : \u03b1'\nas : List \u03b1'\n\u22a2 [] \u2208 traverse f (a :: as) \u2194 Forall\u2082 (fun b a \u21a6 b \u2208 f a) [] (a :: as)",["simp"]],["Control/Traversable/Instances.lean",115,"F : Type u \u2192 Type u\ninst\u271d\u00b9 : Applicative F\n\u03b1' \u03b2' : Type u\nf : \u03b1' \u2192 F \u03b2'\ninst\u271d : LawfulApplicative F\na : \u03b1'\nas bs : List \u03b1'\n\u22a2 (fun a \u21a6 (Function.comp fun x2 \u21a6 a :: x2) \u2218 fun x1 x2 \u21a6 x1 ++ x2) <$> f a <*> traverse f as <*> traverse f bs =\n    (fun a \u21a6 (fun x1 x2 \u21a6 x1 ++ x2) \u2218 fun x2 \u21a6 a :: x2) <$> f a <*> traverse f as <*> traverse f bs",["congr","aesop","tauto"]],["Algebra/Group/Ext.lean",47,"case mk.mk.mk.mk.mk.mk.mk.mk\nM : Type u\nnpow\u271d\u00b9 : \u2115 \u2192 M \u2192 M\nmul\u271d\u00b9 : M \u2192 M \u2192 M\nmul_assoc\u271d\u00b9 : \u2200 (a b c : M), a * b * c = a * (b * c)\nnpow_succ\u271d\u00b9 : \u2200 (n : \u2115) (x : M), npow\u271d\u00b9 (n + 1) x = npow\u271d\u00b9 n x * x\none\u271d\u00b9 : M\nnpow_zero\u271d\u00b9 : \u2200 (x : M), npow\u271d\u00b9 0 x = 1\none_mul\u271d\u00b9 : \u2200 (a : M), 1 * a = a\nmul_one\u271d\u00b9 : \u2200 (a : M), a * 1 = a\nnpow\u271d : \u2115 \u2192 M \u2192 M\nmul\u271d : M \u2192 M \u2192 M\nmul_assoc\u271d : \u2200 (a b c : M), a * b * c = a * (b * c)\nnpow_succ\u271d : \u2200 (n : \u2115) (x : M), npow\u271d (n + 1) x = npow\u271d n x * x\none\u271d : M\nnpow_zero\u271d : \u2200 (x : M), npow\u271d 0 x = 1\none_mul\u271d : \u2200 (a : M), 1 * a = a\nmul_one\u271d : \u2200 (a : M), a * 1 = a\nh_mul : HMul.hMul = HMul.hMul\nthis\u271d : toMulOneClass = toMulOneClass\nh\u2081 : One.one = One.one\nf : M \u2192* M := { toFun := id, map_one' := h\u2081, map_mul' := \u22ef }\nthis : Monoid.npow = Monoid.npow\n\u22a2 mk one_mul\u271d\u00b9 mul_one\u271d\u00b9 npow\u271d\u00b9 npow_zero\u271d\u00b9 npow_succ\u271d\u00b9 = mk one_mul\u271d mul_one\u271d npow\u271d npow_zero\u271d npow_succ\u271d",["congr"]],["Algebra/Group/Ext.lean",53,"case mk.mk\nM : Type u\ntoMonoid\u271d\u00b9 : Monoid M\nmul_comm\u271d\u00b9 : \u2200 (a b : M), a * b = b * a\ntoMonoid\u271d : Monoid M\nmul_comm\u271d : \u2200 (a b : M), a * b = b * a\nh : toMonoid = toMonoid\n\u22a2 mk mul_comm\u271d\u00b9 = mk mul_comm\u271d",["congr"]],["Algebra/Group/Ext.lean",88,"case mk.mk\nM : Type u\ntoLeftCancelMonoid\u271d\u00b9 : LeftCancelMonoid M\nmul_right_cancel\u271d\u00b9 : \u2200 (a b c : M), a * b = c * b \u2192 a = c\ntoLeftCancelMonoid\u271d : LeftCancelMonoid M\nmul_right_cancel\u271d : \u2200 (a b c : M), a * b = c * b \u2192 a = c\nh : toLeftCancelMonoid = toLeftCancelMonoid\n\u22a2 mk mul_right_cancel\u271d\u00b9 = mk mul_right_cancel\u271d",["congr"]],["Algebra/Group/Ext.lean",129,"case mk.mk.mk.mk.mk.mk\nM : Type u_1\ntoMonoid\u271d\u00b9 : Monoid M\nzpow\u271d\u00b9 : \u2124 \u2192 M \u2192 M\nzpow_zero'\u271d\u00b9 : \u2200 (a : M), zpow\u271d\u00b9 0 a = 1\nzpow_succ'\u271d\u00b9 : \u2200 (n : \u2115) (a : M), zpow\u271d\u00b9 (\u2191n.succ) a = zpow\u271d\u00b9 (\u2191n) a * a\ninv\u271d\u00b9 : M \u2192 M\nzpow_neg'\u271d\u00b9 : \u2200 (n : \u2115) (a : M), zpow\u271d\u00b9 (Int.negSucc n) a = (zpow\u271d\u00b9 (\u2191n.succ) a)\u207b\u00b9\ndiv\u271d\u00b9 : M \u2192 M \u2192 M\ndiv_eq_mul_inv\u271d\u00b9 : \u2200 (a b : M), a / b = a * b\u207b\u00b9\ntoMonoid\u271d : Monoid M\nzpow\u271d : \u2124 \u2192 M \u2192 M\nzpow_zero'\u271d : \u2200 (a : M), zpow\u271d 0 a = 1\nzpow_succ'\u271d : \u2200 (n : \u2115) (a : M), zpow\u271d (\u2191n.succ) a = zpow\u271d (\u2191n) a * a\ninv\u271d : M \u2192 M\nzpow_neg'\u271d : \u2200 (n : \u2115) (a : M), zpow\u271d (Int.negSucc n) a = (zpow\u271d (\u2191n.succ) a)\u207b\u00b9\ndiv\u271d : M \u2192 M \u2192 M\ndiv_eq_mul_inv\u271d : \u2200 (a b : M), a / b = a * b\u207b\u00b9\nh_mul : HMul.hMul = HMul.hMul\nh_inv : Inv.inv = Inv.inv\nh_mon : toMonoid = toMonoid\nh\u2081 : One.one = One.one\nf : M \u2192* M := { toFun := id, map_one' := h\u2081, map_mul' := \u22ef }\nthis\u271d\u00b9 : Monoid.npow = Monoid.npow\nthis\u271d : DivInvMonoid.zpow = DivInvMonoid.zpow\nthis : Div.div = Div.div\n\u22a2 mk div_eq_mul_inv\u271d\u00b9 zpow\u271d\u00b9 zpow_zero'\u271d\u00b9 zpow_succ'\u271d\u00b9 zpow_neg'\u271d\u00b9 =\n    mk div_eq_mul_inv\u271d zpow\u271d zpow_zero'\u271d zpow_succ'\u271d zpow_neg'\u271d",["congr"]],["LinearAlgebra/StdBasis.lean",165,"\u03b9 : Type u_5\nR : Type u_6\nM : Type u_7\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b9 \u2192 M\nw : \u03b9 \u2192 R\n\u22a2 \u2211 x : \u03b9, ((Pi.basisFun R \u03b9).repr w) x \u2022 v x = \u2211 i : \u03b9, w i \u2022 v i",["congr","aesop","tauto","abel","norm_num","simp"]],["LinearAlgebra/StdBasis.lean",112,"case neg.refl\nR : Type u_1\n\u03b7 : Type u_2\n\u03b9s : \u03b7 \u2192 Type u_3\nMs : \u03b7 \u2192 Type u_4\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : (i : \u03b7) \u2192 AddCommMonoid (Ms i)\ninst\u271d\u00b2 : (i : \u03b7) \u2192 Module R (Ms i)\ninst\u271d\u00b9 : Fintype \u03b7\ninst\u271d : DecidableEq \u03b7\ns : (j : \u03b7) \u2192 Basis (\u03b9s j) R (Ms j)\nj : \u03b7\ni : \u03b9s j\nhj : \u00acj = j\n\u22a2 False",["contradiction","aesop","tauto"]],["CategoryTheory/Functor/OfSequence.lean",46,"C : Type u_1\ninst\u271d : Category.{?u.784, u_1} C\nX : \u2115 \u2192 C\nf\u271d : (n : \u2115) \u2192 X n \u27f6 X (n + 1)\nx\u271d\u00b9 : \u2115 \u2192 C\nf : (n : \u2115) \u2192 x\u271d\u00b9 n \u27f6 x\u271d\u00b9 (n + 1)\nl : \u2115\nx\u271d : 0 \u2264 l + 1\n\u22a2 0 \u2264 l",["omega","aesop","simp"]],["CategoryTheory/Functor/OfSequence.lean",138,"C : Type u_1\ninst\u271d : Category.{?u.15919, u_1} C\nF G : \u2115 \u2964 C\napp : (n : \u2115) \u2192 F.obj n \u27f6 G.obj n\nnaturality : \u2200 (n : \u2115), F.map (homOfLE \u22ef) \u226b app (n + 1) = app n \u226b G.map (homOfLE \u22ef)\ni j : \u2115\nhk : j = i + 0\n\u22a2 j = i",["omega","aesop","congr","tauto","assumption"]],["Combinatorics/SimpleGraph/ConcreteColorings.lean",70,"case cons\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nc : G.Coloring Bool\nu\u271d v\u271d u v w : \u03b1\nh : G.Adj u v\np : G.Walk v w\nih : Even p.length \u2194 (c v = true \u2194 c w = true)\nthis : \u00acc u = true \u2194 c v = true\n\u22a2 \u00acEven p.length \u2194 (c u = true \u2194 c w = true)",["tauto"]],["Combinatorics/SimpleGraph/ConcreteColorings.lean",76,"\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nc : G.Coloring Bool\nu v : \u03b1\np : G.Walk u v\n\u22a2 \u00ac(c u = true \u2194 c v = true) \u2194 (\u00acc u = true \u2194 c v = true)",["tauto"]],["Analysis/InnerProductSpace/NormPow.lean",58,"case h.e'_9\nx p : \u211d\nhp : 1 < p\n\u22a2 p * \u2016x\u2016 ^ (p - 2) * x = ((p * \u2016x\u2016 ^ (p - 2)) \u2022 (innerSL \u211d) x) 1",["simp","aesop","norm_num"]],["Probability/Kernel/IonescuTulcea/Maps.lean",124,"\u03b9 : Type u_1\ninst\u271d\u2074 : LinearOrder \u03b9\ninst\u271d\u00b3 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b2 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : (i : \u03b9) \u2192 MeasurableSpace (X i)\na : \u03b9\nx : (n : \u03b9) \u2192 X n\n\u22a2 (fun x i \u21a6 if hi : i \u2264 a then x.1 \u27e8i, \u22ef\u27e9 else x.2 \u27e8i, \u22ef\u27e9) ((fun x \u21a6 (fun i \u21a6 x \u2191i, fun i \u21a6 x \u2191i)) x) = x",["simp","aesop"]],["Algebra/Category/CoalgebraCat/Basic.lean",86,"R : Type u\ninst\u271d : CommRing R\nV W : CoalgebraCat R\nx\u271d\u00b2 x\u271d\u00b9 : V.Hom W\nf g : \u2191V.toModuleCat \u2192\u2097c[R] \u2191W.toModuleCat\nx\u271d : { toCoalgHom' := f }.toCoalgHom' = { toCoalgHom' := g }.toCoalgHom'\n\u22a2 { toCoalgHom' := f } = { toCoalgHom' := g }",["congr","aesop","tauto"]],["Topology/IndicatorConstPointwise.lean",122,"\u03b1 : Type u_1\nA : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\n\u03b9 : Type u_3\nL : Filter \u03b9\nAs : \u03b9 \u2192 Set \u03b1\ninst\u271d\u00b9 : T1Space \u03b2\nb : \u03b2\ninst\u271d : NeZero b\n\u22a2 (\u2200 (x : \u03b1), \u2200\u1da0 (i : \u03b9) in L, x \u2208 As i \u2194 x \u2208 A) \u2194 \u2200 (i : \u03b1), \u2200\u1da0 (x : \u03b9) in L, As x i = (i \u2208 A)",["aesop","omega","tauto","infer_instance"]],["Topology/IndicatorConstPointwise.lean",48,"case h\n\u03b9 : Type u_3\nL : Filter \u03b9\n\u03b2 : Type u_4\np : \u03b9 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nq : Prop\ninst\u271d : Decidable q\na b : \u03b2\nF G : Filter \u03b2\nhaG : {a}\u1d9c \u2208 G\nhbF : {b}\u1d9c \u2208 F\nhaF : \ud835\udcdf {a} \u2264 F\nhbG : \ud835\udcdf {b} \u2264 G\nhq : q\nh : Tendsto (fun i \u21a6 if p i then a else b) L F\ni : \u03b9\nhi : p i \u2227 \u00aca = b\n\u22a2 p i \u2194 q",["tauto","aesop"]],["Topology/IndicatorConstPointwise.lean",53,"case h\n\u03b9 : Type u_3\nL : Filter \u03b9\n\u03b2 : Type u_4\np : \u03b9 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nq : Prop\ninst\u271d : Decidable q\na b : \u03b2\nF G : Filter \u03b2\nhaG : {a}\u1d9c \u2208 G\nhbF : {b}\u1d9c \u2208 F\nhaF : \ud835\udcdf {a} \u2264 F\nhbG : \ud835\udcdf {b} \u2264 G\nhq : \u00acq\nh : Tendsto (fun i \u21a6 if p i then a else b) L G\ni : \u03b9\nhi : \u00acp i \u2227 \u00acb = a\n\u22a2 p i \u2194 q",["tauto","aesop"]],["Control/Applicative.lean",82,"F : Type u \u2192 Type w\nG : Type v \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : Applicative G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 (f <$> pure x).run = (pure (f x)).run",["simp"]],["Control/Applicative.lean",124,"case e_a.e_a.h.h\nF : Type u \u2192 Type w\nG : Type v \u2192 Type u\ninst\u271d\u2077 : Applicative F\ninst\u271d\u2076 : Applicative G\ninst\u271d\u2075 : LawfulApplicative F\ninst\u271d\u2074 : LawfulApplicative G\n\u03b1 \u03b2 \u03b3 : Type v\nf : Type u \u2192 Type w\ng : Type v \u2192 Type u\ninst\u271d\u00b3 : Applicative f\ninst\u271d\u00b2 : Applicative g\ninst\u271d\u00b9 : CommApplicative f\ninst\u271d : CommApplicative g\n\u03b1\u271d \u03b2\u271d : Type v\nx\u271d\u00b9 : Comp f g \u03b1\u271d\nx\u271d : Comp f g \u03b2\u271d\nx : g \u03b2\u271d\ny : g \u03b1\u271d\n\u22a2 flip Prod.mk <$> x <*> y = (fun b a \u21a6 (a, b)) <$> x <*> y",["congr"]],["CategoryTheory/Subpresheaf/Image.lean",153,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\nG : Subpresheaf F\nf : F'' \u27f6 F'\ng : F' \u27f6 F\n\u22a2 G.preimage (f \u226b g) = (G.preimage g).preimage f",["aesop","tauto"]],["CategoryTheory/Subpresheaf/Image.lean",173,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' : C\u1d52\u1d56 \u2964 Type w\nG : Subpresheaf F\np : F' \u27f6 F\n\u22a2 G.preimage p = \u22a4 \u2194 \u22a4 \u2264 G.preimage p",["aesop","simp"]],["Algebra/Category/HopfAlgebraCat/Basic.lean",84,"R : Type u\ninst\u271d : CommRing R\nV W : HopfAlgebraCat R\nx\u271d\u00b2 x\u271d\u00b9 : V.Hom W\nf g : V.carrier \u2192\u2090c[R] W.carrier\nx\u271d : { toBialgHom' := f }.toBialgHom = { toBialgHom' := g }.toBialgHom\n\u22a2 { toBialgHom' := f } = { toBialgHom' := g }",["congr","aesop","tauto"]],["GroupTheory/Archimedean.lean",56,"G : Type u_1\ninst\u271d\u00b9 : LinearOrderedCommGroup G\ninst\u271d : MulArchimedean G\nH : Subgroup G\na : G\na_min : a \u2208 lowerBounds {g | g \u2208 H \u2227 1 < g}\na_in : a \u2208 H\na_pos : 1 < a\ng : G\ng_in : g \u2208 H\nk : \u2124\nright\u271d : \u2200 (y : \u2124), (fun k \u21a6 a ^ k \u2264 g \u2227 g < a ^ (k + 1)) y \u2192 y = k\nnonneg : a ^ k \u2264 g\nlt : g < a ^ (k + 1)\nh\u271d : \u00acg / a ^ k = 1\nh : a \u2264 g / a ^ k\nh' : \u00aca \u2264 g / a ^ k\n\u22a2 False",["contradiction","aesop","tauto"]],["Analysis/Convex/Uniform.lean",87,"E : Type u_1\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : UniformConvexSpace E\n\u03b5 : \u211d\ninst\u271d : NormedSpace \u211d E\nh\u03b5 : 0 < \u03b5\nh\u03b5' : 0 < \u03b5 / 3\n\u03b4 : \u211d\nh\u03b4 : 0 < \u03b4\nh : \u2200 \u2983x : E\u2984, \u2016x\u2016 = 1 \u2192 \u2200 \u2983y : E\u2984, \u2016y\u2016 = 1 \u2192 \u03b5 / 3 \u2264 \u2016x - y\u2016 \u2192 \u2016x + y\u2016 \u2264 2 - \u03b4\n\u03b4' : \u211d := 1 / 2 \u2293 (\u03b5 / 3 \u2293 \u03b4 / 3)\nx : E\nhx : \u2016x\u2016 \u2264 1\ny : E\nhy : \u2016y\u2016 \u2264 1\nhxy : \u03b5 \u2264 \u2016x - y\u2016\nhx' : 1 - \u03b4' < \u2016x\u2016\nhy' : 1 - \u03b4' < \u2016y\u2016\nh\u03b4' : 0 < 1 - \u03b4'\nh\u2081 : \u2200 (z : E), 1 - \u03b4' < \u2016z\u2016 \u2192 \u2016\u2016z\u2016\u207b\u00b9 \u2022 z\u2016 = 1\nh\u2082 : \u2200 (z : E), \u2016z\u2016 \u2264 1 \u2192 1 - \u03b4' \u2264 \u2016z\u2016 \u2192 \u2016\u2016z\u2016\u207b\u00b9 \u2022 z - z\u2016 \u2264 \u03b4'\nx' : E := \u2016x\u2016\u207b\u00b9 \u2022 x\ny' : E := \u2016y\u2016\u207b\u00b9 \u2022 y\nx\u271d\u00b9 x\u271d : E\n\u22a2 x - y = x\u271d\u00b9 - x\u271d + (x - x\u271d\u00b9) + (x\u271d - y)",["abel","aesop","norm_num","simp"]],["Topology/Order/Hom/Basic.lean",93,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2077 : TopologicalSpace \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b2\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b3\ninst\u271d\u00b2 : Preorder \u03b3\ninst\u271d\u00b9 : TopologicalSpace \u03b4\ninst\u271d : Preorder \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\nmonotone'\u271d\u00b9 : Monotone toFun\u271d\u00b9\ncontinuous_toFun\u271d\u00b9 : Continuous { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9 }.toFun\ntoFun\u271d : \u03b1 \u2192 \u03b2\nmonotone'\u271d : Monotone toFun\u271d\ncontinuous_toFun\u271d : Continuous { toFun := toFun\u271d, monotone' := monotone'\u271d }.toFun\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, monotone' := monotone'\u271d, continuous_toFun := continuous_toFun\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, monotone' := monotone'\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 } =\n    { toFun := toFun\u271d, monotone' := monotone'\u271d, continuous_toFun := continuous_toFun\u271d }",["congr","aesop"]],["Data/List/ReduceOption.lean",56,"case mpr\n\u03b1 : Type u_1\nl : List (Option \u03b1)\nw\u271d : \u2115\nh : l = replicate w\u271d none\n\u22a2 \u2200 (a : Option \u03b1), w\u271d \u2260 0 \u2227 a = none \u2192 id a = none",["tauto","aesop","simp"]],["Data/Complex/Order.lean",153,"x : \u211d\nhx : 0 < x\n\u22a2 0 < \u2191x",["positivity","omega","aesop","tauto","infer_instance"]],["Data/Complex/Order.lean",154,"x : \u211d\nhx : 0 \u2264 x\n\u22a2 0 \u2264 \u2191x",["positivity","omega","aesop","tauto","infer_instance"]],["Data/Complex/Order.lean",155,"x : \u211d\nhx : x \u2260 0\n\u22a2 \u2191x \u2260 0",["positivity","omega","aesop","tauto","infer_instance"]],["Data/Complex/Order.lean",39,"z w : \u2102\n\u22a2 (z.re \u2264 w.re \u2227 \u00acw.re \u2264 z.re) \u2227 z.im = w.im \u2194 (z.re \u2264 w.re \u2227 z.im = w.im) \u2227 \u00ac(w.re \u2264 z.re \u2227 w.im = z.im)",["tauto","aesop"]],["CategoryTheory/Sites/LocallyFullyFaithful.lean",132,"C : Type uC\ninst\u271d\u00b3 : Category.{vC, uC} C\nD : Type uD\ninst\u271d\u00b2 : Category.{vD, uD} D\nG\u271d : C \u2964 D\nJ : GrothendieckTopology C\nK : GrothendieckTopology D\nA : Type u_1\ninst\u271d\u00b9 : Category.{?u.15067, u_1} A\nG : C \u2964 D\ninst\u271d : G.Faithful\nU\u271d V\u271d : C\nf\u2081 : U\u271d \u27f6 V\u271d\ne : G.map f\u2081 = G.map f\u2081\n\u22a2 Sieve.functorPushforward G (Sieve.equalizer f\u2081 f\u2081) \u2208 K (G.obj U\u271d)",["simp","omega","aesop","tauto","infer_instance"]],["Algebra/GCDMonoid/Nat.lean",62,"u : \u2124\u02e3\neq : u = -1\n\u22a2 -1 < 0",["decide","omega","aesop","tauto","simp"]],["RingTheory/TwoSidedIdeal/Lattice.lean",92,"case h.e'_3.h\nR : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\n\u03b9 : Type u_2\nI : \u03b9 \u2192 TwoSidedIdeal R\nx\u271d : RingCon R\n\u22a2 (x\u271d \u2208 ringCon '' Set.range fun i \u21a6 I i) \u2194 x\u271d \u2208 Set.range fun i \u21a6 (I i).ringCon",["simp","aesop","norm_num"]],["AlgebraicTopology/DoldKan/NReflectsIso.lean",58,"case h\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nX Y : SimplicialObject C\nf : X \u27f6 Y\ninst\u271d : IsIso (N\u2081.map f)\nh\u2082 : \u2200 (i : \u2115), (inv (N\u2081.map f)).f.f i \u226b PInfty.f i \u226b f.app (op \u298bi\u298c) = PInfty.f i\nh\u2083 :\n  \u2200 (n : \u2115), PInfty.f n \u226b (inv (N\u2081.map f)).f.f n \u226b f.app (op \u298bn\u298c) = (inv (N\u2081.map f)).f.f n \u226b PInfty.f n \u226b f.app (op \u298bn\u298c)\nh\u2081 : \u2200 (i : \u2115), PInfty.f i \u226b f.app (op \u298bi\u298c) \u226b (inv (N\u2081.map f)).f.f i = PInfty.f i\nh\u2081\u2080 : f.app (op \u298b0\u298c) \u226b (inv (N\u2081.map f)).f.f 0 = \ud835\udfd9 (X _\u298b0\u298c)\nh\u2082\u2080 : (inv (N\u2081.map f)).f.f 0 \u226b f.app (op \u298b0\u298c) = \ud835\udfd9 (Y _\u298b0\u298c)\n\u22a2 f.app (op \u298b0\u298c) \u226b (inv (N\u2081.map f)).f.f 0 = \ud835\udfd9 (X _\u298b0\u298c) \u2227 (inv (N\u2081.map f)).f.f 0 \u226b f.app (op \u298b0\u298c) = \ud835\udfd9 (Y _\u298b0\u298c)",["tauto","aesop"]],["Algebra/GroupWithZero/Indicator.lean",60,"\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d : MulZeroOneClass M\u2080\ns t : Set \u03b9\nx\u271d : \u03b9\n\u22a2 (s \u2229 t).indicator 1 x\u271d = (s \u2229 t).indicator (fun j \u21a6 1) x\u271d",["congr","aesop","tauto"]],["Topology/OmegaCompletePartialOrder.lean",132,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : OmegaCompletePartialOrder \u03b2\nf : Scott \u03b1 \u2192 Scott \u03b2\nhf : Continuous f\nh : Monotone f\nc : Chain (Scott \u03b1)\nz : Scott \u03b2\nhf'' : IsOpen (f \u207b\u00b9' notBelow z)\nhf' : (\u00acf (\u03c9Sup c) \u2264 z) = \u03c9Sup (c.map { toFun := fun x \u21a6 \u00acf x \u2264 z, monotone' := \u22ef })\n\u22a2 (\u2203 a, (\u2203 y, \u00acf (c y) \u2264 z \u2194 a) \u2227 a) \u2194 \u2203 x, \u00acf (c x) \u2264 z",["tauto"]],["Topology/Separation/Profinite.lean",60,"case h\nX : Type u_1\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : CompactSpace X\ninst\u271d : TotallyDisconnectedSpace X\nx : X\nU : Set X\nhxU : x \u2208 U\nU_op : IsOpen U\nthis : U \u2208 \ud835\udcdd x\nV : Set X\nhVU : V \u2286 U\nhxV : x \u2208 V\nhV : IsClopen V\n\u22a2 (V \u2208 fun U \u21a6 IsClosed U \u2227 IsOpen U) \u2227 x \u2208 V \u2227 V \u2286 U",["tauto","aesop"]],["Algebra/Homology/ShortComplex/Ab.lean",151,"S : ShortComplex Ab\n\u22a2 (AddCommGrp.Hom.hom S.f).range = (AddCommGrp.Hom.hom S.g).ker \u2194\n    (ConcreteCategory.hom S.g).ker = (ConcreteCategory.hom S.f).range",["tauto","aesop"]],["Logic/Equiv/Fintype.lean",74,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 \u2191(f.toEquivRange (e (f.toEquivRange.symm \u27e8b, ?h\u27e9))) = f (e (\u22ef.invOfMemRange \u27e8b, h\u27e9))\n```\n---\n```lean\ncase h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 b \u2208 Set.range \u21d1f",["congr","aesop","tauto"]],["Combinatorics/Young/SemistandardTableau.lean",68,"case mk.mk\n\u03bc : YoungDiagram\nentry\u271d\u00b9 : \u2115 \u2192 \u2115 \u2192 \u2115\nrow_weak'\u271d\u00b9 : \u2200 {i j1 j2 : \u2115}, j1 < j2 \u2192 (i, j2) \u2208 \u03bc \u2192 entry\u271d\u00b9 i j1 \u2264 entry\u271d\u00b9 i j2\ncol_strict'\u271d\u00b9 : \u2200 {i1 i2 j : \u2115}, i1 < i2 \u2192 (i2, j) \u2208 \u03bc \u2192 entry\u271d\u00b9 i1 j < entry\u271d\u00b9 i2 j\nzeros'\u271d\u00b9 : \u2200 {i j : \u2115}, (i, j) \u2209 \u03bc \u2192 entry\u271d\u00b9 i j = 0\nentry\u271d : \u2115 \u2192 \u2115 \u2192 \u2115\nrow_weak'\u271d : \u2200 {i j1 j2 : \u2115}, j1 < j2 \u2192 (i, j2) \u2208 \u03bc \u2192 entry\u271d i j1 \u2264 entry\u271d i j2\ncol_strict'\u271d : \u2200 {i1 i2 j : \u2115}, i1 < i2 \u2192 (i2, j) \u2208 \u03bc \u2192 entry\u271d i1 j < entry\u271d i2 j\nzeros'\u271d : \u2200 {i j : \u2115}, (i, j) \u2209 \u03bc \u2192 entry\u271d i j = 0\nh :\n  { entry := entry\u271d\u00b9, row_weak' := row_weak'\u271d\u00b9, col_strict' := col_strict'\u271d\u00b9, zeros' := zeros'\u271d\u00b9 }.entry =\n    { entry := entry\u271d, row_weak' := row_weak'\u271d, col_strict' := col_strict'\u271d, zeros' := zeros'\u271d }.entry\n\u22a2 { entry := entry\u271d\u00b9, row_weak' := row_weak'\u271d\u00b9, col_strict' := col_strict'\u271d\u00b9, zeros' := zeros'\u271d\u00b9 } =\n    { entry := entry\u271d, row_weak' := row_weak'\u271d, col_strict' := col_strict'\u271d, zeros' := zeros'\u271d }",["congr","aesop"]],["Data/ZMod/Units.lean",68,"case neg\nn m : \u2115\nhm : NeZero m\nh\u271d : n \u2223 m\nx : \u2115\nhx : x.Coprime n\nps : Finset \u2115 := Finset.filter (fun p \u21a6 \u00acp \u2223 x) m.primeFactors\np : \u2115\npp : Nat.Prime p\nhp : p \u2223 x + ps.prod id * n\nhpn : p \u2223 m\nhpx : \u00acp \u2223 x\npps : p \u2208 ps\nh : p \u2223 x\n\u22a2 False",["contradiction","omega","aesop","tauto"]],["LinearAlgebra/QuadraticForm/QuadraticModuleCat.lean",71,"R : Type u\ninst\u271d : CommRing R\nV W : QuadraticModuleCat R\nx\u271d\u00b2 x\u271d\u00b9 : V.Hom W\nf g : V.form \u2192q\u1d62 W.form\nx\u271d : { toIsometry' := f }.toIsometry = { toIsometry' := g }.toIsometry\n\u22a2 { toIsometry' := f } = { toIsometry' := g }",["congr","aesop","tauto"]],["Topology/Instances/Rat.lean",56,"x y : \u2115\n\u22a2 dist \u2191\u2191x \u2191\u2191y = dist \u2191x \u2191y",["congr","aesop","tauto","abel","norm_num","simp"]],["Topology/Instances/Rat.lean",72,"x y : \u2124\n\u22a2 dist \u2191\u2191x \u2191\u2191y = dist \u2191x \u2191y",["congr","aesop","tauto","abel","norm_num","simp"]],["Algebra/Group/Subsemigroup/Membership.lean",73,"M : Type u_2\ninst\u271d : Mul M\nS T : Subsemigroup M\nthis : S \u2264 S \u2294 T\n\u22a2 \u2200 {x : M}, x \u2208 S \u2192 x \u2208 S \u2294 T",["tauto","aesop","congr","assumption"]],["Algebra/Group/Subsemigroup/Membership.lean",78,"M : Type u_2\ninst\u271d : Mul M\nS T : Subsemigroup M\nthis : T \u2264 S \u2294 T\n\u22a2 \u2200 {x : M}, x \u2208 T \u2192 x \u2208 S \u2294 T",["tauto","aesop","congr","assumption"]],["Algebra/Group/Subsemigroup/Membership.lean",87,"\u03b9 : Sort u_1\nM : Type u_2\ninst\u271d : Mul M\nS : \u03b9 \u2192 Subsemigroup M\ni : \u03b9\nthis : S i \u2264 iSup S\n\u22a2 \u2200 {x : M}, x \u2208 S i \u2192 x \u2208 iSup S",["tauto","aesop","congr","assumption"]],["Algebra/Group/Subsemigroup/Membership.lean",93,"M : Type u_2\ninst\u271d : Mul M\nS : Set (Subsemigroup M)\ns : Subsemigroup M\nhs : s \u2208 S\nthis : s \u2264 sSup S\n\u22a2 \u2200 {x : M}, x \u2208 s \u2192 x \u2208 sSup S",["tauto","aesop","congr","assumption"]],["LinearAlgebra/Quotient/Pi.lean",55,"case h\u2081\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u2076 : CommRing R\nMs : \u03b9 \u2192 Type u_3\ninst\u271d\u2075 : (i : \u03b9) \u2192 AddCommGroup (Ms i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Module R (Ms i)\nN : Type u_4\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\np : (i : \u03b9) \u2192 Submodule R (Ms i)\nq : Submodule R N\nf : (i : \u03b9) \u2192 Ms i \u2192\u2097[R] N\nhf : \u2200 (i : \u03b9), p i \u2264 comap (f i) q\ni : \u03b9\nx : Ms i \u29f8 p i\na\u271d : i \u2209 Finset.univ\nthis : i \u2208 Finset.univ\n\u22a2 ((p i).mapQ q (f i) \u22ef) (Pi.single i x i) = 0",["contradiction","aesop","tauto"]],["Computability/NFA.lean",136,"case cons\n\u03b1 : Type u\n\u03c3 : Type v\nM : DFA \u03b1 \u03c3\na : \u03b1\ns : List \u03b1\nih : \u2200 (start : \u03c3), List.foldl M.toNFA.stepSet {start} s = {List.foldl M.step start s}\nstart : \u03c3\n\u22a2 List.foldl M.toNFA.stepSet {M.step start a} s = {List.foldl M.step (M.step start a) s}",["tauto","omega","aesop","infer_instance"]],["NumberTheory/NumberField/Discriminant/Defs.lean",80,"b : Basis (Fin 1) \u2124 (\ud835\udcde \u211a) := (Basis.singleton (Fin 1) \u2124).map ringOfIntegersEquiv.toAddEquiv.toIntLinearEquiv.symm\n\u22a2 ((Algebra.leftMulMatrix b) 1).trace = 1",["norm_num","aesop","simp"]],["Algebra/Order/Group/Finset.lean",24,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\nh : 0 \u2260 0\n\u22a2 (0 \u2022 s).toFinset = s.toFinset",["contradiction","omega","aesop","tauto"]],["Analysis/Polynomial/CauchyBound.lean",79,"K : Type u_1\ninst\u271d : NormedDivisionRing K\np : K[X]\nhp : p \u2260 0\na : K\nh : \u2016p.leadingCoeff\u2016\u208a * \u2016a\u2016\u208a ^ p.natDegree = \u2016\u2211 i \u2208 range p.natDegree, p.coeff i * a ^ i\u2016\u208a\nha : \u2016a\u2016\u208a = 1\nthis : 1 \u2264 (p.cauchyBound - 1) * \u2191p.natDegree\n\u22a2 1 \u2264 p.cauchyBound",["simp","aesop","norm_num"]],["NumberTheory/NumberField/ProductFormula.lean",61,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nx : \ud835\udcde K\nh_x_nezero : x \u2260 0\nh_span_nezero : span {x} \u2260 0\nt\u2080 : Set (HeightOneSpectrum (\ud835\udcde K)) := {v | x \u2208 v.asIdeal}\nh_fin\u2080 : t\u2080.Finite\nt\u2081 : Set (HeightOneSpectrum (\ud835\udcde K)) := mulSupport fun v \u21a6 \u2016(embedding v) \u2191x\u2016\nt\u2082 : Set (HeightOneSpectrum (\ud835\udcde K)) := mulSupport fun v \u21a6 \u2191(absNorm (v.maxPowDividing (span {x})))\nh_fin\u2081 : t\u2081.Finite\nv : HeightOneSpectrum (\ud835\udcde K)\nhv :\n  \u2191(absNorm v.asIdeal) ^ (Associates.mk v.asIdeal).count (Associates.mk (span {x})).factors \u2260 \u2191(absNorm v.asIdeal) ^ 0\nh : (Associates.mk v.asIdeal).count (Associates.mk (span {x})).factors = 0\n\u22a2 \u2191(absNorm v.asIdeal) ^ (Associates.mk v.asIdeal).count (Associates.mk (span {x})).factors = \u2191(absNorm v.asIdeal) ^ 0",["congr","aesop","tauto"]],["CategoryTheory/Limits/Shapes/Pullback/Square.lean",122,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nsq : Square C\nh : sq.IsPullback\ninst\u271d : Mono sq.f\u2083\u2084\n\u22a2 Mono sq.f\u2083\u2084",["infer_instance","omega","aesop","congr","gcongr","tauto","assumption"]],["CategoryTheory/Limits/Shapes/Pullback/Square.lean",139,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nsq : Square C\nh : sq.IsPushout\ninst\u271d : Epi sq.f\u2081\u2082\n\u22a2 Epi sq.f\u2081\u2082",["infer_instance","omega","aesop","congr","gcongr","tauto","assumption"]],["CategoryTheory/Limits/Shapes/Pullback/Square.lean",119,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nsq : Square C\nh : sq.IsPullback\ninst\u271d : Mono sq.f\u2082\u2084\n\u22a2 MorphismProperty.monomorphisms C sq.f\u2082\u2084",["assumption","omega","aesop","congr","tauto","infer_instance"]],["CategoryTheory/Limits/Shapes/Pullback/Square.lean",136,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nsq : Square C\nh : sq.IsPushout\ninst\u271d : Epi sq.f\u2081\u2083\n\u22a2 MorphismProperty.epimorphisms C sq.f\u2081\u2083",["assumption","omega","aesop","congr","tauto","infer_instance"]],["Data/Nat/PrimeFin.lean",91,"case h\na b : \u2115\nha : a \u2260 0\nhb : b \u2260 0\na\u271d : \u2115\n\u22a2 Prime a\u271d \u2227 a\u271d \u2223 a \u2227 a\u271d \u2223 b \u2194 (Prime a\u271d \u2227 a\u271d \u2223 a) \u2227 Prime a\u271d \u2227 a\u271d \u2223 b",["aesop","tauto"]],["CategoryTheory/Localization/Bousfield.lean",133,"case mpr\nC : Type u_1\nD : Type u_2\ninst\u271d\u00b3 : Category.{u_4, u_1} C\ninst\u271d\u00b2 : Category.{u_3, u_2} D\nF : C \u2964 D\nG : D \u2964 C\nadj : G \u22a3 F\ninst\u271d\u00b9 : F.Full\ninst\u271d : F.Faithful\nX Y : D\nf : X \u27f6 Y\na\u271d : IsIso (G.map f)\n\u22a2 IsIso (F.map (G.map f))",["infer_instance","omega","tauto"]],["Tactic/Positivity/Finset.lean",94,"\u03b1 : Type u_1\ns : Finset \u03b1\n\u22a2 0 \u2264 #s",["positivity","omega","aesop","norm_num","simp"]],["Tactic/Positivity/Finset.lean",99,"\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\n\u22a2 0 \u2264 Fintype.card \u03b1",["positivity","omega","aesop","norm_num","simp"]],["Tactic/Positivity/Finset.lean",100,"\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\n\u22a2 0 \u2264 s.dens",["positivity","aesop","norm_num","simp"]],["Tactic/Positivity/Finset.lean",105,"\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 0 < univ.dens",["positivity","aesop","norm_num","simp"]],["Tactic/Positivity/Finset.lean",106,"\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 univ.dens \u2260 0",["positivity","aesop","norm_num","simp"]],["Tactic/Positivity/Finset.lean",111,"\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\nG : Type u_2\nA : Finset G\nf\u271d : G \u2192 \u2115 := fun x \u21a6 1\na\u271d : \u2200 (s : G), f\u271d s ^ 2 = 1\n\u22a2 0 \u2264 #A",["positivity","omega","aesop","norm_num","simp"]],["LinearAlgebra/FreeModule/ModN.lean",25,"G : Type u_1\nH : Type u_2\nM : Type u_3\ninst\u271d : AddCommGroup G\nn : \u2115\n\u22a2 \u2200 (x : G), n \u2022 x \u2208 (LinearMap.range ((LinearMap.lsmul \u2124 G) \u2191n)).toAddSubgroup",["simp","aesop","norm_num"]],["LinearAlgebra/FreeModule/ModN.lean",42,"G : Type u_1\nH : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup G\nn : \u2115\ninst\u271d : AddMonoid M\n\u03c6 : { \u03c6 // \u2200 (g : G), n \u2022 \u03c6 g = 0 }\n\u22a2 (fun f \u21a6 \u27e8f.comp (QuotientAddGroup.mk' (LinearMap.range ((LinearMap.lsmul \u2124 G) \u2191n)).toAddSubgroup), \u22ef\u27e9)\n      ((fun \u03c6 \u21a6 QuotientAddGroup.lift (LinearMap.range ((LinearMap.lsmul \u2124 G) \u2191n)).toAddSubgroup \u2191\u03c6 \u22ef) \u03c6) =\n    \u03c6",["aesop","congr","tauto"]],["Data/Real/Pi/Wallis.lean",61,"case zero\n\u22a2 1 = 1 * \u21911 ^ 4 / (\u21911 ^ 2 * (2 * \u21910 + 1))",["norm_num","ring","aesop","linarith","simp"]],["Data/Real/Pi/Wallis.lean",97,"case e_a\nthis : \ud835\udcdd (\u03c0 / 2) = \ud835\udcdd ((1 - 0) * (\u03c0 / 2))\nn : \u2115\n\u22a2 2 * \u2191n + 1 = 2 * \u2191n + 2 - 1",["ring","omega","linarith","tauto","infer_instance"]],["Analysis/Meromorphic/Divisor/MeromorphicFunction.lean",52,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nU\u271d : Set \ud835\udd5c\nz : \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : CompleteSpace E\nf : \ud835\udd5c \u2192 E\nU : Set \ud835\udd5c\nhf : MeromorphicOn f U\n\u22a2 \u2200 (a : \ud835\udd5c), (\u2203 (x : a \u2208 U), \u22ef.order = 0 \u2228 \u22ef.order = \u22a4) \u2192 \u2200 (h : MeromorphicOn f U \u2227 a \u2208 U), \u22ef.order = 0 \u2228 \u22ef.order = \u22a4",["tauto","aesop"]],["NumberTheory/ModularForms/LevelOne.lean",92,"case intro\ng : ModularForm \u0393(1) 0\nc' : \u2102\nhc' : \u21d1g = Function.const \u210d c'\n\u22a2 \u2203 c, c \u2022 const 1 = g",["aesop","omega","tauto","infer_instance"]],["Topology/ContinuousMap/Defs.lean",73,"case mk.mk\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ntoFun\u271d\u00b9 : X \u2192 Y\ncontinuous_toFun\u271d\u00b9 : Continuous toFun\u271d\u00b9\ntoFun\u271d : X \u2192 Y\ncontinuous_toFun\u271d : Continuous toFun\u271d\nh :\n  { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun =\n    { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }.toFun\n\u22a2 { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 } =\n    { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }",["congr","aesop"]],["Topology/Hom/Open.lean",66,"case mk.mk.mk.mk\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\ntoFun\u271d\u00b9 : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d\u00b9 : Continuous toFun\u271d\u00b9\nmap_open'\u271d\u00b9 : IsOpenMap { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9 }.toFun\ntoFun\u271d : \u03b1 \u2192 \u03b2\ncontinuous_toFun\u271d : Continuous toFun\u271d\nmap_open'\u271d : IsOpenMap { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d }.toFun\nh :\n  (fun f \u21a6 f.toFun) { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, map_open' := map_open'\u271d\u00b9 } =\n    (fun f \u21a6 f.toFun) { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, map_open' := map_open'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, continuous_toFun := continuous_toFun\u271d\u00b9, map_open' := map_open'\u271d\u00b9 } =\n    { toFun := toFun\u271d, continuous_toFun := continuous_toFun\u271d, map_open' := map_open'\u271d }",["congr","aesop"]],["LinearAlgebra/QuadraticForm/Real.lean",39,"\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nw : \u03b9 \u2192 \u211d\nu : \u03b9 \u2192 \u211d\u02e3 := fun i \u21a6 if h : w i = 0 then 1 else Units.mk0 (w i) h\ni : \u03b9\nthis : \u2191(u i) \u2260 0\n\u22a2 1 / \u221a|\u2191(u i)| \u2260 0",["positivity","aesop","norm_num","simp"]],["Algebra/Star/Subsemiring.lean",34,"case mk.mk.mk.mk.mk\nR : Type v\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : StarRing R\ncarrier\u271d : Set R\nmul_mem'\u271d : \u2200 {a b : R}, a \u2208 carrier\u271d \u2192 b \u2208 carrier\u271d \u2192 a * b \u2208 carrier\u271d\none_mem'\u271d : 1 \u2208 { carrier := carrier\u271d, mul_mem' := mul_mem'\u271d }.carrier\nadd_mem'\u271d :\n  \u2200 {a b : R},\n    a \u2208 { carrier := carrier\u271d, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d }.carrier \u2192\n      b \u2208 { carrier := carrier\u271d, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d }.carrier \u2192\n        a + b \u2208 { carrier := carrier\u271d, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d }.carrier\nzero_mem'\u271d : 0 \u2208 { carrier := carrier\u271d, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d }.carrier\nstar_mem'\u271d\u00b9 :\n  \u2200 {a : R},\n    a \u2208\n        { carrier := carrier\u271d, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d, add_mem' := add_mem'\u271d,\n            zero_mem' := zero_mem'\u271d }.carrier \u2192\n      star a \u2208\n        { carrier := carrier\u271d, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d, add_mem' := add_mem'\u271d,\n            zero_mem' := zero_mem'\u271d }.carrier\ntoSubsemiring\u271d : Subsemiring R\nstar_mem'\u271d : \u2200 {a : R}, a \u2208 toSubsemiring\u271d.carrier \u2192 star a \u2208 toSubsemiring\u271d.carrier\nh : (fun {s} \u21a6 s.carrier) = fun {s} \u21a6 s.carrier\n\u22a2 { carrier := carrier\u271d, mul_mem' := mul_mem'\u271d, one_mem' := one_mem'\u271d, add_mem' := add_mem'\u271d, zero_mem' := zero_mem'\u271d,\n      star_mem' := star_mem'\u271d\u00b9 } =\n    { toSubsemiring := toSubsemiring\u271d, star_mem' := star_mem'\u271d }",["congr","aesop"]],["Analysis/Hofer.lean",31,"X : Type u_1\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : CompleteSpace X\nx : X\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\n\u03d5 : X \u2192 \u211d\ncont : Continuous \u03d5\nnonneg : \u2200 (y : X), 0 \u2264 \u03d5 y\nH : \u00ac\u2203 \u03b5' > 0, \u2203 x', \u03b5' \u2264 \u03b5 \u2227 d x' x \u2264 2 * \u03b5 \u2227 \u03b5 * \u03d5 x \u2264 \u03b5' * \u03d5 x' \u2227 \u2200 (y : X), d x' y \u2264 \u03b5' \u2192 \u03d5 y \u2264 2 * \u03d5 x'\nx' : X\nk : \u2115\n\u22a2 0 < 2 ^ k",["positivity","aesop","norm_num","simp"]],["Algebra/Lie/Derivation/AdjointAction.lean",53,"case h\nR : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nx x\u271d : L\n\u22a2 \u2191((ad R L) x) x\u271d = ((LieAlgebra.ad R L) x) x\u271d",["simp","aesop","norm_num"]],["Algebra/Lie/Derivation/AdjointAction.lean",80,"R : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\n\u22a2 \u2200 (x : LieDerivation R L L) (y : L), \u2203 z, (ad R L) (x y) = (ad R L) z",["tauto","omega","aesop","norm_num","simp"]],["Algebra/MvPolynomial/Supported.lean",42,"\u03c3 : Type u_1\nR : Type u\ninst\u271d : CommSemiring R\ns : Set \u03c3\n\u22a2 (aeval fun x \u21a6 X \u2191x).range = (aeval (X \u2218 Subtype.val)).range",["congr","aesop","tauto"]],["Analysis/Normed/Affine/Convex.lean",54,"E\u271d : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b3 : NormedSpace \u211d E\u271d\ns\u271d : Set E\u271d\nx : E\u271d\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Set E\nhs : s \u2208 \ud835\udcdd 0\n\u22a2 Fintype.card (Fin (finrank \u211d E + 1)) = finrank \u211d E + 1",["simp","aesop","norm_num"]],["Data/Finsupp/AList.lean",71,"case h.e'_3\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Zero M\ninst\u271d : DecidableEq \u03b1\nl : AList fun _x \u21a6 M\na : \u03b1\n\u22a2 (lookup a l).getD 0 = l.lookupFinsupp a",["congr"]],["Algebra/Group/Nat/Even.lean",98,"m n : \u2115\n\u22a2 \u00acEven 25394535",["decide","omega","infer_instance"]],["CategoryTheory/Widesubcategory.lean",70,"case mk.mk\nC : Type u\u2081\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} D\nF : C \u2192 D\nP : MorphismProperty D\ninst\u271d : P.IsMultiplicative\nX Y : InducedWideCategory D F P\nval\u271d\u00b9 : F X \u27f6 F Y\nproperty\u271d\u00b9 : val\u271d\u00b9 \u2208 {f | P f}\nval\u271d : F X \u27f6 F Y\nproperty\u271d : val\u271d \u2208 {f | P f}\neq : (wideInducedFunctor F P).map \u27e8val\u271d\u00b9, property\u271d\u00b9\u27e9 = (wideInducedFunctor F P).map \u27e8val\u271d, property\u271d\u27e9\n\u22a2 \u27e8val\u271d\u00b9, property\u271d\u00b9\u27e9 = \u27e8val\u271d, property\u271d\u27e9",["aesop","congr"]],["Topology/Instances/CantorSet.lean",81,"n : \u2115\n\u22a2 1 / 3 \u2260 0",["norm_num","aesop","linarith","positivity","simp"]],["NumberTheory/Zsqrtd/QuadraticReciprocity.lean",81,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhp3 : p % 4 = 3\nhpi : \u00acIrreducible \u2191p\na b : \u2115\nhab : a ^ 2 + b ^ 2 = p\nthis : \u2200 (a b : ZMod 4), a ^ 2 + b ^ 2 \u2260 \u2191p\n\u22a2 \u2191a ^ 2 + \u2191b ^ 2 = \u2191(a ^ 2 + b ^ 2)",["simp","aesop","norm_num"]],["NumberTheory/Zsqrtd/QuadraticReciprocity.lean",72,"case intro.intro.intro\np : \u2115\nhp : Fact (Nat.Prime p)\nhpi : Prime \u2191p\nhp1 : p % 2 = 1\nhp3 : p % 4 \u2260 3\nhp41 : p % 4 = 1\nk : \u2115\nk_lt_p : k < p\nhk : -1 = \u2191k * \u2191k\nhkmul : \u2191k ^ 2 + 1 = { re := \u2191k, im := 1 } * { re := \u2191k, im := -1 }\nhkltp : 1 + k * k < p * p\nhpk\u2081 : \u00ac\u2191p \u2223 { re := \u2191k, im := -1 }\nhpk\u2082 : \u00ac\u2191p \u2223 { re := \u2191k, im := 1 }\ny : \u2115\nhy : k ^ 2 + 1 = p * y\nthis : \u2191p \u2223 { re := \u2191k, im := 1 } \u2228 \u2191p \u2223 { re := \u2191k, im := -1 }\n\u22a2 False",["tauto","aesop"]],["NumberTheory/Zsqrtd/QuadraticReciprocity.lean",39,"p : \u2115\nhp : Fact (Nat.Prime p)\nhpi : Prime \u2191p\nhp1 : p % 2 = 1\nhp3 : p % 4 \u2260 3\nhp41 : p % 4 = 1\n\u22a2 1 \u2260 3",["decide","omega","aesop","linarith","tauto","norm_num","simp"]],["NumberTheory/Zsqrtd/QuadraticReciprocity.lean",80,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhp3 : p % 4 = 3\nhpi : \u00acIrreducible \u2191p\na b : \u2115\nhab : a ^ 2 + b ^ 2 = p\n\u22a2 \u2200 (a b : ZMod 4), a ^ 2 + b ^ 2 \u2260 \u21913",["decide"]],["RingTheory/Algebraic/Defs.lean",54,"case a.h.a\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nx : A\na\u271d : R[X]\n\u22a2 \u00ac(a\u271d \u2260 0 \u2227 (aeval x) a\u271d = 0) \u2194 (aeval x) a\u271d = 0 \u2192 a\u271d = 0",["tauto","aesop"]],["Data/List/Perm/Lattice.lean",90,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : ys.Nodup\nh'' : n \u2264 xs.length\nn' : \u2115 := xs.length - n\nh\u2080 : n = xs.length - n'\nh\u2081 : drop n xs = (take n' xs.reverse).reverse\n\u22a2 xs ~ ys",["assumption","omega","congr","gcongr","tauto","infer_instance"]],["Topology/Homotopy/Contractible.lean",106,"case h.h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : ContractibleSpace X\np : X\nh : (ContinuousMap.id X).Homotopy (const X p)\nthis : \u2200 (x : X), Joined p x\nx\u271d : X\n\u22a2 x\u271d \u2208 pathComponent p \u2194 x\u271d \u2208 Set.univ",["tauto","omega","aesop"]],["GroupTheory/FixedPointFree.lean",78,"F : Type u_1\nG : Type u_2\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : FunLike F G G\ninst\u271d\u00b9 : MonoidHomClass F G G\n\u03c6 : F\ninst\u271d : Finite G\nh\u03c6 : FixedPointFree \u21d1\u03c6\nh2 : Function.Involutive \u21d1\u03c6\ng : G\nhg : 1 = 2\nkey : \u03c6 g = g\n\u22a2 False",["contradiction","omega","aesop","tauto","infer_instance"]],["Data/Real/Sign.lean",42,"\u22a2 0 < 1",["norm_num","aesop","positivity","simp"]],["Data/Real/Sign.lean",94,"case inl\nr : \u211d\nhn : r.sign = -1\n\u22a2 (-1)\u207b\u00b9 = -1",["norm_num","omega","tauto","infer_instance"]],["Analysis/Convex/SpecificFunctions/Pow.lean",88,"\u22a2 1 / 2 < 1",["linarith","omega","tauto","infer_instance","norm_num"]],["Algebra/Ring/NegOnePow.lean",64,"case mp\nn : \u2124\nh' : Odd n\nh : -1 = 1\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/Ring/NegOnePow.lean",73,"case mp\nn : \u2124\nh : 1 = -1\nh' : Even n\n\u22a2 False",["contradiction","aesop","tauto"]],["Algebra/Ring/NegOnePow.lean",97,"case pos\nn\u2081 n\u2082 : \u2124\nh\u2082 : Even n\u2082\n\u22a2 Even n\u2081 \u2194 (Even n\u2081 \u2194 Even n\u2082)",["tauto","aesop"]],["Algebra/Ring/NegOnePow.lean",101,"case neg\nn\u2081 n\u2082 : \u2124\nh\u2082 : Odd n\u2082\n\u22a2 Odd n\u2081 \u2194 (\u00acOdd n\u2081 \u2194 \u00acOdd n\u2082)",["tauto"]],["Algebra/Ring/Rat.lean",90,"q : \u211a\nthis : q * (\u2191q.den /. 1) = q.num /. 1\n\u22a2 q * (\u2191q.den /. 1) = q.num /. 1",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Group/Int/Even.lean",70,"case succ\nm : \u2124\nn\u271d : \u2115\na\u271d : Even (m ^ n\u271d) \u2194 Even m \u2227 n\u271d \u2260 0\n\u22a2 Even m \u2192 \u00acn\u271d = 0 \u2192 Even m",["tauto","aesop"]],["Algebra/Group/Int/Even.lean",87,"m n : \u2124\n\u22a2 \u00acEven 25394535",["decide","tauto"]],["Analysis/Normed/Group/Completeness.lean",41,"\u03b1 : Type u_1\ninst\u271d : PseudoMetricSpace \u03b1\nu : \u2115 \u2192 \u03b1\nhu : CauchySeq u\nn : \u2115\n\u22a2 0 < (fun n \u21a6 (1 / 2) ^ n) n",["positivity","aesop","norm_num","simp"]],["Algebra/Order/Archimedean/IndicatorCard.lean",71,"case h\n\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : OrderedAddCommMonoid R\ninst\u271d\u00b9 : AddLeftStrictMono R\ninst\u271d : Archimedean R\nr : R\nh : 0 < r\ns : \u2115 \u2192 Set \u03b1\n\u03c9 : \u03b1\n\u22a2 Tendsto (fun n \u21a6 \u2211 k \u2208 Finset.range n, {n | \u03c9 \u2208 s n}.indicator (fun x \u21a6 r) k) atTop atTop =\n    Tendsto (fun n \u21a6 \u2211 k \u2208 Finset.range n, (s k).indicator (fun x \u21a6 r) \u03c9) atTop atTop",["congr","aesop","tauto"]],["Algebra/ContinuedFractions/Determinant.lean",65,"K : Type u_1\ninst\u271d : Field K\ns : SimpContFract K\nn\u271d n : \u2115\nhyp : n + 1 = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n + 1 - 1)\ng : GenContFract K := \u2191s\nconts : Pair K := g.contsAux (n + 2)\npred_conts : Pair K := g.contsAux (n + 1)\npred_conts_eq : pred_conts = g.contsAux (n + 1)\nppred_conts : Pair K := g.contsAux n\nIH : n = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n - 1) \u2192 ppred_conts.a * pred_conts.b - ppred_conts.b * pred_conts.a = (-1) ^ n\nppred_conts_eq : ppred_conts = g.contsAux n\npA : K := pred_conts.a\npB : K := pred_conts.b\nppA : K := ppred_conts.a\nppB : K := ppred_conts.b\nnot_terminated_at_n : \u00acg.TerminatedAt n\ngp : Pair K\ns_nth_eq : g.s.get? n = some gp\nthis : pA * ppB - pB * ppA = (-1) ^ (n + 1)\n\u22a2 pA * ppB - pB * ppA = (-1) ^ (n + 1)",["assumption","aesop","congr","gcongr","tauto"]],["Algebra/Ring/CharZero.lean",29,"\u03b1 : Type u_1\nR : Type u_2\nS : Type u_3\nn : \u2115\ninst\u271d\u00b9 : AddMonoidWithOne R\ninst\u271d : CharZero R\n\u22a2 2 \u2260 0",["decide","omega","aesop","tauto","simp"]],["Data/Set/Constructions.lean",65,"\u03b1 : Type u_1\nS : Set (Set \u03b1)\nA : Set \u03b1\ncond : FiniteInter S\nP s\u271d : Set \u03b1\nh\u271d : s\u271d \u2208 S\n\u22a2 s\u271d \u2208 S",["assumption","aesop","congr","gcongr","tauto"]],["Data/Set/Enumerate.lean",85,"case intro.succ.some\n\u03b1 : Type u_1\nsel : Set \u03b1 \u2192 Option \u03b1\na : \u03b1\nh_sel : \u2200 (s : Set \u03b1) (a : \u03b1), sel s = some a \u2192 a \u2208 s\nm k : \u2115\ns : Set \u03b1\nval\u271d : \u03b1\nih : \u2200 {s : Set \u03b1}, enumerate sel s k = some a \u2192 enumerate sel s (k + m) = some a \u2192 m = 0\nh\u2081 : enumerate sel (s \\ {val\u271d}) k = some a\nh\u2082 : enumerate sel (s \\ {val\u271d}) (k + m) = some a\nh : sel s = some val\u271d\n\u22a2 m = 0",["tauto","aesop"]],["Combinatorics/SimpleGraph/Girth.lean",58,"\u03b1 : Type u_1\n\u22a2 \u22a5.egirth = \u22a4",["simp","aesop","norm_num"]],["Combinatorics/SimpleGraph/Girth.lean",88,"case intro.intro\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\nh : \u00acG.IsAcyclic\nw\u271d\u00b9 : \u03b1\nw\u271d : G.Walk w\u271d\u00b9 w\u271d\u00b9\nh\u271d : w\u271d.IsCycle \u2227 G.egirth = \u2191w\u271d.length\n\u22a2 \u2203 a w, w.IsCycle \u2227 w\u271d.length = w.length",["tauto","aesop"]],["NumberTheory/Harmonic/Bounds.lean",48,"n : \u2115\nhn0 : \u00acn = 0\nhn : 1 \u2264 n\n\u22a2 1 < \u21912",["norm_num","aesop","simp"]],["Data/Finset/PImage.lean",87,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b2\nf : \u03b1 \u2192. \u03b2\ninst\u271d : (x : \u03b1) \u2192 Decidable (f x).Dom\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 pimage f \u2205 \u2194 a\u271d \u2208 \u2205",["simp","aesop","tauto"]],["Order/Filter/Ker.lean",31,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Filter \u03b1\ns : Set \u03b1\na : \u03b1\n\u22a2 \u2200 (a : Set \u03b1) (x : \u03b1), (\u2200 (s : Set \u03b1), (\u2200 x \u2208 a, x \u2208 s) \u2192 x \u2208 s) \u2192 x \u2208 a",["aesop","tauto"]],["Logic/Lemmas.lean",20,"a b c : Prop\n\u22a2 ((a \u2194 b) \u2194 c) \u2194 (a \u2194 (b \u2194 c))",["tauto"]],["Logic/Lemmas.lean",21,"a b c : Prop\n\u22a2 (a \u2194 (b \u2194 c)) \u2194 (b \u2194 (a \u2194 c))",["tauto"]],["Logic/Lemmas.lean",22,"a b c : Prop\n\u22a2 ((a \u2194 b) \u2194 c) \u2194 ((a \u2194 c) \u2194 b)",["tauto"]],["Topology/Category/CompHausLike/EffectiveEpi.lean",53,"P : TopCat \u2192 Prop\nB X : CompHausLike P\n\u03c0 : X \u27f6 B\nh\u03c0 : Function.Surjective \u21d1(ConcreteCategory.hom \u03c0)\nW\u271d : CompHausLike P\ne : X \u27f6 W\u271d\nh : \u2200 {Z : CompHausLike P} (g\u2081 g\u2082 : Z \u27f6 X), g\u2081 \u226b \u03c0 = g\u2082 \u226b \u03c0 \u2192 g\u2081 \u226b e = g\u2082 \u226b e\ng : B \u27f6 W\u271d\nhm : \u03c0 \u226b g = e\nthis : g = ofHom P (\u22ef.liftEquiv \u27e8TopCat.Hom.hom e, \u22ef\u27e9)\n\u22a2 g = (fun {W} e h \u21a6 ofHom P (\u22ef.lift (TopCat.Hom.hom e) \u22ef)) e \u22ef",["assumption","aesop","congr","tauto"]],["Topology/Category/TopCat/EffectiveEpi.lean",50,"B X : TopCat\n\u03c0 : X \u27f6 B\nh\u03c0 : IsQuotientMap \u21d1(ConcreteCategory.hom \u03c0)\nW\u271d : TopCat\ne : X \u27f6 W\u271d\nh : \u2200 {Z : TopCat} (g\u2081 g\u2082 : Z \u27f6 X), g\u2081 \u226b \u03c0 = g\u2082 \u226b \u03c0 \u2192 g\u2081 \u226b e = g\u2082 \u226b e\ng : B \u27f6 W\u271d\nhm : \u03c0 \u226b g = e\nthis : g = ofHom (h\u03c0.liftEquiv \u27e8Hom.hom e, \u22ef\u27e9)\n\u22a2 g = (fun {W} e h \u21a6 ofHom (h\u03c0.lift (Hom.hom e) \u22ef)) e \u22ef",["assumption","congr","tauto"]],["RingTheory/Fintype.lean",39,"R : Type u_1\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Fintype R\ninst\u271d : DecidableEq R\nh\u271d : Fintype.card R \u2264 3\nh : Fintype.card R = 3\n\u22a2 1 < 3",["norm_num","omega","decide","aesop","tauto","simp"]],["Analysis/SpecialFunctions/Log/Monotone.lean",73,"case refine_3\na : \u211d\nha : 0 < a\nx : \u211d\nhex : rexp (1 / a) \u2264 x\ny : \u211d\nx\u271d : rexp (1 / a) \u2264 y\nhxy : x \u2264 y\nx_pos : 0 < x\ny_pos : 0 < y\n\u22a2 x ^ a \u2264 y ^ a",["gcongr","omega","tauto","infer_instance"]],["Analysis/SpecialFunctions/Log/Monotone.lean",77,"\u22a2 0 < 1 / 2",["norm_num","aesop","linarith","positivity","simp"]],["Analysis/SpecialFunctions/Log/Monotone.lean",78,"case h.e'_6.h.e'_2.h.h.e'_3.h.e'_1\nx\u271d : \u211d\n\u22a2 2 = 1 / (1 / 2)",["norm_num","ring","aesop","linarith","simp"]],["RingTheory/Polynomial/Hermite/Gaussian.lean",60,"n : \u2115\nx : \u211d\n\u22a2 -1 \u2260 0",["norm_num","omega","aesop","linarith","positivity","infer_instance","simp"]],["Algebra/BigOperators/Module.lean",39,"R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nm n : \u2115\nhmn : m < n\nh\u2081 : \u2211 i \u2208 Ico (m + 1) n, f i \u2022 \u2211 i \u2208 range i, g i = \u2211 i \u2208 Ico m (n - 1), f (i + 1) \u2022 \u2211 i \u2208 range (i + 1), g i\nh\u2082 :\n  \u2211 i \u2208 Ico (m + 1) n, f i \u2022 \u2211 i \u2208 range (i + 1), g i =\n    \u2211 i \u2208 Ico m (n - 1), f i \u2022 \u2211 i \u2208 range (i + 1), g i + f (n - 1) \u2022 \u2211 i \u2208 range n, g i - f m \u2022 \u2211 i \u2208 range (m + 1), g i\ni : \u2115\n\u22a2 f i \u2022 \u2211 i \u2208 range (i + 1), g i - f (i + 1) \u2022 \u2211 i \u2208 range (i + 1), g i =\n    -(f (i + 1) \u2022 \u2211 i \u2208 range (i + 1), g i - f i \u2022 \u2211 i \u2208 range (i + 1), g i)",["abel","aesop","norm_num","simp"]],["MeasureTheory/Function/SpecialFunctions/Inner.lean",43,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\nm : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : OpensMeasurableSpace E\ninst\u271d : SecondCountableTopology E\n\u03bc : MeasureTheory.Measure \u03b1\nf g : \u03b1 \u2192 E\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\nx : \u03b1\nhxg : g x = mk g hg x\nhxf : f x = mk f hf x\n\u22a2 Inner.inner (f x) (g x) = Inner.inner (mk f hf x) (mk g hg x)",["congr","aesop"]],["Data/Complex/ExponentialBounds.lean",50,"this : |log 2 - 287209 / 414355| \u2264 1 / 10000000000\n\u22a2 |log 2 - 287209 / 414355| \u2264 1 / 10000000000",["assumption","aesop","congr","linarith","gcongr","tauto"]],["Data/Complex/ExponentialBounds.lean",51,"\u22a2 0 < 2\u207b\u00b9",["norm_num","aesop","linarith","positivity","simp"]],["Data/Complex/ExponentialBounds.lean",65,"\u22a2 1 / 10 ^ 10 + 287209 / 414355 < 0.6931471808",["norm_num","omega","linarith","tauto","infer_instance"]],["Order/Interval/Set/InitialSeg.lean",82,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : PrincipalSeg (fun x1 x2 \u21a6 x1 < x2) fun x1 x2 \u21a6 x1 < x2\n\u22a2 \u2200 {a b : \u03b1},\n    (Equiv.ofBijective (fun a \u21a6 \u27e8f.toRelEmbedding a, \u22ef\u27e9) \u22ef) a \u2264\n        (Equiv.ofBijective (fun a \u21a6 \u27e8f.toRelEmbedding a, \u22ef\u27e9) \u22ef) b \u2194\n      a \u2264 b",["simp","aesop"]],["Topology/Sets/Order.lean",33,"case mk.mk.mk.mk\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LE \u03b1\ncarrier\u271d\u00b9 : Set \u03b1\nisClopen'\u271d\u00b9 : IsClopen carrier\u271d\u00b9\nupper'\u271d\u00b9 : IsUpperSet { carrier := carrier\u271d\u00b9, isClopen' := isClopen'\u271d\u00b9 }.carrier\ncarrier\u271d : Set \u03b1\nisClopen'\u271d : IsClopen carrier\u271d\nupper'\u271d : IsUpperSet { carrier := carrier\u271d, isClopen' := isClopen'\u271d }.carrier\nh :\n  (fun s \u21a6 s.carrier) { carrier := carrier\u271d\u00b9, isClopen' := isClopen'\u271d\u00b9, upper' := upper'\u271d\u00b9 } =\n    (fun s \u21a6 s.carrier) { carrier := carrier\u271d, isClopen' := isClopen'\u271d, upper' := upper'\u271d }\n\u22a2 { carrier := carrier\u271d\u00b9, isClopen' := isClopen'\u271d\u00b9, upper' := upper'\u271d\u00b9 } =\n    { carrier := carrier\u271d, isClopen' := isClopen'\u271d, upper' := upper'\u271d }",["congr","aesop"]],["LinearAlgebra/Matrix/Nondegenerate.lean",57,"case h.e'_2.h\u2081\nm : Type u_1\nA : Type u_3\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : IsDomain A\ninst\u271d : DecidableEq m\nM : Matrix m m A\nhM : M.det \u2260 0\nv : m \u2192 A\ni : m\nhv : v \u2b1d\u1d65 M *\u1d65 M.cramer (Pi.single i 1) = 0\na\u271d : i \u2209 Finset.univ\nthis : i \u2208 Finset.univ\n\u22a2 v i * (M.det * Pi.single i 1 i) = 0",["contradiction","aesop","tauto"]],["MeasureTheory/Covering/OneDim.lean",51,"x \u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\ny : \u211d\nhy : y \u2208 Icc (x - \u03b5) x\n\u22a2 x \u2264 x + \u03b5",["linarith","omega","tauto","infer_instance"]],["RingTheory/Ideal/Nonunits.lean",57,"\u03b1 : Type u_2\na : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nH : IsUnit a\n\u22a2 False",["contradiction","aesop","tauto","infer_instance"]],["LinearAlgebra/Matrix/Unique.lean",55,"m : Type u_1\nn : Type u_2\nA : Type u_3\nR : Type u_4\ninst\u271d\u2074 : Unique m\ninst\u271d\u00b3 : Unique n\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Algebra R A\nr : R\n\u22a2 __spread\u271d\u207b\u2070.toFun ((algebraMap R (Matrix m m A)) r) = (algebraMap R A) r",["aesop","congr","tauto"]],["AlgebraicTopology/SimplicialSet/Boundary.lean",43,"case obj.h.h\nn : \u2115\nx\u271d\u00b9 : SimplexCategory\u1d52\u1d56\nx\u271d : \u0394[n].obj x\u271d\u00b9\n\u22a2 (\u2203 x, \u2200 (x_1 : Fin ((Opposite.unop x\u271d\u00b9).len + 1)), \u00ac(stdSimplex.asOrderHom x\u271d) x_1 = x) \u2194\n    \u2203 i, \u2200 (x : Fin ((Opposite.unop x\u271d\u00b9).len + 1)), \u00ac(SimplexCategory.Hom.toOrderHom (stdSimplex.objEquiv x\u271d)) x = i",["tauto","aesop"]],["Algebra/Order/Ring/Rat.lean",29,"\u22a2 0 \u2264 1",["decide","aesop","congr","tauto"]],["Algebra/BigOperators/Finsupp/Fin.lean",29,"M : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : AddCommMonoid N\nn : \u2115\n\u03c3 : Fin n \u2192\u2080 M\ni : M\nf : Fin (n + 1) \u2192 M \u2192 N\nh : \u2200 (x : Fin (n + 1)), f x 0 = 0\n\u22a2 f 0 i + \u2211 x : Fin n, f x.succ (\u03c3 x) = f 0 i + \u2211 i : Fin n, Fin.tail f i (\u03c3 i)",["congr","aesop","tauto"]],["Logic/Function/ULift.lean",12,"\u03b1 : Type u_1\na b : \u03b1\nx\u271d : { down := a }.down = { down := b }.down\n\u22a2 { down := a } = { down := b }",["congr"]],["Logic/Function/ULift.lean",20,"\u03b1 : Sort u_1\na b : \u03b1\nx\u271d : { down := a }.down = { down := b }.down\n\u22a2 { down := a } = { down := b }",["congr"]]]},{"tactics":["norm_num","ring","abel"],"cost":15,"goals":[["MeasureTheory/Integral/SetToL1.lean",106,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\n\u03b2 : Type u_7\ninst\u271d : AddCommMonoid \u03b2\nT T' : Set \u03b1 \u2192 \u03b2\nhT : FinMeasAdditive \u03bc T\nhT' : FinMeasAdditive \u03bc T'\ns t : Set \u03b1\nhs : MeasurableSet s\nht : MeasurableSet t\nh\u03bcs : \u03bc s \u2260 \u22a4\nh\u03bct : \u03bc t \u2260 \u22a4\nhst : Disjoint s t\n\u22a2 T s + T t + (T' s + T' t) = T s + T' s + (T t + T' t)",["abel"]],["MeasureTheory/Integral/SetToL1.lean",242,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\n\u03b2 : Type u_7\ninst\u271d : SeminormedAddCommGroup \u03b2\nT : Set \u03b1 \u2192 \u03b2\nC : \u211d\nc : \u211d\u22650\u221e\nhc_ne_top : c \u2260 \u22a4\nh : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 c \u2022 \u03bc s = \u22a4 \u2192 \u03bc s = \u22a4\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s < \u22a4\nhc\u03bcs : c * \u03bc s \u2260 \u22a4\nhT : FinMeasAdditive (c \u2022 \u03bc) T \u2227 \u2200 (s : Set \u03b1), MeasurableSet s \u2192 c * \u03bc s < \u22a4 \u2192 \u2016T s\u2016 \u2264 C * (c.toReal * (\u03bc s).toReal)\n\u22a2 C * (c.toReal * (\u03bc s).toReal) = c.toReal * C * (\u03bc s).toReal",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",241,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc : \u211d := b (max_bi b) + (1 - b (max_bi b)) / 2\nh_max_bi_pos : 0 < b (max_bi b)\nh_max_bi_lt_one : 0 < 1 - b (max_bi b)\nhc_pos : 0 < c\nh\u2081 : 0 < (1 - b (max_bi b)) / 2\n\u22a2 1 * (1 / 2) + 1 / 2 = 1",["norm_num","ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1177,"case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nn : \u2115\nhn : 0 < n\nb' : \u211d := b (min_bi b)\nhb_pos : 0 < b'\n\u22a2 1 / 2 \u2264 1",["norm_num","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",185,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ngt_zero : 0 < b (min_bi b)\nhlo : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 c * \u2016\u2191x\u2016\nhlo' : \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 b (min_bi b) / 2 * \u2016\u2191x\u2016\nn : \u2115\nhn' : \u2200 (i : \u03b1), b i * \u2191n - \u2191n / log \u2191n ^ 2 \u2264 \u2191(r i n)\ni : \u03b1\nhn : \u2016\u2191n / log \u2191n ^ 2\u2016 \u2264 b (min_bi b) / 2 * \u2191n\n\u22a2 b (min_bi b) / 2 * \u2191n = b (min_bi b) * \u2191n - b (min_bi b) / 2 * \u2191n",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",237,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc : \u211d := b (max_bi b) + (1 - b (max_bi b)) / 2\nh_max_bi_pos : 0 < b (max_bi b)\nh_max_bi_lt_one : 0 < 1 - b (max_bi b)\nhc_pos : 0 < c\nh\u2081 : 0 < (1 - b (max_bi b)) / 2\n\u22a2 b (max_bi b) + (1 - b (max_bi b)) / 2 = b (max_bi b) * (1 / 2) + 1 / 2",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",252,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc : \u211d := b (max_bi b) + (1 - b (max_bi b)) / 2\nh_max_bi_pos : 0 < b (max_bi b)\nh_max_bi_lt_one : 0 < 1 - b (max_bi b)\nhc_pos : 0 < c\nh\u2081 : 0 < (1 - b (max_bi b)) / 2\nhc_lt_one : c < 1\nhlo : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 c * \u2016\u2191x\u2016\nhlo' : \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 (1 - b (max_bi b)) / 2 * \u2016\u2191x\u2016\nn : \u2115\nhn' : \u2200 (i : \u03b1), \u2191(r i n) \u2264 b i * \u2191n + \u2191n / log \u2191n ^ 2\ni : \u03b1\nhn : \u2191n / log \u2191n ^ 2 \u2264 (1 - b (max_bi b)) / 2 * \u2191n\n\u22a2 b i * \u2191n + (1 - b (max_bi b)) / 2 * \u2191n = (b i + (1 - b (max_bi b)) / 2) * \u2191n",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",657,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhc\u2081_pos : 0 < c\u2081\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 \u2264 p a b + 1\n\u22a2 \u2191n ^ (p a b + 1) * (c\u2082 * g \u2191n / (c\u2081 * \u2191n) ^ (p a b + 1)) = c\u2082 * g \u2191n * \u2191n ^ (p a b + 1) / (c\u2081 * \u2191n) ^ (p a b + 1)",["ring"]],["Computability/AkraBazzi/AkraBazzi.lean",660,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhc\u2081_pos : 0 < c\u2081\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 \u2264 p a b + 1\n\u22a2 c\u2082 * g \u2191n * \u2191n ^ (p a b + 1) / (\u2191n ^ (p a b + 1) * c\u2081 ^ (p a b + 1)) =\n    c\u2082 * g \u2191n * (\u2191n ^ (p a b + 1) / \u2191n ^ (p a b + 1)) / c\u2081 ^ (p a b + 1)",["ring"]],["Computability/AkraBazzi/AkraBazzi.lean",662,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhc\u2081_pos : 0 < c\u2081\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 \u2264 p a b + 1\n\u22a2 c\u2082 * g \u2191n / c\u2081 ^ (p a b + 1) = c\u2082 / c\u2081 ^ (p a b + 1) * g \u2191n",["ring"]],["Computability/AkraBazzi/AkraBazzi.lean",693,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhc\u2081_pos : 0 < c\u2081\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : p a b + 1 < 0\n\u22a2 \u2191n ^ (p a b + 1) * (c\u2082 * g \u2191n / \u2191n ^ (p a b + 1)) = c\u2082 * (\u2191n ^ (p a b + 1) / \u2191n ^ (p a b + 1)) * g \u2191n",["ring"]],["Computability/AkraBazzi/AkraBazzi.lean",739,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nhc\u2083' : 0 < 1 - c\u2083\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nhn\u2083 : \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 \u2264 p a b + 1\n\u22a2 \u2191n ^ p a b * (\u2191n - c\u2083 * \u2191n) * (c\u2082 * g \u2191n / \u2191n ^ (p a b + 1)) =\n    \u2191n ^ p a b * \u2191n * (1 - c\u2083) * (c\u2082 * g \u2191n / \u2191n ^ (p a b + 1))",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",741,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nhc\u2083' : 0 < 1 - c\u2083\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nhn\u2083 : \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 \u2264 p a b + 1\n\u22a2 \u2191n ^ (p a b + 1) * (1 - c\u2083) * (c\u2082 * g \u2191n / \u2191n ^ (p a b + 1)) =\n    c\u2082 * (1 - c\u2083) * g \u2191n * (\u2191n ^ (p a b + 1) / \u2191n ^ (p a b + 1))",["ring"]],["Computability/AkraBazzi/AkraBazzi.lean",777,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nhc\u2083' : 0 < 1 - c\u2083\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nhn\u2083 : \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 > p a b + 1\n\u22a2 \u2191n ^ p a b * (\u2191n - c\u2083 * \u2191n) * (c\u2082 * g \u2191n / (c\u2081 * \u2191n) ^ (p a b + 1)) =\n    \u2191n ^ p a b * \u2191n * (1 - c\u2083) * (c\u2082 * g \u2191n / (c\u2081 * \u2191n) ^ (p a b + 1))",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",781,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nhc\u2083' : 0 < 1 - c\u2083\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nhn\u2083 : \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 > p a b + 1\n\u22a2 \u2191n ^ (p a b + 1) * (1 - c\u2083) * (c\u2082 * g \u2191n / (c\u2081 ^ (p a b + 1) * \u2191n ^ (p a b + 1))) =\n    \u2191n ^ (p a b + 1) / \u2191n ^ (p a b + 1) * (1 - c\u2083) * c\u2082 * g \u2191n / c\u2081 ^ (p a b + 1)",["ring"]],["Computability/AkraBazzi/AkraBazzi.lean",783,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nhc\u2083' : 0 < 1 - c\u2083\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nhn\u2083 : \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 > p a b + 1\n\u22a2 (1 - c\u2083) * c\u2082 * g \u2191n / c\u2081 ^ (p a b + 1) = (1 - c\u2083) * c\u2082 / c\u2081 ^ (p a b + 1) * g \u2191n",["ring"]],["Computability/AkraBazzi/AkraBazzi.lean",1064,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 - \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nh_main_norm : (fun n \u21a6 \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n \u21a6 \u2016b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\u2016\nh_main : (fun n \u21a6 q \u2191(r i n) - q (b i * \u2191n)) \u2264\u1da0[atTop] fun n \u21a6 b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\nn : \u2115\nhn : q \u2191(r i n) - q (b i * \u2191n) \u2264 b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\nthis : 0 < b i\n\u22a2 b i ^ p a b * \u2191n ^ p a b * (1 - \u03b5 (b i * \u2191n)) + b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n) =\n    b i ^ p a b * \u2191n ^ p a b * (1 - \u03b5 \u2191n)",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1160,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 + \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nh_main_norm : (fun n \u21a6 \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n \u21a6 \u2016b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\u2016\nh_main : (fun n \u21a6 q (b i * \u2191n) - q \u2191(r i n)) \u2264\u1da0[atTop] fun n \u21a6 b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\nn : \u2115\nhn : q (b i * \u2191n) - q \u2191(r i n) \u2264 b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\nthis : 0 < b i\n\u22a2 b i ^ p a b * \u2191n ^ p a b * (1 + \u03b5 (b i * \u2191n)) - b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n) =\n    b i ^ p a b * \u2191n ^ p a b * (1 + \u03b5 \u2191n)",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1260,"case e_a.e_f.h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\nx\u271d : \u03b1\n\u22a2 a x\u271d * (C * ((1 - \u03b5 \u2191(r x\u271d n)) * (\u2191(r x\u271d n) ^ p a b * (1 + \u2211 u \u2208 range (r x\u271d n), g \u2191u / \u2191u ^ (p a b + 1))))) =\n    C * a x\u271d * (\u2191(r x\u271d n) ^ p a b * (1 - \u03b5 \u2191(r x\u271d n)) * (1 + \u2211 u \u2208 range (r x\u271d n), g \u2191u / \u2191u ^ (p a b + 1)))",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1297,"case e_a.e_f.h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\nx\u271d : \u03b1\n\u22a2 C * a x\u271d * (b x\u271d ^ p a b * (1 - \u03b5 \u2191n) * (asympBound g a b n - c\u2081 * g \u2191n)) =\n    C * (1 - \u03b5 \u2191n) * (asympBound g a b n - c\u2081 * g \u2191n) * (a x\u271d * b x\u271d ^ p a b)",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1300,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\n\u22a2 C * (1 - \u03b5 \u2191n) * (asympBound g a b n - c\u2081 * g \u2191n) + g \u2191n =\n    C * (1 - \u03b5 \u2191n) * asympBound g a b n + (1 - C * c\u2081 * (1 - \u03b5 \u2191n)) * g \u2191n",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1307,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\n\u22a2 2 * (c\u2081\u207b\u00b9 * c\u2081) * (1 / 2) = 2 * c\u2081\u207b\u00b9 * c\u2081 * (1 / 2)",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1311,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\n\u22a2 C * (1 - \u03b5 \u2191n) * asympBound g a b n + 0 = C * ((1 - \u03b5 \u2191n) * asympBound g a b n)",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1444,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\n\u22a2 C * (1 + \u03b5 \u2191n) * (asympBound g a b n - c\u2081 * g \u2191n) + g \u2191n =\n    C * (1 + \u03b5 \u2191n) * asympBound g a b n + (1 - C * c\u2081 * (1 + \u03b5 \u2191n)) * g \u2191n",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1454,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\n\u22a2 C * c\u2081 * 2 = C * (2 * c\u2081)",["ring","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",1456,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\n\u22a2 (2 * c\u2081)\u207b\u00b9 * (2 * c\u2081) = c\u2081\u207b\u00b9 * c\u2081",["ring"]],["Computability/AkraBazzi/AkraBazzi.lean",1458,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\n\u22a2 C * (1 + \u03b5 \u2191n) * asympBound g a b n + 0 = C * ((1 + \u03b5 \u2191n) * asympBound g a b n)",["ring","linarith"]],["MeasureTheory/Integral/FundThmCalculus.lean",264,"case pos.refine_3\n\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nf : \u211d \u2192 E\nc : E\nl l' : Filter \u211d\nlt : Filter \u03b9\n\u03bc : Measure \u211d\nu v : \u03b9 \u2192 \u211d\ninst\u271d\u00b9 : l'.IsMeasurablyGenerated\ninst\u271d : TendstoIxxClass Ioc l l'\nhfm : StronglyMeasurableAtFilter f l' \u03bc\nhf : Tendsto f (l' \u2293 ae \u03bc) (\ud835\udcdd c)\nhl : \u03bc.FiniteAtFilter l'\nhu : Tendsto u lt l\nhv : Tendsto v lt l\nhE : CompleteSpace E\nA :\n  (fun i \u21a6 \u222b (x : \u211d) in Ioc (u i) (v i), f x \u2202\u03bc - (\u03bc (Ioc (u i) (v i))).toReal \u2022 c) =o[lt] fun i \u21a6\n    (\u03bc (Ioc (u i) (v i))).toReal\nB :\n  (fun i \u21a6 \u222b (x : \u211d) in Ioc (v i) (u i), f x \u2202\u03bc - (\u03bc (Ioc (v i) (u i))).toReal \u2022 c) =o[lt] fun i \u21a6\n    (\u03bc (Ioc (v i) (u i))).toReal\nt : \u03b9\n\u22a2 \u222b (x : \u211d) in Ioc (u t) (v t), f x \u2202\u03bc - (\u03bc (Ioc (u t) (v t))).toReal \u2022 c -\n      (\u222b (x : \u211d) in Ioc (v t) (u t), f x \u2202\u03bc - (\u03bc (Ioc (v t) (u t))).toReal \u2022 c) =\n    \u222b (x : \u211d) in Ioc (u t) (v t), f x \u2202\u03bc - \u222b (x : \u211d) in Ioc (v t) (u t), f x \u2202\u03bc -\n      ((\u03bc (Ioc (u t) (v t))).toReal \u2022 c - (\u03bc (Ioc (v t) (u t))).toReal \u2022 c)",["abel"]],["Analysis/Calculus/MeanValue.lean",556,"case e_a\nE : Type u_1\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\n\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : IsRCLikeNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nf : E \u2192 G\nC : \u211d\ns : Set E\nx y : E\nf' : E \u2192 E \u2192L[\ud835\udd5c] G\n\u03c6 : E \u2192L[\ud835\udd5c] G\nhf : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\nbound : \u2200 x \u2208 s, \u2016f' x - \u03c6\u2016 \u2264 C\nhs : Convex \u211d s\nxs : x \u2208 s\nys : y \u2208 s\ng : E \u2192 G := fun y \u21a6 f y - \u03c6 y\nhg : \u2200 x \u2208 s, HasFDerivWithinAt g (f' x - \u03c6) s x\n\u22a2 f y - f x - (\u03c6 y - \u03c6 x) = f y - \u03c6 y - (f x - \u03c6 x)",["abel"]],["Analysis/Calculus/MeanValue.lean",785,"f f' : \u211d \u2192 \u211d\na b : \u211d\nhab : a < b\nhfc : ContinuousOn f (Icc a b)\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\ng g' : \u211d \u2192 \u211d\nhgc : ContinuousOn g (Icc a b)\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nh : \u211d \u2192 \u211d := fun x \u21a6 (g b - g a) * f x - (f b - f a) * g x\n\u22a2 (g b - g a) * f a - (f b - f a) * g a = (g b - g a) * f b - (f b - f a) * g b",["ring","linarith"]],["Analysis/Calculus/MeanValue.lean",806,"case h.e'_5.h.e'_3\nf f' : \u211d \u2192 \u211d\na b : \u211d\nhab : a < b\ng g' : \u211d \u2192 \u211d\nlfa lga lfb lgb : \u211d\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhfa : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd lfa)\nhga : Tendsto g (\ud835\udcdd[>] a) (\ud835\udcdd lga)\nhfb : Tendsto f (\ud835\udcdd[<] b) (\ud835\udcdd lfb)\nhgb : Tendsto g (\ud835\udcdd[<] b) (\ud835\udcdd lgb)\nh : \u211d \u2192 \u211d := fun x \u21a6 (lgb - lga) * f x - (lfb - lfa) * g x\nthis : Tendsto h (\ud835\udcdd[>] a) (\ud835\udcdd ((lgb - lga) * lfa - (lfb - lfa) * lga))\n\u22a2 lgb * lfa - lfb * lga = (lgb - lga) * lfa - (lfb - lfa) * lga",["ring","linarith"]],["Analysis/Calculus/MeanValue.lean",811,"case h.e'_5.h.e'_3\nf f' : \u211d \u2192 \u211d\na b : \u211d\nhab : a < b\ng g' : \u211d \u2192 \u211d\nlfa lga lfb lgb : \u211d\nhff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x\nhfa : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd lfa)\nhga : Tendsto g (\ud835\udcdd[>] a) (\ud835\udcdd lga)\nhfb : Tendsto f (\ud835\udcdd[<] b) (\ud835\udcdd lfb)\nhgb : Tendsto g (\ud835\udcdd[<] b) (\ud835\udcdd lgb)\nh : \u211d \u2192 \u211d := fun x \u21a6 (lgb - lga) * f x - (lfb - lfa) * g x\nhha : Tendsto h (\ud835\udcdd[>] a) (\ud835\udcdd (lgb * lfa - lfb * lga))\nthis : Tendsto h (\ud835\udcdd[<] b) (\ud835\udcdd ((lgb - lga) * lfb - (lfb - lfa) * lgb))\n\u22a2 lgb * lfa - lfb * lga = (lgb - lga) * lfb - (lfb - lfa) * lgb",["ring","linarith"]],["MeasureTheory/Function/Jacobian.lean",163,"case e_a\nE : Type u_1\nF : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : SecondCountableTopology F\nf : E \u2192 F\ns : Set E\nf' : E \u2192 E \u2192L[\u211d] F\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\nr : (E \u2192L[\u211d] F) \u2192 \u211d\u22650\nrpos : \u2200 (A : E \u2192L[\u211d] F), r A \u2260 0\nhs : s.Nonempty\nT : Set \u2191s\nT_count : T.Countable\nhT : \u22c3 x \u2208 T, ball (f' \u2191x) \u2191(r (f' \u2191x)) = \u22c3 x, ball (f' \u2191x) \u2191(r (f' \u2191x))\nu : \u2115 \u2192 \u211d\nleft\u271d : StrictAnti u\nu_pos : \u2200 (n : \u2115), 0 < u n\nu_lim : Tendsto u atTop (\ud835\udcdd 0)\nM : \u2115 \u2192 \u2191T \u2192 Set E :=\n  fun n z \u21a6 {x | x \u2208 s \u2227 \u2200 y \u2208 s \u2229 ball x (u n), \u2016f y - f x - (f' \u2191\u2191z) (y - x)\u2016 \u2264 \u2191(r (f' \u2191\u2191z)) * \u2016y - x\u2016}\nx : E\nxs : x \u2208 s\nz : \u2191s\nzT : z \u2208 T\nhz : f' x \u2208 ball (f' \u2191z) \u2191(r (f' \u2191z))\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nh\u03b5 : \u2016f' x - f' \u2191z\u2016 + \u03b5 \u2264 \u2191(r (f' \u2191z))\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : ball x \u03b4 \u2229 s \u2286 {y | \u2016f y - f x - (f' x) (y - x)\u2016 \u2264 \u03b5 * \u2016y - x\u2016}\nn : \u2115\nhn : u n < \u03b4\ny : E\nhy : y \u2208 s \u2229 ball x (u n)\n\u22a2 f y - f x - ((f' \u2191z) y - (f' \u2191z) x) =\n    f y - f x - ((f' x) y - (f' x) x) + ((f' x) y - (f' \u2191z) y - ((f' x) x - (f' \u2191z) x))",["abel"]],["MeasureTheory/Function/Jacobian.lean",335,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nA : E \u2192L[\u211d] E\nm : \u211d\u22650\nhm : ENNReal.ofReal |A.det| < \u2191m\nd : \u211d\u22650\u221e := ENNReal.ofReal |A.det|\n\u03b5 : \u211d\nh\u03b5 : \u03bc (closedBall 0 \u03b5 + \u21d1A '' closedBall 0 1) < \u2191m * \u03bc (closedBall 0 1)\n\u03b5pos : 0 < \u03b5\nthis : Iio \u27e8\u03b5, \u22ef\u27e9 \u2208 \ud835\udcdd 0\n\u03b4 : \u211d\u22650\ns : Set E\nf : E \u2192 E\nhf : ApproximatesLinearOn f A s \u03b4\nh\u03b4 : \u2191\u03b4 < \u03b5\nx : E\nr : \u211d\nxs : x \u2208 s\nr0 : 0 \u2264 r\nz : E\nzs : z \u2208 s\nzr : \u2016z - x\u2016 \u2264 r\n\u22a2 A z - A x + (f z - f x - (A z - A x) + f x) = f z",["abel"]],["MeasureTheory/Function/Jacobian.lean",351,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nA : E \u2192L[\u211d] E\nm : \u211d\u22650\nhm : ENNReal.ofReal |A.det| < \u2191m\nd : \u211d\u22650\u221e := ENNReal.ofReal |A.det|\n\u03b5 : \u211d\nh\u03b5 : \u03bc (closedBall 0 \u03b5 + \u21d1A '' closedBall 0 1) < \u2191m * \u03bc (closedBall 0 1)\n\u03b5pos : 0 < \u03b5\nthis\u271d : Iio \u27e8\u03b5, \u22ef\u27e9 \u2208 \ud835\udcdd 0\n\u03b4 : \u211d\u22650\ns : Set E\nf : E \u2192 E\nhf : ApproximatesLinearOn f A s \u03b4\nh\u03b4 : \u2191\u03b4 < \u03b5\nx : E\nr : \u211d\nxs : x \u2208 s\nr0 : 0 \u2264 r\nK : f '' (s \u2229 closedBall x r) \u2286 {f x} + r \u2022 (\u21d1A '' closedBall 0 1 + closedBall 0 \u03b5)\nthis : \u21d1A '' closedBall 0 r + closedBall (f x) (\u03b5 * r) = {f x} + r \u2022 (\u21d1A '' closedBall 0 1 + closedBall 0 \u03b5)\n\u22a2 ENNReal.ofReal (r ^ finrank \u211d E) * (\u2191m * \u03bc (closedBall 0 1)) =\n    \u2191m * (ENNReal.ofReal (r ^ finrank \u211d E) * \u03bc (closedBall 0 1))",["ring"]],["MeasureTheory/Function/Jacobian.lean",527,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ns : Set E\nf : E \u2192 E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nA : E \u2192L[\u211d] E\n\u03b4 : \u211d\u22650\nhf : ApproximatesLinearOn f A s \u03b4\nhs : MeasurableSet s\nf' : E \u2192 E \u2192L[\u211d] E\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\nx : E\nhx : Tendsto (fun r \u21a6 \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd 1)\nxs : x \u2208 s\nz : E\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nB\u2081 : \u2200\u1da0 (r : \u211d) in \ud835\udcdd[>] 0, (s \u2229 ({x} + r \u2022 closedBall z \u03b5)).Nonempty\n\u03c1 : \u211d\n\u03c1pos : \u03c1 > 0\nh\u03c1 : ball x \u03c1 \u2229 s \u2286 {y | \u2016f y - f x - (f' x) (y - x)\u2016 \u2264 \u03b5 * \u2016y - x\u2016}\nB\u2082 : \u2200\u1da0 (r : \u211d) in \ud835\udcdd[>] 0, {x} + r \u2022 closedBall z \u03b5 \u2286 ball x \u03c1\nr : \u211d\ny : E\nys : y \u2208 s\nhy : y \u2208 {x} + r \u2022 closedBall z \u03b5\nr\u03c1 : {x} + r \u2022 closedBall z \u03b5 \u2286 ball x \u03c1\nrpos : 0 < r\na : E\naz : a \u2208 closedBall z \u03b5\nya : y = x + r \u2022 a\nnorm_a : \u2016a\u2016 \u2264 \u2016z\u2016 + \u03b5\n\u22a2 \u2191\u03b4 * (r * \u2016a\u2016) + \u03b5 * (r * \u2016a\u2016) = r * (\u2191\u03b4 + \u03b5) * \u2016a\u2016",["ring","linarith"]],["Analysis/Analytic/Basic.lean",955,"case e_a\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\np : FormalMultilinearSeries \ud835\udd5c E F\ns : Set E\nx : E\nr : \u211d\u22650\u221e\ny : E\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhy : y \u2208 EMetric.ball 0 r\nh'y : x + y \u2208 insert x s\nA\u271d : Tendsto (fun z \u21a6 p.partialSum z.1 y) (atTop \u00d7\u02e2 \ud835\udcdd y) (\ud835\udcdd (f (x + y)))\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nr' : \u211d\u22650\nyr' : \u2016y\u2016\u208a < r'\nr'r : \u2191r' < r\nyr'_2 : \u2016y\u2016 < \u2191r'\nS : Summable fun n \u21a6 \u2016p n\u2016 * \u2191r' ^ n\nk : \u2115\nhk : \u2211' (n : \u2115), \u2016p (n + k)\u2016 * \u2191r' ^ (n + k) < \u03b5 / 4\nA : \u2200\u1da0 (z : \u2115 \u00d7 E) in atTop \u00d7\u02e2 \ud835\udcdd y, dist (p.partialSum k z.2) (p.partialSum k y) < \u03b5 / 4\nB : \u2200\u1da0 (z : \u2115 \u00d7 E) in atTop \u00d7\u02e2 \ud835\udcdd y, \u2016z.2\u2016\u208a < r'\nC : \u2200\u1da0 (z : \u2115 \u00d7 E) in atTop \u00d7\u02e2 \ud835\udcdd y, k \u2264 z.1\nn : \u2115\nz : E\nh'z : \u2016(n, z).2\u2016\u208a < r'\nhkn : k \u2264 (n, z).1\nhz : \u2016p.partialSum k z - p.partialSum k y\u2016 < \u03b5 / 4\nI : \u2200 (w : E), \u2016w\u2016\u208a < r' \u2192 \u2016\u2211 i \u2208 Finset.Ico k n, (p i) fun x \u21a6 w\u2016 \u2264 \u03b5 / 4\n\u22a2 ((\u2211 i \u2208 Finset.range k, (p i) fun x \u21a6 z) + \u2211 i \u2208 Finset.Ico k n, (p i) fun x \u21a6 z) -\n      ((\u2211 i \u2208 Finset.range k, (p i) fun x \u21a6 y) + \u2211 i \u2208 Finset.Ico k n, (p i) fun x \u21a6 y) =\n    (((\u2211 i \u2208 Finset.range k, (p i) fun x \u21a6 z) - \u2211 i \u2208 Finset.range k, (p i) fun x \u21a6 y) +\n        \u2211 i \u2208 Finset.Ico k n, (p i) fun x \u21a6 z) +\n      -\u2211 i \u2208 Finset.Ico k n, (p i) fun x \u21a6 y",["abel"]],["Analysis/Analytic/Basic.lean",1110,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\np : FormalMultilinearSeries \ud835\udd5c E F\ns : Set E\nx : E\nr : \u211d\u22650\u221e\nhf : HasFPowerSeriesWithinOnBall f p s x r\nr' : \u211d\u22650\nhr : \u2191r' < r\nhr'0 : 0 < r'\na : \u211d\nha : a \u2208 Ioo 0 1\nC : \u211d\nhC : 0 < C\nhp : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * a ^ n / \u2191r' ^ n\nL : E \u00d7 E \u2192 \u211d := fun y \u21a6 C * (a / \u2191r') ^ 2 * (\u2016y - (x, x)\u2016 * \u2016y.1 - y.2\u2016) * (a / (1 - a) ^ 2 + 2 / (1 - a))\ny : E \u00d7 E\nhy' : \u2016y - (x, x)\u2016\u208a < r'\nys : y \u2208 insert x s \u00d7\u02e2 insert x s\nhy : y \u2208 EMetric.ball x r \u00d7\u02e2 EMetric.ball x r\nA : \u2115 \u2192 F := fun n \u21a6 ((p n) fun x_1 \u21a6 y.1 - x) - (p n) fun x_1 \u21a6 y.2 - x\nhA : HasSum (fun n \u21a6 A (n + 2)) (f y.1 - f y.2 - (p 1) fun x \u21a6 y.1 - y.2)\nB : \u2115 \u2192 \u211d := fun n \u21a6 C * (a / \u2191r') ^ 2 * (\u2016y - (x, x)\u2016 * \u2016y.1 - y.2\u2016) * ((\u2191n + 2) * a ^ n)\nn : \u2115\n\u22a2 \u2016p (n + 2)\u2016 * \u2191(n + 2) * (\u2016y - (x, x)\u2016 ^ n * \u2016y - (x, x)\u2016) * \u2016y.1 - y.2\u2016 =\n    \u2016p (n + 2)\u2016 * \u2016y - (x, x)\u2016 ^ n * (\u2191(n + 2) * \u2016y - (x, x)\u2016 * \u2016y.1 - y.2\u2016)",["ring","linarith"]],["Data/Ordmap/Ordset.lean",598,"case pos\n\u03b1 : Type u_1\nx : \u03b1\nhl : nil.Balanced\nsl : nil.Sized\nrs : \u2115\nrx : \u03b1\nrls : \u2115\nrll : Ordnode \u03b1\nrlx : \u03b1\nrlr : Ordnode \u03b1\nrrs : \u2115\nrrl : Ordnode \u03b1\nrrx : \u03b1\nrrr : Ordnode \u03b1\nhr : ((node rls rll rlx rlr).node' rx (node rrs rrl rrx rrr)).Balanced\nsr : (node rs (node rls rll rlx rlr) rx (node rrs rrl rrx rrr)).Sized\nh\u271d : rls < ratio * rrs\n\u22a2 rls + 1 + rrs = rls + rrs + 1",["abel","omega","linarith"]],["Data/Ordmap/Ordset.lean",599,"case neg\n\u03b1 : Type u_1\nx : \u03b1\nhl : nil.Balanced\nsl : nil.Sized\nrs : \u2115\nrx : \u03b1\nrls : \u2115\nrll : Ordnode \u03b1\nrlx : \u03b1\nrlr : Ordnode \u03b1\nrrs : \u2115\nrrl : Ordnode \u03b1\nrrx : \u03b1\nrrr : Ordnode \u03b1\nhr : ((node rls rll rlx rlr).node' rx (node rrs rrl rrx rrr)).Balanced\nsr : (node rs (node rls rll rlx rlr) rx (node rrs rrl rrx rrr)).Sized\nh\u271d : \u00acrls < ratio * rrs\n\u22a2 rll.size + 1 + (rlr.size + rrs + 1) = rll.size + rlr.size + 1 + rrs + 1",["abel"]],["Data/Ordmap/Ordset.lean",625,"case pos\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nhr : nil.Balanced\nsr : nil.Sized\nlls : \u2115\nlll : Ordnode \u03b1\nllx : \u03b1\nllr : Ordnode \u03b1\nlrs : \u2115\nlrl : Ordnode \u03b1\nlrx : \u03b1\nlrr : Ordnode \u03b1\nhl : ((node lls lll llx llr).node' lx (node lrs lrl lrx lrr)).Balanced\nsl : (node ls (node lls lll llx llr) lx (node lrs lrl lrx lrr)).Sized\nh\u271d : lrs < ratio * lls\n\u22a2 lls + (lrs + 1) = lls + lrs + 1",["abel"]],["Data/Ordmap/Ordset.lean",626,"case neg\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nhr : nil.Balanced\nsr : nil.Sized\nlls : \u2115\nlll : Ordnode \u03b1\nllx : \u03b1\nllr : Ordnode \u03b1\nlrs : \u2115\nlrl : Ordnode \u03b1\nlrx : \u03b1\nlrr : Ordnode \u03b1\nhl : ((node lls lll llx llr).node' lx (node lrs lrl lrx lrr)).Balanced\nsl : (node ls (node lls lll llx llr) lx (node lrs lrl lrx lrr)).Sized\nh\u271d : \u00aclrs < ratio * lls\n\u22a2 lls + lrl.size + 1 + (lrr.size + 1) = lls + (lrl.size + lrr.size + 1) + 1",["abel"]],["Data/Ordmap/Ordset.lean",641,"case pos\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nll : Ordnode \u03b1\nlx : \u03b1\nlr : Ordnode \u03b1\nhl : (node ls ll lx lr).Balanced\nsl : (node ls ll lx lr).Sized\nrs : \u2115\nrx : \u03b1\nh : delta * ls < rs\nrls : \u2115\nrll : Ordnode \u03b1\nrlx : \u03b1\nrlr : Ordnode \u03b1\nrrs : \u2115\nrrl : Ordnode \u03b1\nrrx : \u03b1\nrrr : Ordnode \u03b1\nhr : (node rs (node rls rll rlx rlr) rx (node rrs rrl rrx rrr)).Balanced\nsr : (node rs (node rls rll rlx rlr) rx (node rrs rrl rrx rrr)).Sized\nrd : delta \u2264 (node rls rll rlx rlr).size + (node rrs rrl rrx rrr).size\nh\u271d : rls < ratio * rrs\n\u22a2 ls + rls + 1 + rrs = ls + (rls + rrs + 1)",["abel"]],["Data/Ordmap/Ordset.lean",642,"case neg\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nll : Ordnode \u03b1\nlx : \u03b1\nlr : Ordnode \u03b1\nhl : (node ls ll lx lr).Balanced\nsl : (node ls ll lx lr).Sized\nrs : \u2115\nrx : \u03b1\nh : delta * ls < rs\nrls : \u2115\nrll : Ordnode \u03b1\nrlx : \u03b1\nrlr : Ordnode \u03b1\nrrs : \u2115\nrrl : Ordnode \u03b1\nrrx : \u03b1\nrrr : Ordnode \u03b1\nhr : (node rs (node rls rll rlx rlr) rx (node rrs rrl rrx rrr)).Balanced\nsr : (node rs (node rls rll rlx rlr) rx (node rrs rrl rrx rrr)).Sized\nrd : delta \u2264 (node rls rll rlx rlr).size + (node rrs rrl rrx rrr).size\nh\u271d : \u00acrls < ratio * rrs\n\u22a2 ls + rll.size + 1 + (rlr.size + rrs + 1) = ls + (rll.size + rlr.size + 1 + rrs + 1)",["abel"]],["Data/Ordmap/Ordset.lean",652,"case pos\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : (node rs rl rx rr).Balanced\nsr : (node rs rl rx rr).Sized\nh : \u00acdelta * ls < rs\nh_1 : delta * rs < ls\nlls : \u2115\nlll : Ordnode \u03b1\nllx : \u03b1\nllr : Ordnode \u03b1\nlrs : \u2115\nlrl : Ordnode \u03b1\nlrx : \u03b1\nlrr : Ordnode \u03b1\nhl : (node ls (node lls lll llx llr) lx (node lrs lrl lrx lrr)).Balanced\nsl : (node ls (node lls lll llx llr) lx (node lrs lrl lrx lrr)).Sized\nld : delta \u2264 (node lls lll llx llr).size + (node lrs lrl lrx lrr).size\nh\u271d : lrs < ratio * lls\n\u22a2 lls + (lrs + rs + 1) = lls + lrs + 1 + rs",["abel"]],["Data/Ordmap/Ordset.lean",653,"case neg\n\u03b1 : Type u_1\nx : \u03b1\nls : \u2115\nlx : \u03b1\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : (node rs rl rx rr).Balanced\nsr : (node rs rl rx rr).Sized\nh : \u00acdelta * ls < rs\nh_1 : delta * rs < ls\nlls : \u2115\nlll : Ordnode \u03b1\nllx : \u03b1\nllr : Ordnode \u03b1\nlrs : \u2115\nlrl : Ordnode \u03b1\nlrx : \u03b1\nlrr : Ordnode \u03b1\nhl : (node ls (node lls lll llx llr) lx (node lrs lrl lrx lrr)).Balanced\nsl : (node ls (node lls lll llx llr) lx (node lrs lrl lrx lrr)).Sized\nld : delta \u2264 (node lls lll llx llr).size + (node lrs lrl lrx lrr).size\nh\u271d : \u00aclrs < ratio * lls\n\u22a2 lls + lrl.size + 1 + (lrr.size + rs + 1) = lls + (lrl.size + lrr.size + 1) + 1 + rs",["abel"]],["Data/Ordmap/Ordset.lean",1281,"case refine_2\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nls : \u2115\nll : Ordnode \u03b1\nlx : \u03b1\nlr : Ordnode \u03b1\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr t : Ordnode \u03b1\nhl : Valid' o\u2081 (Ordnode.node ls ll lx lr) o\u2082\nhr : Valid' o\u2081 (Ordnode.node rs rl rx rr) o\u2082\nh : 3 * (ll.size + lr.size + 1) < rl.size + rr.size + 1\nv : Valid' o\u2081 t \u2191rx\ne : t.size = ll.size + lr.size + 1 + rl.size\nhr\u2081 : rl.size \u2264 delta * rr.size\nhr\u2082 : rr.size \u2264 delta * rl.size\nH\u2082 : 1 \u2264 t.size \u2192 1 \u2264 rr.size \u2192 rr.size \u2264 delta * t.size\nH\u2081 : t.size = 0 \u2192 rr.size \u2264 1\n\u22a2 ll.size + lr.size + 1 + rl.size + rr.size + 1 = ll.size + lr.size + 1 + (rl.size + rr.size + 1)",["abel","omega","linarith"]],["Analysis/InnerProductSpace/Projection.lean",133,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nne : K.Nonempty\nh\u2081 : IsComplete K\nh\u2082 : Convex \u211d K\nu : F\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\nthis : Nonempty \u2191K := Set.Nonempty.to_subtype ne\nzero_le_\u03b4 : 0 \u2264 \u03b4\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nw : \u2115 \u2192 \u2191K\nhw : \u2200 (n : \u2115), \u2016u - \u2191(w n)\u2016 < \u03b4 + 1 / (\u2191n + 1)\nnorm_tendsto : Tendsto (fun n \u21a6 \u2016u - \u2191(w n)\u2016) atTop (\ud835\udcdd \u03b4)\nb\u271d : \u2115 \u2192 \u211d := fun n \u21a6 8 * \u03b4 * (1 / (\u2191n + 1)) + 4 * (1 / (\u2191n + 1)) * (1 / (\u2191n + 1))\np q N : \u2115\nhp : N \u2264 p\nhq : N \u2264 q\nwp : F := \u2191(w p)\nwq : F := \u2191(w q)\na : F := u - wq\nb : F := u - wp\nhalf : \u211d := 1 / 2\ndiv : \u211d := 1 / (\u2191N + 1)\neq\u2081 : wp - wq = a - b\n\u22a2 u + u - (wq + wp) = u - wq + (u - wp)",["abel"]],["Analysis/InnerProductSpace/Projection.lean",214,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nh : Convex \u211d K\nu v : F\nhv : v \u2208 K\nthis\u271d : Nonempty \u2191K := Nonempty.intro \u27e8v, hv\u27e9\neq : \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016\nw : F\nhw : w \u2208 K\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\np : \u211d := \u27eau - v, w - v\u27eb_\u211d\nq : \u211d := \u2016w - v\u2016 ^ 2\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\n\u03b8 : \u211d\nh\u03b8\u2081 : 0 < \u03b8\nh\u03b8\u2082 : \u03b8 \u2264 1\nthis : \u2016u - v\u2016 ^ 2 \u2264 \u2016u - v\u2016 ^ 2 - 2 * \u03b8 * \u27eau - v, w - v\u27eb_\u211d + \u03b8 * \u03b8 * \u2016w - v\u2016 ^ 2\n\u22a2 \u2016u - v\u2016 ^ 2 - 2 * \u03b8 * \u27eau - v, w - v\u27eb_\u211d + \u03b8 * \u03b8 * \u2016w - v\u2016 ^ 2 =\n    \u2016u - v\u2016 ^ 2 + (\u03b8 * \u03b8 * \u2016w - v\u2016 ^ 2 - 2 * \u03b8 * \u27eau - v, w - v\u27eb_\u211d)",["abel","ring","linarith"]],["Analysis/InnerProductSpace/Projection.lean",648,"case h.e'_2.h.e'_3\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : InnerProductSpace \u211d F\nK : Submodule \ud835\udd5c E\ninst\u271d : HasOrthogonalProjection K\nx : E\nw : \u21a5K := (orthogonalProjection K) x\nv : E := x - \u2191w\nthis : \u27eav, \u2191w\u27eb_\ud835\udd5c = 0\n\u22a2 \u2191((orthogonalProjection K) x) + \u2191((orthogonalProjection K) x) - x = \u2191w - (x - \u2191w)",["abel"]],["Analysis/InnerProductSpace/Projection.lean",690,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d : HasOrthogonalProjection K\nv : E\n\u22a2 2 \u2022 (v - \u2191((orthogonalProjection K) v)) - v = v - 2 \u2022 \u2191((orthogonalProjection K) v)",["abel"]],["Analysis/InnerProductSpace/Projection.lean",117,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nne : K.Nonempty\nh\u2081 : IsComplete K\nh\u2082 : Convex \u211d K\nu : F\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\nthis : Nonempty \u2191K := Set.Nonempty.to_subtype ne\nzero_le_\u03b4 : 0 \u2264 \u03b4\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nw : \u2115 \u2192 \u2191K\nhw : \u2200 (n : \u2115), \u2016u - \u2191(w n)\u2016 < \u03b4 + 1 / (\u2191n + 1)\nnorm_tendsto : Tendsto (fun n \u21a6 \u2016u - \u2191(w n)\u2016) atTop (\ud835\udcdd \u03b4)\nb\u271d : \u2115 \u2192 \u211d := fun n \u21a6 8 * \u03b4 * (1 / (\u2191n + 1)) + 4 * (1 / (\u2191n + 1)) * (1 / (\u2191n + 1))\np q N : \u2115\nhp : N \u2264 p\nhq : N \u2264 q\nwp : F := \u2191(w p)\nwq : F := \u2191(w q)\na : F := u - wq\nb : F := u - wp\nhalf : \u211d := 1 / 2\ndiv : \u211d := 1 / (\u2191N + 1)\n\u22a2 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016 + \u2016wp - wq\u2016 * \u2016wp - wq\u2016 =\n    2 * \u2016u - half \u2022 (wq + wp)\u2016 * (2 * \u2016u - half \u2022 (wq + wp)\u2016) + \u2016wp - wq\u2016 * \u2016wp - wq\u2016",["ring","linarith"]],["Analysis/InnerProductSpace/Projection.lean",160,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nne : K.Nonempty\nh\u2081 : IsComplete K\nh\u2082 : Convex \u211d K\nu : F\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\nthis\u271d : Nonempty \u2191K := Set.Nonempty.to_subtype ne\nzero_le_\u03b4 : 0 \u2264 \u03b4\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nw : \u2115 \u2192 \u2191K\nhw : \u2200 (n : \u2115), \u2016u - \u2191(w n)\u2016 < \u03b4 + 1 / (\u2191n + 1)\nnorm_tendsto : Tendsto (fun n \u21a6 \u2016u - \u2191(w n)\u2016) atTop (\ud835\udcdd \u03b4)\nb\u271d : \u2115 \u2192 \u211d := fun n \u21a6 8 * \u03b4 * (1 / (\u2191n + 1)) + 4 * (1 / (\u2191n + 1)) * (1 / (\u2191n + 1))\np q N : \u2115\nhp : N \u2264 p\nhq : N \u2264 q\nwp : F := \u2191(w p)\nwq : F := \u2191(w q)\na : F := u - wq\nb : F := u - wp\nhalf : \u211d := 1 / 2\ndiv : \u211d := 1 / (\u2191N + 1)\nthis : 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016 + \u2016wp - wq\u2016 * \u2016wp - wq\u2016 = 2 * (\u2016a\u2016 * \u2016a\u2016 + \u2016b\u2016 * \u2016b\u2016)\neq : \u03b4 \u2264 \u2016u - half \u2022 (wq + wp)\u2016\neq\u2081 : 4 * \u03b4 * \u03b4 \u2264 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016\neq\u2082 : \u2016a\u2016 \u2264 \u03b4 + div\neq\u2082' : \u2016b\u2016 \u2264 \u03b4 + div\n\u22a2 2 * ((\u03b4 + div) * (\u03b4 + div) + (\u03b4 + div) * (\u03b4 + div)) - 4 * \u03b4 * \u03b4 = 8 * \u03b4 * div + 4 * div * div",["ring","linarith"]],["Analysis/InnerProductSpace/Projection.lean",210,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nh : Convex \u211d K\nu v : F\nhv : v \u2208 K\nthis : Nonempty \u2191K := Nonempty.intro \u27e8v, hv\u27e9\neq : \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016\nw : F\nhw : w \u2208 K\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\np : \u211d := \u27eau - v, w - v\u27eb_\u211d\nq : \u211d := \u2016w - v\u2016 ^ 2\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\n\u03b8 : \u211d\nh\u03b8\u2081 : 0 < \u03b8\nh\u03b8\u2082 : \u03b8 \u2264 1\n\u22a2 \u2016u - v\u2016 * \u2016u - v\u2016 - 2 * (\u03b8 * \u27eau - v, w - v\u27eb_\u211d) + \u03b8 * \u2016w - v\u2016 * (\u03b8 * \u2016w - v\u2016) =\n    \u2016u - v\u2016 * \u2016u - v\u2016 - 2 * \u03b8 * \u27eau - v, w - v\u27eb_\u211d + \u03b8 * \u03b8 * (\u2016w - v\u2016 * \u2016w - v\u2016)",["ring","linarith"]],["Analysis/InnerProductSpace/Projection.lean",218,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nh : Convex \u211d K\nu v : F\nhv : v \u2208 K\nthis\u271d : Nonempty \u2191K := Nonempty.intro \u27e8v, hv\u27e9\neq : \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016\nw : F\nhw : w \u2208 K\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\np : \u211d := \u27eau - v, w - v\u27eb_\u211d\nq : \u211d := \u2016w - v\u2016 ^ 2\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\n\u03b8 : \u211d\nh\u03b8\u2081 : 0 < \u03b8\nh\u03b8\u2082 : \u03b8 \u2264 1\nthis : 0 \u2264 \u03b8 * \u03b8 * \u2016w - v\u2016 ^ 2 - 2 * \u03b8 * \u27eau - v, w - v\u27eb_\u211d\neq\u2081 :\n  \u2016u - v\u2016 ^ 2 - 2 * \u03b8 * \u27eau - v, w - v\u27eb_\u211d + \u03b8 * \u03b8 * \u2016w - v\u2016 ^ 2 =\n    \u2016u - v\u2016 ^ 2 + (\u03b8 * \u03b8 * \u2016w - v\u2016 ^ 2 - 2 * \u03b8 * \u27eau - v, w - v\u27eb_\u211d)\n\u22a2 \u03b8 * \u03b8 * \u2016w - v\u2016 ^ 2 - 2 * \u03b8 * \u27eau - v, w - v\u27eb_\u211d = \u03b8 * (\u03b8 * \u2016w - v\u2016 ^ 2 - 2 * \u27eau - v, w - v\u27eb_\u211d)",["ring","linarith"]],["Analysis/NormedSpace/Multilinear/Basic.lean",276,"\ud835\udd5c : Type u\n\u03b9 : Type v\nE : \u03b9 \u2192 Type wE\nG : Type wG\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b2 : SeminormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\ninst\u271d : Fintype \u03b9\nf : MultilinearMap \ud835\udd5c E G\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\nA :\n  \u2200 (i : \u03b9),\n    (\u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else \u2016m\u2081 j\u2016 \u2294 \u2016m\u2082 j\u2016) \u2264 \u2016m\u2081 - m\u2082\u2016 * (\u2016m\u2081\u2016 \u2294 \u2016m\u2082\u2016) ^ (Fintype.card \u03b9 - 1)\n\u22a2 C * (\u2191(Fintype.card \u03b9) * (\u2016m\u2081 - m\u2082\u2016 * (\u2016m\u2081\u2016 \u2294 \u2016m\u2082\u2016) ^ (Fintype.card \u03b9 - 1))) =\n    C * \u2191(Fintype.card \u03b9) * (\u2016m\u2081\u2016 \u2294 \u2016m\u2082\u2016) ^ (Fintype.card \u03b9 - 1) * \u2016m\u2081 - m\u2082\u2016",["ring","linarith"]],["Analysis/Analytic/Composition.lean",475,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nq : FormalMultilinearSeries \ud835\udd5c F G\np : FormalMultilinearSeries \ud835\udd5c E F\nhq : 0 < q.radius\nhp : 0 < p.radius\nrq rp : \u211d\u22650\nhrp : rp < 1 \u2227 \u2191rp < p.radius\nhrq : rq < 1 \u2227 \u2191rq < q.radius\nrp_pos : 0 < rp\nrq_pos : 0 < rq\nCq : \u211d\u22650\n_hCq0 : Cq > 0\nhCq : \u2200 (n : \u2115), \u2016q n\u2016\u208a * rq ^ n \u2264 Cq\nCp : \u211d\u22650\nhCp1 : Cp \u2265 1\nhCp : \u2200 (n : \u2115), \u2016p n\u2016\u208a * rp ^ n \u2264 Cp\nr0 : \u211d\u22650 := (4 * Cp)\u207b\u00b9\nr0_pos : 0 < r0\nr : \u211d\u22650 := rp * rq * r0\nr_pos : 0 < r\nn : \u2115\nc : Composition n\nA : \u2016q c.length\u2016\u208a * rq ^ n \u2264 Cq\nB : (\u220f i : Fin c.length, \u2016p (c.blocksFun i)\u2016\u208a) * rp ^ n \u2264 Cp ^ n\n\u22a2 (\u2016q c.length\u2016\u208a * \u220f i : Fin c.length, \u2016p (c.blocksFun i)\u2016\u208a) * r ^ n =\n    \u2016q c.length\u2016\u208a * rq ^ n * ((\u220f i : Fin c.length, \u2016p (c.blocksFun i)\u2016\u208a) * rp ^ n) * r0 ^ n",["ring"]],["Analysis/Analytic/Composition.lean",480,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nq : FormalMultilinearSeries \ud835\udd5c F G\np : FormalMultilinearSeries \ud835\udd5c E F\nhq : 0 < q.radius\nhp : 0 < p.radius\nrq rp : \u211d\u22650\nhrp : rp < 1 \u2227 \u2191rp < p.radius\nhrq : rq < 1 \u2227 \u2191rq < q.radius\nrp_pos : 0 < rp\nrq_pos : 0 < rq\nCq : \u211d\u22650\n_hCq0 : Cq > 0\nhCq : \u2200 (n : \u2115), \u2016q n\u2016\u208a * rq ^ n \u2264 Cq\nCp : \u211d\u22650\nhCp1 : Cp \u2265 1\nhCp : \u2200 (n : \u2115), \u2016p n\u2016\u208a * rp ^ n \u2264 Cp\nr0 : \u211d\u22650 := (4 * Cp)\u207b\u00b9\nr0_pos : 0 < r0\nr : \u211d\u22650 := rp * rq * r0\nr_pos : 0 < r\nn : \u2115\nc : Composition n\nA : \u2016q c.length\u2016\u208a * rq ^ n \u2264 Cq\nB : (\u220f i : Fin c.length, \u2016p (c.blocksFun i)\u2016\u208a) * rp ^ n \u2264 Cp ^ n\n\u22a2 Cq * Cp ^ n * 4 ^ n = Cq * (4 ^ n * Cp ^ n)",["ring"]],["Analysis/Seminorm.lean",1204,"\ud835\udd5c : Type u_3\nE : Type u_7\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nx : E\nhx : p x \u2260 0\nx\u03b5pos : 0 < p x / \u03b5\nn : \u2124\nhn : p x / \u03b5 \u2208 Ico (\u2016c\u2016 ^ n) (\u2016c\u2016 ^ (n + 1))\ncpos : 0 < \u2016c\u2016\ncnpos : 0 < \u2016c ^ (n + 1)\u2016\n\u22a2 \u03b5\u207b\u00b9 * \u2016c\u2016 * p x = \u03b5\u207b\u00b9 * p x * \u2016c\u2016",["ring","linarith"]],["Analysis/Distribution/SchwartzSpace.lean",611,"C\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\nthis : 0 \u2264 C\u2082\n\u22a2 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l) = 2 ^ l * (1 + x) ^ (-\u2191l) * (C\u2081 + C\u2082)",["ring","linarith"]],["Analysis/Distribution/SchwartzSpace.lean",911,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \u211d F\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup D\ninst\u271d\u00b2 : NormedSpace \u211d D\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : SMulCommClass \u211d \ud835\udd5c F\ng : D \u2192 E\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nhgrowth : \u2200 N \u2264 n, \u2200 (x : D), \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\nkg : \u2115\nCg : \u211d\nhg_upper' : \u2200 (x : D), \u2016x\u2016 \u2264 Cg * (1 + \u2016g x\u2016) ^ kg\nhCg : 1 \u2264 1 + Cg\nk' : \u2115 := kg * (k + l * n)\nf : \ud835\udce2(E, F)\nx : D\nseminorm_f : \u211d := ((Finset.Iic (k', n)).sup (schwartzSeminormFamily \ud835\udd5c E F)) f\nhg_upper'' : (1 + \u2016x\u2016) ^ (k + l * n) \u2264 (1 + Cg) ^ (k + l * n) * (1 + \u2016g x\u2016) ^ k'\nhbound : \u2200 i \u2264 n, \u2016iteratedFDeriv \u211d i (\u21d1f) (g x)\u2016 \u2264 2 ^ k' * seminorm_f / (1 + \u2016g x\u2016) ^ k'\nhgrowth' : \u2200 (N : \u2115), 1 \u2264 N \u2192 N \u2264 n \u2192 \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 ((C + 1) * (1 + \u2016x\u2016) ^ l) ^ N\nthis :\n  \u2016iteratedFDeriv \u211d n (f.toFun \u2218 g) x\u2016 \u2264 \u2191n ! * (2 ^ k' * seminorm_f / (1 + \u2016g x\u2016) ^ k') * ((C + 1) * (1 + \u2016x\u2016) ^ l) ^ n\nhxk : \u2016x\u2016 ^ k \u2264 (1 + \u2016x\u2016) ^ k\n\u22a2 (1 + \u2016x\u2016) ^ k * (\u2191n ! * (2 ^ k' * seminorm_f / (1 + \u2016g x\u2016) ^ k') * ((C + 1) ^ n * (1 + \u2016x\u2016) ^ (l * n))) =\n    (1 + \u2016x\u2016) ^ k * (1 + \u2016x\u2016) ^ (l * n) / (1 + \u2016g x\u2016) ^ k' * ((C + 1) ^ n * \u2191n ! * 2 ^ k' * seminorm_f)",["ring"]],["Analysis/Distribution/SchwartzSpace.lean",1289,"\ud835\udd5c : Type u_1\nE : Type u_4\nF : Type u_5\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \u211d F\ninst\u271d\u2074 : MeasurableSpace E\ninst\u271d\u00b3 : OpensMeasurableSpace E\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : SMulCommClass \u211d \ud835\udd5c F\np : \u211d\u22650\u221e\n\u03bc : autoParam (Measure E) _auto\u271d\nh\u03bc : Measure.HasTemperateGrowth \u03bc\nk : \u2115\nhk : eLpNorm (fun x \u21a6 (1 + \u2016x\u2016) ^ (-\u2191k)) p \u03bc < \u22a4\nf : \ud835\udce2(E, F)\nh_one_add : \u2200 (x : E), 0 < 1 + \u2016x\u2016\n\u22a2 eLpNorm (fun x \u21a6 (1 + \u2016x\u2016) ^ (-\u2191k)) p \u03bc *\n      (2 ^ k * ENNReal.ofReal (((Finset.Iic (k, 0)).sup (schwartzSeminormFamily \ud835\udd5c E F)) f)) =\n    eLpNorm (fun x \u21a6 (1 + \u2016x\u2016) ^ (-\u2191k)) p \u03bc * 2 ^ k *\n      ENNReal.ofReal (((Finset.Iic (k, 0)).sup (schwartzSeminormFamily \ud835\udd5c E F)) f)",["ring"]],["Geometry/Manifold/VectorField/LieBracket.lean",360,"\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nH : Type u_2\ninst\u271d\u2076 : TopologicalSpace H\nE : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : ChartedSpace H M\ns : Set M\nx : M\nV W W\u2081 : (x : M) \u2192 TangentSpace I x\ninst\u271d\u00b9 : IsManifold I 2 M\ninst\u271d : CompleteSpace E\nhW : MDifferentiableWithinAt I I.tangent (fun x \u21a6 { proj := x, snd := W x }) s x\nhW\u2081 : MDifferentiableWithinAt I I.tangent (fun x \u21a6 { proj := x, snd := W\u2081 x }) s x\nhs : UniqueMDiffWithinAt I s x\n\u22a2 -(mlieBracketWithin I W V s x + mlieBracketWithin I W\u2081 V s x) =\n    -mlieBracketWithin I W V s x + -mlieBracketWithin I W\u2081 V s x",["abel"]],["MeasureTheory/Integral/IntervalIntegral.lean",620,"E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\n\u22a2 -\u222b (a : \u211d) in Ioc a b, f a \u2202\u03bc - -\u222b (a : \u211d) in Ioc b a, f a \u2202\u03bc =\n    -(\u222b (x : \u211d) in Ioc a b, f x \u2202\u03bc - \u222b (x : \u211d) in Ioc b a, f x \u2202\u03bc)",["abel"]],["Topology/MetricSpace/GromovHausdorff.lean",276,"X : Type u\ninst\u271d\u2075 : MetricSpace X\ninst\u271d\u2074 : CompactSpace X\ninst\u271d\u00b3 : Nonempty X\nY : Type v\ninst\u271d\u00b2 : MetricSpace Y\ninst\u271d\u00b9 : CompactSpace Y\ninst\u271d : Nonempty Y\ninhabited_h\u271d : Inhabited X\ninhabited_h : Inhabited Y\np q : NonemptyCompacts \u21a5(lp (fun n \u21a6 \u211d) \u22a4)\nhp : \u27e6p\u27e7 = toGHSpace X\nhq : \u27e6q\u27e7 = toGHSpace Y\nbound : hausdorffDist \u2191p \u2191q < diam univ + 1 + diam univ\n\u03a6 : X \u2192 \u21a5(lp (fun n \u21a6 \u211d) \u22a4)\n\u03a6isom : Isometry \u03a6\n\u03a6range : range \u03a6 = \u2191p\n\u03a8 : Y \u2192 \u21a5(lp (fun n \u21a6 \u211d) \u22a4)\n\u03a8isom : Isometry \u03a8\n\u03a8range : range \u03a8 = \u2191q\nxX : X\nh\u271d : xX \u2208 univ\ny : \u21a5(lp (fun n \u21a6 \u211d) \u22a4)\nhy : y \u2208 range \u03a8\nz : Y\ndy : dist (\u03a6 xX) (\u03a8 z) < diam univ + 1 + diam univ\nhzy : \u03a8 z = y\nD\u03a6 : diam (range \u03a6) = diam univ\nD\u03a8 : diam (range \u03a8) = diam univ\n\u22a2 diam univ + (diam univ + 1 + diam univ) + diam univ = 2 * diam univ + 1 + 2 * diam univ",["ring","linarith"]],["Topology/MetricSpace/GromovHausdorff.lean",740,"case e_a\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\n\u03b5 : \u211d := 2 / 5 * \u03b4\n\u03b5pos : 0 < \u03b5\ns : (p : GHSpace) \u2192 Set p.Rep\nhs : \u2200 (p : GHSpace), (s p).Finite \u2227 univ \u2286 \u22c3 x \u2208 s p, ball x \u03b5\nN\u271d : (p : GHSpace) \u2192 (t : Set p.Rep) \u2192 t.Finite \u2192 \u2115\ne : (p : GHSpace) \u2192 (t : Set p.Rep) \u2192 (a : t.Finite) \u2192 \u2191t \u2243 Fin (N\u271d p t a)\nx\u271d : \u2200 (p : GHSpace) (t : Set p.Rep), t.Finite \u2192 True\nN : GHSpace \u2192 \u2115 := fun p \u21a6 N\u271d p (s p) \u22ef\nE : (p : GHSpace) \u2192 \u2191(s p) \u2243 Fin (N\u271d p (s p) \u22ef) := fun p \u21a6 e p (s p) \u22ef\nF : GHSpace \u2192 (n : \u2115) \u00d7 (Fin n \u2192 Fin n \u2192 \u2124) := fun p \u21a6 \u27e8N p, fun a b \u21a6 \u230a\u03b5\u207b\u00b9 * dist ((E p).symm a) ((E p).symm b)\u230b\u27e9\np q : GHSpace\nhpq : F p = F q\nNpq : N p = N q\n\u03a8 : \u2191(s p) \u2192 \u2191(s q) := fun x \u21a6 (E q).symm (Fin.cast Npq ((E p) x))\n\u03a6 : \u2191(s p) \u2192 q.Rep := fun x \u21a6 \u2191(\u03a8 x)\nx y : \u2191(s p)\ni : \u2115 := \u2191((E p) x)\nhip : i < N p\nhiq : i < N q\ni' : i = \u2191((E q) (\u03a8 x))\nj : \u2115 := \u2191((E p) y)\nhjp : j < N p\nhjq : j < N q\nj' : j = \u2191((E q) (\u03a8 y))\nthis\u271d\u00b9 : (F p).snd ((E p) x) ((E p) y) = \u230a\u03b5\u207b\u00b9 * dist x y\u230b\nAp : (F p).snd \u27e8i, hip\u27e9 \u27e8j, hjp\u27e9 = \u230a\u03b5\u207b\u00b9 * dist x y\u230b\nthis\u271d : (F q).snd ((E q) (\u03a8 x)) ((E q) (\u03a8 y)) = \u230a\u03b5\u207b\u00b9 * dist (\u03a8 x) (\u03a8 y)\u230b\nAq : (F q).snd \u27e8i, hiq\u27e9 \u27e8j, hjq\u27e9 = \u230a\u03b5\u207b\u00b9 * dist (\u03a8 x) (\u03a8 y)\u230b\nthis : \u230a\u03b5\u207b\u00b9 * dist x y\u230b = \u230a\u03b5\u207b\u00b9 * dist (\u03a8 x) (\u03a8 y)\u230b\n\u22a2 \u03b5\u207b\u00b9 * (dist x y - dist (\u03a8 x) (\u03a8 y)) = \u03b5\u207b\u00b9 * dist x y - \u03b5\u207b\u00b9 * dist (\u03a8 x) (\u03a8 y)",["ring","linarith"]],["Topology/MetricSpace/GromovHausdorff.lean",752,"\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\n\u03b5 : \u211d := 2 / 5 * \u03b4\n\u03b5pos : 0 < \u03b5\ns : (p : GHSpace) \u2192 Set p.Rep\nhs : \u2200 (p : GHSpace), (s p).Finite \u2227 univ \u2286 \u22c3 x \u2208 s p, ball x \u03b5\nN\u271d : (p : GHSpace) \u2192 (t : Set p.Rep) \u2192 t.Finite \u2192 \u2115\ne : (p : GHSpace) \u2192 (t : Set p.Rep) \u2192 (a : t.Finite) \u2192 \u2191t \u2243 Fin (N\u271d p t a)\nx\u271d : \u2200 (p : GHSpace) (t : Set p.Rep), t.Finite \u2192 True\nN : GHSpace \u2192 \u2115 := fun p \u21a6 N\u271d p (s p) \u22ef\nE : (p : GHSpace) \u2192 \u2191(s p) \u2243 Fin (N\u271d p (s p) \u22ef) := fun p \u21a6 e p (s p) \u22ef\nF : GHSpace \u2192 (n : \u2115) \u00d7 (Fin n \u2192 Fin n \u2192 \u2124) := fun p \u21a6 \u27e8N p, fun a b \u21a6 \u230a\u03b5\u207b\u00b9 * dist ((E p).symm a) ((E p).symm b)\u230b\u27e9\np q : GHSpace\nhpq : F p = F q\nNpq : N p = N q\n\u03a8 : \u2191(s p) \u2192 \u2191(s q) := fun x \u21a6 (E q).symm (Fin.cast Npq ((E p) x))\n\u03a6 : \u2191(s p) \u2192 q.Rep := fun x \u21a6 \u2191(\u03a8 x)\nmain : ghDist p.Rep q.Rep \u2264 \u03b5 + \u03b5 / 2 + \u03b5\n\u22a2 \u03b5 + \u03b5 / 2 + \u03b5 = \u03b4",["ring"]],["Topology/MetricSpace/GromovHausdorff.lean",909,"case e_a\nt : Set GHSpace\nC : \u211d\nu : \u2115 \u2192 \u211d\nK : \u2115 \u2192 \u2115\nulim : Tendsto u atTop (\ud835\udcdd 0)\nhdiam : \u2200 p \u2208 t, diam univ \u2264 C\nhcov : \u2200 p \u2208 t, \u2200 (n : \u2115), \u2203 s, #\u2191s \u2264 \u2191(K n) \u2227 univ \u2286 \u22c3 x \u2208 s, ball x (u n)\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\n\u03b5 : \u211d := 1 / 5 * \u03b4\n\u03b5pos : 0 < \u03b5\nn : \u2115\nhn : \u2200 n_1 \u2265 n, dist (u n_1) 0 < \u03b5\nu_le_\u03b5 : u n \u2264 \u03b5\ns : (p : GHSpace) \u2192 Set p.Rep\nN : GHSpace \u2192 \u2115\nhN : \u2200 (p : GHSpace), N p \u2264 K n\nE : (p : GHSpace) \u2192 \u2191(s p) \u2243 Fin (N p)\nhs : \u2200 p \u2208 t, univ \u2286 \u22c3 x \u2208 s p, ball x (u n)\nM : \u2115 := \u230a\u03b5\u207b\u00b9 * (C \u2294 0)\u230b\u208a\nF : GHSpace \u2192 (k : Fin (K n).succ) \u00d7 (Fin \u2191k \u2192 Fin \u2191k \u2192 Fin M.succ) :=\n  fun p \u21a6 \u27e8\u27e8N p, \u22ef\u27e9, fun a b \u21a6 \u27e8M \u2293 \u230a\u03b5\u207b\u00b9 * dist ((E p).symm a) ((E p).symm b)\u230b\u208a, \u22ef\u27e9\u27e9\np : GHSpace\npt : p \u2208 t\nq : GHSpace\nqt : q \u2208 t\nhpq : (fun p \u21a6 F \u2191p) \u27e8p, pt\u27e9 = (fun p \u21a6 F \u2191p) \u27e8q, qt\u27e9\nNpq : N p = N q\n\u03a8 : \u2191(s p) \u2192 \u2191(s q) := fun x \u21a6 (E q).symm (Fin.cast Npq ((E p) x))\n\u03a6 : \u2191(s p) \u2192 q.Rep := fun x \u21a6 \u2191(\u03a8 x)\nx y : \u2191(s p)\nthis\u271d\u00b9 : dist (\u03a6 x) (\u03a6 y) = dist (\u03a8 x) (\u03a8 y)\ni : \u2115 := \u2191((E p) x)\nhip : i < N p\nhiq : i < N q\ni' : i = \u2191((E q) (\u03a8 x))\nj : \u2115 := \u2191((E p) y)\nhjp : j < N p\nhjq : j < N q\nj' : j = \u2191((E q) (\u03a8 y))\nAp : \u2191((F p).snd \u27e8i, hip\u27e9 \u27e8j, hjp\u27e9) = \u230a\u03b5\u207b\u00b9 * dist x y\u230b\u208a\nAq : \u2191((F q).snd \u27e8i, hiq\u27e9 \u27e8j, hjq\u27e9) = \u230a\u03b5\u207b\u00b9 * dist (\u03a8 x) (\u03a8 y)\u230b\u208a\nthis\u271d : \u2191((F p).snd \u27e8i, hip\u27e9 \u27e8j, hjp\u27e9) = \u2191((F q).snd \u27e8i, hiq\u27e9 \u27e8j, hjq\u27e9)\nthis : \u230a\u03b5\u207b\u00b9 * dist x y\u230b = \u230a\u03b5\u207b\u00b9 * dist (\u03a8 x) (\u03a8 y)\u230b\n\u22a2 \u03b5\u207b\u00b9 * (dist x y - dist (\u03a8 x) (\u03a8 y)) = \u03b5\u207b\u00b9 * dist x y - \u03b5\u207b\u00b9 * dist (\u03a8 x) (\u03a8 y)",["ring","linarith"]],["Topology/MetricSpace/GromovHausdorff.lean",921,"t : Set GHSpace\nC : \u211d\nu : \u2115 \u2192 \u211d\nK : \u2115 \u2192 \u2115\nulim : Tendsto u atTop (\ud835\udcdd 0)\nhdiam : \u2200 p \u2208 t, diam univ \u2264 C\nhcov : \u2200 p \u2208 t, \u2200 (n : \u2115), \u2203 s, #\u2191s \u2264 \u2191(K n) \u2227 univ \u2286 \u22c3 x \u2208 s, ball x (u n)\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\n\u03b5 : \u211d := 1 / 5 * \u03b4\n\u03b5pos : 0 < \u03b5\nn : \u2115\nhn : \u2200 n_1 \u2265 n, dist (u n_1) 0 < \u03b5\nu_le_\u03b5 : u n \u2264 \u03b5\ns : (p : GHSpace) \u2192 Set p.Rep\nN : GHSpace \u2192 \u2115\nhN : \u2200 (p : GHSpace), N p \u2264 K n\nE : (p : GHSpace) \u2192 \u2191(s p) \u2243 Fin (N p)\nhs : \u2200 p \u2208 t, univ \u2286 \u22c3 x \u2208 s p, ball x (u n)\nM : \u2115 := \u230a\u03b5\u207b\u00b9 * (C \u2294 0)\u230b\u208a\nF : GHSpace \u2192 (k : Fin (K n).succ) \u00d7 (Fin \u2191k \u2192 Fin \u2191k \u2192 Fin M.succ) :=\n  fun p \u21a6 \u27e8\u27e8N p, \u22ef\u27e9, fun a b \u21a6 \u27e8M \u2293 \u230a\u03b5\u207b\u00b9 * dist ((E p).symm a) ((E p).symm b)\u230b\u208a, \u22ef\u27e9\u27e9\np : GHSpace\npt : p \u2208 t\nq : GHSpace\nqt : q \u2208 t\nhpq : (fun p \u21a6 F \u2191p) \u27e8p, pt\u27e9 = (fun p \u21a6 F \u2191p) \u27e8q, qt\u27e9\nNpq : N p = N q\n\u03a8 : \u2191(s p) \u2192 \u2191(s q) := fun x \u21a6 (E q).symm (Fin.cast Npq ((E p) x))\n\u03a6 : \u2191(s p) \u2192 q.Rep := fun x \u21a6 \u2191(\u03a8 x)\nmain : ghDist p.Rep q.Rep \u2264 \u03b5 + \u03b5 / 2 + \u03b5\n\u22a2 5\u207b\u00b9 * \u03b4 + 5\u207b\u00b9 * \u03b4 / 2 + 5\u207b\u00b9 * \u03b4 = \u03b4 / 2",["ring","linarith"]],["LinearAlgebra/TensorProduct/Basic.lean",1278,"R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx\u271d x y : M \u2297[R] N\nhx : -x + x = 0\nhy : -y + y = 0\nthis : -x + x + (-y + y) = 0\n\u22a2 (Neg.aux R) x + (Neg.aux R) y + (x + y) = (Neg.aux R) x + x + ((Neg.aux R) y + y)",["abel"]],["RingTheory/Ideal/Operations.lean",696,"R : Type u\n\u03b9 : Type u_1\ninst\u271d : CommSemiring R\nI : Ideal R\nJ : \u03b9 \u2192 Ideal R\ni : \u03b9\ns : Finset \u03b9\na\u271d : i \u2209 s\nhf : \u2200 j \u2208 insert i s, I + J j = 1\nK : Ideal R := \u2a05 j \u2208 s, J j\nhs : (\u2200 j \u2208 s, I + J j = 1) \u2192 I + K = 1\n\u22a2 I + K * (I + J i) = (1 + K) * I + K * J i",["ring"]],["MeasureTheory/Covering/Differentiation.lean",562,"case e_a.e_a\n\u03b1 : Type u_1\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nv : VitaliFamily \u03bc\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : BorelSpace \u03b1\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\n\u03c1 : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03c1\nh\u03c1 : \u03c1 \u226a \u03bc\ns : Set \u03b1\nhs : MeasurableSet s\nt : \u211d\u22650\nht : 1 < t\nt_ne_zero' : t \u2260 0\nt_ne_zero : \u2191t \u2260 0\n\u03bd : Measure \u03b1 := \u03bc.withDensity (v.limRatioMeas h\u03c1)\nf : \u03b1 \u2192 \u211d\u22650\u221e := v.limRatioMeas h\u03c1\nf_meas : Measurable f\nA : \u03bd (s \u2229 f \u207b\u00b9' {0}) \u2264 (\u2191t ^ 2 \u2022 \u03c1) (s \u2229 f \u207b\u00b9' {0})\nB : \u03bd (s \u2229 f \u207b\u00b9' {\u22a4}) \u2264 (\u2191t ^ 2 \u2022 \u03c1) (s \u2229 f \u207b\u00b9' {\u22a4})\nn : \u2124\nI : Set \u211d\u22650\u221e := Ico (\u2191t ^ n) (\u2191t ^ (n + 1))\nM : MeasurableSet (s \u2229 f \u207b\u00b9' I)\n\u22a2 n + 1 = 2 + (n - 1)",["abel","ring","omega","linarith"]],["LinearAlgebra/QuadraticForm/Basic.lean",104,"M : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : AddCommGroup N\nf g : M \u2192 N\nx y : M\n\u22a2 f (x + y) + g (x + y) - (f x + g x) - (f y + g y) = f (x + y) - f x - f y + (g (x + y) - g x - g y)",["abel"]],["LinearAlgebra/QuadraticForm/Basic.lean",221,"case intro\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\nQ : QuadraticMap R M N\nx y z : M\nB : BilinMap R M N\nh : \u2200 (x y : M), Q (x + y) = Q x + Q y + (B x) y\n\u22a2 Q x + Q y + (B x) y + Q z + ((B x) z + (B y) z) + (Q x + Q y + Q z) =\n    Q x + Q y + (B x) y + (Q y + Q z + (B y) z) + (Q x + Q z + (B x) z)",["abel"]],["LinearAlgebra/QuadraticForm/Basic.lean",225,"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\nQ : QuadraticMap R M N\nx : M\n\u22a2 (2 * 2) \u2022 Q x = \u21914 \u2022 Q x",["norm_num","ring"]],["Algebra/Order/Floor.lean",962,"case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na : \u03b1\nc : \u2115\nz : \u2124\nhz : fract a * \u2191c - fract (a * \u2191c) = \u2191z\ny : \u2124\nhy : fract (a * \u2191c + a) - fract (a * \u2191c) - fract a = \u2191y\n\u22a2 fract a * \u2191c + fract a - fract (a * \u2191c + a) =\n    fract a * \u2191c - fract (a * \u2191c) - (fract (a * \u2191c + a) - fract (a * \u2191c) - fract a)",["abel"]],["Algebra/Order/Floor.lean",1216,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na : \u03b1\nha : fract a \u2260 0\n\u22a2 \u2191\u2308a\u2309 - a = 1 - (a + 1 - \u2191\u2308a\u2309)",["abel"]],["Analysis/Calculus/FDeriv/Measurable.lean",494,"case e_a\nF : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nx : \u211d\nhx : DifferentiableWithinAt \u211d f (Ici x) x\nthis\u271d : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x_1 : \u211d) in \ud835\udcdd[\u2265] x, \u2016f x_1 - f x - (x_1 - x) \u2022 derivWithin f (Ici x) x\u2016 \u2264 c * \u2016x_1 - x\u2016\nm : \u211d\nxm : m \u2208 Ioi x\nhm : Ico x m \u2286 {x_1 | (fun x_2 \u21a6 \u2016f x_2 - f x - (x_2 - x) \u2022 derivWithin f (Ici x) x\u2016 \u2264 \u03b5 / 2 * \u2016x_2 - x\u2016) x_1}\nr : \u211d\nhr : r \u2208 Ioo 0 (m - x)\nthis : r \u2208 Ioc (r / 2) r\ny : \u211d\nhy : y \u2208 Icc x (x + r)\nz : \u211d\nhz : z \u2208 Icc x (x + r)\n\u22a2 f z - f y - (z \u2022 derivWithin f (Ici x) x - y \u2022 derivWithin f (Ici x) x) =\n    f z - f x - (z \u2022 derivWithin f (Ici x) x - x \u2022 derivWithin f (Ici x) x) -\n      (f y - f x - (y \u2022 derivWithin f (Ici x) x - x \u2022 derivWithin f (Ici x) x))",["abel"]],["Analysis/Calculus/FDeriv/Measurable.lean",841,"case e_a\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b3 : LocallyCompactSpace E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\n\u03b1 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 E \u2192 F\nr s : \u211d\nhf : Continuous (Function.uncurry f)\nL : E \u2192L[\ud835\udd5c] F\nthis\u271d : ProperSpace E\na : \u03b1\nx : E\nr' : \u211d\nhr :\n  \u2200 (y : E), dist y (a, x).2 < r' \u2192 \u2200 (z : E), dist z (a, x).2 < r' \u2192 \u2016f (a, x).1 z - f (a, x).1 y - (L z - L y)\u2016 < s * r\nIrr' : r / 2 < r'\nIr'r : r' \u2264 r\nha : Continuous (f a)\nt : \u211d\nhrt : r / 2 < t\nhtr' : t < r'\nt' : \u211d\nhrt' : r / 2 < t'\nht't : t' < t\nb : \u211d\nb_lt : b < s * r\nhb : \u2200 y \u2208 closedBall x t, \u2200 z \u2208 closedBall x t, \u2016f a z - f a y - (L z - L y)\u2016 \u2264 b\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nh\u03b5 : b + 2 * \u03b5 < s * r\nu : Set \u03b1\nu_open : IsOpen u\nau : a \u2208 u\nhu : \u2200 (p : \u03b1 \u00d7 E), p.1 \u2208 u \u2192 p.2 \u2208 closedBall x t \u2192 dist (Function.uncurry f p) (Function.uncurry f (a, p.2)) < \u03b5\nthis : u \u00d7\u02e2 ball x (t - t') \u2208 \ud835\udcdd (a, x)\na' : \u03b1\nx' : E\nha'x' : a' \u2208 u \u2227 dist x' x < t - t'\ny : E\nhy : dist y (a', x').2 < t'\nz : E\nhz : dist z (a', x').2 < t'\ndyx : dist y x \u2264 t\ndzx : dist z x \u2264 t\n\u22a2 f a' z - f a' y - (L z - L y) = f a' z - f a z + (f a y - f a' y) + (f a z - f a y - (L z - L y))",["abel"]],["Analysis/Calculus/FDeriv/Measurable.lean",271,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",296,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : E \u2192L[\ud835\udd5c] F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\npos : 0 < 4 + 12 * \u2016c\u2016\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",603,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",628,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",169,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nx : E\nhx : DifferentiableAt \ud835\udd5c f x\n\u03b4 : \u211d := \u03b5 / 2 / 2\nR : \u211d\nR_pos : R > 0\nhR : \u2200 y \u2208 ball x R, \u2016f y - f x - (fderiv \ud835\udd5c f x) (y - x)\u2016 \u2264 \u03b4 * \u2016y - x\u2016\nr : \u211d\nhr : r \u2208 Ioo 0 R\nthis : r \u2208 Ioc (r / 2) r\ny : E\nhy : y \u2208 ball x r\nz : E\nhz : z \u2208 ball x r\n\u22a2 \u03b4 * r + \u03b4 * r = \u03b5 / 2 * r",["ring"]],["Analysis/Calculus/FDeriv/Measurable.lean",189,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nr \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhr : 0 < r\nx : E\nL\u2081 L\u2082 : E \u2192L[\ud835\udd5c] F\nh\u2081 : x \u2208 A f L\u2081 r \u03b5\nh\u2082 : x \u2208 A f L\u2082 r \u03b5\ny : E\nley : r \u2264 2 * \u2016c\u2016 * \u2016y\u2016\nylt : \u2016y\u2016 < r / 2\n\u22a2 \u03b5 * r + \u03b5 * r = 2 * \u03b5 * r",["ring","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",191,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nr \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhr : 0 < r\nx : E\nL\u2081 L\u2082 : E \u2192L[\ud835\udd5c] F\nh\u2081 : x \u2208 A f L\u2081 r \u03b5\nh\u2082 : x \u2208 A f L\u2082 r \u03b5\ny : E\nley : r \u2264 2 * \u2016c\u2016 * \u2016y\u2016\nylt : \u2016y\u2016 < r / 2\n\u22a2 2 * \u03b5 * (2 * \u2016c\u2016 * \u2016y\u2016) = 4 * \u2016c\u2016 * \u03b5 * \u2016y\u2016",["ring","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",263,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\ne p q e' p' q' : \u2115\nhp : n e \u2264 p\nhq : n e \u2264 q\nhp' : n e' \u2264 p'\nhq' : n e' \u2264 q'\nhe' : e \u2264 e'\nr : \u2115 := n e \u2294 n e'\nI : (1 / 2) ^ e' \u2264 (1 / 2) ^ e\nJ1 : \u2016L e p q - L e p r\u2016 \u2264 4 * \u2016c\u2016 * (1 / 2) ^ e\nJ2 : \u2016L e p r - L e' p' r\u2016 \u2264 4 * \u2016c\u2016 * (1 / 2) ^ e\nJ3 : \u2016L e' p' r - L e' p' q'\u2016 \u2264 4 * \u2016c\u2016 * (1 / 2) ^ e\n\u22a2 4 * \u2016c\u2016 * (1 / 2) ^ e + 4 * \u2016c\u2016 * (1 / 2) ^ e + 4 * \u2016c\u2016 * (1 / 2) ^ e = 12 * \u2016c\u2016 * (1 / 2) ^ e",["ring","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",331,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : E \u2192L[\ud835\udd5c] F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\npos : 0 < 4 + 12 * \u2016c\u2016\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / (4 + 12 * \u2016c\u2016)\ny : E\nhy : y \u2208 ball 0 ((1 / 2) ^ (n e + 1))\ny_pos : \u00acy = 0\nyzero : 0 < \u2016y\u2016\ny_lt : \u2016y\u2016 < (1 / 2) ^ (n e + 1)\nyone : \u2016y\u2016 \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : \u2016y\u2016 \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < \u2016y\u2016\nm_ge : n e \u2264 m\nkm : k = m + 1\nJ1 : \u2016f (x + y) - f x - (L e (n e) m) (x + y - x)\u2016 \u2264 (1 / 2) ^ e * (1 / 2) ^ m\n\u22a2 2 ^ e * 2 ^ (m + 2) = 4 * (2 ^ e * 2 ^ m)",["ring"]],["Analysis/Calculus/FDeriv/Measurable.lean",339,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : E \u2192L[\ud835\udd5c] F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\npos : 0 < 4 + 12 * \u2016c\u2016\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / (4 + 12 * \u2016c\u2016)\ny : E\nhy : y \u2208 ball 0 ((1 / 2) ^ (n e + 1))\ny_pos : \u00acy = 0\nyzero : 0 < \u2016y\u2016\ny_lt : \u2016y\u2016 < (1 / 2) ^ (n e + 1)\nyone : \u2016y\u2016 \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : \u2016y\u2016 \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < \u2016y\u2016\nm_ge : n e \u2264 m\nkm : k = m + 1\nJ1 : \u2016f (x + y) - f x - (L e (n e) m) (x + y - x)\u2016 \u2264 (1 / 2) ^ e * (1 / 2) ^ m\nJ2 : \u2016f (x + y) - f x - (L e (n e) m) y\u2016 \u2264 4 * (1 / 2) ^ e * \u2016y\u2016\n\u22a2 4 * (1 / 2) ^ e * \u2016y\u2016 + 12 * \u2016c\u2016 * (1 / 2) ^ e * \u2016y\u2016 = (4 + 12 * \u2016c\u2016) * \u2016y\u2016 * (1 / 2) ^ e",["ring","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",341,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : E \u2192L[\ud835\udd5c] F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\npos : 0 < 4 + 12 * \u2016c\u2016\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / (4 + 12 * \u2016c\u2016)\ny : E\nhy : y \u2208 ball 0 ((1 / 2) ^ (n e + 1))\ny_pos : \u00acy = 0\nyzero : 0 < \u2016y\u2016\ny_lt : \u2016y\u2016 < (1 / 2) ^ (n e + 1)\nyone : \u2016y\u2016 \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : \u2016y\u2016 \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < \u2016y\u2016\nm_ge : n e \u2264 m\nkm : k = m + 1\nJ1 : \u2016f (x + y) - f x - (L e (n e) m) (x + y - x)\u2016 \u2264 (1 / 2) ^ e * (1 / 2) ^ m\nJ2 : \u2016f (x + y) - f x - (L e (n e) m) y\u2016 \u2264 4 * (1 / 2) ^ e * \u2016y\u2016\n\u22a2 (4 + 12 * \u2016c\u2016) * \u2016y\u2016 * \u03b5 = \u03b5 * \u2016y\u2016 * (4 + 12 * \u2016c\u2016)",["ring","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",506,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nx : \u211d\nhx : DifferentiableWithinAt \u211d f (Ici x) x\nthis\u271d : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x_1 : \u211d) in \ud835\udcdd[\u2265] x, \u2016f x_1 - f x - (x_1 - x) \u2022 derivWithin f (Ici x) x\u2016 \u2264 c * \u2016x_1 - x\u2016\nm : \u211d\nxm : m \u2208 Ioi x\nhm : Ico x m \u2286 {x_1 | (fun x_2 \u21a6 \u2016f x_2 - f x - (x_2 - x) \u2022 derivWithin f (Ici x) x\u2016 \u2264 \u03b5 / 2 * \u2016x_2 - x\u2016) x_1}\nr : \u211d\nhr : r \u2208 Ioo 0 (m - x)\nthis : r \u2208 Ioc (r / 2) r\ny : \u211d\nhy : y \u2208 Icc x (x + r)\nz : \u211d\nhz : z \u2208 Icc x (x + r)\n\u22a2 \u03b5 / 2 * r + \u03b5 / 2 * r = \u03b5 * r",["ring","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",524,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nr x : \u211d\nhr : 0 < r\n\u03b5 : \u211d\nL\u2081 L\u2082 : F\nh\u2081 : x \u2208 A f L\u2081 r \u03b5\nh\u2082 : x \u2208 A f L\u2082 r \u03b5\n\u22a2 \u03b5 * r + \u03b5 * r = r / 2 * (4 * \u03b5)",["ring","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",594,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\ne p q e' p' q' : \u2115\nhp : n e \u2264 p\nhq : n e \u2264 q\nhp' : n e' \u2264 p'\nhq' : n e' \u2264 q'\nhe' : e \u2264 e'\nr : \u2115 := n e \u2294 n e'\nI : (1 / 2) ^ e' \u2264 (1 / 2) ^ e\nJ1 : \u2016L e p q - L e p r\u2016 \u2264 4 * (1 / 2) ^ e\nJ2 : \u2016L e p r - L e' p' r\u2016 \u2264 4 * (1 / 2) ^ e\nJ3 : \u2016L e' p' r - L e' p' q'\u2016 \u2264 4 * (1 / 2) ^ e\n\u22a2 4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e = 12 * (1 / 2) ^ e",["ring","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",660,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / 16\ny : \u211d\nhy : y \u2208 Icc x (x + (1 / 2) ^ (n e + 1))\nxy : x < y\nyzero : 0 < y - x\ny_le : y - x \u2264 (1 / 2) ^ (n e + 1)\nyone : y - x \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : y - x \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < y - x\nm_ge : n e \u2264 m\nkm : k = m + 1\n\u22a2 2 ^ e * 2 ^ (m + 2) = 4 * (2 ^ e * 2 ^ m)",["ring"]],["Analysis/Calculus/FDeriv/Measurable.lean",669,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / 16\ny : \u211d\nhy : y \u2208 Icc x (x + (1 / 2) ^ (n e + 1))\nxy : x < y\nyzero : 0 < y - x\ny_le : y - x \u2264 (1 / 2) ^ (n e + 1)\nyone : y - x \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : y - x \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < y - x\nm_ge : n e \u2264 m\nkm : k = m + 1\nJ : \u2016f y - f x - (y - x) \u2022 L e (n e) m\u2016 \u2264 4 * (1 / 2) ^ e * \u2016y - x\u2016\n\u22a2 4 * (1 / 2) ^ e * \u2016y - x\u2016 + \u2016y - x\u2016 * (12 * (1 / 2) ^ e) = 16 * \u2016y - x\u2016 * (1 / 2) ^ e",["ring","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",671,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / 16\ny : \u211d\nhy : y \u2208 Icc x (x + (1 / 2) ^ (n e + 1))\nxy : x < y\nyzero : 0 < y - x\ny_le : y - x \u2264 (1 / 2) ^ (n e + 1)\nyone : y - x \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : y - x \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < y - x\nm_ge : n e \u2264 m\nkm : k = m + 1\nJ : \u2016f y - f x - (y - x) \u2022 L e (n e) m\u2016 \u2264 4 * (1 / 2) ^ e * \u2016y - x\u2016\n\u22a2 16 * \u2016y - x\u2016 * (\u03b5 / 16) = \u03b5 * \u2016y - x\u2016",["ring","linarith"]],["MeasureTheory/Constructions/Polish/Basic.lean",479,"\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nf g : (\u2115 \u2192 \u2115) \u2192 \u03b1\nhf : Continuous f\nhg : Continuous g\nh : Disjoint (range f) (range g)\nhfg : \u00acMeasurablySeparable (range f) (range g)\nI :\n  \u2200 (n : \u2115) (x y : \u2115 \u2192 \u2115),\n    \u00acMeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) \u2192\n      \u2203 x' y',\n        x' \u2208 cylinder x n \u2227 y' \u2208 cylinder y n \u2227 \u00acMeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1))\nA : Type := { p // \u00acMeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }\nF : A \u2192 A\nhFn : \u2200 (p : A), (\u2191(F p)).1 = (\u2191p).1 + 1\nhFx : \u2200 (p : A), (\u2191(F p)).2.1 \u2208 cylinder (\u2191p).2.1 (\u2191p).1\nhFy : \u2200 (p : A), (\u2191(F p)).2.2 \u2208 cylinder (\u2191p).2.2 (\u2191p).1\np0 : A := \u27e8(0, fun x \u21a6 0, fun x \u21a6 0), \u22ef\u27e9\np : \u2115 \u2192 A := fun n \u21a6 F^[n] p0\nprec : \u2200 (n : \u2115), p (n + 1) = F (p n)\npn_fst : \u2200 (n : \u2115), (\u2191(p n)).1 = n\nIx : \u2200 (m n : \u2115), m + 1 \u2264 n \u2192 (\u2191(p n)).2.1 m = (\u2191(p (m + 1))).2.1 m\nIy : \u2200 (m n : \u2115), m + 1 \u2264 n \u2192 (\u2191(p n)).2.2 m = (\u2191(p (m + 1))).2.2 m\nx : \u2115 \u2192 \u2115 := fun n \u21a6 (\u2191(p (n + 1))).2.1 n\nhx : x = fun n \u21a6 (\u2191(p (n + 1))).2.1 n\ny : \u2115 \u2192 \u2115 := fun n \u21a6 (\u2191(p (n + 1))).2.2 n\nhy : y = fun n \u21a6 (\u2191(p (n + 1))).2.2 n\nM : \u2200 (n : \u2115), \u00acMeasurablySeparable (f '' cylinder x n) (g '' cylinder y n)\nu v : Set \u03b1\nu_open : IsOpen u\nv_open : IsOpen v\nxu : f x \u2208 u\nyv : g y \u2208 v\nhuv : Disjoint u v\nthis : MetricSpace (\u2115 \u2192 \u2115) := metricSpaceNatNat\n\u03b5x : \u211d\n\u03b5xpos : \u03b5x > 0\nh\u03b5x : ball x \u03b5x \u2286 f \u207b\u00b9' u\n\u03b5y : \u211d\n\u03b5ypos : \u03b5y > 0\nh\u03b5y : ball y \u03b5y \u2286 g \u207b\u00b9' v\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["MeasureTheory/Constructions/Polish/Basic.lean",713,"case h.e'_4\n\u03b3 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2075 : TopologicalSpace \u03b3\ninst\u271d\u2074 : PolishSpace \u03b3\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : T2Space \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : OpensMeasurableSpace \u03b2\nf : \u03b3 \u2192 \u03b2\nf_cont : Continuous f\nf_inj : Injective f\nthis\u271d : UpgradedPolishSpace \u03b3 := upgradePolishSpace \u03b3\nb : Set (Set \u03b3)\nb_count : b.Countable\nb_nonempty : \u2205 \u2209 b\nhb : IsTopologicalBasis b\nthis : Encodable \u2191b\nA : Type (max 0 u_3) := { p // Disjoint \u2191p.1 \u2191p.2 }\nq : A \u2192 Set \u03b2\nhq1 : \u2200 (p : A), f '' \u2191(\u2191p).1 \u2286 q p\nhq2 : \u2200 (p : A), Disjoint (f '' \u2191(\u2191p).2) (q p)\nq_meas : \u2200 (p : A), MeasurableSet (q p)\nE : \u2191b \u2192 Set \u03b2 := fun s \u21a6 closure (f '' \u2191s) \u2229 \u22c2 t, \u22c2 (ht : Disjoint \u2191s \u2191t), q \u27e8(s, t), ht\u27e9 \\ q \u27e8(t, s), \u22ef\u27e9\nu : \u2115 \u2192 \u211d\nu_anti : StrictAnti u\nu_pos : \u2200 (n : \u2115), 0 < u n\nu_lim : Tendsto u atTop (\ud835\udcdd 0)\nF : \u2115 \u2192 Set \u03b2 := fun n \u21a6 \u22c3 s, \u22c3 (_ : Bornology.IsBounded \u2191s \u2227 diam \u2191s \u2264 u n), E s\ny : \u03b3\nn : \u2115\ns : Set \u03b3\nsb : s \u2208 b\nys : y \u2208 s\nhs : s \u2286 ball y (u n / 2)\n\u22a2 u n = 2 * (u n / 2)",["ring","linarith"]],["NumberTheory/ArithmeticFunction.lean",651,"case h.mk.mk.mk.intro.intro.intro\nR : Type u_1\ninst\u271d : CommSemiring R\nf g : ArithmeticFunction R\nhf : f.IsMultiplicative\nhg : g.IsMultiplicative\na1 a2 b1 b2 : \u2115\nha : \u00ac((a1, a2), b1, b2).1.1 * ((a1, a2), b1, b2).1.2 = 0\ncop : (((a1, a2), b1, b2).1.1 * ((a1, a2), b1, b2).1.2).Coprime (((a1, a2), b1, b2).2.1 * ((a1, a2), b1, b2).2.2)\nhb : \u00ac((a1, a2), b1, b2).2.1 * ((a1, a2), b1, b2).2.2 = 0\n\u22a2 f a1 * g a2 * (f b1 * g b2) =\n    f ((a1, a2), b1, b2).1.1 * f ((a1, a2), b1, b2).2.1 * (g ((a1, a2), b1, b2).1.2 * g ((a1, a2), b1, b2).2.2)",["ring"]],["NumberTheory/ArithmeticFunction.lean",1055,"R : Type u_1\ninst\u271d : CommRing R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nn : \u2115\nhn : Squarefree n\np : \u2115\nhp : p \u2208 n.primeFactors\n\u22a2 1 - f p = 1 + \u2191(-1) * f p",["ring"]],["Analysis/MeanInequalities.lean",582,"\u03b9 : Type u\ns : Finset \u03b9\nf : \u03b9 \u2192 \u211d\u22650\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nq : \u211d := p / (p - 1)\nhpq : p.IsConjExponent q\nhp\u2081 : 1 / p * p = 1\n\u22a2 1 / q * p = p / q",["ring"]],["Analysis/MeanInequalities.lean",938,"\u03b9 : Type u\ns : Finset \u03b9\nf : \u03b9 \u2192 \u211d\u22650\u221e\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nq : \u211d := p / (p - 1)\nhpq : p.IsConjExponent q\nhp\u2081 : 1 / p * p = 1\n\u22a2 1 / q * p = p / q",["ring"]],["Analysis/Convex/Function.lean",1060,"\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b2 : Type u_5\ninst\u271d\u2075 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2074 : OrderedAddCommMonoid \u03b2\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : Module \ud835\udd5c \u03b2\ninst\u271d : OrderedSMul \ud835\udd5c \u03b2\nf : E \u2192 \u03b2\ns : Set E\nx y : E\nhf : StrictConvexOn \ud835\udd5c s f\nhfx : IsMinOn f s x\nhfy : IsMinOn f s y\nhx : x \u2208 s\nhy : y \u2208 s\nhxy : \u00acx = y\nz : E := 2\u207b\u00b9 \u2022 x + 2\u207b\u00b9 \u2022 y\n\u22a2 2\u207b\u00b9 + 2\u207b\u00b9 = 1",["norm_num","ring"]],["Analysis/Convex/Function.lean",1063,"\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b2 : Type u_5\ninst\u271d\u2075 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2074 : OrderedAddCommMonoid \u03b2\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : Module \ud835\udd5c \u03b2\ninst\u271d : OrderedSMul \ud835\udd5c \u03b2\nf : E \u2192 \u03b2\ns : Set E\nx y : E\nhf : StrictConvexOn \ud835\udd5c s f\nhfx : IsMinOn f s x\nhfy : IsMinOn f s y\nhx : x \u2208 s\nhy : y \u2208 s\nhxy : \u00acx = y\nz : E := 2\u207b\u00b9 \u2022 x + 2\u207b\u00b9 \u2022 y\nhz : z \u2208 s\n\u22a2 2\u207b\u00b9 + 2\u207b\u00b9 = 1",["norm_num"]],["Analysis/Convex/Function.lean",1065,"\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b2 : Type u_5\ninst\u271d\u2075 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2074 : OrderedAddCommMonoid \u03b2\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : Module \ud835\udd5c \u03b2\ninst\u271d : OrderedSMul \ud835\udd5c \u03b2\nf : E \u2192 \u03b2\ns : Set E\nx y : E\nhf : StrictConvexOn \ud835\udd5c s f\nhfx : IsMinOn f s x\nhfy : IsMinOn f s y\nhx : x \u2208 s\nhy : y \u2208 s\nhxy : \u00acx = y\nz : E := 2\u207b\u00b9 \u2022 x + 2\u207b\u00b9 \u2022 y\nhz : z \u2208 s\n\u22a2 (2\u207b\u00b9 + 2\u207b\u00b9) \u2022 f z = f z",["norm_num"]],["Analysis/SpecialFunctions/Pow/Real.lean",82,"x : \u211d\nhx : x < 0\ny : \u211d\n\u22a2 (\u2191(log x) + \u2191\u03c0 * Complex.I) * \u2191y = \u2191(log x) * \u2191y + \u2191y * \u2191\u03c0 * Complex.I",["ring"]],["Analysis/SpecialFunctions/Pow/Real.lean",983,"x : \u211d\nh : x < 0\n\u22a2 1 / 2 * \u03c0 = \u03c0 / 2",["ring","linarith"]],["Analysis/SpecialFunctions/Pow/Real.lean",989,"case e_a\nx r : \u211d\nhx : 0 \u2264 x\n\u22a2 r / 2 = 1 / 2 * r",["ring","linarith"]],["Analysis/Fourier/FourierTransformDeriv.lean",119,"case h.e'_12.h\nV : Type u_1\nW : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : NormedSpace \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup W\ninst\u271d : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nv : V\nw : W\nha : HasFDerivAt (fun w' \u21a6 (L v) w') (L v) w\ny : W\n\u22a2 2 * \u2191\u03c0 * I * \u2191(\ud835\udc1e (-(L v) w)) * \u2191((L v) y) = \u2191((L v) y) * (2 * \u2191\u03c0 * I * \u2191(\ud835\udc1e (-(L v) w)))",["ring"]],["Analysis/Fourier/FourierTransformDeriv.lean",126,"V : Type u_1\nW : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : NormedSpace \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup W\ninst\u271d : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nv : V\nw y : W\n\u22a2 2 * \u2191\u03c0 * I * \u2191(\ud835\udc1e (-(L v) w)) * \u2191((L v) y) = 2 * \u2191\u03c0 * I * \u2191((L v) y) * \u2191(\ud835\udc1e (-(L v) w))",["ring"]],["Analysis/Fourier/FourierTransformDeriv.lean",142,"V : Type u_1\nW : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : NormedSpace \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup W\ninst\u271d : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nv y : V\nw : W\n\u22a2 2 * \u2191\u03c0 * I * \u2191(\ud835\udc1e (-(L v) w)) * \u2191((L y) w) = 2 * \u2191\u03c0 * I * \u2191((L y) w) * \u2191(\ud835\udc1e (-(L v) w))",["ring"]],["Analysis/Fourier/FourierTransformDeriv.lean",188,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : NormedSpace \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup W\ninst\u271d : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\nv : V\n\u22a2 2 * \u03c0 * (\u2016L\u2016 * \u2016v\u2016) * \u2016f v\u2016 = 2 * \u03c0 * \u2016L\u2016 * \u2016v\u2016 * \u2016f v\u2016",["ring","linarith"]],["Analysis/Fourier/FourierTransformDeriv.lean",332,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : NormedSpace \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup W\ninst\u271d : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\nv : V\nn : \u2115\nm : Fin n \u2192 W\n\u22a2 2 ^ n * \u03c0 ^ n * ((\u2016L\u2016 ^ n * \u2016v\u2016 ^ n * \u220f x : Fin n, \u2016m x\u2016) * \u2016f v\u2016) =\n    2 ^ n * \u03c0 ^ n * \u2016L\u2016 ^ n * \u2016v\u2016 ^ n * \u2016f v\u2016 * \u220f x : Fin n, \u2016m x\u2016",["ring","linarith"]],["Analysis/Fourier/FourierTransformDeriv.lean",381,"case inl\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : NormedSpace \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup W\ninst\u271d : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\nK : WithTop \u2115\u221e\nC : \u211d\nhf : ContDiff \u211d K f\nn k : \u2115\nhk : \u2191k \u2264 K\nv : V\nhv : \u2200 i \u2264 k, \u2200 j \u2264 n, \u2016v\u2016 ^ j * \u2016iteratedFDeriv \u211d i f v\u2016 \u2264 C\nT : ContinuousMultilinearMap \u211d (fun i \u21a6 W \u2192L[\u211d] \u211d) (ContinuousMultilinearMap \u211d (fun i \u21a6 W) \u211d) :=\n  (ContinuousMultilinearMap.mkPiAlgebra \u211d (Fin n) \u211d).compContinuousLinearMapLRight\nI\u2081 : \u2200 (m : \u2115), \u2016iteratedFDeriv \u211d m \u21d1T fun x \u21a6 L v\u2016 \u2264 \u2191(n.descFactorial m) * 1 * (\u2016L\u2016 * \u2016v\u2016) ^ (n - m)\nI\u2082 :\n  \u2200 (m : \u2115),\n    \u2016iteratedFDeriv \u211d m (\u21d1T \u2218 \u21d1(ContinuousLinearMap.pi fun x \u21a6 L)) v\u2016 \u2264\n      \u2191(n.descFactorial m) * 1 * (\u2016L\u2016 * \u2016v\u2016) ^ (n - m) * \u2016L\u2016 ^ m\nm : \u2115\nhm : m \u2264 n\n\u22a2 \u2191(n.descFactorial m) * 1 * (\u2016L\u2016 * \u2016v\u2016) ^ (n - m) * \u2016L\u2016 ^ m =\n    \u2191(n.descFactorial m) * (\u2016L\u2016 ^ m * \u2016L\u2016 ^ (n - m)) * \u2016v\u2016 ^ (n - m)",["ring"]],["Analysis/Fourier/FourierTransformDeriv.lean",409,"case e_f.h\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : NormedSpace \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup W\ninst\u271d : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\nK : WithTop \u2115\u221e\nC : \u211d\nhf : ContDiff \u211d K f\nn k : \u2115\nhk : \u2191k \u2264 K\nv : V\nhv : \u2200 i \u2264 k, \u2200 j \u2264 n, \u2016v\u2016 ^ j * \u2016iteratedFDeriv \u211d i f v\u2016 \u2264 C\nT : ContinuousMultilinearMap \u211d (fun i \u21a6 W \u2192L[\u211d] \u211d) (ContinuousMultilinearMap \u211d (fun i \u21a6 W) \u211d) :=\n  (ContinuousMultilinearMap.mkPiAlgebra \u211d (Fin n) \u211d).compContinuousLinearMapLRight\nI\u2081 : \u2200 (m : \u2115), \u2016iteratedFDeriv \u211d m \u21d1T fun x \u21a6 L v\u2016 \u2264 \u2191(n.descFactorial m) * 1 * (\u2016L\u2016 * \u2016v\u2016) ^ (n - m)\nI\u2082 :\n  \u2200 (m : \u2115),\n    \u2016iteratedFDeriv \u211d m (\u21d1T \u2218 \u21d1(ContinuousLinearMap.pi fun x \u21a6 L)) v\u2016 \u2264\n      \u2191(n.descFactorial m) * 1 * (\u2016L\u2016 * \u2016v\u2016) ^ (n - m) * \u2016L\u2016 ^ m\nI\u2083 :\n  \u2200 (m : \u2115),\n    \u2016iteratedFDeriv \u211d m (\u21d1T \u2218 \u21d1(ContinuousLinearMap.pi fun x \u21a6 L)) v\u2016 \u2264 \u2191(n.descFactorial m) * \u2016L\u2016 ^ n * \u2016v\u2016 ^ (n - m)\nA : ContDiff \u211d K fun y \u21a6 T fun x \u21a6 L y\ni : \u2115\n\u22a2 \u2191(k.choose i) * (\u2191(n.descFactorial i) * \u2016L\u2016 ^ n * \u2016v\u2016 ^ (n - i)) * \u2016iteratedFDeriv \u211d (k - i) f v\u2016 =\n    \u2191(k.choose i) * \u2191(n.descFactorial i) * \u2016L\u2016 ^ n * (\u2016v\u2016 ^ (n - i) * \u2016iteratedFDeriv \u211d (k - i) f v\u2016)",["ring","linarith"]],["Analysis/Fourier/FourierTransformDeriv.lean",466,"E : Type u_1\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u2076 : NormedAddCommGroup V\ninst\u271d\u2075 : NormedSpace \u211d V\ninst\u271d\u2074 : NormedAddCommGroup W\ninst\u271d\u00b3 : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\ninst\u271d\u00b2 : MeasurableSpace V\ninst\u271d\u00b9 : BorelSpace V\n\u03bc : Measure V\ninst\u271d : SecondCountableTopology V\nN : WithTop \u2115\u221e\nhf : \u2200 (n : \u2115), \u2191n \u2264 N \u2192 Integrable (fun v \u21a6 \u2016v\u2016 ^ n * \u2016f v\u2016) \u03bc\nh'f : AEStronglyMeasurable f \u03bc\nn : \u2115\nhn : \u2191n < N\nw : W\nI\u2081 : Integrable (fun v \u21a6 fourierPowSMulRight L f v n) \u03bc\nv : V\n\u22a2 \u2016v\u2016 * ((2 * \u03c0 * \u2016L\u2016) ^ n * \u2016v\u2016 ^ n * \u2016f v\u2016) = (2 * \u03c0 * \u2016L\u2016) ^ n * (\u2016v\u2016 ^ n * \u2016v\u2016 * \u2016f v\u2016)",["ring","linarith"]],["Analysis/Fourier/FourierTransformDeriv.lean",563,"case succ.h.H.e_a\nE : Type u_1\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : NormedSpace \u211d V\ninst\u271d\u2075 : NormedAddCommGroup W\ninst\u271d\u2074 : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\ninst\u271d\u00b3 : MeasurableSpace V\ninst\u271d\u00b2 : BorelSpace V\ninst\u271d\u00b9 : FiniteDimensional \u211d V\n\u03bc : Measure V\ninst\u271d : \u03bc.IsAddHaarMeasure\nN : \u2115\u221e\nhf : ContDiff \u211d (\u2191N) f\nh'f : \u2200 (n : \u2115), \u2191n \u2264 N \u2192 Integrable (iteratedFDeriv \u211d n f) \u03bc\nn : \u2115\nih :\n  \u2191n \u2264 N \u2192\n    fourierIntegral \ud835\udc1e \u03bc L.toLinearMap\u2082 (iteratedFDeriv \u211d n f) = fun w \u21a6\n      fourierPowSMulRight (-L.flip) (fourierIntegral \ud835\udc1e \u03bc L.toLinearMap\u2082 f) w n\nhn : \u2191(n + 1) \u2264 N\nw : W\nm : Fin (n + 1) \u2192 V\nJ : Integrable (fderiv \u211d (iteratedFDeriv \u211d n f)) \u03bc\nh'n : \u2191n < N\n\u22a2 2 * \u2191\u03c0 * I * (\u2191((L (m 0)) w) * ((-(2 * \u2191\u03c0 * I)) ^ n * \u220f x : Fin n, -\u2191((L (m x.succ)) w))) =\n    (-(2 * \u2191\u03c0 * I)) ^ n * (2 * \u2191\u03c0 * I) * (\u2191((L (m 0)) w) * \u220f x : Fin n, -\u2191((L (m x.succ)) w))",["ring"]],["Analysis/Fourier/FourierTransformDeriv.lean",661,"E : Type u_1\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : NormedSpace \u211d V\ninst\u271d\u2075 : NormedAddCommGroup W\ninst\u271d\u2074 : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\ninst\u271d\u00b3 : MeasurableSpace V\ninst\u271d\u00b2 : BorelSpace V\ninst\u271d\u00b9 : FiniteDimensional \u211d V\n\u03bc : Measure V\ninst\u271d : \u03bc.IsAddHaarMeasure\nK N : \u2115\u221e\nhf : ContDiff \u211d (\u2191N) f\nh'f : \u2200 (k n : \u2115), \u2191k \u2264 K \u2192 \u2191n \u2264 N \u2192 Integrable (fun v \u21a6 \u2016v\u2016 ^ k * \u2016iteratedFDeriv \u211d n f v\u2016) \u03bc\nk n : \u2115\nhk : \u2191k \u2264 K\nhn : \u2191n \u2264 N\nv : V\nw : W\n\u22a2 (2 ^ k * \u03c0 ^ k * (2 * \u2191k + 2) ^ n * \u2016L\u2016 ^ k *\n        \u2211 p \u2208 Finset.range (k + 1) \u00d7\u02e2 Finset.range (n + 1), \u222b (v : V), \u2016v\u2016 ^ p.1 * \u2016iteratedFDeriv \u211d p.2 f v\u2016 \u2202\u03bc) *\n      \u2016v\u2016 ^ n =\n    \u2016v\u2016 ^ n * (2 ^ k * \u03c0 ^ k * \u2016L\u2016 ^ k) * (2 * \u2191k + 2) ^ n *\n      \u2211 p \u2208 Finset.range (k + 1) \u00d7\u02e2 Finset.range (n + 1), \u222b (v : V), \u2016v\u2016 ^ p.1 * \u2016iteratedFDeriv \u211d p.2 f v\u2016 \u2202\u03bc",["ring","linarith"]],["Probability/StrongLaw.lean",348,"\u03a9 : Type u_1\ninst\u271d\u00b9 : MeasureSpace \u03a9\ninst\u271d : IsProbabilityMeasure \u2119\nX : \u03a9 \u2192 \u211d\nhint : Integrable X \u2119\nhnonneg : 0 \u2264 X\nK : \u2115\nY : \u2115 \u2192 \u03a9 \u2192 \u211d := fun n \u21a6 truncation X \u2191n\n\u03c1 : Measure \u211d := Measure.map X \u2119\nY2 : \u2200 (n : \u2115), \u222b (a : \u03a9), (Y n ^ 2) a = \u222b (x : \u211d) in 0 ..\u2191n, x ^ 2 \u2202\u03c1\nk : \u2115\nx\u271d : k \u2208 range K\nIk : \u2191k \u2264 \u2191(k + 1)\nx : \u211d\nhx : x \u2208 Set.Ioc \u2191k \u2191(k + 1)\n\u22a2 2 / (\u2191k + 1) * x ^ 2 = x / (\u2191k + 1) * (2 * x)",["ring"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",810,"case e_x\n\u03b8 : \u211d := \u03c0 / 5\nh\u03b8 : \u03b8 = \u03c0 / 5\nc : \u211d := cos \u03b8\ns : \u211d := sin \u03b8\nhs : s \u2260 0\n\u22a2 \u03c0 * 5 - 2 * \u03c0 = 2 * \u03c0 + \u03c0",["linarith","ring"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",814,"\u03b8 : \u211d := \u03c0 / 5\nh\u03b8 : \u03b8 = \u03c0 / 5\nc : \u211d := cos \u03b8\ns : \u211d := sin \u03b8\nhs : s \u2260 0\n\u22a2 2 * s * c * c + (2 * c ^ 2 - 1) * s = s * (2 * c * c) + s * (2 * c ^ 2 - 1)",["linarith","ring"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",815,"\u03b8 : \u211d := \u03c0 / 5\nh\u03b8 : \u03b8 = \u03c0 / 5\nc : \u211d := cos \u03b8\ns : \u211d := sin \u03b8\nhs : s \u2260 0\n\u22a2 s * (2 * c * c) + s * (2 * c ^ 2 - 1) = s * (4 * c ^ 2 - 1)",["linarith","ring"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",831,"case inl\nc : \u211d := cos (\u03c0 / 5)\nthis : 4 * (c * c) + -2 * c + -1 = 0\nhd : discrim 4 (-2) (-1) = 2 * \u221a5 * (2 * \u221a5)\nh : c = (- -2 + 2 * \u221a5) / (2 * 4)\n\u22a2 (2 + 2 * \u221a5) * 4 = (1 + \u221a5) * (2 * 4)",["linarith","ring"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",147,"\u22a2 2 = 4 / 2",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",396,"x : \u211d\nh0x : 0 < x\nhxp : x < \u03c0\nhx2 : \u00acx \u2264 2\n\u22a2 2 + 2 = 4",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",640,"n : \u2115\n\u22a2 2 \u2264 2 ^ 2 - 2",["norm_num","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",694,"case e_x.e_a\n\u22a2 4 = 2 ^ 2",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",701,"case e_x.e_a\n\u22a2 4 = 2 ^ 2",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",708,"case e_x.e_a\n\u22a2 8 = 2 ^ 3",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",715,"case e_x.e_a\n\u22a2 8 = 2 ^ 3",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",722,"case e_x.e_a\n\u22a2 16 = 2 ^ 4",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",729,"case e_x.e_a\n\u22a2 16 = 2 ^ 4",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",736,"case e_x.e_a\n\u22a2 32 = 2 ^ 5",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",743,"case e_x.e_a\n\u22a2 32 = 2 ^ 5",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",753,"case e_x\n\u22a2 3 * (\u03c0 / 3) = \u03c0",["ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",777,"case e_x\n\u22a2 \u03c0 / 2 - \u03c0 / 6 = \u03c0 / 3",["ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",784,"case e_a.e_x\n\u22a2 \u03c0 / 2 - \u03c0 / 3 = \u03c0 / 6",["ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",791,"case e_x\n\u22a2 \u03c0 / 2 - \u03c0 / 3 = \u03c0 / 6",["ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",861,"\u22a2 1 / 2 / (\u221a3 / 2) = 1 / \u221a3",["ring","linarith"]],["Geometry/Euclidean/Circumcenter.lean",661,"case e_f\nV : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nn : \u2115\ns : Simplex \u211d P n\ni\u2081 i\u2082 : Fin (n + 1)\nh : i\u2081 \u2260 i\u2082\nhc : #{i\u2081, i\u2082} = 2\nW : AffineSubspace \u211d P := affineSpan \u211d (s.points '' {i\u2081, i\u2082})\nh_faces :\n  \u2191((EuclideanGeometry.orthogonalProjection W) s.circumcenter) = \u2191((s.face hc).orthogonalProjectionSpan s.circumcenter)\n\u22a2 (fun x \u21a6\n      (if x \u2208 {i\u2081, i\u2082} then ((\u21912)\u207b\u00b9 + (\u21912)\u207b\u00b9) \u2022 (s.pointsWithCircumcenter (pointIndex x) -\u1d65 Classical.choice \u22ef)\n        else \u2211 _x : Fin (n + 1), 0) -\n        if x = i\u2081 \u2228 x = i\u2082 then 1 \u2022 (s.pointsWithCircumcenter (pointIndex x) -\u1d65 Classical.choice \u22ef)\n        else \u2211 _x : Fin (n + 1), 0) =\n    fun _x \u21a6 0",["norm_num"]],["Geometry/Euclidean/Circumcenter.lean",121,"case h.left.right.inl\nV : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\ns : AffineSubspace \u211d P\ninst\u271d : HasOrthogonalProjection s.direction\nps : Set P\nhnps : ps.Nonempty\np : P\nhps : ps \u2286 \u2191s\nhp : p \u2209 s\nthis : Nonempty \u21a5s\ncc : P\ncr : \u211d\nhcccru : \u2200 (y : Sphere P), y.center \u2208 s \u2227 ps \u2286 Metric.sphere y.center y.radius \u2192 y = { center := cc, radius := cr }\nhcc : cc \u2208 s\nhcr : ps \u2286 Metric.sphere cc cr\nx : \u211d := dist cc \u2191((orthogonalProjection s) p)\ny : \u211d := dist p \u2191((orthogonalProjection s) p)\nhy0 : y \u2260 0\nycc\u2082 : \u211d := (x * x + y * y - cr * cr) / (2 * y)\ncc\u2082 : P := (ycc\u2082 / y) \u2022 (p -\u1d65 \u2191((orthogonalProjection s) p)) +\u1d65 cc\ncr\u2082 : \u211d := \u221a(cr * cr + ycc\u2082 * ycc\u2082)\nhpo : p = 1 \u2022 (p -\u1d65 \u2191((orthogonalProjection s) p)) +\u1d65 \u2191((orthogonalProjection s) p)\np\u2081 : P\nhp\u2081 : p\u2081 = p\n\u22a2 (dist cc \u2191((orthogonalProjection s) p) * dist cc \u2191((orthogonalProjection s) p) * (2 * y * y * (2 * y * y)) +\n        (2 * y * y - (x * x + y * y - cr * cr)) * (2 * y * y - (x * x + y * y - cr * cr)) *\n          (dist p \u2191((orthogonalProjection s) p) * dist p \u2191((orthogonalProjection s) p))) *\n      (2 * y * (2 * y)) =\n    (cr * cr * (2 * y * (2 * y)) + (x * x + y * y - cr * cr) * (x * x + y * y - cr * cr)) * (2 * y * y * (2 * y * y))",["ring","linarith"]],["Geometry/Euclidean/Circumcenter.lean",155,"case intro\nV : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\ns : AffineSubspace \u211d P\ninst\u271d : HasOrthogonalProjection s.direction\nps : Set P\np : P\nhps : ps \u2286 \u2191s\nhp : p \u2209 s\nthis : Nonempty \u21a5s\ncc : P\ncr : \u211d\nhcccru : \u2200 (y : Sphere P), y.center \u2208 s \u2227 ps \u2286 Metric.sphere y.center y.radius \u2192 y = { center := cc, radius := cr }\nhcc : cc \u2208 s\nhcr : ps \u2286 Metric.sphere cc cr\nx : \u211d := dist cc \u2191((orthogonalProjection s) p)\ny : \u211d := dist p \u2191((orthogonalProjection s) p)\nhy0 : y \u2260 0\nycc\u2082 : \u211d := (x * x + y * y - cr * cr) / (2 * y)\ncc\u2082 : P := (ycc\u2082 / y) \u2022 (p -\u1d65 \u2191((orthogonalProjection s) p)) +\u1d65 cc\ncr\u2082 : \u211d := \u221a(cr * cr + ycc\u2082 * ycc\u2082)\nhpo : p = 1 \u2022 (p -\u1d65 \u2191((orthogonalProjection s) p)) +\u1d65 \u2191((orthogonalProjection s) p)\ncc\u2083 : P\ncr\u2083 : \u211d\nhcc\u2083 : cc\u2083 \u2208 affineSpan \u211d (insert p \u2191s)\nhcr\u2083 : insert p ps \u2286 Metric.sphere cc\u2083 cr\u2083\nt\u2083 : \u211d\nhcc\u2083' : cc \u2208 s\nhcc\u2083'' : cc\u2083 = t\u2083 \u2022 (p -\u1d65 \u2191((orthogonalProjection s) p)) +\u1d65 cc\nhcr\u2083' : \u2200 p\u2081 \u2208 ps, dist p\u2081 \u2191\u27e8cc, hcc\u2083'\u27e9 = cr\np0 : P\nhp0 : p0 \u2208 ps\nh' : \u2191\u27e8cc, hcc\u2083'\u27e9 = cc\n\u22a2 cr * cr + t\u2083 * t\u2083 * dist p \u2191((orthogonalProjection s) p) * dist p \u2191((orthogonalProjection s) p) =\n    cr * cr + t\u2083 * y * (t\u2083 * y)",["ring","linarith"]],["MeasureTheory/Measure/Lebesgue/EqHaar.lean",631,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : BorelSpace E\ninst\u271d\u00b9 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\ns : Set E\nx : E\nh : Tendsto (fun r \u21a6 \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd 0)\nt u : Set E\nh'u : \u03bc u \u2260 0\nt_bound : t \u2286 closedBall 0 1\nA : Tendsto (fun r \u21a6 \u03bc (s \u2229 ({x} + r \u2022 t)) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd 0)\nB : Tendsto (fun r \u21a6 \u03bc (closedBall x r) / \u03bc ({x} + r \u2022 u)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc (closedBall x 1) / \u03bc ({x} + u)))\nC : Tendsto (fun r \u21a6 \u03bc (s \u2229 ({x} + r \u2022 t)) / \u03bc (closedBall x r) * (\u03bc (closedBall x r) / \u03bc ({x} + r \u2022 u))) (\ud835\udcdd[>] 0) (\ud835\udcdd 0)\nr : \u211d\nrpos : 0 < r\n\u22a2 \u03bc (s \u2229 ({x} + r \u2022 t)) * (\u03bc (closedBall x r))\u207b\u00b9 * (\u03bc (closedBall x r) * (\u03bc ({x} + r \u2022 u))\u207b\u00b9) =\n    \u03bc (closedBall x r) * (\u03bc (closedBall x r))\u207b\u00b9 * (\u03bc (s \u2229 ({x} + r \u2022 t)) * (\u03bc ({x} + r \u2022 u))\u207b\u00b9)",["ring"]],["Algebra/Quaternion.lean",1128,"R : Type u_3\ninst\u271d : CommRing R\na b : \u210d[R]\n\u22a2 normSq a + (a * star b).re + ((b * star a).re + normSq b) = normSq a + normSq b + ((a * star b).re + (b * star a).re)",["abel","ring"]],["Algebra/Quaternion.lean",646,"case re\nS : Type u_1\nT : Type u_2\nR : Type u_3\nc\u2081 c\u2082 c\u2083 r x y : R\na\u271d b\u271d : \u210d[R,c\u2081,c\u2082,c\u2083]\ninst\u271d : CommRing R\na b : \u210d[R,c\u2081,c\u2082,c\u2083]\n\u22a2 a.re + b.re + c\u2082 * (a.imI + b.imI) = a.re + c\u2082 * a.imI + (b.re + c\u2082 * b.imI)",["ring"]],["Algebra/Quaternion.lean",649,"case re\nR : Type u_3\nc\u2081 c\u2082 c\u2083 : R\na : \u210d[R,c\u2081,c\u2082,c\u2083]\ninst\u271d : CommRing R\n\u22a2 a.re + (a.re + c\u2082 * a.imI) = a.re + a.re + c\u2082 * a.imI",["ring","abel"]],["Algebra/Quaternion.lean",897,"R : Type u_3\ninst\u271d : CommRing R\na b : \u210d[R]\n\u22a2 a.re * b.imI + a.imI * b.re + 0 * a.imI * b.imI - -1 * a.imJ * b.imK + -1 * a.imK * b.imJ =\n    a.re * b.imI + a.imI * b.re + a.imJ * b.imK - a.imK * b.imJ",["ring"]],["Algebra/Quaternion.lean",901,"R : Type u_3\ninst\u271d : CommRing R\na b : \u210d[R]\n\u22a2 a.re * b.imJ + -1 * a.imI * b.imK + a.imJ * b.re + 0 * a.imJ * b.imI - -1 * a.imK * b.imI =\n    a.re * b.imJ - a.imI * b.imK + a.imJ * b.re + a.imK * b.imI",["ring"]],["Algebra/Quaternion.lean",1271,"R : Type u_1\nc\u2081 c\u2082 c\u2083 : R\n\u22a2 #R * (#R * (#R * #R)) = #R ^ 4",["ring"]],["Geometry/Euclidean/Angle/Oriented/Affine.lean",574,"V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\nhd2 : Fact (finrank \u211d V = 2)\ninst\u271d : Oriented \u211d V (Fin 2)\np\u2081 p\u2082 p : P\nh : p\u2081 \u2260 p\u2082\nhd : inner (p -\u1d65 p\u2081) (p -\u1d65 p\u2081) = inner (p -\u1d65 p\u2082) (p -\u1d65 p\u2082)\n\u22a2 \u215f 2 * inner (p -\u1d65 p\u2082) (p -\u1d65 p\u2082) + \u215f 2 * inner (p -\u1d65 p\u2081) (p -\u1d65 p\u2082) -\n      (\u215f 2 * inner (p -\u1d65 p\u2081) (p -\u1d65 p\u2082) + \u215f 2 * inner (p -\u1d65 p\u2082) (p -\u1d65 p\u2082)) =\n    0",["abel","ring","linarith"]],["MeasureTheory/Function/SimpleFuncDenseLp.lean",916,"case h.e'_3.h.e'_5\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\np : \u211d\u22650\u221e\n\u03bc : Measure \u03b1\nhp_ne_top : p \u2260 \u22a4\nP : (\u03b1 \u2192 E) \u2192 Prop\nh0P :\n  \u2200 (c : E) \u2983s : Set \u03b1\u2984,\n    MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 \u2200 {\u03b5 : \u211d\u22650\u221e}, \u03b5 \u2260 0 \u2192 \u2203 g, eLpNorm (g - s.indicator fun x \u21a6 c) p \u03bc \u2264 \u03b5 \u2227 P g\nh1P : \u2200 (f g : \u03b1 \u2192 E), P f \u2192 P g \u2192 P (f + g)\nh2P : \u2200 (f : \u03b1 \u2192 E), P f \u2192 AEStronglyMeasurable f \u03bc\nf\u271d : \u03b1 \u2192 E\nhf\u271d : MemLp f\u271d p \u03bc\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nhp_pos : p \u2260 0\nf f' : \u03b1 \u2192\u209b E\nhff' : Disjoint (support \u21d1f) (support \u21d1f')\nhf : \u2200 (\u03b4 : \u211d\u22650\u221e), \u03b4 \u2260 0 \u2192 MemLp (\u21d1f) p \u03bc \u2192 \u2203 g, eLpNorm (\u21d1f - g) p \u03bc \u2264 \u03b4 \u2227 P g\nhf' : \u2200 (\u03b4 : \u211d\u22650\u221e), \u03b4 \u2260 0 \u2192 MemLp (\u21d1f') p \u03bc \u2192 \u2203 g, eLpNorm (\u21d1f' - g) p \u03bc \u2264 \u03b4 \u2227 P g\n\u03b4 : \u211d\u22650\u221e\n\u03b4pos : \u03b4 \u2260 0\nint_ff' : MemLp (\u21d1f) p \u03bc \u2227 MemLp (\u21d1f') p \u03bc\n\u03b7 : \u211d\u22650\u221e\n\u03b7pos : 0 < \u03b7\nh\u03b7 :\n  \u2200 (f g : \u03b1 \u2192 E),\n    AEStronglyMeasurable f \u03bc \u2192 AEStronglyMeasurable g \u03bc \u2192 eLpNorm f p \u03bc \u2264 \u03b7 \u2192 eLpNorm g p \u03bc \u2264 \u03b7 \u2192 eLpNorm (f + g) p \u03bc < \u03b4\ng : \u03b1 \u2192 E\nhg : eLpNorm (\u21d1f - g) p \u03bc \u2264 \u03b7\nPg : P g\ng' : \u03b1 \u2192 E\nhg' : eLpNorm (\u21d1f' - g') p \u03bc \u2264 \u03b7\nPg' : P g'\n\u22a2 \u21d1f + \u21d1f' - (g + g') = \u21d1f - g + (\u21d1f' - g')",["abel"]],["SetTheory/Game/Basic.lean",542,"case refine_3.inl.mk.inl\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\ni : xl\nj : yl\n\u22a2 \u27e6xL i * mk yl yr yL yR\u27e7 + \u27e6xL i * mk zl zr zL zR\u27e7 + (\u27e6mk xl xr xL xR * yL j\u27e7 + \u27e6mk xl xr xL xR * mk zl zr zL zR\u27e7) -\n      (\u27e6xL i * yL j\u27e7 + \u27e6xL i * mk zl zr zL zR\u27e7) =\n    \u27e6xL i * y\u27e7 + \u27e6x * yL j\u27e7 - \u27e6xL i * yL j\u27e7 + \u27e6x * z\u27e7",["abel"]],["SetTheory/Game/Basic.lean",550,"case refine_3.inl.mk.inr\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\ni : xl\nk : zl\n\u22a2 \u27e6xL i * mk yl yr yL yR\u27e7 + \u27e6xL i * mk zl zr zL zR\u27e7 + (\u27e6mk xl xr xL xR * mk yl yr yL yR\u27e7 + \u27e6mk xl xr xL xR * zL k\u27e7) -\n      (\u27e6xL i * mk yl yr yL yR\u27e7 + \u27e6xL i * zL k\u27e7) =\n    \u27e6x * y\u27e7 + (\u27e6xL i * z\u27e7 + \u27e6x * zL k\u27e7 - \u27e6xL i * zL k\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",558,"case refine_3.inr.mk.inl\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\ni : xr\nj : yr\n\u22a2 \u27e6xR i * mk yl yr yL yR\u27e7 + \u27e6xR i * mk zl zr zL zR\u27e7 + (\u27e6mk xl xr xL xR * yR j\u27e7 + \u27e6mk xl xr xL xR * mk zl zr zL zR\u27e7) -\n      (\u27e6xR i * yR j\u27e7 + \u27e6xR i * mk zl zr zL zR\u27e7) =\n    \u27e6xR i * y\u27e7 + \u27e6x * yR j\u27e7 - \u27e6xR i * yR j\u27e7 + \u27e6x * z\u27e7",["abel"]],["SetTheory/Game/Basic.lean",566,"case refine_3.inr.mk.inr\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\ni : xr\nk : zr\n\u22a2 \u27e6xR i * mk yl yr yL yR\u27e7 + \u27e6xR i * mk zl zr zL zR\u27e7 + (\u27e6mk xl xr xL xR * mk yl yr yL yR\u27e7 + \u27e6mk xl xr xL xR * zR k\u27e7) -\n      (\u27e6xR i * mk yl yr yL yR\u27e7 + \u27e6xR i * zR k\u27e7) =\n    \u27e6x * y\u27e7 + (\u27e6xR i * z\u27e7 + \u27e6x * zR k\u27e7 - \u27e6xR i * zR k\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",575,"case refine_4.inl.mk.inl\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\ni : xl\nj : yr\n\u22a2 \u27e6xL i * mk yl yr yL yR\u27e7 + \u27e6xL i * mk zl zr zL zR\u27e7 + (\u27e6mk xl xr xL xR * yR j\u27e7 + \u27e6mk xl xr xL xR * mk zl zr zL zR\u27e7) -\n      (\u27e6xL i * yR j\u27e7 + \u27e6xL i * mk zl zr zL zR\u27e7) =\n    \u27e6xL i * y\u27e7 + \u27e6x * yR j\u27e7 - \u27e6xL i * yR j\u27e7 + \u27e6x * z\u27e7",["abel"]],["SetTheory/Game/Basic.lean",583,"case refine_4.inl.mk.inr\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\ni : xl\nk : zr\n\u22a2 \u27e6xL i * mk yl yr yL yR\u27e7 + \u27e6xL i * mk zl zr zL zR\u27e7 + (\u27e6mk xl xr xL xR * mk yl yr yL yR\u27e7 + \u27e6mk xl xr xL xR * zR k\u27e7) -\n      (\u27e6xL i * mk yl yr yL yR\u27e7 + \u27e6xL i * zR k\u27e7) =\n    \u27e6x * y\u27e7 + (\u27e6xL i * z\u27e7 + \u27e6x * zR k\u27e7 - \u27e6xL i * zR k\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",591,"case refine_4.inr.mk.inl\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\ni : xr\nj : yl\n\u22a2 \u27e6xR i * mk yl yr yL yR\u27e7 + \u27e6xR i * mk zl zr zL zR\u27e7 + (\u27e6mk xl xr xL xR * yL j\u27e7 + \u27e6mk xl xr xL xR * mk zl zr zL zR\u27e7) -\n      (\u27e6xR i * yL j\u27e7 + \u27e6xR i * mk zl zr zL zR\u27e7) =\n    \u27e6xR i * y\u27e7 + \u27e6x * yL j\u27e7 - \u27e6xR i * yL j\u27e7 + \u27e6x * z\u27e7",["abel"]],["SetTheory/Game/Basic.lean",599,"case refine_4.inr.mk.inr\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\ni : xr\nk : zl\n\u22a2 \u27e6xR i * mk yl yr yL yR\u27e7 + \u27e6xR i * mk zl zr zL zR\u27e7 + (\u27e6mk xl xr xL xR * mk yl yr yL yR\u27e7 + \u27e6mk xl xr xL xR * zL k\u27e7) -\n      (\u27e6xR i * mk yl yr yL yR\u27e7 + \u27e6xR i * zL k\u27e7) =\n    \u27e6x * y\u27e7 + (\u27e6xR i * z\u27e7 + \u27e6x * zL k\u27e7 - \u27e6xR i * zL k\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",714,"case refine_3.inl.mk.inl.mk\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\nk : zl\ni : xl\nj : yl\n\u22a2 \u27e6xL i * (mk yl yr yL yR * mk zl zr zL zR)\u27e7 + \u27e6mk xl xr xL xR * (yL j * mk zl zr zL zR)\u27e7 -\n          \u27e6xL i * (yL j * mk zl zr zL zR)\u27e7 +\n        \u27e6mk xl xr xL xR * (mk yl yr yL yR * zL k)\u27e7 -\n      (\u27e6xL i * (mk yl yr yL yR * zL k)\u27e7 + \u27e6mk xl xr xL xR * (yL j * zL k)\u27e7 - \u27e6xL i * (yL j * zL k)\u27e7) =\n    \u27e6xL i * (y * z)\u27e7 + (\u27e6x * (yL j * z)\u27e7 + \u27e6x * (y * zL k)\u27e7 - \u27e6x * (yL j * zL k)\u27e7) -\n      (\u27e6xL i * (yL j * z)\u27e7 + \u27e6xL i * (y * zL k)\u27e7 - \u27e6xL i * (yL j * zL k)\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",729,"case refine_3.inl.mk.inr.mk\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\nk : zl\ni : xr\nj : yr\n\u22a2 \u27e6xR i * (mk yl yr yL yR * mk zl zr zL zR)\u27e7 + \u27e6mk xl xr xL xR * (yR j * mk zl zr zL zR)\u27e7 -\n          \u27e6xR i * (yR j * mk zl zr zL zR)\u27e7 +\n        \u27e6mk xl xr xL xR * (mk yl yr yL yR * zL k)\u27e7 -\n      (\u27e6xR i * (mk yl yr yL yR * zL k)\u27e7 + \u27e6mk xl xr xL xR * (yR j * zL k)\u27e7 - \u27e6xR i * (yR j * zL k)\u27e7) =\n    \u27e6xR i * (y * z)\u27e7 + (\u27e6x * (yR j * z)\u27e7 + \u27e6x * (y * zL k)\u27e7 - \u27e6x * (yR j * zL k)\u27e7) -\n      (\u27e6xR i * (yR j * z)\u27e7 + \u27e6xR i * (y * zL k)\u27e7 - \u27e6xR i * (yR j * zL k)\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",744,"case refine_3.inr.mk.inl.mk\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\nk : zr\ni : xl\nj : yr\n\u22a2 \u27e6xL i * (mk yl yr yL yR * mk zl zr zL zR)\u27e7 + \u27e6mk xl xr xL xR * (yR j * mk zl zr zL zR)\u27e7 -\n          \u27e6xL i * (yR j * mk zl zr zL zR)\u27e7 +\n        \u27e6mk xl xr xL xR * (mk yl yr yL yR * zR k)\u27e7 -\n      (\u27e6xL i * (mk yl yr yL yR * zR k)\u27e7 + \u27e6mk xl xr xL xR * (yR j * zR k)\u27e7 - \u27e6xL i * (yR j * zR k)\u27e7) =\n    \u27e6xL i * (y * z)\u27e7 + (\u27e6x * (yR j * z)\u27e7 + \u27e6x * (y * zR k)\u27e7 - \u27e6x * (yR j * zR k)\u27e7) -\n      (\u27e6xL i * (yR j * z)\u27e7 + \u27e6xL i * (y * zR k)\u27e7 - \u27e6xL i * (yR j * zR k)\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",759,"case refine_3.inr.mk.inr.mk\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\nk : zr\ni : xr\nj : yl\n\u22a2 \u27e6xR i * (mk yl yr yL yR * mk zl zr zL zR)\u27e7 + \u27e6mk xl xr xL xR * (yL j * mk zl zr zL zR)\u27e7 -\n          \u27e6xR i * (yL j * mk zl zr zL zR)\u27e7 +\n        \u27e6mk xl xr xL xR * (mk yl yr yL yR * zR k)\u27e7 -\n      (\u27e6xR i * (mk yl yr yL yR * zR k)\u27e7 + \u27e6mk xl xr xL xR * (yL j * zR k)\u27e7 - \u27e6xR i * (yL j * zR k)\u27e7) =\n    \u27e6xR i * (y * z)\u27e7 + (\u27e6x * (yL j * z)\u27e7 + \u27e6x * (y * zR k)\u27e7 - \u27e6x * (yL j * zR k)\u27e7) -\n      (\u27e6xR i * (yL j * z)\u27e7 + \u27e6xR i * (y * zR k)\u27e7 - \u27e6xR i * (yL j * zR k)\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",775,"case refine_4.inl.mk.inl.mk\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\nk : zr\ni : xl\nj : yl\n\u22a2 \u27e6xL i * (mk yl yr yL yR * mk zl zr zL zR)\u27e7 + \u27e6mk xl xr xL xR * (yL j * mk zl zr zL zR)\u27e7 -\n          \u27e6xL i * (yL j * mk zl zr zL zR)\u27e7 +\n        \u27e6mk xl xr xL xR * (mk yl yr yL yR * zR k)\u27e7 -\n      (\u27e6xL i * (mk yl yr yL yR * zR k)\u27e7 + \u27e6mk xl xr xL xR * (yL j * zR k)\u27e7 - \u27e6xL i * (yL j * zR k)\u27e7) =\n    \u27e6xL i * (y * z)\u27e7 + (\u27e6x * (yL j * z)\u27e7 + \u27e6x * (y * zR k)\u27e7 - \u27e6x * (yL j * zR k)\u27e7) -\n      (\u27e6xL i * (yL j * z)\u27e7 + \u27e6xL i * (y * zR k)\u27e7 - \u27e6xL i * (yL j * zR k)\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",790,"case refine_4.inl.mk.inr.mk\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\nk : zr\ni : xr\nj : yr\n\u22a2 \u27e6xR i * (mk yl yr yL yR * mk zl zr zL zR)\u27e7 + \u27e6mk xl xr xL xR * (yR j * mk zl zr zL zR)\u27e7 -\n          \u27e6xR i * (yR j * mk zl zr zL zR)\u27e7 +\n        \u27e6mk xl xr xL xR * (mk yl yr yL yR * zR k)\u27e7 -\n      (\u27e6xR i * (mk yl yr yL yR * zR k)\u27e7 + \u27e6mk xl xr xL xR * (yR j * zR k)\u27e7 - \u27e6xR i * (yR j * zR k)\u27e7) =\n    \u27e6xR i * (y * z)\u27e7 + (\u27e6x * (yR j * z)\u27e7 + \u27e6x * (y * zR k)\u27e7 - \u27e6x * (yR j * zR k)\u27e7) -\n      (\u27e6xR i * (yR j * z)\u27e7 + \u27e6xR i * (y * zR k)\u27e7 - \u27e6xR i * (yR j * zR k)\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",805,"case refine_4.inr.mk.inl.mk\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\nk : zl\ni : xl\nj : yr\n\u22a2 \u27e6xL i * (mk yl yr yL yR * mk zl zr zL zR)\u27e7 + \u27e6mk xl xr xL xR * (yR j * mk zl zr zL zR)\u27e7 -\n          \u27e6xL i * (yR j * mk zl zr zL zR)\u27e7 +\n        \u27e6mk xl xr xL xR * (mk yl yr yL yR * zL k)\u27e7 -\n      (\u27e6xL i * (mk yl yr yL yR * zL k)\u27e7 + \u27e6mk xl xr xL xR * (yR j * zL k)\u27e7 - \u27e6xL i * (yR j * zL k)\u27e7) =\n    \u27e6xL i * (y * z)\u27e7 + (\u27e6x * (yR j * z)\u27e7 + \u27e6x * (y * zL k)\u27e7 - \u27e6x * (yR j * zL k)\u27e7) -\n      (\u27e6xL i * (yR j * z)\u27e7 + \u27e6xL i * (y * zL k)\u27e7 - \u27e6xL i * (yR j * zL k)\u27e7)",["abel"]],["SetTheory/Game/Basic.lean",820,"case refine_4.inr.mk.inr.mk\nx\u271d y\u271d z\u271d : PGame\nxl xr : Type u_1\nxL : xl \u2192 PGame\nxR : xr \u2192 PGame\nyl yr : Type u_1\nyL : yl \u2192 PGame\nyR : yr \u2192 PGame\nzl zr : Type u_1\nzL : zl \u2192 PGame\nzR : zr \u2192 PGame\nx : PGame := mk xl xr xL xR\ny : PGame := mk yl yr yL yR\nz : PGame := mk zl zr zL zR\nk : zl\ni : xr\nj : yl\n\u22a2 \u27e6xR i * (mk yl yr yL yR * mk zl zr zL zR)\u27e7 + \u27e6mk xl xr xL xR * (yL j * mk zl zr zL zR)\u27e7 -\n          \u27e6xR i * (yL j * mk zl zr zL zR)\u27e7 +\n        \u27e6mk xl xr xL xR * (mk yl yr yL yR * zL k)\u27e7 -\n      (\u27e6xR i * (mk yl yr yL yR * zL k)\u27e7 + \u27e6mk xl xr xL xR * (yL j * zL k)\u27e7 - \u27e6xR i * (yL j * zL k)\u27e7) =\n    \u27e6xR i * (y * z)\u27e7 + (\u27e6x * (yL j * z)\u27e7 + \u27e6x * (y * zL k)\u27e7 - \u27e6x * (yL j * zL k)\u27e7) -\n      (\u27e6xR i * (yL j * z)\u27e7 + \u27e6xR i * (y * zL k)\u27e7 - \u27e6xR i * (yL j * zL k)\u27e7)",["abel"]],["NumberTheory/RamificationInertia/Basic.lean",538,"case a\nR : Type u\ninst\u271d\u00b2 : CommRing R\nS : Type v\ninst\u271d\u00b9 : CommRing S\nf : R \u2192+* S\np : Ideal R\nP : Ideal S\ninst\u271d : Algebra R S\nhfp : NeZero e\ni : \u2115\na : S\na_mem : a \u2208 P ^ i\nx\u271d : R \u29f8 p\ny\u271d : S \u29f8 P\nx : R\ny : S\n\u22a2 (Quotient.mk (P ^ e)) a * ((Quotient.mk (P ^ e)) (f x) * (Quotient.mk (P ^ e)) y) =\n    (Quotient.mk (P ^ e)) (f x) * ((Quotient.mk (P ^ e)) a * (Quotient.mk (P ^ e)) y)",["ring"]],["Analysis/RCLike/Basic.lean",376,"K : Type u_1\nE : Type u_2\ninst\u271d : RCLike K\nz\u271d z w : K\n\u22a2 (re z * re w - im z * im w) * (re z * re w - im z * im w) + (re z * im w + im z * re w) * (re z * im w + im z * re w) =\n    (re z * re z + im z * im z) * (re w * re w + im w * im w)",["ring","linarith"]],["Analysis/RCLike/Basic.lean",419,"K : Type u_1\ninst\u271d : RCLike K\nz w : K\n\u22a2 (re z + re w) * (re z + re w) + (im z + im w) * (im z + im w) =\n    re z * re z + im z * im z + (re w * re w + im w * im w) + 2 * (re z * re w - im z * -im w)",["ring","linarith"]],["Topology/MetricSpace/PiNat.lean",400,"E\u271d : \u2115 \u2192 Type u_1\ninst\u271d\u00b2 : (n : \u2115) \u2192 TopologicalSpace (E\u271d n)\ninst\u271d\u00b9 : \u2200 (n : \u2115), DiscreteTopology (E\u271d n)\nE : \u2115 \u2192 Type u_2\ninst\u271d : (n : \u2115) \u2192 UniformSpace (E n)\nh : \u2200 (n : \u2115), uniformity (E n) = \ud835\udcdf idRel\nthis : \u2200 (n : \u2115), DiscreteTopology (E n)\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["Topology/MetricSpace/PiNat.lean",683,"\u03b1 : Type u_2\ninst\u271d\u00b3 : MetricSpace \u03b1\ninst\u271d\u00b2 : CompleteSpace \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\ninst\u271d : Nonempty \u03b1\nthis : MetricSpace (\u2115 \u2192 \u2115) := metricSpaceNatNat\nI0 : 0 < 1 / 2\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["Topology/MetricSpace/PiNat.lean",712,"\u03b1 : Type u_2\ninst\u271d\u00b3 : MetricSpace \u03b1\ninst\u271d\u00b2 : CompleteSpace \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\ninst\u271d : Nonempty \u03b1\nthis : MetricSpace (\u2115 \u2192 \u2115) := metricSpaceNatNat\nI0 : 0 < 1 / 2\nI1 : 1 / 2 < 1\nu : \u2115 \u2192 \u03b1\nhu : DenseRange u\ns : Set (\u2115 \u2192 \u2115) := {x | (\u22c2 n, closedBall (u (x n)) ((1 / 2) ^ n)).Nonempty}\ng : \u2191s \u2192 \u03b1 := fun x \u21a6 Set.Nonempty.some \u22ef\nA : \u2200 (x : \u2191s) (n : \u2115), dist (g x) (u (\u2191x n)) \u2264 (1 / 2) ^ n\ny x : \u2191s\nhxy : dist x y < 1\nhne : x \u2260 y\nhne' : \u2191x \u2260 \u2191y\ndist' : dist x y = dist \u2191x \u2191y\nn : \u2115 := firstDiff \u2191x \u2191y - 1\ndiff_pos : 0 < firstDiff \u2191x \u2191y\nhn : firstDiff \u2191x \u2191y = n + 1\nB : \u2191x n = \u2191y n\n\u22a2 (1 / 2) ^ n + (1 / 2) ^ n = 4 * (1 / 2) ^ (n + 1)",["ring"]],["Analysis/InnerProductSpace/Basic.lean",230,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nx y : E\n\u22a2 \u27eax, x\u27eb_\ud835\udd5c + \u27eay, x\u27eb_\ud835\udd5c + (\u27eax, y\u27eb_\ud835\udd5c + \u27eay, y\u27eb_\ud835\udd5c) = \u27eax, x\u27eb_\ud835\udd5c + \u27eax, y\u27eb_\ud835\udd5c + \u27eay, x\u27eb_\ud835\udd5c + \u27eay, y\u27eb_\ud835\udd5c",["ring","abel"]],["Analysis/InnerProductSpace/Basic.lean",237,"F : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx y : F\nthis : \u27eay, x\u27eb_\u211d = \u27eax, y\u27eb_\u211d\n\u22a2 \u27eax, x\u27eb_\u211d + \u27eax, y\u27eb_\u211d + \u27eax, y\u27eb_\u211d = \u27eax, x\u27eb_\u211d + 2 * \u27eax, y\u27eb_\u211d",["ring","linarith"]],["Analysis/InnerProductSpace/Basic.lean",241,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nx y : E\n\u22a2 \u27eax, x\u27eb_\ud835\udd5c - \u27eay, x\u27eb_\ud835\udd5c - (\u27eax, y\u27eb_\ud835\udd5c - \u27eay, y\u27eb_\ud835\udd5c) = \u27eax, x\u27eb_\ud835\udd5c - \u27eax, y\u27eb_\ud835\udd5c - \u27eay, x\u27eb_\ud835\udd5c + \u27eay, y\u27eb_\ud835\udd5c",["ring","abel"]],["Analysis/InnerProductSpace/Basic.lean",248,"F : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx y : F\nthis : \u27eay, x\u27eb_\u211d = \u27eax, y\u27eb_\u211d\n\u22a2 \u27eax, x\u27eb_\u211d - \u27eax, y\u27eb_\u211d - \u27eax, y\u27eb_\u211d = \u27eax, x\u27eb_\u211d - 2 * \u27eax, y\u27eb_\u211d",["ring","linarith"]],["Analysis/InnerProductSpace/Basic.lean",253,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nx y : E\n\u22a2 \u27eax, x\u27eb_\ud835\udd5c + \u27eax, y\u27eb_\ud835\udd5c + \u27eay, x\u27eb_\ud835\udd5c + \u27eay, y\u27eb_\ud835\udd5c + (\u27eax, x\u27eb_\ud835\udd5c - \u27eax, y\u27eb_\ud835\udd5c - \u27eay, x\u27eb_\ud835\udd5c + \u27eay, y\u27eb_\ud835\udd5c) = 2 * (\u27eax, x\u27eb_\ud835\udd5c + \u27eay, y\u27eb_\ud835\udd5c)",["ring"]],["Analysis/InnerProductSpace/Basic.lean",456,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nx y : E\n\u22a2 re \u27eax, y\u27eb_\ud835\udd5c = (\u2016x\u2016 * \u2016x\u2016 + 2 * re \u27eax, y\u27eb_\ud835\udd5c + \u2016y\u2016 * \u2016y\u2016 - \u2016x\u2016 * \u2016x\u2016 - \u2016y\u2016 * \u2016y\u2016) / 2",["ring","linarith"]],["Analysis/InnerProductSpace/Basic.lean",468,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nx y : E\n\u22a2 re \u27eax, y\u27eb_\ud835\udd5c = (\u2016x\u2016 * \u2016x\u2016 + 2 * re \u27eax, y\u27eb_\ud835\udd5c + \u2016y\u2016 * \u2016y\u2016 - (\u2016x\u2016 * \u2016x\u2016 - 2 * re \u27eax, y\u27eb_\ud835\udd5c + \u2016y\u2016 * \u2016y\u2016)) / 4",["ring","linarith"]],["Analysis/InnerProductSpace/Basic.lean",474,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nx y : E\n\u22a2 im \u27eax, y\u27eb_\ud835\udd5c =\n    (\u2016x\u2016 * \u2016x\u2016 - 2 * -im \u27eax, y\u27eb_\ud835\udd5c + \u2016I \u2022 y\u2016 * \u2016I \u2022 y\u2016 - (\u2016x\u2016 * \u2016x\u2016 + 2 * -im \u27eax, y\u27eb_\ud835\udd5c + \u2016I \u2022 y\u2016 * \u2016I \u2022 y\u2016)) / 4",["ring","linarith"]],["Analysis/InnerProductSpace/Basic.lean",615,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx y : F\nhx : x \u2260 0\nhy : y \u2260 0\nR : \u211d\n\u22a2 ((R * R * \u2016x\u2016 * (R * R * \u2016x\u2016) * (\u2016y\u2016 * \u2016y\u2016 * (\u2016x\u2016 * \u2016x\u2016)) -\n            \u2016x\u2016 * \u2016x\u2016 * (\u2016x\u2016 * \u2016x\u2016) * (2 * (R * R * (R * R * \u27eax, y\u27eb_\u211d)))) *\n          (\u2016y\u2016 * \u2016y\u2016 * (\u2016y\u2016 * \u2016y\u2016)) +\n        R * R * \u2016y\u2016 * (R * R * \u2016y\u2016) * (\u2016x\u2016 * \u2016x\u2016 * (\u2016x\u2016 * \u2016x\u2016) * (\u2016y\u2016 * \u2016y\u2016 * (\u2016x\u2016 * \u2016x\u2016)))) *\n      (\u2016x\u2016 * \u2016y\u2016 * (\u2016x\u2016 * \u2016y\u2016)) =\n    R * R * (R * R) * (\u2016x\u2016 * \u2016x\u2016 - 2 * \u27eax, y\u27eb_\u211d + \u2016y\u2016 * \u2016y\u2016) *\n      (\u2016x\u2016 * \u2016x\u2016 * (\u2016x\u2016 * \u2016x\u2016) * (\u2016y\u2016 * \u2016y\u2016 * (\u2016x\u2016 * \u2016x\u2016)) * (\u2016y\u2016 * \u2016y\u2016 * (\u2016y\u2016 * \u2016y\u2016)))",["ring","linarith"]],["Analysis/InnerProductSpace/Basic.lean",882,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d : RCLike \ud835\udd5c\nx y z : \ud835\udd5c\n\u22a2 re z * (re x + re y) - im z * (-im x + -im y) = re z * re x - im z * -im x + (re z * re y - im z * -im y)",["ring","linarith"]],["Analysis/InnerProductSpace/Basic.lean",885,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d : RCLike \ud835\udd5c\nx y : \ud835\udd5c\nr : \u211d\n\u22a2 re y * (r * re x) - im y * -(r * im x) = r * (re y * re x - im y * -im x)",["ring","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Deriv.lean",65,"case h.e'_9\nx : \u2102\n\u22a2 -(cexp (-x * I) - cexp (x * I)) * I * 2\u207b\u00b9 = (cexp (x * I) * (1 * I) + cexp (-x * I) * (-1 * I)) * 2\u207b\u00b9",["ring"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",178,"case bc.hpq\n\u03b9 : Type u_1\nA : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b9) \u2192 MeasurableSpace (A i)\n\u03bc : (i : \u03b9) \u2192 Measure (A i)\ninst\u271d\u00b9 : DecidableEq \u03b9\np : \u211d\ninst\u271d : \u2200 (i : \u03b9), SigmaFinite (\u03bc i)\nhp\u2080 : 0 \u2264 p\ns : Finset \u03b9\nhp : \u2191(#s) * p \u2264 1\ni : \u03b9\nhi : i \u2209 s\nf : ((i : \u03b9) \u2192 A i) \u2192 \u211d\u22650\u221e\nhf : Measurable f\nx : (i : \u03b9) \u2192 A i\nX : A i \u2192 (a : \u03b9) \u2192 A a := update x i\nhF\u2081 : \u2200 {j : \u03b9}, Measurable fun t \u21a6 (\u222b\u22ef\u222b\u207b_{j}, f \u2202\u03bc) (X t)\nhF\u2080 : Measurable fun t \u21a6 f (X t)\nk : \u211d := \u2191(#s)\nhk' : 0 \u2264 1 - k * p\n\u22a2 1 - k * p + \u2191(#s) * p = 1",["ring","aesop","linarith","abel"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",524,"E : Type u_4\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : MeasurableSpace E\ninst\u271d\u2075 : BorelSpace E\ninst\u271d\u2074 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b3 : \u03bc.IsAddHaarMeasure\nF' : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup F'\ninst\u271d\u00b9 : InnerProductSpace \u211d F'\ninst\u271d : CompleteSpace F'\nu : E \u2192 F'\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\np p' : \u211d\u22650\nhp\u271d : 1 \u2264 p\nhp'0 : \u00acp' = 0\nn : \u2115 := finrank \u211d E\nhn\u271d : 0 < n\nhp' : (\u2191p')\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191n)\u207b\u00b9\nn' : \u211d\u22650 := (\u2191n).conjExponent\nh2p : \u2191p < \u2191n\nh0n : 2 \u2264 n\nhn : (\u2191n).IsConjExponent n'\nh1n : 1 \u2264 \u2191n\nh2n : 0 < \u2191n - 1\nhnp : 0 < \u2191n - \u2191p\nhp : 1 < p\nq : \u211d := (\u2191p).conjExponent\nhq : (\u2191p).IsConjExponent q\nh0p : p \u2260 0\nh1p : \u2191p \u2260 1\nh3p : \u2191p - 1 \u2260 0\nh0p' : p' \u2260 0\nh2q : 1 / \u2191n' - 1 / q = 1 / \u2191p'\n\u03b3 : \u211d\u22650 := \u27e8\u2191p * (\u2191n - 1) / (\u2191n - \u2191p), \u22ef\u27e9\nh0\u03b3 : \u2191\u03b3 = \u2191p * (\u2191n - 1) / (\u2191n - \u2191p)\nh1\u03b3 : 1 < \u2191\u03b3\n\u22a2 (\u2191n - \u2191p) * (\u2191n - 1) * (\u2191p * \u2191n) = (\u2191n - \u2191p) * (\u2191p * (\u2191n - 1) * \u2191n)",["ring","linarith"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",527,"E : Type u_4\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : MeasurableSpace E\ninst\u271d\u2075 : BorelSpace E\ninst\u271d\u2074 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b3 : \u03bc.IsAddHaarMeasure\nF' : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup F'\ninst\u271d\u00b9 : InnerProductSpace \u211d F'\ninst\u271d : CompleteSpace F'\nu : E \u2192 F'\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\np p' : \u211d\u22650\nhp\u271d : 1 \u2264 p\nhp'0 : \u00acp' = 0\nn : \u2115 := finrank \u211d E\nhn\u271d : 0 < n\nhp' : (\u2191p')\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191n)\u207b\u00b9\nn' : \u211d\u22650 := (\u2191n).conjExponent\nh2p : \u2191p < \u2191n\nh0n : 2 \u2264 n\nhn : (\u2191n).IsConjExponent n'\nh1n : 1 \u2264 \u2191n\nh2n : 0 < \u2191n - 1\nhnp : 0 < \u2191n - \u2191p\nhp : 1 < p\nq : \u211d := (\u2191p).conjExponent\nhq : (\u2191p).IsConjExponent q\nh0p : p \u2260 0\nh1p : \u2191p \u2260 1\nh3p : \u2191p - 1 \u2260 0\nh0p' : p' \u2260 0\nh2q : 1 / \u2191n' - 1 / q = 1 / \u2191p'\n\u03b3 : \u211d\u22650 := \u27e8\u2191p * (\u2191n - 1) / (\u2191n - \u2191p), \u22ef\u27e9\nh0\u03b3 : \u2191\u03b3 = \u2191p * (\u2191n - 1) / (\u2191n - \u2191p)\nh1\u03b3 : 1 < \u2191\u03b3\nh2\u03b3 : \u03b3 * n' = p'\n\u22a2 \u2191p * (\u2191n - 1) - (\u2191n - \u2191p) = \u2191n * (\u2191p - 1)",["ring","linarith"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",528,"E : Type u_4\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : MeasurableSpace E\ninst\u271d\u2075 : BorelSpace E\ninst\u271d\u2074 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b3 : \u03bc.IsAddHaarMeasure\nF' : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup F'\ninst\u271d\u00b9 : InnerProductSpace \u211d F'\ninst\u271d : CompleteSpace F'\nu : E \u2192 F'\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\np p' : \u211d\u22650\nhp\u271d : 1 \u2264 p\nhp'0 : \u00acp' = 0\nn : \u2115 := finrank \u211d E\nhn\u271d : 0 < n\nhp' : (\u2191p')\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191n)\u207b\u00b9\nn' : \u211d\u22650 := (\u2191n).conjExponent\nh2p : \u2191p < \u2191n\nh0n : 2 \u2264 n\nhn : (\u2191n).IsConjExponent n'\nh1n : 1 \u2264 \u2191n\nh2n : 0 < \u2191n - 1\nhnp : 0 < \u2191n - \u2191p\nhp : 1 < p\nq : \u211d := (\u2191p).conjExponent\nhq : (\u2191p).IsConjExponent q\nh0p : p \u2260 0\nh1p : \u2191p \u2260 1\nh3p : \u2191p - 1 \u2260 0\nh0p' : p' \u2260 0\nh2q : 1 / \u2191n' - 1 / q = 1 / \u2191p'\n\u03b3 : \u211d\u22650 := \u27e8\u2191p * (\u2191n - 1) / (\u2191n - \u2191p), \u22ef\u27e9\nh0\u03b3 : \u2191\u03b3 = \u2191p * (\u2191n - 1) / (\u2191n - \u2191p)\nh1\u03b3 : 1 < \u2191\u03b3\nh2\u03b3 : \u03b3 * n' = p'\nthis : \u2191p * (\u2191n - 1) - (\u2191n - \u2191p) = \u2191n * (\u2191p - 1)\n\u22a2 (\u2191n - \u2191p) * (\u2191p - 1) * (\u2191p * \u2191n) = (\u2191n - \u2191p) * (\u2191n * (\u2191p - 1) * \u2191p)",["ring","linarith"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",571,"E : Type u_4\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : MeasurableSpace E\ninst\u271d\u2075 : BorelSpace E\ninst\u271d\u2074 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b3 : \u03bc.IsAddHaarMeasure\nF' : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup F'\ninst\u271d\u00b9 : InnerProductSpace \u211d F'\ninst\u271d : CompleteSpace F'\nu : E \u2192 F'\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\np p' : \u211d\u22650\nhp\u271d : 1 \u2264 p\nhp'0 : \u00acp' = 0\nn : \u2115 := finrank \u211d E\nhn\u271d : 0 < n\nhp' : (\u2191p')\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191n)\u207b\u00b9\nn' : \u211d\u22650 := (\u2191n).conjExponent\nh2p : \u2191p < \u2191n\nh0n : 2 \u2264 n\nhn : (\u2191n).IsConjExponent n'\nh1n : 1 \u2264 \u2191n\nh2n : 0 < \u2191n - 1\nhnp : 0 < \u2191n - \u2191p\nhp : 1 < p\nq : \u211d := (\u2191p).conjExponent\nhq : (\u2191p).IsConjExponent q\nh0p : p \u2260 0\nh1p : \u2191p \u2260 1\nh3p : \u2191p - 1 \u2260 0\nh0p' : p' \u2260 0\nh2q : 1 / \u2191n' - 1 / q = 1 / \u2191p'\n\u03b3 : \u211d\u22650 := \u27e8\u2191p * (\u2191n - 1) / (\u2191n - \u2191p), \u22ef\u27e9\nh0\u03b3 : \u2191\u03b3 = \u2191p * (\u2191n - 1) / (\u2191n - \u2191p)\nh1\u03b3 : 1 < \u2191\u03b3\nh2\u03b3 : \u03b3 * n' = p'\nh3\u03b3 : (\u2191\u03b3 - 1) * q = \u2191p'\nh4\u03b3 : \u2191\u03b3 \u2260 0\nh3u : \u00ac\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc = 0\nh4u : \u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc \u2260 \u22a4\nh5u : (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q) \u2260 0\nh6u : (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q) \u2260 \u22a4\nh7u : Continuous u\nh8u : Continuous (fderiv \u211d u)\nv : E \u2192 \u211d := fun x \u21a6 \u2016u x\u2016 ^ \u2191\u03b3\nhv : ContDiff \u211d 1 v\nh2v : HasCompactSupport v\nC : \u211d\u22650 := eLpNormLESNormFDerivOneConst \u03bc \u2191n'\n\u22a2 \u2191C * \u2191\u03b3 * ((\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (x : E), \u2016fderiv \u211d u x\u2016\u2091 ^ \u2191p \u2202\u03bc) ^ (1 / \u2191p)) =\n    \u2191C * \u2191\u03b3 * (\u222b\u207b (x : E), \u2016fderiv \u211d u x\u2016\u2091 ^ \u2191p \u2202\u03bc) ^ (1 / \u2191p) * (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q)",["ring"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",709,"F : Type u_3\ninst\u271d\u2078 : NormedAddCommGroup F\ninst\u271d\u2077 : NormedSpace \u211d F\nE : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\ninst\u271d\u2074 : MeasurableSpace E\ninst\u271d\u00b3 : BorelSpace E\ninst\u271d\u00b2 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : FiniteDimensional \u211d F\nu : E \u2192 F\ns : Set E\nhu : ContDiff \u211d 1 u\nh2u : support u \u2286 s\np q : \u211d\u22650\nhp : 1 \u2264 p\nh2p : p < \u2191(finrank \u211d E)\nhpq : \u2191p\u207b\u00b9 - (\u2191(finrank \u211d E))\u207b\u00b9 \u2264 (\u2191q)\u207b\u00b9\nhs : Bornology.IsBounded s\nhq0 : \u00acq = 0\np' : \u211d\u22650 := (p\u207b\u00b9 - (\u2191(finrank \u211d E))\u207b\u00b9)\u207b\u00b9\nhp' : \u2191p'\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191(finrank \u211d E))\u207b\u00b9\nthis : \u2191q \u2264 \u2191p'\nt : \u211d\u22650 := (\u03bc s).toNNReal ^ (1 / \u2191q - 1 / \u2191p')\nC : \u211d\u22650 := SNormLESNormFDerivOfEqConst F \u03bc \u2191p\n\u22a2 \u2191C * eLpNorm (fderiv \u211d u) (\u2191p) \u03bc * \u2191t =\n    \u2191((\u03bc s).toNNReal ^ (1 / \u2191q - 1 / \u2191(p\u207b\u00b9 - (\u2191(finrank \u211d E))\u207b\u00b9)\u207b\u00b9)) * \u2191(SNormLESNormFDerivOfEqConst F \u03bc \u2191p) *\n      eLpNorm (fderiv \u211d u) (\u2191p) \u03bc",["ring"]],["NumberTheory/PellMatiyasevic.lean",497,"y2 y1 y0 yn1 yn0 xn1 xn0 ay a2 : \u2124\n\u22a2 (a2 * yn1 - yn0) * ay + y2 - (a2 * xn1 - xn0) = y2 - a2 * y1 + y0 + a2 * (yn1 * ay + y1 - xn1) - (yn0 * ay + y0 - xn0)",["ring","linarith"]],["NumberTheory/PellMatiyasevic.lean",850,"a y k : \u2115\nhy0 : y \u2260 0\nhk0 : k \u2260 0\nhyk : y ^ k < a\nhya : y < a\n\u22a2 \u2191a ^ 2 - (\u2191a - \u2191y) ^ 2 - 1 = 2 * \u2191a * \u2191y - \u2191y * \u2191y - 1",["ring","linarith"]],["NumberTheory/LSeries/HurwitzZetaEven.lean",423,"a b : UnitAddCircle\ns : \u2102\n\u22a2 completedHurwitzZetaEven\u2080 a s - (if a = 0 then 1 else 0) / s - 1 / (1 - s) -\n      (completedHurwitzZetaEven\u2080 b s - (if b = 0 then 1 else 0) / s - 1 / (1 - s)) =\n    completedHurwitzZetaEven\u2080 a s - completedHurwitzZetaEven\u2080 b s -\n      ((if a = 0 then 1 else 0) / s - (if b = 0 then 1 else 0) / s)",["abel","ring"]],["NumberTheory/LSeries/HurwitzZetaEven.lean",140,"x : \u211d\nhx : 0 < x\na : \u211d\nh1 : I * \u2191(1 / x) = -1 / (I * \u2191x)\nhx' : I * \u2191x \u2260 0\n\u22a2 \u2191a * I * \u2191x = \u2191a * (I * \u2191x)",["ring"]],["NumberTheory/LSeries/HurwitzZetaEven.lean",146,"x : \u211d\nhx : 0 < x\na : \u211d\nh1 : I * \u2191(1 / x) = -1 / (I * \u2191x)\nhx' : I * \u2191x \u2260 0\nh2 : \u2191a * I * \u2191x / (I * \u2191x) = \u2191a\nh3 : 1 / (-I * (I * \u2191x)) ^ (1 / 2) = 1 / \u2191(x ^ (1 / 2))\n\u22a2 -\u2191\u03c0 * I * (\u2191a ^ 2 * -1 * \u2191x ^ 2) = -(-\u2191\u03c0 * \u2191a ^ 2 * \u2191x) * (I * \u2191x)",["ring"]],["Algebra/Order/ToIntervalMod.lean",456,"\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\n\u22a2 -b - -(toIocDiv hp (-a) b \u2022 p + 1 \u2022 p) = p - (b - toIocDiv hp (-a) b \u2022 p)",["abel"]],["Algebra/Order/ToIntervalMod.lean",463,"\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\n\u22a2 -b - -(toIcoDiv hp (-a) b \u2022 p + 1 \u2022 p) = p - (b - toIcoDiv hp (-a) b \u2022 p)",["abel"]],["Algebra/Order/ToIntervalMod.lean",472,"case refine_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nh : toIcoMod hp a b = toIcoMod hp a c\n\u22a2 toIcoMod hp a c + toIcoDiv hp a c \u2022 p - (toIcoMod hp a c + toIcoDiv hp a b \u2022 p) =\n    toIcoDiv hp a c \u2022 p - toIcoDiv hp a b \u2022 p",["abel"]],["Algebra/Order/ToIntervalMod.lean",481,"case refine_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nh : toIocMod hp a b = toIocMod hp a c\n\u22a2 toIocMod hp a c + toIocDiv hp a c \u2022 p - (toIocMod hp a c + toIocDiv hp a b \u2022 p) =\n    toIocDiv hp a c \u2022 p - toIocDiv hp a b \u2022 p",["abel"]],["Algebra/Order/ToIntervalMod.lean",912,"case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a < b - toIocDiv hp a b \u2022 p\nhr : b - toIocDiv hp a b \u2022 p \u2264 a + p\n\u22a2 a + toIocDiv hp a b \u2022 p + p = a + p + toIocDiv hp a b \u2022 p",["abel"]],["Algebra/Order/ToIntervalMod.lean",919,"case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a \u2264 b - toIcoDiv hp a b \u2022 p\nhr : b - toIcoDiv hp a b \u2022 p < a + p\n\u22a2 a + toIcoDiv hp a b \u2022 p + p = a + p + toIcoDiv hp a b \u2022 p",["abel"]],["Algebra/Order/ToIntervalMod.lean",879,"\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorRing \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\n\u22a2 b - \u2191\u230a(b - a) / p\u230b * p = a + (b - a - p * \u2191\u230a(b - a) / p\u230b)",["ring","linarith"]],["Algebra/Order/ToIntervalMod.lean",888,"\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorRing \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\n\u22a2 b + \u2191\u230a(a + p - b) / p\u230b * p = a + p - (a + p - b - p * \u2191\u230a(a + p - b) / p\u230b)",["ring","linarith"]],["MeasureTheory/Measure/LevyProkhorovMetric.lean",464,"\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : PseudoMetricSpace \u03a9\ninst\u271d : OpensMeasurableSpace \u03a9\n\u03bcs : \u2115 \u2192 LevyProkhorov (ProbabilityMeasure \u03a9)\n\u03bd : LevyProkhorov (ProbabilityMeasure \u03a9)\nh\u03bcs : Tendsto \u03bcs atTop (\ud835\udcdd \u03bd)\nP : ProbabilityMeasure \u03a9 := (equiv (ProbabilityMeasure \u03a9)) \u03bd\nPs : \u2115 \u2192 ProbabilityMeasure \u03a9 := fun n \u21a6 (equiv (ProbabilityMeasure \u03a9)) (\u03bcs n)\nf\u271d f : \u03a9 \u2192\u1d47 \u211d\nf_nn : 0 \u2264 f\nf_zero : \u00ac\u2016f\u2016 = 0\nnorm_f_pos : 0 < \u2016f\u2016\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\n\u03b5s : \u2115 \u2192 \u211d\nleft\u271d : StrictAnti \u03b5s\n\u03b5s_lim : Tendsto \u03b5s atTop (\ud835\udcdd 0)\n\u03b5_of_room : Tendsto (fun x \u21a6 dist (\u03bcs x) \u03bd + \u03b5s x) atTop (\ud835\udcdd 0)\n\u03b5_of_room' : Tendsto (fun n \u21a6 dist (\u03bcs n) \u03bd + \u03b5s n) atTop (\ud835\udcdd[>] 0)\nkey :\n  Tendsto ((fun \u03b5 \u21a6 \u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P (thickening \u03b5 {a | t \u2264 f a}))).toReal) \u2218 fun n \u21a6 dist (\u03bcs n) \u03bd + \u03b5s n)\n    atTop (\ud835\udcdd (\u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P {a | t \u2264 f a})).toReal))\naux : \u2200 (z : \u211d), Iio (z + \u03b4 / 2) \u2208 \ud835\udcdd z\nn : \u2115\nhn :\n  ((fun \u03b5 \u21a6 \u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P (thickening \u03b5 {a | t \u2264 f a}))).toReal) \u2218 fun n \u21a6 dist (\u03bcs n) \u03bd + \u03b5s n) n <\n    (\u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P {a | t \u2264 f a})).toReal) + \u03b4 / 2\nhn' : dist (\u03bcs n) \u03bd + \u03b5s n < \u2016f\u2016\u207b\u00b9 * \u03b4 / 2\n\u03b5s_pos : 0 < \u03b5s n\nbound :\n  \u222b (\u03c9 : \u03a9), f \u03c9 \u2202\u2191(Ps n) \u2264\n    (\u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191P (thickening (dist (\u03bcs n) \u03bd + \u03b5s n) {a | t \u2264 f a})).toReal) + (dist (\u03bcs n) \u03bd + \u03b5s n) * \u2016f\u2016\n\u22a2 \u03b4 * (\u2016f\u2016 * 2) + \u2016f\u2016 * \u03b4 * 2 = \u03b4 * (2 * (\u2016f\u2016 * 2))",["ring","linarith"]],["MeasureTheory/Measure/LevyProkhorovMetric.lean",542,"case h.e'_4\n\u03a9 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03a9\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : OpensMeasurableSpace \u03a9\ninst\u271d : SeparableSpace \u03a9\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\nX_emp : Nonempty \u03a9\nxs : \u2115 \u2192 \u03a9\nxs_dense : DenseRange xs\nhalf_\u03b5_pos : 0 < \u03b5 / 2\nBs : \u2115 \u2192 Set \u03a9 := fun n \u21a6 ball (xs n) (\u03b5 / 2)\nAs : \u2115 \u2192 Set \u03a9 := disjointed Bs\nn : \u2115\n\u22a2 \u03b5 = 2 * (\u03b5 / 2)",["ring","linarith"]],["NumberTheory/FLT/Three.lean",96,"case neg\na b c : \u2124\nha : a \u2260 0\nHgcd : {a, b, c}.gcd id = 1\nh3a : 3 \u2223 a\nHF : a ^ 3 + b ^ 3 = (-c) ^ 3\nH : \u2200 (a b c : \u2124), c \u2260 0 \u2192 \u00ac3 \u2223 a \u2192 \u00ac3 \u2223 b \u2192 3 \u2223 c \u2192 IsCoprime a b \u2192 a ^ 3 + b ^ 3 \u2260 c ^ 3\nhbc : IsCoprime (-b) (-c)\nh3b : \u00ac3 \u2223 b\nh3c : \u00ac3 \u2223 c\n\u22a2 (-b) ^ 3 + (a ^ 3 + b ^ 3) = a ^ 3",["ring","linarith"]],["NumberTheory/FLT/Three.lean",254,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\u271d\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nz : \ud835\udcde K\nhz : S'.c = (h\u03b6\u271d.toInteger - 1) * z\nx : \ud835\udcde K\nhx : S'.a ^ 3 - 1 = (h\u03b6\u271d.toInteger - 1) ^ 4 * x\ny : \ud835\udcde K\nhy : S'.b ^ 3 - 1 = (h\u03b6\u271d.toInteger - 1) ^ 4 * y\nh\u03b6 : IsPrimitiveRoot \u03b6 (\u21913 ^ 1)\n\u22a2 (h\u03b6.toInteger - 1) * (\u2191S'.u * (h\u03b6\u271d.toInteger - 1) ^ 2 * z ^ 3 - (h\u03b6\u271d.toInteger - 1) ^ 3 * (x + y)) =\n    \u2191S'.u * ((h\u03b6\u271d.toInteger - 1) * z) ^ 3 - (h\u03b6\u271d.toInteger - 1) ^ 4 * x - (h\u03b6\u271d.toInteger - 1) ^ 4 * y",["ring"]],["NumberTheory/FLT/Three.lean",256,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\u271d\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nz : \ud835\udcde K\nhz : S'.c = (h\u03b6\u271d.toInteger - 1) * z\nx : \ud835\udcde K\nhx : S'.a ^ 3 - 1 = (h\u03b6\u271d.toInteger - 1) ^ 4 * x\ny : \ud835\udcde K\nhy : S'.b ^ 3 - 1 = (h\u03b6\u271d.toInteger - 1) ^ 4 * y\nh\u03b6 : IsPrimitiveRoot \u03b6 (\u21913 ^ 1)\n\u22a2 S'.a ^ 3 + S'.b ^ 3 - (S'.a ^ 3 - 1) - (S'.b ^ 3 - 1) = 2",["ring","norm_num"]],["NumberTheory/FLT/Three.lean",265,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\u271d\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nz : \ud835\udcde K\nhz : S'.c = (h\u03b6\u271d.toInteger - 1) * z\nx : \ud835\udcde K\nhx : S'.a ^ 3 + 1 = (h\u03b6\u271d.toInteger - 1) ^ 4 * x\ny : \ud835\udcde K\nhy : S'.b ^ 3 + 1 = (h\u03b6\u271d.toInteger - 1) ^ 4 * y\nh\u03b6 : IsPrimitiveRoot \u03b6 (\u21913 ^ 1)\n\u22a2 (h\u03b6.toInteger - 1) * ((h\u03b6\u271d.toInteger - 1) ^ 3 * (x + y) - \u2191S'.u * (h\u03b6\u271d.toInteger - 1) ^ 2 * z ^ 3) =\n    (h\u03b6\u271d.toInteger - 1) ^ 4 * x + (h\u03b6\u271d.toInteger - 1) ^ 4 * y - \u2191S'.u * ((h\u03b6\u271d.toInteger - 1) * z) ^ 3",["ring"]],["NumberTheory/FLT/Three.lean",267,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\u271d\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nz : \ud835\udcde K\nhz : S'.c = (h\u03b6\u271d.toInteger - 1) * z\nx : \ud835\udcde K\nhx : S'.a ^ 3 + 1 = (h\u03b6\u271d.toInteger - 1) ^ 4 * x\ny : \ud835\udcde K\nhy : S'.b ^ 3 + 1 = (h\u03b6\u271d.toInteger - 1) ^ 4 * y\nh\u03b6 : IsPrimitiveRoot \u03b6 (\u21913 ^ 1)\n\u22a2 S'.a ^ 3 + 1 + (S'.b ^ 3 + 1) - (S'.a ^ 3 + S'.b ^ 3) = 2",["ring"]],["NumberTheory/FLT/Three.lean",275,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nx : \ud835\udcde K\nhx : S'.a ^ 3 - 1 = \u03bb ^ 4 * x\ny : \ud835\udcde K\nhy : S'.b ^ 3 + 1 = \u03bb ^ 4 * y\n\u22a2 \u03bb ^ 4 * (\u2191S'.u\u207b\u00b9 * (x + y)) = \u2191S'.u\u207b\u00b9 * (\u03bb ^ 4 * x + \u03bb ^ 4 * y)\n```\n---\n```lean\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nx : \ud835\udcde K\nhx : S'.a ^ 3 + 1 = \u03bb ^ 4 * x\ny : \ud835\udcde K\nhy : S'.b ^ 3 - 1 = \u03bb ^ 4 * y\n\u22a2 \u03bb ^ 4 * (\u2191S'.u\u207b\u00b9 * (x + y)) = \u2191S'.u\u207b\u00b9 * (\u03bb ^ 4 * x + \u03bb ^ 4 * y)",["ring"]],["NumberTheory/FLT/Three.lean",314,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\n\u22a2 (S'.a + S'.b) * (S'.a + \u2191\u03b7 * S'.b) * (S'.a + \u2191\u03b7 ^ 2 * S'.b) =\n    S'.a ^ 3 + S'.a ^ 2 * S'.b * (\u2191\u03b7 ^ 2 + \u2191\u03b7 + 1) + S'.a * S'.b ^ 2 * (\u2191\u03b7 ^ 2 + \u2191\u03b7 + \u2191\u03b7 ^ 3) + \u2191\u03b7 ^ 3 * S'.b ^ 3",["ring"]],["NumberTheory/FLT/Three.lean",317,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\n\u22a2 S'.a ^ 3 + S'.a ^ 2 * S'.b * (-\u2191\u03b7 - 1 + \u2191\u03b7 + 1) + S'.a * S'.b ^ 2 * (-\u2191\u03b7 - 1 + \u2191\u03b7 + 1) + S'.b ^ 3 = S'.a ^ 3 + S'.b ^ 3",["ring"]],["NumberTheory/FLT/Three.lean",391,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\n\u22a2 S.a + h\u03b6.toInteger * S.b = S.a + S.b + \u03bb * S.b",["ring"]],["NumberTheory/FLT/Three.lean",425,"case intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nk k' : \ud835\udcde K\nhk' : S.a + S.b = \u03bb ^ 2 * k'\nhk : S.b = \u03bb * k * -\u2191\u03b7 + \u2191\u03b7 * \u03bb * k'\n\u22a2 \u03bb * k * -\u2191\u03b7 + \u2191\u03b7 * \u03bb * k' = \u03bb * ((k - k') * -\u2191\u03b7)",["ring"]],["NumberTheory/FLT/Three.lean",451,"case h.e'_4\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\np : \ud835\udcde K\nhp : Prime p\nhpab : p \u2223 1 * S.a + 1 * S.b\nhpa\u03b7sqb : p \u2223 1 * S.a + \u2191\u03b7 ^ 2 * S.b\nthis : p \u2223 -(\u2191\u03b7 ^ 2 - 1)\n\u22a2 \u03bb = 1 * h\u03b6.toInteger - (-(-h\u03b6.toInteger - 1) - 1 * h\u03b6.toInteger)",["ring","aesop"]],["NumberTheory/FLT/Three.lean",465,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\np : \ud835\udcde K\nhp : Prime p\nhpa\u03b7b : p \u2223 1 * S.a + \u2191\u03b7 * S.b\nhpa\u03b7sqb : p \u2223 1 * S.a + \u2191\u03b7 ^ 2 * S.b\nthis : p \u2223 \u2191\u03b7 ^ 2 - \u2191\u03b7\n\u22a2 (-\u2191\u03b7 - 1 - \u2191\u03b7) * (-\u2191\u03b7 - 1) = 2 * \u2191\u03b7 ^ 2 + 3 * \u2191\u03b7 + 1",["ring"]],["NumberTheory/FLT/Three.lean",466,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\np : \ud835\udcde K\nhp : Prime p\nhpa\u03b7b : p \u2223 1 * S.a + \u2191\u03b7 * S.b\nhpa\u03b7sqb : p \u2223 1 * S.a + \u2191\u03b7 ^ 2 * S.b\nthis : p \u2223 \u2191\u03b7 ^ 2 - \u2191\u03b7\n\u22a2 2 * (-h\u03b6.toInteger - 1) + 3 * h\u03b6.toInteger + 1 = \u03bb",["ring"]],["NumberTheory/FLT/Three.lean",578,"case h.e'_2\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : 2 \u2264 S.multiplicity\nhh :\n  FermatLastTheoremForThreeGen.Solution.x S *\n      (FermatLastTheoremForThreeGen.Solution.y S * FermatLastTheoremForThreeGen.Solution.z S) =\n    \u2191S.u * FermatLastTheoremForThreeGen.Solution.w S ^ 3\n\u22a2 FermatLastTheoremForThreeGen.Solution.x S * FermatLastTheoremForThreeGen.Solution.y S *\n      FermatLastTheoremForThreeGen.Solution.z S =\n    FermatLastTheoremForThreeGen.Solution.x S *\n      (FermatLastTheoremForThreeGen.Solution.y S * FermatLastTheoremForThreeGen.Solution.z S)",["ring"]],["NumberTheory/FLT/Three.lean",581,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\n\u22a2 (S.a + S.b) * ((S.a + \u2191\u03b7 * S.b) * (S.a + \u2191\u03b7 ^ 2 * S.b)) = (S.a + S.b) * (S.a + \u2191\u03b7 * S.b) * (S.a + \u2191\u03b7 ^ 2 * S.b)",["ring"]],["NumberTheory/FLT/Three.lean",636,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\n\u22a2 S.a + S.b + (S.a + \u2191\u03b7 * S.b) * \u2191\u03b7 + (S.a + (-\u2191\u03b7 - 1) * S.b) * (-\u2191\u03b7 - 1) =\n    S.a + S.b + \u2191\u03b7 ^ 2 * S.b - S.a + \u2191\u03b7 ^ 2 * S.b + 2 * \u2191\u03b7 * S.b + S.b",["ring"]],["NumberTheory/FLT/Three.lean",637,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\n\u22a2 S.a + S.b + (-\u2191\u03b7 - 1) * S.b - S.a + (-\u2191\u03b7 - 1) * S.b + 2 * \u2191\u03b7 * S.b + S.b = 0",["ring"]],["NumberTheory/FLT/Three.lean",659,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : (S.multiplicity - 1) * 3 + 1 = 3 * S.multiplicity - 2\n\u22a2 \u2191\u03b7 ^ 2 * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2081 S) * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2082 S)\u207b\u00b9 *\n        (\u03bb ^ (S.multiplicity - 1) * FermatLastTheoremForThreeGen.Solution.X S) ^ 3 *\n      (\u03bb * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2082 S) * \u2191\u03b7) =\n    FermatLastTheoremForThreeGen.Solution.X S ^ 3 *\n          (\u2191(FermatLastTheoremForThreeGen.Solution.u\u2082 S) * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2082 S)\u207b\u00b9) *\n        (\u2191\u03b7 ^ 3 * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2081 S)) *\n      (\u03bb ^ ((S.multiplicity - 1) * 3) * \u03bb)",["ring"]],["NumberTheory/FLT/Three.lean",663,"case refine_3\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\n\u22a2 FermatLastTheoremForThreeGen.Solution.Z S ^ 3 * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2083 S) * \u03bb * h\u03b6.toInteger ^ 2 *\n      \u2191(FermatLastTheoremForThreeGen.Solution.u\u2082 S) =\n    h\u03b6.toInteger * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2083 S) * FermatLastTheoremForThreeGen.Solution.Z S ^ 3 *\n      (\u03bb * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2082 S) * h\u03b6.toInteger)",["ring"]],["NumberTheory/FLT/Three.lean",668,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : 3 * (S.multiplicity - 1) = 2 + (3 * S.multiplicity - 5)\n\u22a2 \u2191(FermatLastTheoremForThreeGen.Solution.u\u2085 S) *\n      (\u03bb ^ (S.multiplicity - 1) * FermatLastTheoremForThreeGen.Solution.X S) ^ 3 =\n    \u03bb ^ (3 * (S.multiplicity - 1)) * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2085 S) *\n      FermatLastTheoremForThreeGen.Solution.X S ^ 3",["ring"]],["NumberTheory/FLT/Three.lean",670,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : 3 * (S.multiplicity - 1) = 2 + (3 * S.multiplicity - 5)\n\u22a2 \u03bb ^ 2 * \u03bb ^ (3 * S.multiplicity - 5) * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2085 S) *\n      FermatLastTheoremForThreeGen.Solution.X S ^ 3 =\n    \u03bb ^ 2 *\n      (\u03bb ^ (3 * S.multiplicity - 5) * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2085 S) *\n        FermatLastTheoremForThreeGen.Solution.X S ^ 3)",["ring"]],["NumberTheory/FLT/Three.lean",683,"case hcong.intro.inl.inl.intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : \u03bb ^ 2 \u2223 \u03bb ^ 4\nX : \ud835\udcde K\nhX :\n  \u2191(FermatLastTheoremForThreeGen.Solution.u\u2085 S) *\n      (\u03bb ^ (S.multiplicity - 1) * FermatLastTheoremForThreeGen.Solution.X S) ^ 3 =\n    \u03bb ^ 2 * X\nY : \ud835\udcde K\nhY : FermatLastTheoremForThreeGen.Solution.Y S ^ 3 - 1 = \u03bb ^ 2 * Y\nZ : \ud835\udcde K\nhZ : FermatLastTheoremForThreeGen.Solution.Z S ^ 3 - 1 = \u03bb ^ 2 * Z\n\u22a2 \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) - \u2191(-1) =\n    FermatLastTheoremForThreeGen.Solution.Y S ^ 3 +\n          \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) * FermatLastTheoremForThreeGen.Solution.Z S ^ 3 -\n        (FermatLastTheoremForThreeGen.Solution.Y S ^ 3 - 1) -\n      \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) * (FermatLastTheoremForThreeGen.Solution.Z S ^ 3 - 1)",["ring"]],["NumberTheory/FLT/Three.lean",686,"case hcong.intro.inl.inr.intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : \u03bb ^ 2 \u2223 \u03bb ^ 4\nX : \ud835\udcde K\nhX :\n  \u2191(FermatLastTheoremForThreeGen.Solution.u\u2085 S) *\n      (\u03bb ^ (S.multiplicity - 1) * FermatLastTheoremForThreeGen.Solution.X S) ^ 3 =\n    \u03bb ^ 2 * X\nY : \ud835\udcde K\nhY : FermatLastTheoremForThreeGen.Solution.Y S ^ 3 - 1 = \u03bb ^ 2 * Y\nZ : \ud835\udcde K\nhZ : FermatLastTheoremForThreeGen.Solution.Z S ^ 3 + 1 = \u03bb ^ 2 * Z\n\u22a2 \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) - \u21911 =\n    -(FermatLastTheoremForThreeGen.Solution.Y S ^ 3 +\n            \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) * FermatLastTheoremForThreeGen.Solution.Z S ^ 3 -\n          (FermatLastTheoremForThreeGen.Solution.Y S ^ 3 - 1) -\n        \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) * (FermatLastTheoremForThreeGen.Solution.Z S ^ 3 + 1))",["ring"]],["NumberTheory/FLT/Three.lean",689,"case hcong.intro.inr.inl.intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : \u03bb ^ 2 \u2223 \u03bb ^ 4\nX : \ud835\udcde K\nhX :\n  \u2191(FermatLastTheoremForThreeGen.Solution.u\u2085 S) *\n      (\u03bb ^ (S.multiplicity - 1) * FermatLastTheoremForThreeGen.Solution.X S) ^ 3 =\n    \u03bb ^ 2 * X\nY : \ud835\udcde K\nhY : FermatLastTheoremForThreeGen.Solution.Y S ^ 3 + 1 = \u03bb ^ 2 * Y\nZ : \ud835\udcde K\nhZ : FermatLastTheoremForThreeGen.Solution.Z S ^ 3 - 1 = \u03bb ^ 2 * Z\n\u22a2 \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) - \u21911 =\n    FermatLastTheoremForThreeGen.Solution.Y S ^ 3 +\n          \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) * FermatLastTheoremForThreeGen.Solution.Z S ^ 3 -\n        (FermatLastTheoremForThreeGen.Solution.Y S ^ 3 + 1) -\n      \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) * (FermatLastTheoremForThreeGen.Solution.Z S ^ 3 - 1)",["ring"]],["NumberTheory/FLT/Three.lean",692,"case hcong.intro.inr.inr.intro.intro\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : \u03bb ^ 2 \u2223 \u03bb ^ 4\nX : \ud835\udcde K\nhX :\n  \u2191(FermatLastTheoremForThreeGen.Solution.u\u2085 S) *\n      (\u03bb ^ (S.multiplicity - 1) * FermatLastTheoremForThreeGen.Solution.X S) ^ 3 =\n    \u03bb ^ 2 * X\nY : \ud835\udcde K\nhY : FermatLastTheoremForThreeGen.Solution.Y S ^ 3 + 1 = \u03bb ^ 2 * Y\nZ : \ud835\udcde K\nhZ : FermatLastTheoremForThreeGen.Solution.Z S ^ 3 + 1 = \u03bb ^ 2 * Z\n\u22a2 \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) - \u2191(-1) =\n    -(FermatLastTheoremForThreeGen.Solution.Y S ^ 3 +\n            \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) * FermatLastTheoremForThreeGen.Solution.Z S ^ 3 -\n          (FermatLastTheoremForThreeGen.Solution.Y S ^ 3 + 1) -\n        \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) * (FermatLastTheoremForThreeGen.Solution.Z S ^ 3 + 1))",["ring"]],["NumberTheory/FLT/Three.lean",701,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\n\u22a2 FermatLastTheoremForThreeGen.Solution.Y S ^ 3 +\n      (\u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) * FermatLastTheoremForThreeGen.Solution.Z S) ^ 3 =\n    FermatLastTheoremForThreeGen.Solution.Y S ^ 3 +\n      \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) ^ 2 * \u2191(FermatLastTheoremForThreeGen.Solution.u\u2084 S) *\n        FermatLastTheoremForThreeGen.Solution.Z S ^ 3",["ring"]],["Algebra/Lie/Basic.lean",227,"L : Type v\ninst\u271d : LieRing L\nx y z : L\n\u22a2 -(\u2045y, \u2045z, x\u2046\u2046 - \u2045z, \u2045y, x\u2046\u2046) + \u2045y, \u2045z, x\u2046\u2046 + -\u2045z, \u2045y, x\u2046\u2046 = 0",["abel"]],["Algebra/Lie/Basic.lean",240,"R : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nt : R\nx\u271d y z : L\nm\u271d n\u271d : M\nx : L\nf : M \u2192\u2097[R] N\nm n : M\n\u22a2 \u2045x, f m\u2046 + \u2045x, f n\u2046 - (f \u2045x, m\u2046 + f \u2045x, n\u2046) = \u2045x, f m\u2046 - f \u2045x, m\u2046 + (\u2045x, f n\u2046 - f \u2045x, n\u2046)",["abel"]],["Algebra/Lie/Basic.lean",246,"case h\nR : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nt : R\nx\u271d y\u271d z : L\nm n\u271d : M\nx y : L\nf : M \u2192\u2097[R] N\nn : M\n\u22a2 \u2045x, f n\u2046 + \u2045y, f n\u2046 - (f \u2045x, n\u2046 + f \u2045y, n\u2046) = \u2045x, f n\u2046 - f \u2045x, n\u2046 + (\u2045y, f n\u2046 - f \u2045y, n\u2046)",["abel"]],["Algebra/Lie/Basic.lean",250,"case h\nR : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nt : R\nx\u271d y z : L\nm n\u271d : M\nx : L\nf g : M \u2192\u2097[R] N\nn : M\n\u22a2 \u2045x, f n\u2046 + \u2045x, g n\u2046 - (f \u2045x, n\u2046 + g \u2045x, n\u2046) = \u2045x, f n\u2046 - f \u2045x, n\u2046 + (\u2045x, g n\u2046 - g \u2045x, n\u2046)",["abel"]],["Algebra/Lie/Basic.lean",255,"case h\nR : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nt : R\nx\u271d y\u271d z : L\nm n\u271d : M\nx y : L\nf : M \u2192\u2097[R] N\nn : M\n\u22a2 \u2045x, \u2045y, f n\u2046\u2046 - \u2045x, f \u2045y, n\u2046\u2046 - (\u2045y, f \u2045x, n\u2046\u2046 - f \u2045y, \u2045x, n\u2046\u2046) =\n    \u2045x, \u2045y, f n\u2046\u2046 - \u2045y, \u2045x, f n\u2046\u2046 - (f \u2045x, \u2045y, n\u2046\u2046 - f \u2045y, \u2045x, n\u2046\u2046) +\n      (\u2045y, \u2045x, f n\u2046\u2046 - \u2045y, f \u2045x, n\u2046\u2046 - (\u2045x, f \u2045y, n\u2046\u2046 - f \u2045x, \u2045y, n\u2046\u2046))",["abel"]],["Analysis/SpecialFunctions/Integrals.lean",362,"a b : \u211d\nr : \u2102\nhr : r + 1 \u2260 0\nhab : \u00ac0 \u2209 [[a, b]]\nh : -1 < r.re\nthis : \u2200 (c : \u211d), \u222b (x : \u211d) in 0 ..c, \u2191x ^ r = \u2191c ^ (r + 1) / (r + 1) - 0 ^ (r + 1) / (r + 1)\n\u22a2 -(\u2191a ^ (r + 1) / (r + 1) - 0 / (r + 1)) + (\u2191b ^ (r + 1) / (r + 1) - 0 / (r + 1)) =\n    \u2191b ^ (r + 1) / (r + 1) - \u2191a ^ (r + 1) / (r + 1)",["ring","abel"]],["Analysis/SpecialFunctions/Integrals.lean",502,"case inl\nb : \u211d\nh : b < 0\n\u22a2 -(-b * log b - -b) = b * log b - b",["ring","linarith"]],["Analysis/SpecialFunctions/Integrals.lean",510,"a b : \u211d\n\u22a2 -(a * log a - a) + (b * log b - b) = b * log b - a * log a - b + a",["ring","linarith","abel"]],["Analysis/SpecialFunctions/Integrals.lean",587,"case h.e'_9\na b : \u211d\nt : \u2102\nht : t \u2260 -1\nthis : t + 1 \u2260 0\nx : \u211d\na\u271d : x \u2208 [[a, b]]\nf : HasDerivAt (fun y \u21a6 1 + y ^ 2) (2 * \u2191x) \u2191x\nz : \u2102\nhz : 0 < z.re\n\u22a2 z ^ t * (2 * (t + 1)) = (t + 1) * z ^ t * 2",["ring"]],["Analysis/SpecialFunctions/Integrals.lean",589,"case h.e'_9\na b : \u211d\nt : \u2102\nht : t \u2260 -1\nthis : t + 1 \u2260 0\nx : \u211d\na\u271d : x \u2208 [[a, b]]\nf : HasDerivAt (fun y \u21a6 1 + y ^ 2) (2 * \u2191x) \u2191x\ng : \u2200 {z : \u2102}, 0 < z.re \u2192 HasDerivAt (fun z \u21a6 z ^ (t + 1) / (2 * (t + 1))) (z ^ t / 2) z\n\u22a2 \u2191x * (1 + \u2191x ^ 2) ^ t * 2 = (1 + \u2191x ^ 2) ^ t * (2 * \u2191x)",["ring"]],["Analysis/SpecialFunctions/Integrals.lean",629,"a b : \u211d\nn : \u2115\nC : \u211d := sin a ^ (n + 1) * cos a - sin b ^ (n + 1) * cos b\n\u03b1 \u03b2 \u03b3 : \u211d\n\u22a2 \u03b2 * \u03b1 * \u03b3 * \u03b1 = \u03b2 * (\u03b1 * \u03b1 * \u03b3)",["ring","linarith"]],["Analysis/SpecialFunctions/Integrals.lean",639,"a b : \u211d\nn : \u2115\nC : \u211d := sin a ^ (n + 1) * cos a - sin b ^ (n + 1) * cos b\nh : \u2200 (\u03b1 \u03b2 \u03b3 : \u211d), \u03b2 * \u03b1 * \u03b3 * \u03b1 = \u03b2 * (\u03b1 * \u03b1 * \u03b3)\nhu : \u2200 x \u2208 [[a, b]], HasDerivAt (fun y \u21a6 sin y ^ (n + 1)) (\u2191(n + 1) * cos x * sin x ^ n) x\nhv : \u2200 x \u2208 [[a, b]], HasDerivAt (-cos) (sin x) x\nH :\n  \u222b (x : \u211d) in a..b, sin x ^ (n + 1) * sin x =\n    sin b ^ (n + 1) * (-cos) b - sin a ^ (n + 1) * (-cos) a - \u222b (x : \u211d) in a..b, \u2191(n + 1) * cos x * sin x ^ n * (-cos) x\n\u22a2 -(sin b ^ (n + 1) * cos b) + sin a ^ (n + 1) * cos a = C",["ring"]],["Analysis/SpecialFunctions/Integrals.lean",654,"case h.e'_2\na b : \u211d\nn : \u2115\n\u22a2 (\u222b (x : \u211d) in a..b, sin x ^ (n + 2)) * (\u2191n + 2) =\n    (\u222b (x : \u211d) in a..b, sin x ^ (n + 2)) + (\u2191n + 1) * \u222b (x : \u211d) in a..b, sin x ^ (n + 2)",["ring","linarith"]],["Analysis/SpecialFunctions/Integrals.lean",696,"a b : \u211d\nn : \u2115\nC : \u211d := cos b ^ (n + 1) * sin b - cos a ^ (n + 1) * sin a\n\u03b1 \u03b2 \u03b3 : \u211d\n\u22a2 \u03b2 * \u03b1 * \u03b3 * \u03b1 = \u03b2 * (\u03b1 * \u03b1 * \u03b3)",["ring","linarith"]],["Analysis/SpecialFunctions/Integrals.lean",721,"case h.e'_2\na b : \u211d\nn : \u2115\n\u22a2 (\u222b (x : \u211d) in a..b, cos x ^ (n + 2)) * (\u2191n + 2) =\n    (\u222b (x : \u211d) in a..b, cos x ^ (n + 2)) + (\u2191n + 1) * \u222b (x : \u211d) in a..b, cos x ^ (n + 2)",["ring","linarith"]],["Analysis/SpecialFunctions/Integrals.lean",774,"case e_f.h\na b : \u211d\nm n : \u2115\nhc : Continuous fun u \u21a6 u ^ n * (1 - u ^ 2) ^ m\nx\u271d : \u211d\n\u22a2 (1 - cos x\u271d ^ 2) ^ m * -sin x\u271d * cos x\u271d ^ n = cos x\u271d ^ n * (1 - cos x\u271d ^ 2) ^ m * -sin x\u271d",["ring","linarith"]],["Analysis/SpecialFunctions/Integrals.lean",805,"a b c : \u211d\n\u22a2 (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4",["ring","linarith"]],["Analysis/SpecialFunctions/Integrals.lean",807,"a b : \u211d\nh1 : \u2200 (c : \u211d), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4\nh2 : Continuous fun x \u21a6 cos (2 * x) ^ 2\nx\u271d : \u211d\n\u22a2 cos x\u271d * sin x\u271d = 2 * sin x\u271d * cos x\u271d / 2",["ring","linarith"]],["Analysis/SpecialFunctions/Integrals.lean",808,"a b : \u211d\nh1 : \u2200 (c : \u211d), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4\nh2 : Continuous fun x \u21a6 cos (2 * x) ^ 2\nh3 : \u2200 (x : \u211d), cos x * sin x = sin (2 * x) / 2\nd : \u211d\n\u22a2 2 * (2 * d) = 4 * d",["ring","linarith"]],["Analysis/SpecialFunctions/Integrals.lean",810,"case h.e'_3\na b : \u211d\nh1 : \u2200 (c : \u211d), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4\nh2 : Continuous fun x \u21a6 cos (2 * x) ^ 2\nh3 : \u2200 (x : \u211d), cos x * sin x = sin (2 * x) / 2\nh4 : \u2200 (d : \u211d), 2 * (2 * d) = 4 * d\n\u22a2 (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =\n    (b - a - 2\u207b\u00b9 * ((sin (4 * b) / 2 - sin (4 * a) / 2 + 2 * b - 2 * a) / 2)) / 4",["ring","linarith","infer_instance"]],["Geometry/Euclidean/MongePoint.lean",117,"n : \u2115\n\u22a2 \u2191n + 2 + 1 + -2 = \u2191n + 1",["ring","linarith","abel"]],["Geometry/Euclidean/MongePoint.lean",149,"case h.e_6.h.h.circumcenterIndex\nV : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nn : \u2115\ns : Simplex \u211d P (n + 2)\nhn1 : \u2191n + 1 \u2260 0\n\u22a2 -1 + (-2 + -\u2191n) + (\u2191n + 1) = -2",["ring","linarith","abel"]],["Data/Nat/Digits.lean",159,"case e_f.h.h\nb : \u2115\nl : List \u2115\nx\u271d\u00b9 x\u271d : \u2115\n\u22a2 x\u271d\u00b9 * (b ^ x\u271d * b) = b * (x\u271d\u00b9 * b ^ x\u271d)",["ring","linarith"]],["Data/Nat/Digits.lean",188,"case cons\nb : \u2115\nl2 : List \u2115\nhd : \u2115\ntl : List \u2115\nIH : ofDigits b (tl ++ l2) = ofDigits b tl + b ^ tl.length * ofDigits b l2\n\u22a2 \u2191hd + b * (ofDigits b tl + b ^ tl.length * ofDigits b l2) = \u2191hd + b * ofDigits b tl + b * b ^ tl.length * ofDigits b l2",["ring","linarith"]],["Data/Nat/Digits.lean",340,"case cons\nn b hd : \u2115\ntl : List \u2115\nih : n * ofDigits b tl = ofDigits b (List.map (fun x \u21a6 n * x) tl)\n\u22a2 n * (hd + b * ofDigits b tl) = n * hd + b * (n * ofDigits b tl)",["ring","linarith"]],["Data/Nat/Digits.lean",458,"b k m n : \u2115\nhb : 1 < b\nhm : 0 < m\n\u22a2 b ^ (b.digits n).length * (b ^ k * m) = b ^ ((b.digits n).length + k) * m",["ring"]],["Data/Nat/Digits.lean",698,"a b : \u2115\nt : List \u2115\n\u22a2 \u2191a + -1 * (\u2191b + -1 * (List.map (fun n \u21a6 \u2191n) t).alternatingSum) = \u2191a + -\u2191b + (List.map (fun n \u21a6 \u2191n) t).alternatingSum",["ring","omega","linarith"]],["Algebra/Lie/Weights/Basic.lean",108,"case a.h.h\nR : Type u_2\nL : Type u_3\ninst\u271d\u00b9\u2074 : CommRing R\ninst\u271d\u00b9\u00b3 : LieRing L\ninst\u271d\u00b9\u00b2 : LieAlgebra R L\nM\u2081 : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\ninst\u271d\u00b9\u00b9 : AddCommGroup M\u2081\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : LieRingModule L M\u2081\ninst\u271d\u2078 : LieModule R L M\u2081\ninst\u271d\u2077 : AddCommGroup M\u2082\ninst\u271d\u2076 : Module R M\u2082\ninst\u271d\u2075 : LieRingModule L M\u2082\ninst\u271d\u2074 : LieModule R L M\u2082\ninst\u271d\u00b3 : AddCommGroup M\u2083\ninst\u271d\u00b2 : Module R M\u2083\ninst\u271d\u00b9 : LieRingModule L M\u2083\ninst\u271d : LieModule R L M\u2083\ng : M\u2081 \u2297[R] M\u2082 \u2192\u2097\u2045R,L\u2046 M\u2083\n\u03c7\u2081 \u03c7\u2082 : R\nx : L\nt : \u21a5\ud835\udd4e(M\u2081, \u03c7\u2081, x) \u2297[R] \u21a5\ud835\udd4e(M\u2082, \u03c7\u2082, x)\nF : Module.End R M\u2083 := (toEnd R L M\u2083) x - (\u03c7\u2081 + \u03c7\u2082) \u2022 1\nm\u2081\u271d : M\u2081\nhm\u2081 : m\u2081\u271d \u2208 \ud835\udd4e(M\u2081, \u03c7\u2081, x)\nm\u2082\u271d : M\u2082\nhm\u2082 : m\u2082\u271d \u2208 \ud835\udd4e(M\u2082, \u03c7\u2082, x)\nf\u2081 : Module.End R (M\u2081 \u2297[R] M\u2082) := LinearMap.rTensor M\u2082 ((toEnd R L M\u2081) x - \u03c7\u2081 \u2022 1)\nf\u2082 : Module.End R (M\u2081 \u2297[R] M\u2082) := LinearMap.lTensor M\u2081 ((toEnd R L M\u2082) x - \u03c7\u2082 \u2022 1)\nm\u2081 : M\u2081\nm\u2082 : M\u2082\n\u22a2 g (\u2045x, m\u2081\u2046 \u2297\u209c[R] m\u2082) + g (m\u2081 \u2297\u209c[R] \u2045x, m\u2082\u2046) - (\u03c7\u2081 \u2022 g (m\u2081 \u2297\u209c[R] m\u2082) + \u03c7\u2082 \u2022 g (m\u2081 \u2297\u209c[R] m\u2082)) =\n    g (\u2045x, m\u2081\u2046 \u2297\u209c[R] m\u2082) - \u03c7\u2081 \u2022 g (m\u2081 \u2297\u209c[R] m\u2082) + (g (m\u2081 \u2297\u209c[R] \u2045x, m\u2082\u2046) - \u03c7\u2082 \u2022 g (m\u2081 \u2297\u209c[R] m\u2082))",["abel"]],["Analysis/Normed/Ring/Basic.lean",449,"\u03b1 : Type u_2\ninst\u271d : SeminormedRing \u03b1\na b : \u03b1\u02e3\n\u22a2 (\u2016\u2191a - 1\u2016 * \u2016\u2191b - 1\u2016 + \u2016\u2191b - 1\u2016 * \u2016\u2191a - 1\u2016) * \u2016\u2191a\u207b\u00b9\u2016 * \u2016\u2191b\u207b\u00b9\u2016 = 2 * \u2016\u2191a\u207b\u00b9\u2016 * \u2016\u2191b\u207b\u00b9\u2016 * \u2016\u2191a - 1\u2016 * \u2016\u2191b - 1\u2016",["ring","linarith"]],["Analysis/Analytic/Inverse.lean",383,"case a.a\nn : \u2115\np : \u2115 \u2192 \u211d\nhp : \u2200 (k : \u2115), 0 \u2264 p k\nr a : \u211d\nhr : 0 \u2264 r\nha : 0 \u2264 a\nk : \u2115\na\u271d\u00b9 : k \u2208 Ico 2 (n + 1)\nc : Composition k\na\u271d : c \u2208 {c | 1 < c.length}.toFinset\n\u22a2 a ^ k * (r ^ c.length * \u220f j : Fin c.length, p (c.blocksFun j)) =\n    r ^ c.length * (a ^ k * \u220f x : Fin c.length, p (c.blocksFun x))",["ring","linarith"]],["Analysis/Analytic/Inverse.lean",469,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nx : E\nn : \u2115\nhn : 2 \u2264 n + 1\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nr a C : \u211d\nhr : 0 \u2264 r\nha : 0 \u2264 a\nhC : 0 \u2264 C\nhp : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\n\u22a2 \u2016\u2191i.symm\u2016 * a +\n      \u2016\u2191i.symm\u2016 *\n        (C *\n          \u2211 i_1 \u2208 Ico 2 (n + 1),\n            a ^ i_1 *\n              \u2211 i_2 \u2208 {c | 1 < c.length}.toFinset,\n                r ^ i_2.length * \u220f j : Fin i_2.length, \u2016p.rightInv i x (i_2.blocksFun j)\u2016) =\n    \u2016\u2191i.symm\u2016 * a +\n      C *\n        (\u2016\u2191i.symm\u2016 *\n          \u2211 k \u2208 Ico 2 (n + 1),\n            a ^ k *\n              \u2211 c \u2208 {c | 1 < c.length}.toFinset, r ^ c.length * \u220f j : Fin c.length, \u2016p.rightInv i x (c.blocksFun j)\u2016)",["ring","linarith"]],["Analysis/Analytic/Inverse.lean",530,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nhp : 0 < p.radius\nC r : \u211d\nCpos : 0 < C\nrpos : 0 < r\nple : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\na : \u211d\napos : 0 < a\nha1 : 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a \u2264 1\nha2 : r * (I + 1) * a \u2264 1 / 2\nS : \u2115 \u2192 \u211d := fun n \u21a6 \u2211 k \u2208 Ico 1 n, a ^ k * \u2016p.rightInv i x k\u2016\nn : \u2115\none_le_n : 1 \u2264 n\nhn : S n \u2264 (I + 1) * a\nIn : 2 \u2264 n + 1\nrSn : r * S n \u2264 1 / 2\n\u22a2 I * a + I * C * ((r * S n) ^ 2 / (1 / 2)) = I * a + 2 * I * C * (r * S n) ^ 2",["ring","linarith"]],["Analysis/Analytic/Inverse.lean",532,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nhp : 0 < p.radius\nC r : \u211d\nCpos : 0 < C\nrpos : 0 < r\nple : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\na : \u211d\napos : 0 < a\nha1 : 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a \u2264 1\nha2 : r * (I + 1) * a \u2264 1 / 2\nS : \u2115 \u2192 \u211d := fun n \u21a6 \u2211 k \u2208 Ico 1 n, a ^ k * \u2016p.rightInv i x k\u2016\nn : \u2115\none_le_n : 1 \u2264 n\nhn : S n \u2264 (I + 1) * a\nIn : 2 \u2264 n + 1\nrSn : r * S n \u2264 1 / 2\n\u22a2 I * a + 2 * I * C * (r * ((I + 1) * a)) ^ 2 = (I + 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a) * a",["ring","linarith"]],["Analysis/Calculus/ContDiff/Bounds.lean",325,"\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ns : Set E\n\u03b9 : Type u_2\nA' : Type u_4\ninst\u271d\u00b3 : NormedCommRing A'\ninst\u271d\u00b2 : NormedAlgebra \ud835\udd5c A'\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : NormOneClass A'\nf : \u03b9 \u2192 E \u2192 A'\nN : WithTop \u2115\u221e\nhs : UniqueDiffOn \ud835\udd5c s\nx : E\nhx : x \u2208 s\ni : \u03b9\nu : Finset \u03b9\nhi : i \u2209 u\nn : \u2115\nhn : \u2191n \u2264 N\nhf : ContDiffOn \ud835\udd5c N (f i) s \u2227 \u2200 a \u2208 u, ContDiffOn \ud835\udd5c N (f a) s\nm : Fin (n + 1)\na\u271d : m \u2208 Finset.univ\nIH :\n  \u2016iteratedFDerivWithin \ud835\udd5c (n - \u2191m) (fun x \u21a6 \u220f j \u2208 u, f j x) s x\u2016 \u2264\n    \u2211 p \u2208 u.sym (n - \u2191m), \u2191(\u2191p).multinomial * \u220f j \u2208 u, \u2016iteratedFDerivWithin \ud835\udd5c (Multiset.count j \u2191p) (f j) s x\u2016\np : Sym \u03b9 (n - \u2191m)\nhp : \u2200 a \u2208 p, a \u2208 u\nhip : i \u2209 p\nthis :\n  \u220f j \u2208 u, \u2016iteratedFDerivWithin \ud835\udd5c (Multiset.count j \u2191p) (f j) s x\u2016 =\n    \u220f j \u2208 u, \u2016iteratedFDerivWithin \ud835\udd5c (Multiset.count j \u2191(Sym.fill i m p)) (f j) s x\u2016\n\u22a2 \u2191(n.choose \u2191m) * \u2016iteratedFDerivWithin \ud835\udd5c (\u2191m) (f i) s x\u2016 *\n      (\u2191(\u2191p).multinomial * \u220f j \u2208 u, \u2016iteratedFDerivWithin \ud835\udd5c (Multiset.count j \u2191(Sym.fill i m p)) (f j) s x\u2016) =\n    \u2191(n.choose \u2191m) * \u2191(\u2191p).multinomial *\n      (\u2016iteratedFDerivWithin \ud835\udd5c (\u2191m) (f i) s x\u2016 *\n        \u220f x_1 \u2208 u, \u2016iteratedFDerivWithin \ud835\udd5c (Multiset.count x_1 \u2191(Sym.fill i m p)) (f x_1) s x\u2016)",["ring","linarith"]],["Analysis/Calculus/ContDiff/Bounds.lean",440,"case a\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nFu : Type u\ninst\u271d\u00b3 : NormedAddCommGroup Fu\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c Fu\nf : E \u2192 Fu\ns : Set E\nt : Set Fu\nx : E\nht : UniqueDiffOn \ud835\udd5c t\nhs : UniqueDiffOn \ud835\udd5c s\nhst : MapsTo f s t\nhx : x \u2208 s\nC D : \u211d\nn : \u2115\nIH :\n  \u2200 m \u2264 n,\n    \u2200 {Gu : Type u} [inst : NormedAddCommGroup Gu] [inst_1 : NormedSpace \ud835\udd5c Gu] {g : Fu \u2192 Gu},\n      ContDiffOn \ud835\udd5c (\u2191m) g t \u2192\n        ContDiffOn \ud835\udd5c (\u2191m) f s \u2192\n          (\u2200 i \u2264 m, \u2016iteratedFDerivWithin \ud835\udd5c i g t (f x)\u2016 \u2264 C) \u2192\n            (\u2200 (i : \u2115), 1 \u2264 i \u2192 i \u2264 m \u2192 \u2016iteratedFDerivWithin \ud835\udd5c i f s x\u2016 \u2264 D ^ i) \u2192\n              \u2016iteratedFDerivWithin \ud835\udd5c m (g \u2218 f) s x\u2016 \u2264 \u2191m ! * C * D ^ m\nGu : Type u\ninst\u271d\u00b9 : NormedAddCommGroup Gu\ninst\u271d : NormedSpace \ud835\udd5c Gu\ng : Fu \u2192 Gu\nhg : ContDiffOn \ud835\udd5c (\u2191(n + 1)) g t\nhf : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nhC : \u2200 i \u2264 n + 1, \u2016iteratedFDerivWithin \ud835\udd5c i g t (f x)\u2016 \u2264 C\nhD : \u2200 (i : \u2115), 1 \u2264 i \u2192 i \u2264 n + 1 \u2192 \u2016iteratedFDerivWithin \ud835\udd5c i f s x\u2016 \u2264 D ^ i\nM : \u2191n < \u2191n.succ\nCnonneg : 0 \u2264 C\nDnonneg : 0 \u2264 D\nI : \u2200 i \u2208 Finset.range (n + 1), \u2016iteratedFDerivWithin \ud835\udd5c i (fderivWithin \ud835\udd5c g t \u2218 f) s x\u2016 \u2264 \u2191i ! * C * D ^ i\nJ : \u2200 (i : \u2115), \u2016iteratedFDerivWithin \ud835\udd5c (n - i) (fderivWithin \ud835\udd5c f s) s x\u2016 \u2264 D ^ (n - i + 1)\ni : \u2115\nhi : i \u2208 Finset.range (n + 1)\n\u22a2 (\u2191i !)\u207b\u00b9 * (\u2191(n - i)!)\u207b\u00b9 * \u2191n ! * (\u2191i ! * C * D ^ i) * D ^ (n - i + 1) =\n    \u2191n ! * ((\u2191i !)\u207b\u00b9 * \u2191i !) * C * (D ^ i * D ^ (n - i + 1)) * (\u2191(n - i)!)\u207b\u00b9",["ring","linarith"]],["NumberTheory/Zsqrtd/Basic.lean",180,"case refine_1.re\nd : \u2124\na\u271d b\u271d : \u2124\u221ad\n\u22a2 a\u271d.re + b\u271d.re = b\u271d.re + a\u271d.re\n```\n---\n```lean\ncase refine_1.im\nd : \u2124\na\u271d b\u271d : \u2124\u221ad\n\u22a2 a\u271d.im + b\u271d.im = b\u271d.im + a\u271d.im\n```\n---\n```lean\ncase refine_2.re\nd : \u2124\na\u271d b\u271d c\u271d : \u2124\u221ad\n\u22a2 a\u271d.re * (b\u271d.re + c\u271d.re) + d * a\u271d.im * (b\u271d.im + c\u271d.im) =\n    a\u271d.re * b\u271d.re + d * a\u271d.im * b\u271d.im + (a\u271d.re * c\u271d.re + d * a\u271d.im * c\u271d.im)\n```\n---\n```lean\ncase refine_2.im\nd : \u2124\na\u271d b\u271d c\u271d : \u2124\u221ad\n\u22a2 a\u271d.re * (b\u271d.im + c\u271d.im) + a\u271d.im * (b\u271d.re + c\u271d.re) = a\u271d.re * b\u271d.im + a\u271d.im * b\u271d.re + (a\u271d.re * c\u271d.im + a\u271d.im * c\u271d.re)\n```\n---\n```lean\ncase refine_3.re\nd : \u2124\na\u271d b\u271d c\u271d : \u2124\u221ad\n\u22a2 (a\u271d.re + b\u271d.re) * c\u271d.re + d * (a\u271d.im + b\u271d.im) * c\u271d.im =\n    a\u271d.re * c\u271d.re + d * a\u271d.im * c\u271d.im + (b\u271d.re * c\u271d.re + d * b\u271d.im * c\u271d.im)\n```\n---\n```lean\ncase refine_3.im\nd : \u2124\na\u271d b\u271d c\u271d : \u2124\u221ad\n\u22a2 (a\u271d.re + b\u271d.re) * c\u271d.im + (a\u271d.im + b\u271d.im) * c\u271d.re = a\u271d.re * c\u271d.im + a\u271d.im * c\u271d.re + (b\u271d.re * c\u271d.im + b\u271d.im * c\u271d.re)\n```\n---\n```lean\ncase refine_6.re\nd : \u2124\na\u271d b\u271d c\u271d : \u2124\u221ad\n\u22a2 (a\u271d.re * b\u271d.re + d * a\u271d.im * b\u271d.im) * c\u271d.re + d * (a\u271d.re * b\u271d.im + a\u271d.im * b\u271d.re) * c\u271d.im =\n    a\u271d.re * (b\u271d.re * c\u271d.re + d * b\u271d.im * c\u271d.im) + d * a\u271d.im * (b\u271d.re * c\u271d.im + b\u271d.im * c\u271d.re)\n```\n---\n```lean\ncase refine_6.im\nd : \u2124\na\u271d b\u271d c\u271d : \u2124\u221ad\n\u22a2 (a\u271d.re * b\u271d.re + d * a\u271d.im * b\u271d.im) * c\u271d.im + (a\u271d.re * b\u271d.im + a\u271d.im * b\u271d.re) * c\u271d.re =\n    a\u271d.re * (b\u271d.re * c\u271d.im + b\u271d.im * c\u271d.re) + a\u271d.im * (b\u271d.re * c\u271d.re + d * b\u271d.im * c\u271d.im)\n```\n---\n```lean\ncase refine_9.re\nd : \u2124\na\u271d b\u271d : \u2124\u221ad\n\u22a2 a\u271d.re * b\u271d.re + d * a\u271d.im * b\u271d.im = b\u271d.re * a\u271d.re + d * b\u271d.im * a\u271d.im\n```\n---\n```lean\ncase refine_9.im\nd : \u2124\na\u271d b\u271d : \u2124\u221ad\n\u22a2 a\u271d.re * b\u271d.im + a\u271d.im * b\u271d.re = b\u271d.re * a\u271d.im + b\u271d.im * a\u271d.re",["ring","linarith"]],["NumberTheory/Zsqrtd/Basic.lean",389,"case h.e'_4\nd x y z w : \u2115\nxy : SqLe x 1 y d\nzw : SqLe z 1 w d\nthis : 0 \u2264 (\u2191(d * y * y) - \u2191(1 * x * x)) * (\u2191(d * w * w) - \u2191(1 * z * z))\n\u22a2 (\u2191x * \u2191z + \u2191d * \u2191y * \u2191w) * (\u2191x * \u2191z + \u2191d * \u2191y * \u2191w) - \u2191d * (\u2191x * \u2191w + \u2191y * \u2191z) * (\u2191x * \u2191w + \u2191y * \u2191z) =\n    (\u2191d * \u2191y * \u2191y - \u2191x * \u2191x) * (\u2191d * \u2191w * \u2191w - \u2191z * \u2191z)\n```\n---\n```lean\ncase h.e'_4\nd x y z w : \u2115\nxy : SqLe x 1 y d\nzw : SqLe w d z 1\nthis : 0 \u2264 (\u2191(d * y * y) - \u2191(1 * x * x)) * (\u2191(1 * z * z) - \u2191(d * w * w))\n\u22a2 \u2191d * (\u2191x * \u2191w + \u2191y * \u2191z) * (\u2191x * \u2191w + \u2191y * \u2191z) - (\u2191x * \u2191z + \u2191d * \u2191y * \u2191w) * (\u2191x * \u2191z + \u2191d * \u2191y * \u2191w) =\n    (\u2191d * \u2191y * \u2191y - \u2191x * \u2191x) * (\u2191z * \u2191z - \u2191d * \u2191w * \u2191w)\n```\n---\n```lean\ncase h.e'_4\nd x y z w : \u2115\nxy : SqLe y d x 1\nzw : SqLe z 1 w d\nthis : 0 \u2264 (\u2191(1 * x * x) - \u2191(d * y * y)) * (\u2191(d * w * w) - \u2191(1 * z * z))\n\u22a2 \u2191d * (\u2191x * \u2191w + \u2191y * \u2191z) * (\u2191x * \u2191w + \u2191y * \u2191z) - (\u2191x * \u2191z + \u2191d * \u2191y * \u2191w) * (\u2191x * \u2191z + \u2191d * \u2191y * \u2191w) =\n    (\u2191x * \u2191x - \u2191d * \u2191y * \u2191y) * (\u2191d * \u2191w * \u2191w - \u2191z * \u2191z)\n```\n---\n```lean\ncase h.e'_4\nd x y z w : \u2115\nxy : SqLe y d x 1\nzw : SqLe w d z 1\nthis : 0 \u2264 (\u2191(1 * x * x) - \u2191(d * y * y)) * (\u2191(1 * z * z) - \u2191(d * w * w))\n\u22a2 (\u2191x * \u2191z + \u2191d * \u2191y * \u2191w) * (\u2191x * \u2191z + \u2191d * \u2191y * \u2191w) - \u2191d * (\u2191x * \u2191w + \u2191y * \u2191z) * (\u2191x * \u2191w + \u2191y * \u2191z) =\n    (\u2191x * \u2191x - \u2191d * \u2191y * \u2191y) * (\u2191z * \u2191z - \u2191d * \u2191w * \u2191w)",["ring","linarith"]],["NumberTheory/Zsqrtd/Basic.lean",445,"d : \u2124\nn m : \u2124\u221ad\n\u22a2 (n.re * m.re + d * n.im * m.im) * (n.re * m.re + d * n.im * m.im) -\n      d * (n.re * m.im + n.im * m.re) * (n.re * m.im + n.im * m.re) =\n    (n.re * n.re - d * n.im * n.im) * (m.re * m.re - d * m.im * m.im)",["ring","linarith"]],["NumberTheory/Zsqrtd/Basic.lean",755,"d : \u2115\ndnsq : Nonsquare d\nx y : \u2115\ng : \u2115 := x.gcd y\ngpos : g > 0\nm n : \u2115\nh : m * g * (m * g) = d * (n * g) * (n * g)\nco : m.Coprime n\nhx : x = m * g\nhy : y = n * g\n\u22a2 g * g * (m * m) = m * g * (m * g)",["ring","linarith"]],["NumberTheory/Zsqrtd/Basic.lean",757,"d : \u2115\ndnsq : Nonsquare d\nx y : \u2115\ng : \u2115 := x.gcd y\ngpos : g > 0\nm n : \u2115\nh : m * g * (m * g) = d * (n * g) * (n * g)\nco : m.Coprime n\nhx : x = m * g\nhy : y = n * g\n\u22a2 d * (n * g) * (n * g) = g * g * (d * (n * n))",["ring"]],["NumberTheory/Zsqrtd/Basic.lean",891,"R : Type\ninst\u271d : CommRing R\nd : \u2124\nr : { r // r * r = \u2191d }\na b : \u2124\u221ad\n\u22a2 \u2191a.re + \u2191b.re + (\u2191a.im + \u2191b.im) * \u2191r = \u2191a.re + \u2191a.im * \u2191r + (\u2191b.re + \u2191b.im * \u2191r)",["ring"]],["NumberTheory/Zsqrtd/Basic.lean",897,"R : Type\ninst\u271d : CommRing R\nd : \u2124\nr : { r // r * r = \u2191d }\na b : \u2124\u221ad\n\u22a2 (\u2191a.re + \u2191a.im * \u2191r) * (\u2191b.re + \u2191b.im * \u2191r) =\n    \u2191a.re * \u2191b.re + (\u2191a.re * \u2191b.im + \u2191a.im * \u2191b.re) * \u2191r + \u2191a.im * \u2191b.im * (\u2191r * \u2191r)",["ring"]],["Data/Complex/Trigonometric.lean",858,"x : \u211d\nhx : |x| \u2264 1\n\u22a2 1 * (5 / 96) + 1 / 2 < 1",["norm_num","linarith"]],["Data/Complex/Trigonometric.lean",891,"\u22a2 |1| ^ 4 * (5 / 96) + (1 - 1 ^ 2 / 2) \u2264 5 / 9",["norm_num"]],["Data/Complex/Trigonometric.lean",903,"\u22a2 2 * (5 / 9) ^ 2 - 1 < 0",["norm_num","linarith"]],["Data/Complex/Trigonometric.lean",122,"a b c d : \u2102\n\u22a2 (a - b) * (c + d) + (a + b) * (c - d) = 2 * (a * c - b * d)",["ring"]],["Data/Complex/Trigonometric.lean",137,"a b c d : \u2102\n\u22a2 (a + b) * (c + d) + (a - b) * (c - d) = 2 * (a * c + b * d)",["ring"]],["Data/Complex/Trigonometric.lean",239,"x : \u2102\n\u22a2 cosh x ^ 2 = sinh x ^ 2 + (cosh x ^ 2 - sinh x ^ 2)",["ring","abel"]],["Data/Complex/Trigonometric.lean",243,"x : \u2102\n\u22a2 sinh x ^ 2 = cosh x ^ 2 - (cosh x ^ 2 - sinh x ^ 2)",["ring","abel"]],["Data/Complex/Trigonometric.lean",249,"x : \u2102\n\u22a2 sinh x * cosh x + cosh x * sinh x = 2 * sinh x * cosh x",["ring"]],["Data/Complex/Trigonometric.lean",252,"x : \u2102\n\u22a2 x + 2 * x = 3 * x",["ring"]],["Data/Complex/Trigonometric.lean",255,"x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 sinh x * (2 * sinh x * cosh x) = 2 * cosh x * sinh x ^ 2",["ring"]],["Data/Complex/Trigonometric.lean",257,"x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : sinh x * (2 * sinh x * cosh x) = 2 * cosh x * sinh x ^ 2\n\u22a2 cosh x * (cosh x ^ 2 + (cosh x ^ 2 - 1)) + 2 * cosh x * (cosh x ^ 2 - 1) = 4 * cosh x ^ 3 - 3 * cosh x",["ring"]],["Data/Complex/Trigonometric.lean",260,"x : \u2102\n\u22a2 x + 2 * x = 3 * x",["ring"]],["Data/Complex/Trigonometric.lean",263,"x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 cosh x * (2 * sinh x * cosh x) = 2 * sinh x * cosh x ^ 2",["ring"]],["Data/Complex/Trigonometric.lean",265,"x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : cosh x * (2 * sinh x * cosh x) = 2 * sinh x * cosh x ^ 2\n\u22a2 sinh x * (sinh x ^ 2 + 1 + sinh x ^ 2) + 2 * sinh x * (sinh x ^ 2 + 1) = 4 * sinh x ^ 3 + 3 * sinh x",["ring"]],["Data/Complex/Trigonometric.lean",341,"x y : \u2102\ns1 : sin x = sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2)\ns2 : sin y = sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 sin ((x + y) / 2) * cos ((x - y) / 2) + cos ((x + y) / 2) * sin ((x - y) / 2) -\n      (sin ((x + y) / 2) * cos ((x - y) / 2) - cos ((x + y) / 2) * sin ((x - y) / 2)) =\n    2 * sin ((x - y) / 2) * cos ((x + y) / 2)",["ring"]],["Data/Complex/Trigonometric.lean",349,"x y : \u2102\ns1 : cos x = cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)\ns2 : cos y = cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)\n\u22a2 cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) -\n      (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) =\n    -2 * sin ((x + y) / 2) * sin ((x - y) / 2)",["ring"]],["Data/Complex/Trigonometric.lean",365,"case calc_3\nx y : \u2102\n\u22a2 cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2) +\n      (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) =\n    2 * cos ((x + y) / 2) * cos ((x - y) / 2)",["ring"]],["Data/Complex/Trigonometric.lean",482,"x : \u2102\n\u22a2 x + 2 * x = 3 * x",["ring"]],["Data/Complex/Trigonometric.lean",485,"x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2",["ring"]],["Data/Complex/Trigonometric.lean",487,"x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2\n\u22a2 cos x * (2 * (cos x * cos x)) - cos x - sin x * (2 * sin x * cos x) =\n    2 * cos x * cos x * cos x + 2 * cos x * (1 - sin x ^ 2) - 3 * cos x",["ring"]],["Data/Complex/Trigonometric.lean",490,"x : \u2102\n\u22a2 x + 2 * x = 3 * x",["ring"]],["Data/Complex/Trigonometric.lean",493,"x : \u2102\nh1 : x + 2 * x = 3 * x\n\u22a2 cos x * (2 * sin x * cos x) = 2 * sin x * cos x ^ 2",["ring"]],["Data/Complex/Trigonometric.lean",495,"x : \u2102\nh1 : x + 2 * x = 3 * x\nh2 : cos x * (2 * sin x * cos x) = 2 * sin x * cos x ^ 2\n\u22a2 sin x * (2 * (1 - sin x ^ 2) - 1) + 2 * sin x * (1 - sin x ^ 2) = 3 * sin x - 4 * sin x ^ 3",["ring"]],["Data/Complex/Trigonometric.lean",573,"x y : \u211d\n\u22a2 2 * sin x * sin y = sin x * sin y + sin x * sin y",["ring","linarith"]],["Data/Complex/Trigonometric.lean",577,"x y : \u211d\n\u22a2 2 * cos x * cos y = cos x * cos y + cos x * cos y",["ring","linarith"]],["Data/Complex/Trigonometric.lean",581,"x y : \u211d\n\u22a2 2 * sin x * cos y = sin x * cos y + sin x * cos y",["ring","linarith"]],["MeasureTheory/Integral/CircleIntegral.lean",447,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR C : \u211d\nhR : 0 < R\nhc : ContinuousOn f (sphere c R)\nhf : \u2200 z \u2208 sphere c R, \u2016f z\u2016 \u2264 C\n\u03b8\u2080 : \u211d\nhmem : \u03b8\u2080 \u2208 Ioc 0 (2 * \u03c0)\nhlt : \u2016f (circleMap c R \u03b8\u2080)\u2016 < C\n\u22a2 R * (2 * (\u03c0 * C)) = 2 * (\u03c0 * (R * C))",["ring","linarith"]],["Analysis/SpecialFunctions/Pow/Deriv.lean",656,"t : \u211d\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["Analysis/SpecialFunctions/Pow/Deriv.lean",249,"case h.e'_9\nx : \u211d\nhx\u271d : x \u2260 0\nr : \u2102\nhr : r + 1 \u2260 0\nhx : 0 > x\nthis\u271d : \u2200\u1da0 (y : \u211d) in \ud835\udcdd x, \u2191y ^ (r + 1) / (r + 1) = (-\u2191y) ^ (r + 1) * cexp (\u2191\u03c0 * I * (r + 1)) / (r + 1)\nthis : HasDerivAt (fun y \u21a6 \u2191(-y) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x\n\u22a2 (r + 1) * \u2191(-x) ^ r * cexp (\u2191\u03c0 * I * r) = -(-(r + 1) * \u2191(-x) ^ r) * cexp (\u2191\u03c0 * I * r)",["ring"]],["Analysis/SpecialFunctions/Pow/Deriv.lean",252,"case h.e'_9\nx : \u211d\nhx\u271d : x \u2260 0\nr : \u2102\nhr : r + 1 \u2260 0\nhx : 0 > x\nthis\u271d : \u2200\u1da0 (y : \u211d) in \ud835\udcdd x, \u2191y ^ (r + 1) / (r + 1) = (-\u2191y) ^ (r + 1) * cexp (\u2191\u03c0 * I * (r + 1)) / (r + 1)\nthis : HasDerivAt (fun y \u21a6 \u2191y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x)\n\u22a2 -(r + 1) * \u2191(-x) ^ r = -1 * ((r + 1) * \u2191(-x) ^ r)",["ring"]],["Analysis/SpecialFunctions/Pow/Deriv.lean",593,"case h.e'_9\nf g : \u211d \u2192 \u211d\nf' g' x : \u211d\ns : Set \u211d\nhf : HasDerivWithinAt f f' s x\nhg : HasDerivWithinAt g g' s x\nh : 0 < f x\n\u22a2 f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x) =\n    g x * f x ^ (g x - 1) * (1 * f') + f x ^ g x * Real.log (f x) * (1 * g')",["ring","linarith"]],["Analysis/SpecialFunctions/Pow/Deriv.lean",604,"case h.e'_9\nf : \u211d \u2192 \u211d\nf' x p : \u211d\ns : Set \u211d\nhf : HasDerivWithinAt f f' s x\nhx : f x \u2260 0 \u2228 1 \u2264 p\n\u22a2 f' * p * f x ^ (p - 1) = p * f x ^ (p - 1) * f'",["ring","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",440,"case pos.h\nC : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Linear R C\nF G K L : CochainComplex C \u2124\nn m : \u2124\n\u03b1 \u03b2 : Cochain F G n\nh : n + 1 = m\np q : \u2124\nhpq : p + m = q\n\u22a2 \u03b1.v p (q - 1) \u22ef \u226b G.d (q - 1) q + \u03b2.v p (q - 1) \u22ef \u226b G.d (q - 1) q +\n      (m.negOnePow \u2022 F.d p (p + 1) \u226b \u03b1.v (p + 1) q \u22ef + m.negOnePow \u2022 F.d p (p + 1) \u226b \u03b2.v (p + 1) q \u22ef) =\n    \u03b1.v p (q - 1) \u22ef \u226b G.d (q - 1) q + m.negOnePow \u2022 F.d p (p + 1) \u226b \u03b1.v (p + 1) q \u22ef +\n      (\u03b2.v p (q - 1) \u22ef \u226b G.d (q - 1) q + m.negOnePow \u2022 F.d p (p + 1) \u226b \u03b2.v (p + 1) q \u22ef)",["abel"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",504,"case h\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G K : CochainComplex C \u2124\nn\u2081 n\u2082 : \u2124\nz\u2081 : Cochain F G n\u2081\nz\u2082 : Cochain G K n\u2082\np q : \u2124\nhpq : p + (n\u2081 + n\u2082 + 1) = q\n\u22a2 z\u2081.v p (p + n\u2081) \u22ef \u226b z\u2082.v (p + n\u2081) (p + n\u2081 + n\u2082) \u22ef \u226b K.d (p + n\u2081 + n\u2082) q +\n      -((n\u2082.negOnePow * n\u2081.negOnePow) \u2022 F.d p (p + 1) \u226b z\u2081.v (p + 1) (p + n\u2081 + 1) \u22ef \u226b z\u2082.v (p + n\u2081 + 1) q \u22ef) =\n    z\u2081.v p (p + n\u2081) \u22ef \u226b z\u2082.v (p + n\u2081) (p + n\u2081 + n\u2082) \u22ef \u226b K.d (p + n\u2081 + n\u2082) q +\n        -(n\u2082.negOnePow \u2022 z\u2081.v p (p + n\u2081) \u22ef \u226b G.d (p + n\u2081) (p + n\u2081 + 1) \u226b z\u2082.v (p + n\u2081 + 1) q \u22ef) +\n      (n\u2082.negOnePow \u2022 z\u2081.v p (p + n\u2081) \u22ef \u226b G.d (p + n\u2081) (p + n\u2081 + 1) \u226b z\u2082.v (p + n\u2081 + 1) q \u22ef +\n        -((n\u2082.negOnePow * n\u2081.negOnePow) \u2022 F.d p (p + 1) \u226b z\u2081.v (p + 1) (p + n\u2081 + 1) \u22ef \u226b z\u2082.v (p + n\u2081 + 1) q \u22ef))",["abel"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",545,"case h\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6\u2081 \u03c6\u2082 : F \u27f6 G\nh : Homotopy \u03c6\u2081 \u03c6\u2082\np : \u2124\neq : \u03c6\u2081.f p = F.d p (p + 1) \u226b h.hom (p + 1) p + h.hom p (p - 1) \u226b G.d (p - 1) p + \u03c6\u2082.f p\n\u22a2 h.hom p (p - 1) \u226b G.d (p - 1) p + F.d p (p + 1) \u226b h.hom (p + 1) p =\n    F.d p (p + 1) \u226b h.hom (p + 1) p + h.hom p (p - 1) \u226b G.d (p - 1) p + \u03c6\u2082.f p - \u03c6\u2082.f p",["abel"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",555,"case h\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\nz : Cochain F G (-1)\np : \u2124\n\u22a2 z.v p (p - 1) \u22ef \u226b G.d (p - 1) p + F.d p (p + 1) \u226b z.v (p + 1) p \u22ef =\n    F.d p (p + 1) \u226b z.v (p + 1) p \u22ef + z.v p (p - 1) \u22ef \u226b G.d (p - 1) p",["abel"]],["NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean",106,"K : Type u_1\ninst\u271d\u00b9 : Field K\nf : InfinitePlace K \u2192 \u211d\u22650\ninst\u271d : NumberField K\n\u22a2 (\u21912 ^ nrRealPlaces K * \u220f x : { w // w.IsReal }, ENNReal.ofReal \u2191(f \u2191x)) *\n      ((\u220f x : { w // w.IsComplex }, ENNReal.ofReal \u2191(f \u2191x) ^ 2) * \u2191pi ^ nrComplexPlaces K) =\n    \u21912 ^ nrRealPlaces K * \u2191pi ^ nrComplexPlaces K *\n      ((\u220f x : { w // w.IsReal }, ENNReal.ofReal \u2191(f \u2191x)) * \u220f x : { w // w.IsComplex }, ENNReal.ofReal \u2191(f \u2191x) ^ 2)",["ring"]],["NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean",237,"K : Type u_1\ninst\u271d\u00b9 : Field K\nf : InfinitePlace K \u2192 \u211d\u22650\nw\u2080 : { w // w.IsComplex }\ninst\u271d : NumberField K\nvol_box : \u2200 (B : \u211d\u22650), volume {x | |x.re| < 1 \u2227 |x.im| < \u2191B ^ 2} = 4 * \u2191B ^ 2\n\u22a2 (\u21912 ^ nrRealPlaces K * \u220f x : { w // w.IsReal }, ENNReal.ofReal \u2191(f \u2191x)) *\n      ((\u220f x \u2208 Finset.univ.erase w\u2080, ENNReal.ofReal \u2191(f \u2191x) ^ 2) * \u2191pi ^ (nrComplexPlaces K - 1) *\n        (\u21912 ^ 2 * \u2191(f \u2191w\u2080) ^ 2)) =\n    (\u21912 ^ nrRealPlaces K * \u21912 ^ 2 * \u2191pi ^ (nrComplexPlaces K - 1) * \u220f x : { w // w.IsReal }, ENNReal.ofReal \u2191(f \u2191x)) *\n      ((\u220f x \u2208 Finset.univ.erase w\u2080, ENNReal.ofReal \u2191(f \u2191x) ^ 2) * \u2191(f \u2191w\u2080) ^ 2)",["ring"]],["Analysis/Calculus/FDeriv/Symmetric.lean",294,"case h.e'_3.e_a\nE : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\ns : Set E\ns_conv : Convex \u211d s\nf : E \u2192 F\nf' : E \u2192 E \u2192L[\u211d] F\nf'' : E \u2192L[\u211d] E \u2192L[\u211d] F\nhf : \u2200 x \u2208 interior s, HasFDerivAt f (f' x) x\nx : E\nxs : x \u2208 s\nhx : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x_1 : E) in \ud835\udcdd[interior s] x, \u2016f' x_1 - f' x - f'' (x_1 - x)\u2016 \u2264 c * \u2016x_1 - x\u2016\nv w : E\nhv : x + v \u2208 interior s\nhw : x + v + w \u2208 interior s\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\ns\u03b4 : Metric.ball x \u03b4 \u2229 interior s \u2286 {x_1 | (fun x_2 \u21a6 \u2016f' x_2 - f' x - f'' (x_2 - x)\u2016 \u2264 \u03b5 * \u2016x_2 - x\u2016) x_1}\nE1 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nE2 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h < 1\nh : \u211d\nh\u03b4 : h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nh_lt_1 : h < 1\nhpos : 0 < h\nxt_mem : \u2200 t \u2208 Icc 0 1, x + h \u2022 v + (t * h) \u2022 w \u2208 interior s\ng : \u211d \u2192 F :=\n  fun t \u21a6 f (x + h \u2022 v + (t * h) \u2022 w) - (t * h) \u2022 (f' x) w - (t * h ^ 2) \u2022 (f'' v) w - ((t * h) ^ 2 / 2) \u2022 (f'' w) w\ng' : \u211d \u2192 F :=\n  fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\nhg' : g' = fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\ng_deriv : \u2200 t \u2208 Icc 0 1, HasDerivWithinAt g (g' t) (Icc 0 1) t\ng'_bound : \u2200 t \u2208 Ico 0 1, \u2016g' t\u2016 \u2264 \u03b5 * ((\u2016v\u2016 + \u2016w\u2016) * \u2016w\u2016) * h ^ 2\nI : \u2016g 1 - g 0\u2016 \u2264 \u03b5 * ((\u2016v\u2016 + \u2016w\u2016) * \u2016w\u2016) * h ^ 2\n\u22a2 f (x + h \u2022 v + h \u2022 w) - f (x + h \u2022 v) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (h ^ 2 / 2) \u2022 (f'' w) w =\n    f (x + h \u2022 v + h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (h ^ 2 / 2) \u2022 (f'' w) w - f (x + h \u2022 v)",["abel"]],["Analysis/Calculus/FDeriv/Symmetric.lean",337,"case h.e'_7.h\nE : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\ns : Set E\ns_conv : Convex \u211d s\nf : E \u2192 F\nf' : E \u2192 E \u2192L[\u211d] F\nf'' : E \u2192L[\u211d] E \u2192L[\u211d] F\nhf : \u2200 x \u2208 interior s, HasFDerivAt f (f' x) x\nx : E\nxs : x \u2208 s\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\nh4v : x + 4 \u2022 v \u2208 interior s\nh4w : x + 4 \u2022 w \u2208 interior s\nA : 1 / 2 \u2208 Ioc 0 1\nB : 1 / 2 \u2208 Icc 0 1\nh2v2w : x + 2 \u2022 v + 2 \u2022 w \u2208 interior s\nh2vww : x + (2 \u2022 v + w) + w \u2208 interior s\nh2v : x + 2 \u2022 v \u2208 interior s\nh2w : x + 2 \u2022 w \u2208 interior s\nhvw : x + (v + w) \u2208 interior s\nh2vw : x + (2 \u2022 v + w) \u2208 interior s\nhvww : x + (v + w) + w \u2208 interior s\nTA1 :\n  (fun h \u21a6\n      f (x + h \u2022 (2 \u2022 v + w) + h \u2022 w) - f (x + h \u2022 (2 \u2022 v + w)) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' (2 \u2022 v + w)) w -\n        (h ^ 2 / 2) \u2022 (f'' w) w) =o[\ud835\udcdd[>] 0]\n    fun h \u21a6 h ^ 2\nTA2 :\n  (fun h \u21a6\n      f (x + h \u2022 (v + w) + h \u2022 w) - f (x + h \u2022 (v + w)) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' (v + w)) w -\n        (h ^ 2 / 2) \u2022 (f'' w) w) =o[\ud835\udcdd[>] 0]\n    fun h \u21a6 h ^ 2\nh : \u211d\n\u22a2 f (x + h \u2022 v + h \u2022 v + h \u2022 w + h \u2022 w) + f (x + h \u2022 v + h \u2022 w) - f (x + h \u2022 v + h \u2022 v + h \u2022 w) -\n        f (x + h \u2022 v + h \u2022 w + h \u2022 w) -\n      h ^ 2 \u2022 (f'' v) w =\n    f (x + h \u2022 v + h \u2022 v + h \u2022 w + h \u2022 w) - f (x + h \u2022 v + h \u2022 v + h \u2022 w) - h \u2022 (f' x) w -\n          (h ^ 2 \u2022 (f'' v) w + h ^ 2 \u2022 (f'' v) w + h ^ 2 \u2022 (f'' w) w) -\n        (h ^ 2 / 2) \u2022 (f'' w) w -\n      (f (x + h \u2022 v + h \u2022 w + h \u2022 w) - f (x + h \u2022 v + h \u2022 w) - h \u2022 (f' x) w - (h ^ 2 \u2022 (f'' v) w + h ^ 2 \u2022 (f'' w) w) -\n        (h ^ 2 / 2) \u2022 (f'' w) w)",["abel"]],["Analysis/Calculus/FDeriv/Symmetric.lean",351,"case h.e'_7.h\nE : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\ns : Set E\ns_conv : Convex \u211d s\nf : E \u2192 F\nf' : E \u2192 E \u2192L[\u211d] F\nf'' : E \u2192L[\u211d] E \u2192L[\u211d] F\nhf : \u2200 x \u2208 interior s, HasFDerivAt f (f' x) x\nx : E\nxs : x \u2208 s\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\nh4v : x + 4 \u2022 v \u2208 interior s\nh4w : x + 4 \u2022 w \u2208 interior s\nh : \u211d\n\u22a2 h ^ 2 \u2022 (f'' w) v - h ^ 2 \u2022 (f'' v) w =\n    f (x + (h \u2022 v + h \u2022 w)) + f (x + (h \u2022 2 \u2022 v + h \u2022 2 \u2022 w)) - f (x + (h \u2022 w + h \u2022 2 \u2022 v)) -\n          f (x + (h \u2022 v + h \u2022 2 \u2022 w)) -\n        h ^ 2 \u2022 (f'' v) w -\n      (f (x + (h \u2022 v + h \u2022 w)) + f (x + (h \u2022 2 \u2022 v + h \u2022 2 \u2022 w)) - f (x + (h \u2022 v + h \u2022 2 \u2022 w)) -\n          f (x + (h \u2022 w + h \u2022 2 \u2022 v)) -\n        h ^ 2 \u2022 (f'' w) v)",["abel"]],["Analysis/Calculus/FDeriv/Symmetric.lean",248,"case h.e'_9.h.e'_5\nE : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\ns : Set E\ns_conv : Convex \u211d s\nf : E \u2192 F\nf' : E \u2192 E \u2192L[\u211d] F\nf'' : E \u2192L[\u211d] E \u2192L[\u211d] F\nhf : \u2200 x \u2208 interior s, HasFDerivAt f (f' x) x\nx : E\nxs : x \u2208 s\nhx : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x_1 : E) in \ud835\udcdd[interior s] x, \u2016f' x_1 - f' x - f'' (x_1 - x)\u2016 \u2264 c * \u2016x_1 - x\u2016\nv w : E\nhv : x + v \u2208 interior s\nhw : x + v + w \u2208 interior s\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\ns\u03b4 : Metric.ball x \u03b4 \u2229 interior s \u2286 {x_1 | (fun x_2 \u21a6 \u2016f' x_2 - f' x - f'' (x_2 - x)\u2016 \u2264 \u03b5 * \u2016x_2 - x\u2016) x_1}\nE1 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nE2 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h < 1\nh : \u211d\nh\u03b4 : h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nh_lt_1 : h < 1\nhpos : 0 < h\nxt_mem : \u2200 t \u2208 Icc 0 1, x + h \u2022 v + (t * h) \u2022 w \u2208 interior s\ng : \u211d \u2192 F :=\n  fun t \u21a6 f (x + h \u2022 v + (t * h) \u2022 w) - (t * h) \u2022 (f' x) w - (t * h ^ 2) \u2022 (f'' v) w - ((t * h) ^ 2 / 2) \u2022 (f'' w) w\ng' : \u211d \u2192 F :=\n  fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\nhg' : g' = fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\nt : \u211d\nht : t \u2208 Icc 0 1\nH :\n  HasDerivWithinAt (fun u \u21a6 ((u * h) ^ 2 / 2) \u2022 (f'' w) w) ((\u21912 * (t * h) ^ (2 - 1) * (1 * h) / 2) \u2022 (f'' w) w) (Icc 0 1)\n    t\n\u22a2 t * h ^ 2 = \u21912 * (t * h) ^ (2 - 1) * (1 * h) / 2",["ring","linarith"]],["Analysis/Calculus/FDeriv/Symmetric.lean",261,"E : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\ns : Set E\ns_conv : Convex \u211d s\nf : E \u2192 F\nf' : E \u2192 E \u2192L[\u211d] F\nf'' : E \u2192L[\u211d] E \u2192L[\u211d] F\nhf : \u2200 x \u2208 interior s, HasFDerivAt f (f' x) x\nx : E\nxs : x \u2208 s\nhx : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x_1 : E) in \ud835\udcdd[interior s] x, \u2016f' x_1 - f' x - f'' (x_1 - x)\u2016 \u2264 c * \u2016x_1 - x\u2016\nv w : E\nhv : x + v \u2208 interior s\nhw : x + v + w \u2208 interior s\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\ns\u03b4 : Metric.ball x \u03b4 \u2229 interior s \u2286 {x_1 | (fun x_2 \u21a6 \u2016f' x_2 - f' x - f'' (x_2 - x)\u2016 \u2264 \u03b5 * \u2016x_2 - x\u2016) x_1}\nE1 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nE2 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h < 1\nh : \u211d\nh\u03b4 : h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nh_lt_1 : h < 1\nhpos : 0 < h\nxt_mem : \u2200 t \u2208 Icc 0 1, x + h \u2022 v + (t * h) \u2022 w \u2208 interior s\ng : \u211d \u2192 F :=\n  fun t \u21a6 f (x + h \u2022 v + (t * h) \u2022 w) - (t * h) \u2022 (f' x) w - (t * h ^ 2) \u2022 (f'' v) w - ((t * h) ^ 2 / 2) \u2022 (f'' w) w\ng' : \u211d \u2192 F :=\n  fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\nhg' : g' = fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\ng_deriv : \u2200 t \u2208 Icc 0 1, HasDerivWithinAt g (g' t) (Icc 0 1) t\nt : \u211d\nht : t \u2208 Ico 0 1\n\u22a2 h * \u2016v\u2016 + 1 * (h * \u2016w\u2016) = h * (\u2016v\u2016 + \u2016w\u2016)",["ring","linarith"]],["Analysis/Calculus/FDeriv/Symmetric.lean",285,"E : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\ns : Set E\ns_conv : Convex \u211d s\nf : E \u2192 F\nf' : E \u2192 E \u2192L[\u211d] F\nf'' : E \u2192L[\u211d] E \u2192L[\u211d] F\nhf : \u2200 x \u2208 interior s, HasFDerivAt f (f' x) x\nx : E\nxs : x \u2208 s\nhx : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x_1 : E) in \ud835\udcdd[interior s] x, \u2016f' x_1 - f' x - f'' (x_1 - x)\u2016 \u2264 c * \u2016x_1 - x\u2016\nv w : E\nhv : x + v \u2208 interior s\nhw : x + v + w \u2208 interior s\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\ns\u03b4 : Metric.ball x \u03b4 \u2229 interior s \u2286 {x_1 | (fun x_2 \u21a6 \u2016f' x_2 - f' x - f'' (x_2 - x)\u2016 \u2264 \u03b5 * \u2016x_2 - x\u2016) x_1}\nE1 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nE2 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h < 1\nh : \u211d\nh\u03b4 : h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nh_lt_1 : h < 1\nhpos : 0 < h\nxt_mem : \u2200 t \u2208 Icc 0 1, x + h \u2022 v + (t * h) \u2022 w \u2208 interior s\ng : \u211d \u2192 F :=\n  fun t \u21a6 f (x + h \u2022 v + (t * h) \u2022 w) - (t * h) \u2022 (f' x) w - (t * h ^ 2) \u2022 (f'' v) w - ((t * h) ^ 2 / 2) \u2022 (f'' w) w\ng' : \u211d \u2192 F :=\n  fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\nhg' : g' = fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\ng_deriv : \u2200 t \u2208 Icc 0 1, HasDerivWithinAt g (g' t) (Icc 0 1) t\nt : \u211d\nht : t \u2208 Ico 0 1\nI : \u2016h \u2022 v + (t * h) \u2022 w\u2016 \u2264 h * (\u2016v\u2016 + \u2016w\u2016)\n\u22a2 \u03b5 * (h * \u2016v\u2016 + h * \u2016w\u2016) * (h * \u2016w\u2016) = \u03b5 * ((\u2016v\u2016 + \u2016w\u2016) * \u2016w\u2016) * h ^ 2",["ring","linarith"]],["Analysis/Calculus/FDeriv/Symmetric.lean",296,"case h.e'_4\nE : Type u_1\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\ns : Set E\ns_conv : Convex \u211d s\nf : E \u2192 F\nf' : E \u2192 E \u2192L[\u211d] F\nf'' : E \u2192L[\u211d] E \u2192L[\u211d] F\nhf : \u2200 x \u2208 interior s, HasFDerivAt f (f' x) x\nx : E\nxs : x \u2208 s\nhx : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x_1 : E) in \ud835\udcdd[interior s] x, \u2016f' x_1 - f' x - f'' (x_1 - x)\u2016 \u2264 c * \u2016x_1 - x\u2016\nv w : E\nhv : x + v \u2208 interior s\nhw : x + v + w \u2208 interior s\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\ns\u03b4 : Metric.ball x \u03b4 \u2229 interior s \u2286 {x_1 | (fun x_2 \u21a6 \u2016f' x_2 - f' x - f'' (x_2 - x)\u2016 \u2264 \u03b5 * \u2016x_2 - x\u2016) x_1}\nE1 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nE2 : \u2200\u1da0 (h : \u211d) in \ud835\udcdd[>] 0, h < 1\nh : \u211d\nh\u03b4 : h * (\u2016v\u2016 + \u2016w\u2016) < \u03b4\nh_lt_1 : h < 1\nhpos : 0 < h\nxt_mem : \u2200 t \u2208 Icc 0 1, x + h \u2022 v + (t * h) \u2022 w \u2208 interior s\ng : \u211d \u2192 F :=\n  fun t \u21a6 f (x + h \u2022 v + (t * h) \u2022 w) - (t * h) \u2022 (f' x) w - (t * h ^ 2) \u2022 (f'' v) w - ((t * h) ^ 2 / 2) \u2022 (f'' w) w\ng' : \u211d \u2192 F :=\n  fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\nhg' : g' = fun t \u21a6 (f' (x + h \u2022 v + (t * h) \u2022 w)) (h \u2022 w) - h \u2022 (f' x) w - h ^ 2 \u2022 (f'' v) w - (t * h ^ 2) \u2022 (f'' w) w\ng_deriv : \u2200 t \u2208 Icc 0 1, HasDerivWithinAt g (g' t) (Icc 0 1) t\ng'_bound : \u2200 t \u2208 Ico 0 1, \u2016g' t\u2016 \u2264 \u03b5 * ((\u2016v\u2016 + \u2016w\u2016) * \u2016w\u2016) * h ^ 2\nI : \u2016g 1 - g 0\u2016 \u2264 \u03b5 * ((\u2016v\u2016 + \u2016w\u2016) * \u2016w\u2016) * h ^ 2\n\u22a2 \u03b5 * ((\u2016v\u2016 + \u2016w\u2016) * \u2016w\u2016 * h ^ 2) = \u03b5 * ((\u2016v\u2016 + \u2016w\u2016) * \u2016w\u2016) * h ^ 2",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",86,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nhf' : \u2203\u1da0 (x : \u211d) in atTop, f x = 0\n\u22a2 1 / 2 \u2208 Set.Ioo 0 1",["norm_num"]],["Computability/AkraBazzi/GrowsPolynomially.lean",154,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\n\u22a2 1 / 2 \u2208 Set.Ioo 0 1",["norm_num"]],["Computability/AkraBazzi/GrowsPolynomially.lean",121,"f : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nhf' : \u2200 (a : \u211d), \u2203 b \u2265 a, f b = 0\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 > 0\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nx : \u211d\nhx_pos : 0 < x\nx\u2080 : \u211d\nhx\u2080_ge : x\u2080 \u2265 x \u2294 1\nhx\u2080 : f x\u2080 = 0\nx\u2080_pos : 0 < x\u2080\nk : \u2115\nz : \u211d\nhxz : x \u2264 z\nhz : z \u2208 Set.Icc (2 ^ (-(\u2191k + 1) - 1) * x\u2080) (2 ^ (-(\u2191k + 1)) * x\u2080)\nhx' : x \u2264 2 ^ (-\u2191k - 1) * x\u2080\nih : f (2 ^ (-\u2191k - 1) * x\u2080) = 0\nhx : z \u2208 Set.Icc (1 / 2 * (2 ^ (-\u2191k - 1) * x\u2080)) (2 ^ (-\u2191k - 1) * x\u2080) \u2192 f z = 0\n\u22a2 -1 + (-\u2191k - 1) = -\u2191k - 2",["ring","omega","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",122,"f : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nhf' : \u2200 (a : \u211d), \u2203 b \u2265 a, f b = 0\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 > 0\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nx : \u211d\nhx_pos : 0 < x\nx\u2080 : \u211d\nhx\u2080_ge : x\u2080 \u2265 x \u2294 1\nhx\u2080 : f x\u2080 = 0\nx\u2080_pos : 0 < x\u2080\nk : \u2115\nz : \u211d\nhxz : x \u2264 z\nhz : z \u2208 Set.Icc (2 ^ (-(\u2191k + 1) - 1) * x\u2080) (2 ^ (-(\u2191k + 1)) * x\u2080)\nhx' : x \u2264 2 ^ (-\u2191k - 1) * x\u2080\nih : f (2 ^ (-\u2191k - 1) * x\u2080) = 0\nhx : z \u2208 Set.Icc (1 / 2 * (2 ^ (-\u2191k - 1) * x\u2080)) (2 ^ (-\u2191k - 1) * x\u2080) \u2192 f z = 0\nh\u2081 : -1 + (-\u2191k - 1) = -\u2191k - 2\n\u22a2 -(\u2191k + 1) - 1 = -\u2191k - 2",["ring","omega","linarith","abel"]],["Computability/AkraBazzi/GrowsPolynomially.lean",220,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nheq : c\u2081 = c\u2082\nn\u2080 : \u211d\nhn\u2080 : \u2200 b \u2265 n\u2080, \u2200 u \u2208 Set.Icc (1 / 2 * b) b, f u = c\u2082 * f b\nn : \u2115\nhn : n \u2265 1\nhyp_ind : \u2200 z \u2208 Set.Ico (n\u2080 \u2294 2) (2 ^ n * (n\u2080 \u2294 2)), f z = f (n\u2080 \u2294 2)\nz : \u211d\nhz : z \u2208 Set.Ico (2 ^ n * (n\u2080 \u2294 2)) (2 ^ (n + 1) * (n\u2080 \u2294 2))\nz_nonneg : 0 \u2264 z\nle_2n : n\u2080 \u2294 2 \u2264 2 ^ n * (n\u2080 \u2294 2)\nn\u2080_le_z : n\u2080 \u2264 z\nfz_eq_c\u2082fz : f z = c\u2082 * f z\nz_to_half_z' : f (1 / 2 * z) = c\u2082 * f z\nz_to_half_z : f (1 / 2 * z) = f z\n\u22a2 2 ^ n = 2\u207b\u00b9 * (2 ^ n * 2)",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",344,"f g : \u211d \u2192 \u211d\nhf\u271d\u00b9 : GrowsPolynomially f\nhg\u271d\u00b9 : GrowsPolynomially g\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 > 0\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhf\u271d :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 |f x|) u \u2208 Set.Icc (c\u2081 * (fun x \u21a6 |f x|) x) (c\u2082 * (fun x \u21a6 |f x|) x)\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 > 0\nc\u2084 : \u211d\nhc\u2084_mem : c\u2084 > 0\nhg\u271d :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 |g x|) u \u2208 Set.Icc (c\u2083 * (fun x \u21a6 |g x|) x) (c\u2084 * (fun x \u21a6 |g x|) x)\nx : \u211d\nhf : \u2200 u \u2208 Set.Icc (b * x) x, |f u| \u2208 Set.Icc (c\u2081 * |f x|) (c\u2082 * |f x|)\nhg : \u2200 u \u2208 Set.Icc (b * x) x, |g u| \u2208 Set.Icc (c\u2083 * |g x|) (c\u2084 * |g x|)\nu : \u211d\nhu : u \u2208 Set.Icc (b * x) x\n\u22a2 c\u2081 * c\u2083 * (|f x| * |g x|) = c\u2081 * |f x| * (c\u2083 * |g x|)",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",354,"f g : \u211d \u2192 \u211d\nhf\u271d\u00b9 : GrowsPolynomially f\nhg\u271d\u00b9 : GrowsPolynomially g\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 > 0\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhf\u271d :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 |f x|) u \u2208 Set.Icc (c\u2081 * (fun x \u21a6 |f x|) x) (c\u2082 * (fun x \u21a6 |f x|) x)\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 > 0\nc\u2084 : \u211d\nhc\u2084_mem : c\u2084 > 0\nhg\u271d :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 |g x|) u \u2208 Set.Icc (c\u2083 * (fun x \u21a6 |g x|) x) (c\u2084 * (fun x \u21a6 |g x|) x)\nx : \u211d\nhf : \u2200 u \u2208 Set.Icc (b * x) x, |f u| \u2208 Set.Icc (c\u2081 * |f x|) (c\u2082 * |f x|)\nhg : \u2200 u \u2208 Set.Icc (b * x) x, |g u| \u2208 Set.Icc (c\u2083 * |g x|) (c\u2084 * |g x|)\nu : \u211d\nhu : u \u2208 Set.Icc (b * x) x\n\u22a2 c\u2082 * |f x| * (c\u2084 * |g x|) = c\u2082 * c\u2084 * (|f x| * |g x|)",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",422,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\n\u22a2 f x + 1 / 2 * f x = 3 / 2 * f x",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",427,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\n\u22a2 f x - 1 / 2 * f x = 1 / 2 * f x",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",438,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\nhx_lb : 1 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonneg : 0 \u2264 f u\nhfg\u2083 : \u2016g u\u2016 \u2264 1 / 2 * f u\n\u22a2 f u - 1 / 2 * f u = 1 / 2 * f u",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",440,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\nhx_lb : 1 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonneg : 0 \u2264 f u\nhfg\u2083 : \u2016g u\u2016 \u2264 1 / 2 * f u\n\u22a2 1 / 2 * (c\u2081 * f x) = c\u2081 / 3 * (3 / 2 * f x)",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",445,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\nhx_lb : 1 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonneg : 0 \u2264 f u\nhfg\u2083 : \u2016g u\u2016 \u2264 1 / 2 * f u\n\u22a2 f u + 1 / 2 * f u = 3 / 2 * f u",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",447,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\nhx_lb : 1 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonneg : 0 \u2264 f u\nhfg\u2083 : \u2016g u\u2016 \u2264 1 / 2 * f u\n\u22a2 3 / 2 * (c\u2082 * f x) = 3 * c\u2082 * (1 / 2 * f x)",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",462,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\n\u22a2 1 / 2 * -f x = -1 / 2 * f x",["ring","linarith","norm_num"]],["Computability/AkraBazzi/GrowsPolynomially.lean",466,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\n\u22a2 f x + -1 / 2 * f x = 1 / 2 * f x",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",475,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\nhx_ub : f x + g x \u2264 1 / 2 * f x\n\u22a2 f x + 1 / 2 * f x = 3 / 2 * f x",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",481,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\nhx_ub : f x + g x \u2264 1 / 2 * f x\nhx_lb : 3 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonpos : f u \u2264 0\n\u22a2 1 / 2 * -f u = -1 / 2 * f u",["ring","linarith","norm_num"]],["Computability/AkraBazzi/GrowsPolynomially.lean",491,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\nhx_ub : f x + g x \u2264 1 / 2 * f x\nhx_lb : 3 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonpos : f u \u2264 0\nhfg\u2083 : \u2016g u\u2016 \u2264 -1 / 2 * f u\n\u22a2 f u + 1 / 2 * f u = 3 / 2 * f u",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",493,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\nhx_ub : f x + g x \u2264 1 / 2 * f x\nhx_lb : 3 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonpos : f u \u2264 0\nhfg\u2083 : \u2016g u\u2016 \u2264 -1 / 2 * f u\n\u22a2 3 / 2 * (c\u2081 * f x) = 3 * c\u2081 * (1 / 2 * f x)",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",501,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\nhx_ub : f x + g x \u2264 1 / 2 * f x\nhx_lb : 3 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonpos : f u \u2264 0\nhfg\u2083 : \u2016g u\u2016 \u2264 -1 / 2 * f u\n\u22a2 f u - 1 / 2 * f u = 1 / 2 * f u",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",503,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\nhx_ub : f x + g x \u2264 1 / 2 * f x\nhx_lb : 3 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonpos : f u \u2264 0\nhfg\u2083 : \u2016g u\u2016 \u2264 -1 / 2 * f u\n\u22a2 1 / 2 * (c\u2082 * f x) = c\u2082 / 3 * (3 / 2 * f x)",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",646,"b : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb\u2080 : 0 < b\nh_tendsto : Tendsto (fun x \u21a6 1 / 2 * log x) atTop atTop\nx : \u211d\nhx_pos : 1 < x\nhx : \u2200 (y : \u211d), b * id x \u2264 y \u2192 -log b < 1 / 2 * log y\nu : \u211d\nhu : u \u2208 Set.Icc (b * x) x\n\u22a2 1 / 2 * log x = log x + -1 / 2 * log x",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",694,"f g : \u211d \u2192 \u211d\nhg\u271d : GrowsPolynomially g\nhf : f =\u0398[atTop] g\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_pos : 0 < b\nc\u2081 : \u211d\nhc\u2081_pos : 0 < c\u2081\nhf_lb : \u2200\u1da0 (x : \u211d) in atTop, c\u2081 * \u2016g x\u2016 \u2264 \u2016f x\u2016\nc\u2082 : \u211d\nhc\u2082_pos : 0 < c\u2082\nhf_ub : \u2200\u1da0 (x : \u211d) in atTop, \u2016f x\u2016 \u2264 c\u2082 * \u2016g x\u2016\nc\u2083 : \u211d\nhc\u2083_pos : 0 < c\u2083\nc\u2084 : \u211d\nhc\u2084_pos : 0 < c\u2084\nhg :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 \u2016g x\u2016) u \u2208 Set.Icc (c\u2083 * (fun x \u21a6 \u2016g x\u2016) x) (c\u2084 * (fun x \u21a6 \u2016g x\u2016) x)\nh_lb_pos : 0 < c\u2081 * c\u2082\u207b\u00b9 * c\u2083\nh_ub_pos : 0 < c\u2082 * c\u2084 * c\u2081\u207b\u00b9\nc\u2082_cancel : c\u2082\u207b\u00b9 * c\u2082 = 1\nc\u2081_cancel : c\u2081\u207b\u00b9 * c\u2081 = 1\nx : \u211d\nhf_pos : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nh_lb : \u2200 (y : \u211d), b * id x \u2264 y \u2192 c\u2081 * \u2016g y\u2016 \u2264 \u2016f y\u2016\nh_ub : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016f y\u2016 \u2264 c\u2082 * \u2016g y\u2016\nhg_bound\u271d : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2200 u \u2208 Set.Icc (b * y) y, \u2016g u\u2016 \u2208 Set.Icc (c\u2083 * \u2016g y\u2016) (c\u2084 * \u2016g y\u2016)\nhx_pos : 0 \u2264 x\nu : \u211d\nhu : u \u2208 Set.Icc (b * x) x\nhbx : b * x \u2264 x\nhg_bound : \u2200 u \u2208 Set.Icc (b * x) x, \u2016g u\u2016 \u2208 Set.Icc (c\u2083 * \u2016g x\u2016) (c\u2084 * \u2016g x\u2016)\n\u22a2 c\u2081 * c\u2082\u207b\u00b9 * c\u2083 * (c\u2082 * \u2016g x\u2016) = c\u2082\u207b\u00b9 * c\u2082 * c\u2081 * (c\u2083 * \u2016g x\u2016)",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",703,"f g : \u211d \u2192 \u211d\nhg\u271d : GrowsPolynomially g\nhf : f =\u0398[atTop] g\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_pos : 0 < b\nc\u2081 : \u211d\nhc\u2081_pos : 0 < c\u2081\nhf_lb : \u2200\u1da0 (x : \u211d) in atTop, c\u2081 * \u2016g x\u2016 \u2264 \u2016f x\u2016\nc\u2082 : \u211d\nhc\u2082_pos : 0 < c\u2082\nhf_ub : \u2200\u1da0 (x : \u211d) in atTop, \u2016f x\u2016 \u2264 c\u2082 * \u2016g x\u2016\nc\u2083 : \u211d\nhc\u2083_pos : 0 < c\u2083\nc\u2084 : \u211d\nhc\u2084_pos : 0 < c\u2084\nhg :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 \u2016g x\u2016) u \u2208 Set.Icc (c\u2083 * (fun x \u21a6 \u2016g x\u2016) x) (c\u2084 * (fun x \u21a6 \u2016g x\u2016) x)\nh_lb_pos : 0 < c\u2081 * c\u2082\u207b\u00b9 * c\u2083\nh_ub_pos : 0 < c\u2082 * c\u2084 * c\u2081\u207b\u00b9\nc\u2082_cancel : c\u2082\u207b\u00b9 * c\u2082 = 1\nc\u2081_cancel : c\u2081\u207b\u00b9 * c\u2081 = 1\nx : \u211d\nhf_pos : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nh_lb : \u2200 (y : \u211d), b * id x \u2264 y \u2192 c\u2081 * \u2016g y\u2016 \u2264 \u2016f y\u2016\nh_ub : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016f y\u2016 \u2264 c\u2082 * \u2016g y\u2016\nhg_bound\u271d : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2200 u \u2208 Set.Icc (b * y) y, \u2016g u\u2016 \u2208 Set.Icc (c\u2083 * \u2016g y\u2016) (c\u2084 * \u2016g y\u2016)\nhx_pos : 0 \u2264 x\nu : \u211d\nhu : u \u2208 Set.Icc (b * x) x\nhbx : b * x \u2264 x\nhg_bound : \u2200 u \u2208 Set.Icc (b * x) x, \u2016g u\u2016 \u2208 Set.Icc (c\u2083 * \u2016g x\u2016) (c\u2084 * \u2016g x\u2016)\n\u22a2 c\u2082 * (c\u2084 * |g x|) = c\u2082 * c\u2084 * |g x|",["ring","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",704,"f g : \u211d \u2192 \u211d\nhg\u271d : GrowsPolynomially g\nhf : f =\u0398[atTop] g\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_pos : 0 < b\nc\u2081 : \u211d\nhc\u2081_pos : 0 < c\u2081\nhf_lb : \u2200\u1da0 (x : \u211d) in atTop, c\u2081 * \u2016g x\u2016 \u2264 \u2016f x\u2016\nc\u2082 : \u211d\nhc\u2082_pos : 0 < c\u2082\nhf_ub : \u2200\u1da0 (x : \u211d) in atTop, \u2016f x\u2016 \u2264 c\u2082 * \u2016g x\u2016\nc\u2083 : \u211d\nhc\u2083_pos : 0 < c\u2083\nc\u2084 : \u211d\nhc\u2084_pos : 0 < c\u2084\nhg :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 \u2016g x\u2016) u \u2208 Set.Icc (c\u2083 * (fun x \u21a6 \u2016g x\u2016) x) (c\u2084 * (fun x \u21a6 \u2016g x\u2016) x)\nh_lb_pos : 0 < c\u2081 * c\u2082\u207b\u00b9 * c\u2083\nh_ub_pos : 0 < c\u2082 * c\u2084 * c\u2081\u207b\u00b9\nc\u2082_cancel : c\u2082\u207b\u00b9 * c\u2082 = 1\nc\u2081_cancel : c\u2081\u207b\u00b9 * c\u2081 = 1\nx : \u211d\nhf_pos : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nh_lb : \u2200 (y : \u211d), b * id x \u2264 y \u2192 c\u2081 * \u2016g y\u2016 \u2264 \u2016f y\u2016\nh_ub : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016f y\u2016 \u2264 c\u2082 * \u2016g y\u2016\nhg_bound\u271d : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2200 u \u2208 Set.Icc (b * y) y, \u2016g u\u2016 \u2208 Set.Icc (c\u2083 * \u2016g y\u2016) (c\u2084 * \u2016g y\u2016)\nhx_pos : 0 \u2264 x\nu : \u211d\nhu : u \u2208 Set.Icc (b * x) x\nhbx : b * x \u2264 x\nhg_bound : \u2200 u \u2208 Set.Icc (b * x) x, \u2016g u\u2016 \u2208 Set.Icc (c\u2083 * \u2016g x\u2016) (c\u2084 * \u2016g x\u2016)\n\u22a2 c\u2082 * c\u2084 * (c\u2081\u207b\u00b9 * c\u2081) * \u2016g x\u2016 = c\u2082 * c\u2084 * c\u2081\u207b\u00b9 * (c\u2081 * \u2016g x\u2016)",["ring","linarith"]],["Analysis/Calculus/VectorField.lean",115,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nV W V\u2081 : E \u2192 E\ns : Set E\nx : E\nhV : DifferentiableWithinAt \ud835\udd5c V s x\nhV\u2081 : DifferentiableWithinAt \ud835\udd5c V\u2081 s x\nhs : UniqueDiffWithinAt \ud835\udd5c s x\n\u22a2 (fderivWithin \ud835\udd5c W s x) (V x) + (fderivWithin \ud835\udd5c W s x) (V\u2081 x) -\n      ((fderivWithin \ud835\udd5c V s x) (W x) + (fderivWithin \ud835\udd5c V\u2081 s x) (W x)) =\n    (fderivWithin \ud835\udd5c W s x) (V x) - (fderivWithin \ud835\udd5c V s x) (W x) +\n      ((fderivWithin \ud835\udd5c W s x) (V\u2081 x) - (fderivWithin \ud835\udd5c V\u2081 s x) (W x))",["abel"]],["Analysis/Calculus/VectorField.lean",122,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nV W V\u2081 : E \u2192 E\nx : E\nhV : DifferentiableAt \ud835\udd5c V x\nhV\u2081 : DifferentiableAt \ud835\udd5c V\u2081 x\n\u22a2 (fderiv \ud835\udd5c W x) (V x) + (fderiv \ud835\udd5c W x) (V\u2081 x) - ((fderiv \ud835\udd5c V x) (W x) + (fderiv \ud835\udd5c V\u2081 x) (W x)) =\n    (fderiv \ud835\udd5c W x) (V x) - (fderiv \ud835\udd5c V x) (W x) + ((fderiv \ud835\udd5c W x) (V\u2081 x) - (fderiv \ud835\udd5c V\u2081 x) (W x))",["abel"]],["Analysis/Calculus/VectorField.lean",130,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nV W W\u2081 : E \u2192 E\ns : Set E\nx : E\nhW : DifferentiableWithinAt \ud835\udd5c W s x\nhW\u2081 : DifferentiableWithinAt \ud835\udd5c W\u2081 s x\nhs : UniqueDiffWithinAt \ud835\udd5c s x\n\u22a2 (fderivWithin \ud835\udd5c W s x) (V x) + (fderivWithin \ud835\udd5c W\u2081 s x) (V x) -\n      ((fderivWithin \ud835\udd5c V s x) (W x) + (fderivWithin \ud835\udd5c V s x) (W\u2081 x)) =\n    (fderivWithin \ud835\udd5c W s x) (V x) - (fderivWithin \ud835\udd5c V s x) (W x) +\n      ((fderivWithin \ud835\udd5c W\u2081 s x) (V x) - (fderivWithin \ud835\udd5c V s x) (W\u2081 x))",["abel"]],["Analysis/Calculus/VectorField.lean",137,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nV W W\u2081 : E \u2192 E\nx : E\nhW : DifferentiableAt \ud835\udd5c W x\nhW\u2081 : DifferentiableAt \ud835\udd5c W\u2081 x\n\u22a2 (fderiv \ud835\udd5c W x) (V x) + (fderiv \ud835\udd5c W\u2081 x) (V x) - ((fderiv \ud835\udd5c V x) (W x) + (fderiv \ud835\udd5c V x) (W\u2081 x)) =\n    (fderiv \ud835\udd5c W x) (V x) - (fderiv \ud835\udd5c V x) (W x) + ((fderiv \ud835\udd5c W\u2081 x) (V x) - (fderiv \ud835\udd5c V x) (W\u2081 x))",["abel"]],["Analysis/Calculus/VectorField.lean",323,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nU V W : E \u2192 E\ns : Set E\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nhU : ContDiffWithinAt \ud835\udd5c 2 U s x\nhV : ContDiffWithinAt \ud835\udd5c 2 V s x\nhW : ContDiffWithinAt \ud835\udd5c 2 W s x\nh'U : IsSymmSndFDerivWithinAt \ud835\udd5c U s x\nh'V : IsSymmSndFDerivWithinAt \ud835\udd5c V s x\nh'W : IsSymmSndFDerivWithinAt \ud835\udd5c W s x\naux\u2081 :\n  \u2200 {U V : E \u2192 E},\n    ContDiffWithinAt \ud835\udd5c 2 U s x \u2192\n      ContDiffWithinAt \ud835\udd5c 2 V s x \u2192 DifferentiableWithinAt \ud835\udd5c (fun x \u21a6 (fderivWithin \ud835\udd5c V s x) (U x)) s x\naux\u2082 :\n  \u2200 {U V : E \u2192 E},\n    ContDiffWithinAt \ud835\udd5c 2 U s x \u2192\n      ContDiffWithinAt \ud835\udd5c 2 V s x \u2192\n        fderivWithin \ud835\udd5c (fun y \u21a6 (fderivWithin \ud835\udd5c U s y) (V y)) s x =\n          (fderivWithin \ud835\udd5c U s x).comp (fderivWithin \ud835\udd5c V s x) + (fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c U s) s x).flip (V x)\n\u22a2 (fderivWithin \ud835\udd5c W s x) ((fderivWithin \ud835\udd5c V s x) (U x)) + ((fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c W s) s x) (U x)) (V x) -\n        ((fderivWithin \ud835\udd5c V s x) ((fderivWithin \ud835\udd5c W s x) (U x)) +\n          ((fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c V s) s x) (U x)) (W x)) -\n      ((fderivWithin \ud835\udd5c U s x) ((fderivWithin \ud835\udd5c W s x) (V x)) - (fderivWithin \ud835\udd5c U s x) ((fderivWithin \ud835\udd5c V s x) (W x))) =\n    (fderivWithin \ud835\udd5c W s x) ((fderivWithin \ud835\udd5c V s x) (U x)) - (fderivWithin \ud835\udd5c W s x) ((fderivWithin \ud835\udd5c U s x) (V x)) -\n        ((fderivWithin \ud835\udd5c V s x) ((fderivWithin \ud835\udd5c U s x) (W x)) + ((fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c V s) s x) (U x)) (W x) -\n          ((fderivWithin \ud835\udd5c U s x) ((fderivWithin \ud835\udd5c V s x) (W x)) +\n            ((fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c U s) s x) (V x)) (W x))) +\n      ((fderivWithin \ud835\udd5c W s x) ((fderivWithin \ud835\udd5c U s x) (V x)) + ((fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c W s) s x) (U x)) (V x) -\n          ((fderivWithin \ud835\udd5c U s x) ((fderivWithin \ud835\udd5c W s x) (V x)) +\n            ((fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c U s) s x) (V x)) (W x)) -\n        ((fderivWithin \ud835\udd5c V s x) ((fderivWithin \ud835\udd5c W s x) (U x)) - (fderivWithin \ud835\udd5c V s x) ((fderivWithin \ud835\udd5c U s x) (W x))))",["abel"]],["Algebra/Homology/Homotopy.lean",168,"\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D E : HomologicalComplex V c\nf\u271d g\u271d : C \u27f6 D\nh\u271d k\u271d : D \u27f6 E\ni\u271d : \u03b9\ne f g : C \u27f6 D\nh : Homotopy e f\nk : Homotopy f g\ni : \u03b9\n\u22a2 (dNext i) h.hom + (prevD i) h.hom + ((dNext i) k.hom + (prevD i) k.hom + g.f i) =\n    (dNext i) h.hom + (dNext i) k.hom + ((prevD i) h.hom + (prevD i) k.hom) + g.f i",["abel"]],["Algebra/Homology/Homotopy.lean",178,"\u03b9 : Type u_1\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nC D E : HomologicalComplex V c\nf g : C \u27f6 D\nh k : D \u27f6 E\ni\u271d : \u03b9\nf\u2081 g\u2081 f\u2082 g\u2082 : C \u27f6 D\nh\u2081 : Homotopy f\u2081 g\u2081\nh\u2082 : Homotopy f\u2082 g\u2082\ni : \u03b9\n\u22a2 (dNext i) h\u2081.hom + (prevD i) h\u2081.hom + g\u2081.f i + ((dNext i) h\u2082.hom + (prevD i) h\u2082.hom + g\u2082.f i) =\n    (dNext i) h\u2081.hom + (dNext i) h\u2082.hom + ((prevD i) h\u2081.hom + (prevD i) h\u2082.hom) + (g\u2081.f i + g\u2082.f i)",["abel"]],["Geometry/Euclidean/Basic.lean",506,"case e_a\nV : Type u_1\nP : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup V\ninst\u271d\u2074 : InnerProductSpace \u211d V\ninst\u271d\u00b3 : MetricSpace P\ninst\u271d\u00b2 : NormedAddTorsor V P\ns : AffineSubspace \u211d P\ninst\u271d\u00b9 : Nonempty \u21a5s\ninst\u271d : HasOrthogonalProjection s.direction\np : P\nv : V := p -\u1d65 \u2191(Classical.arbitrary \u21a5s)\na : V := \u2191((_root_.orthogonalProjection s.direction) v)\nb : P := \u2191(Classical.arbitrary \u21a5s)\n\u22a2 a - v + a = a + a - v",["abel"]],["Geometry/Euclidean/Basic.lean",103,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nr : \u211d\nv : V\np\u2081 p\u2082 : P\n\u22a2 r * (r * inner v v) + 2 * (r * inner v (p\u2081 -\u1d65 p\u2082)) + inner (p\u2081 -\u1d65 p\u2082) (p\u2081 -\u1d65 p\u2082) =\n    inner v v * r * r + 2 * inner v (p\u2081 -\u1d65 p\u2082) * r + inner (p\u2081 -\u1d65 p\u2082) (p\u2081 -\u1d65 p\u2082)",["ring","linarith"]],["Geometry/Euclidean/Basic.lean",116,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nv : V\np\u2081 p\u2082 : P\nhv : v \u2260 0\nr : \u211d\nhvi : inner v v \u2260 0\n\u22a2 (2 * inner v (p\u2081 -\u1d65 p\u2082)) ^ 2 - 4 * inner v v * 0 = 2 * inner v (p\u2081 -\u1d65 p\u2082) * (2 * inner v (p\u2081 -\u1d65 p\u2082))",["ring","linarith"]],["Geometry/Euclidean/Basic.lean",483,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\ns : AffineSubspace \u211d P\np\u2081 p\u2082 : P\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nr\u2081 r\u2082 : \u211d\nv : V\nhv : v \u2208 s.direction\u15ee\n\u22a2 \u2016p\u2081 -\u1d65 p\u2082\u2016 * \u2016p\u2081 -\u1d65 p\u2082\u2016 + |r\u2081 - r\u2082| * \u2016v\u2016 * (|r\u2081 - r\u2082| * \u2016v\u2016) =\n    \u2016p\u2081 -\u1d65 p\u2082\u2016 * \u2016p\u2081 -\u1d65 p\u2082\u2016 + |r\u2081 - r\u2082| * |r\u2081 - r\u2082| * \u2016v\u2016 * \u2016v\u2016",["ring","linarith"]],["RingTheory/GradedAlgebra/HomogeneousLocalization.lean",766,"case h.e'_4.h.e'_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u2115 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\ne d : \u2115\nf : A\nhf : f \u2208 \ud835\udc9c d\ng : A\nhg : g \u2208 \ud835\udc9c e\nx : A\nhx : x = f * g\nhd : d \u2260 0\nthis : Algebra (Away \ud835\udc9c f) (Away \ud835\udc9c x) := (awayMap \ud835\udc9c hg hx).toAlgebra\nn : \u2115\n\u22a2 (d + e) \u2022 (d + e) = e \u2022 e + (2 * e + d) \u2022 d",["ring"]],["RingTheory/GradedAlgebra/HomogeneousLocalization.lean",773,"case h\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u2115 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\ne d : \u2115\nf : A\nhf : f \u2208 \ud835\udc9c d\ng : A\nhg : g \u2208 \ud835\udc9c e\nx : A\nhx : x = f * g\nhd : d \u2260 0\nthis : Algebra (Away \ud835\udc9c f) (Away \ud835\udc9c x) := (awayMap \ud835\udc9c hg hx).toAlgebra\nn : \u2115\nz : Away \ud835\udc9c x := Away.mk \ud835\udc9c \u22ef (d + e) (g ^ e * f ^ (2 * e + d)) \u22ef\n\u22a2 g ^ d * g ^ e * (g ^ e * f ^ (2 * e + d)) = (f * g) ^ e * (f * g) ^ (d + e)",["ring"]],["RingTheory/GradedAlgebra/HomogeneousLocalization.lean",779,"case h.e'_4.h.e'_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u2115 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\ne : \u2115\nf g : A\nhg : g \u2208 \ud835\udc9c e\nx : A\nhx : x = f * g\nthis : Algebra (Away \ud835\udc9c f) (Away \ud835\udc9c x) := (awayMap \ud835\udc9c hg hx).toAlgebra\nn : \u2115\ns : A\nd : \u2115\nhf : f \u2208 \ud835\udc9c (d + 1)\nhd : d + 1 \u2260 0\nhs : s \u2208 \ud835\udc9c (n \u2022 (d + 1 + e))\n\u22a2 n * (e + 1) * (d + 1) = n * (d + 1 + e) + n * d * e",["ring"]],["Analysis/Calculus/FDeriv/Add.lean",113,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\nf' g' : E \u2192L[\ud835\udd5c] F\nx : E\nhf : HasStrictFDerivAt f f' x\nhg : HasStrictFDerivAt g g' x\ny : E \u00d7 E\n\u22a2 f y.1 - f y.2 - (f' y.1 - f' y.2) + (g y.1 - g y.2 - (g' y.1 - g' y.2)) =\n    f y.1 + g y.1 - (f y.2 + g y.2) - (f' y.1 + g' y.1 - (f' y.2 + g' y.2))",["abel"]],["Analysis/Calculus/FDeriv/Add.lean",119,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\nf' g' : E \u2192L[\ud835\udd5c] F\nx : E\nL : Filter E\nhf : HasFDerivAtFilter f f' x L\nhg : HasFDerivAtFilter g g' x L\nx\u271d : E\n\u22a2 f x\u271d - f x - (f' x\u271d - f' x) + (g x\u271d - g x - (g' x\u271d - g' x)) =\n    f x\u271d + g x\u271d - (f x + g x) - (f' x\u271d + g' x\u271d - (f' x + g' x))",["abel"]],["FieldTheory/Separable.lean",170,"case h.e'_4\nR : Type u\ninst\u271d : CommSemiring R\nq p : R[X]\nhp : IsCoprime (q * q * p) (derivative (q * q * p))\n\u22a2 q * derivative q * p + q * derivative q * p + q * q * derivative p =\n    (derivative q * q + q * derivative q) * p + q * q * derivative p",["ring"]],["FieldTheory/Separable.lean",255,"R : Type u\ninst\u271d : CommRing R\nn : \u2115\nu : R\u02e3\nhn : IsUnit \u2191n\na\u271d : Nontrivial R\nhpos : n > 0\nn' : R\nhn' : n' * \u2191n = 1\n\u22a2 -C \u2191u\u207b\u00b9 * (X ^ n - C \u2191u) + C \u2191u\u207b\u00b9 * C n' * X * (\u2191n * X ^ (n - 1)) =\n    C \u2191u\u207b\u00b9 * C \u2191u - C \u2191u\u207b\u00b9 * X ^ n + C \u2191u\u207b\u00b9 * (C n' * \u2191n) * (X * X ^ (n - 1))",["ring"]],["MeasureTheory/Integral/DivergenceTheorem.lean",470,"E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : CompleteSpace E\nf g : \u211d \u00d7 \u211d \u2192 E\nf' g' : \u211d \u00d7 \u211d \u2192 \u211d \u00d7 \u211d \u2192L[\u211d] E\na b : \u211d \u00d7 \u211d\nhle : a \u2264 b\ns : Set (\u211d \u00d7 \u211d)\nhs : s.Countable\nHcf : ContinuousOn f (Set.Icc a b)\nHcg : ContinuousOn g (Set.Icc a b)\nHdf : \u2200 x \u2208 Set.Ioo a.1 b.1 \u00d7\u02e2 Set.Ioo a.2 b.2 \\ s, HasFDerivAt f (f' x) x\nHdg : \u2200 x \u2208 Set.Ioo a.1 b.1 \u00d7\u02e2 Set.Ioo a.2 b.2 \\ s, HasFDerivAt g (g' x) x\nHi : IntegrableOn (fun x \u21a6 (f' x) (1, 0) + (g' x) (0, 1)) (Set.Icc a b) volume\ne : (\u211d \u00d7 \u211d) \u2243L[\u211d] Fin 2 \u2192 \u211d := (ContinuousLinearEquiv.finTwoArrow \u211d \u211d).symm\n\u22a2 ((\u222b (y : \u211d) in Set.Icc a.2 b.2, f (b.1, y)) - \u222b (y : \u211d) in Set.Icc a.2 b.2, f (a.1, y)) +\n      ((\u222b (x : \u211d) in Set.Icc a.1 b.1, g (x, b.2)) - \u222b (x : \u211d) in Set.Icc a.1 b.1, g (x, a.2)) =\n    (((\u222b (x : \u211d) in Set.Icc a.1 b.1, g (x, b.2)) - \u222b (x : \u211d) in Set.Icc a.1 b.1, g (x, a.2)) +\n        \u222b (y : \u211d) in Set.Icc a.2 b.2, f (b.1, y)) -\n      \u222b (y : \u211d) in Set.Icc a.2 b.2, f (a.1, y)",["abel"]],["MeasureTheory/Integral/DivergenceTheorem.lean",497,"case inr\nE : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : CompleteSpace E\nf g : \u211d \u00d7 \u211d \u2192 E\nf' g' : \u211d \u00d7 \u211d \u2192 \u211d \u00d7 \u211d \u2192L[\u211d] E\na\u2081 a\u2082 b\u2081 b\u2082 : \u211d\ns : Set (\u211d \u00d7 \u211d)\nhs : s.Countable\nHcf : ContinuousOn f ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]])\nHcg : ContinuousOn g ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]])\nHdf : \u2200 x \u2208 Set.Ioo (a\u2081 \u2293 b\u2081) (a\u2081 \u2294 b\u2081) \u00d7\u02e2 Set.Ioo (a\u2082 \u2293 b\u2082) (a\u2082 \u2294 b\u2082) \\ s, HasFDerivAt f (f' x) x\nHdg : \u2200 x \u2208 Set.Ioo (a\u2081 \u2293 b\u2081) (a\u2081 \u2294 b\u2081) \u00d7\u02e2 Set.Ioo (a\u2082 \u2293 b\u2082) (a\u2082 \u2294 b\u2082) \\ s, HasFDerivAt g (g' x) x\nHi : IntegrableOn (fun x \u21a6 (f' x) (1, 0) + (g' x) (0, 1)) ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]]) volume\nh\u2081 : \u00aca\u2081 \u2264 b\u2081\nthis :\n  ContinuousOn f ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]]) \u2192\n    ContinuousOn g ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]]) \u2192\n      (\u2200 x \u2208 Set.Ioo (a\u2081 \u2293 b\u2081) (a\u2081 \u2294 b\u2081) \u00d7\u02e2 Set.Ioo (a\u2082 \u2293 b\u2082) (a\u2082 \u2294 b\u2082) \\ s, HasFDerivAt f (f' x) x) \u2192\n        (\u2200 x \u2208 Set.Ioo (a\u2081 \u2293 b\u2081) (a\u2081 \u2294 b\u2081) \u00d7\u02e2 Set.Ioo (a\u2082 \u2293 b\u2082) (a\u2082 \u2294 b\u2082) \\ s, HasFDerivAt g (g' x) x) \u2192\n          IntegrableOn (fun x \u21a6 (f' x) (1, 0) + (g' x) (0, 1)) ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]]) volume \u2192\n            b\u2081 \u2264 a\u2081 \u2192\n              \u222b (x : \u211d) in b\u2081..a\u2081, \u222b (y : \u211d) in a\u2082..b\u2082, (f' (x, y)) (1, 0) + (g' (x, y)) (0, 1) =\n                (((\u222b (x : \u211d) in b\u2081..a\u2081, g (x, b\u2082)) - \u222b (x : \u211d) in b\u2081..a\u2081, g (x, a\u2082)) + \u222b (y : \u211d) in a\u2082..b\u2082, f (a\u2081, y)) -\n                  \u222b (y : \u211d) in a\u2082..b\u2082, f (b\u2081, y)\n\u22a2 -((((\u222b (x : \u211d) in b\u2081..a\u2081, g (x, b\u2082)) - \u222b (x : \u211d) in b\u2081..a\u2081, g (x, a\u2082)) + \u222b (y : \u211d) in a\u2082..b\u2082, f (a\u2081, y)) -\n        \u222b (y : \u211d) in a\u2082..b\u2082, f (b\u2081, y)) =\n    (((-\u222b (x : \u211d) in b\u2081..a\u2081, g (x, b\u2082)) - -\u222b (x : \u211d) in b\u2081..a\u2081, g (x, a\u2082)) + \u222b (y : \u211d) in a\u2082..b\u2082, f (b\u2081, y)) -\n      \u222b (y : \u211d) in a\u2082..b\u2082, f (a\u2081, y)",["abel"]],["MeasureTheory/Integral/DivergenceTheorem.lean",502,"case inr\nE : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : CompleteSpace E\nf g : \u211d \u00d7 \u211d \u2192 E\nf' g' : \u211d \u00d7 \u211d \u2192 \u211d \u00d7 \u211d \u2192L[\u211d] E\na\u2082 b\u2082 : \u211d\ns : Set (\u211d \u00d7 \u211d)\nhs : s.Countable\na\u2081 b\u2081 : \u211d\nHcf : ContinuousOn f ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]])\nHcg : ContinuousOn g ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]])\nHdf : \u2200 x \u2208 Set.Ioo (a\u2081 \u2293 b\u2081) (a\u2081 \u2294 b\u2081) \u00d7\u02e2 Set.Ioo (a\u2082 \u2293 b\u2082) (a\u2082 \u2294 b\u2082) \\ s, HasFDerivAt f (f' x) x\nHdg : \u2200 x \u2208 Set.Ioo (a\u2081 \u2293 b\u2081) (a\u2081 \u2294 b\u2081) \u00d7\u02e2 Set.Ioo (a\u2082 \u2293 b\u2082) (a\u2082 \u2294 b\u2082) \\ s, HasFDerivAt g (g' x) x\nHi : IntegrableOn (fun x \u21a6 (f' x) (1, 0) + (g' x) (0, 1)) ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]]) volume\nh\u2081 : a\u2081 \u2264 b\u2081\nh\u2082 : \u00aca\u2082 \u2264 b\u2082\nthis :\n  ContinuousOn f ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]]) \u2192\n    ContinuousOn g ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]]) \u2192\n      (\u2200 x \u2208 Set.Ioo (a\u2081 \u2293 b\u2081) (a\u2081 \u2294 b\u2081) \u00d7\u02e2 Set.Ioo (a\u2082 \u2293 b\u2082) (a\u2082 \u2294 b\u2082) \\ s, HasFDerivAt f (f' x) x) \u2192\n        (\u2200 x \u2208 Set.Ioo (a\u2081 \u2293 b\u2081) (a\u2081 \u2294 b\u2081) \u00d7\u02e2 Set.Ioo (a\u2082 \u2293 b\u2082) (a\u2082 \u2294 b\u2082) \\ s, HasFDerivAt g (g' x) x) \u2192\n          IntegrableOn (fun x \u21a6 (f' x) (1, 0) + (g' x) (0, 1)) ([[a\u2081, b\u2081]] \u00d7\u02e2 [[a\u2082, b\u2082]]) volume \u2192\n            b\u2082 \u2264 a\u2082 \u2192\n              \u222b (x : \u211d) in a\u2081..b\u2081, \u222b (y : \u211d) in b\u2082..a\u2082, (f' (x, y)) (1, 0) + (g' (x, y)) (0, 1) =\n                (((\u222b (x : \u211d) in a\u2081..b\u2081, g (x, a\u2082)) - \u222b (x : \u211d) in a\u2081..b\u2081, g (x, b\u2082)) + \u222b (y : \u211d) in b\u2082..a\u2082, f (b\u2081, y)) -\n                  \u222b (y : \u211d) in b\u2082..a\u2082, f (a\u2081, y)\n\u22a2 -((((\u222b (x : \u211d) in a\u2081..b\u2081, g (x, a\u2082)) - \u222b (x : \u211d) in a\u2081..b\u2081, g (x, b\u2082)) + \u222b (y : \u211d) in b\u2082..a\u2082, f (b\u2081, y)) -\n        \u222b (y : \u211d) in b\u2082..a\u2082, f (a\u2081, y)) =\n    (((\u222b (x : \u211d) in a\u2081..b\u2081, g (x, b\u2082)) - \u222b (x : \u211d) in a\u2081..b\u2081, g (x, a\u2082)) + -\u222b (y : \u211d) in b\u2082..a\u2082, f (b\u2081, y)) -\n      -\u222b (y : \u211d) in b\u2082..a\u2082, f (a\u2081, y)",["abel"]],["Algebra/Algebra/Unitization.lean",440,"R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring A\ninst\u271d : Module R A\nx\u2081 x\u2082 x\u2083 : Unitization R A\n\u22a2 x\u2081.1 \u2022 x\u2082.2 + x\u2081.1 \u2022 x\u2083.2 + (x\u2082.1 \u2022 x\u2081.2 + x\u2083.1 \u2022 x\u2081.2) + (x\u2081.2 * x\u2082.2 + x\u2081.2 * x\u2083.2) =\n    x\u2081.1 \u2022 x\u2082.2 + x\u2082.1 \u2022 x\u2081.2 + x\u2081.2 * x\u2082.2 + (x\u2081.1 \u2022 x\u2083.2 + x\u2083.1 \u2022 x\u2081.2 + x\u2081.2 * x\u2083.2)",["abel"]],["Algebra/Lie/Weights/Killing.lean",287,"case hN.hadd\nK : Type u_2\nL : Type u_3\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : LieAlgebra K L\ninst\u271d\u2074 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b3 : H.IsCartanSubalgebra\ninst\u271d\u00b2 : IsKilling K L\ninst\u271d\u00b9 : IsTriangularizable K (\u21a5H) L\ninst\u271d : PerfectField K\nx : L\nhx : x \u2208 H\nN S : End K L\nhN : _root_.IsNilpotent ((ad K L) x - S)\nhS : S.IsSemisimple\nhSN : (ad K L) x = N + S\nhS\u2080 : Commute ((ad K L) x) S\nx' : \u21a5H := \u27e8x, hx\u27e9\naux : \u2200 {\u03b1 : \u21a5H \u2192 K} {y : L}, y \u2208 rootSpace H \u03b1 \u2192 S y = \u03b1 x' \u2022 y\nh_der : \u2200 (y z : L) (\u03b1 \u03b2 : \u21a5H \u2192 K), y \u2208 rootSpace H \u03b1 \u2192 z \u2208 rootSpace H \u03b2 \u2192 S \u2045y, z\u2046 = \u2045S y, z\u2046 + \u2045y, S z\u2046\ny\u271d\u00b9 z : L\n\u03b1 : \u21a5H \u2192 K\ny : L\nhy : y \u2208 rootSpace H \u03b1\nx\u271d y\u271d : L\nhx\u271d : x\u271d \u2208 \u2a06 i, rootSpace H i\nhy\u271d : y\u271d \u2208 \u2a06 i, rootSpace H i\nh : S \u2045y, x\u271d\u2046 = \u2045S y, x\u271d\u2046 + \u2045y, S x\u271d\u2046\nh' : S \u2045y, y\u271d\u2046 = \u2045S y, y\u271d\u2046 + \u2045y, S y\u271d\u2046\n\u22a2 \u2045S y, x\u271d\u2046 + \u2045y, S x\u271d\u2046 + (\u2045S y, y\u271d\u2046 + \u2045y, S y\u271d\u2046) = \u2045S y, x\u271d\u2046 + \u2045S y, y\u271d\u2046 + (\u2045y, S x\u271d\u2046 + \u2045y, S y\u271d\u2046)",["abel"]],["Algebra/Lie/Weights/Killing.lean",289,"case hadd\nK : Type u_2\nL : Type u_3\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : LieAlgebra K L\ninst\u271d\u2074 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b3 : H.IsCartanSubalgebra\ninst\u271d\u00b2 : IsKilling K L\ninst\u271d\u00b9 : IsTriangularizable K (\u21a5H) L\ninst\u271d : PerfectField K\nx : L\nhx : x \u2208 H\nN S : End K L\nhN : _root_.IsNilpotent ((ad K L) x - S)\nhS : S.IsSemisimple\nhSN : (ad K L) x = N + S\nhS\u2080 : Commute ((ad K L) x) S\nx' : \u21a5H := \u27e8x, hx\u27e9\naux : \u2200 {\u03b1 : \u21a5H \u2192 K} {y : L}, y \u2208 rootSpace H \u03b1 \u2192 S y = \u03b1 x' \u2022 y\nh_der : \u2200 (y z : L) (\u03b1 \u03b2 : \u21a5H \u2192 K), y \u2208 rootSpace H \u03b1 \u2192 z \u2208 rootSpace H \u03b2 \u2192 S \u2045y, z\u2046 = \u2045S y, z\u2046 + \u2045y, S z\u2046\ny z : L\nhz : z \u2208 \u2a06 \u03b1, rootSpace H \u03b1\nx\u271d y\u271d : L\nhx\u271d : x\u271d \u2208 \u2a06 i, rootSpace H i\nhy\u271d : y\u271d \u2208 \u2a06 i, rootSpace H i\nh : S \u2045x\u271d, z\u2046 = \u2045S x\u271d, z\u2046 + \u2045x\u271d, S z\u2046\nh' : S \u2045y\u271d, z\u2046 = \u2045S y\u271d, z\u2046 + \u2045y\u271d, S z\u2046\n\u22a2 \u2045S x\u271d, z\u2046 + \u2045x\u271d, S z\u2046 + (\u2045S y\u271d, z\u2046 + \u2045y\u271d, S z\u2046) = \u2045S x\u271d, z\u2046 + \u2045S y\u271d, z\u2046 + (\u2045x\u271d, S z\u2046 + \u2045y\u271d, S z\u2046)",["abel"]],["Analysis/SpecialFunctions/Complex/Arg.lean",116,"case h.e'_4.h.e'_4\n\u03b8 : \u211d\n\u22a2 \u03c0 = -\u03c0 + 2 * \u03c0",["ring","linarith"]],["Analysis/SpecialFunctions/Complex/Arg.lean",324,"case h.e'_4.h.e'_4\n\u03b8 : \u211d\n\u22a2 \u03c0 = -\u03c0 + 2 * \u03c0",["ring","linarith"]],["Analysis/SpecialFunctions/Complex/Arg.lean",451,"case h.e'_4.h.e'_4\nr : \u211d\nhr : 0 < r\n\u03b8 : \u211d\n\u22a2 \u03c0 = -\u03c0 + 2 * \u03c0",["ring","linarith"]],["MeasureTheory/Measure/SeparableMeasure.lean",504,"case e_a\nX : Type u_1\nE : Type u_2\nm : MeasurableSpace X\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03bc : Measure X\np : \u211d\u22650\u221e\none_le_p : Fact (1 \u2264 p)\np_ne_top : Fact (p \u2260 \u22a4)\n\ud835\udc9c\u271d : Set (Set X)\ninst\u271d\u00b9 : IsSeparable \u03bc\ninst\u271d : SeparableSpace E\n\ud835\udc9c : Set (Set X)\ncount_\ud835\udc9c : \ud835\udc9c.Countable\nh\ud835\udc9c : \u03bc.MeasureDense \ud835\udc9c\n\ud835\udc9c\u2080 : Set (Set X) := {s | s \u2208 \ud835\udc9c \u2227 \u03bc s \u2260 \u22a4}\nh\ud835\udc9c\u2080 : \u03bc.MeasureDense \ud835\udc9c\u2080\ncount_\ud835\udc9c\u2080 : \ud835\udc9c\u2080.Countable\np_ne_zero : p \u2260 0\nu : Set E\ncountable_u : u.Countable\ndense_u : Dense u\nkey : (n : \u2115) \u2192 (Fin n \u2192 \u2191u) \u2192 (Fin n \u2192 \u2191\ud835\udc9c\u2080) \u2192 \u21a5(Lp E p \u03bc) := fun n d s \u21a6 \u2211 i : Fin n, indicatorConstLp p \u22ef \u22ef \u2191(d i)\nD : Set \u21a5(Lp E p \u03bc) := {s | \u2203 n d t, s = key n d t}\nf g : X \u2192 E\nhf : MemLp f p \u03bc\nhg : MemLp g p \u03bc\nf_mem : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 b \u2208 D, \u2016MemLp.toLp f hf - b\u2016 < \u03b5\ng_mem : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 b \u2208 D, \u2016MemLp.toLp g hg - b\u2016 < \u03b5\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\nbf : \u21a5(Lp E p \u03bc)\nhbf : \u2016MemLp.toLp f hf - bf\u2016 < \u03b5 / 2\nnf : \u2115\ndf : Fin nf \u2192 \u2191u\nsf : Fin nf \u2192 \u2191\ud835\udc9c\u2080\nbf_eq : bf = key nf df sf\nbg : \u21a5(Lp E p \u03bc)\nhbg : \u2016MemLp.toLp g hg - bg\u2016 < \u03b5 / 2\nng : \u2115\ndg : Fin ng \u2192 \u2191u\nsg : Fin ng \u2192 \u2191\ud835\udc9c\u2080\nbg_eq : bg = key ng dg sg\nd : Fin (nf + ng) \u2192 \u2191u := fun i \u21a6 if h : \u2191i < nf then df (i.castLT h) else dg (Fin.subNat nf (Fin.cast \u22ef i) \u22ef)\ns : Fin (nf + ng) \u2192 \u2191\ud835\udc9c\u2080 := fun i \u21a6 if h : \u2191i < nf then sf (i.castLT h) else sg (Fin.subNat nf (Fin.cast \u22ef i) \u22ef)\n\u22a2 MemLp.toLp f hf + MemLp.toLp g hg - (bf + bg) = MemLp.toLp f hf - bf + (MemLp.toLp g hg - bg)",["abel"]],["Topology/TietzeExtension.lean",209,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : NormalSpace Y\nf : X \u2192\u1d47 \u211d\ne : C(X, Y)\nhe : IsClosedEmbedding \u21d1e\nh3 : 0 < 3\nh23 : 0 < 2 / 3\nhf : 0 < \u2016f\u2016\nhc\u2082 : IsClosed (\u21d1e '' (\u21d1f \u207b\u00b9' Ici (\u2016f\u2016 / 3)))\ng : Y \u2192\u1d47 \u211d\nhg\u2082 : EqOn (\u21d1g) (Function.const Y (\u2016f\u2016 / 3)) (\u21d1e '' (\u21d1f \u207b\u00b9' Ici (\u2016f\u2016 / 3)))\nx : X\nhfx : -\u2016f\u2016 \u2264 f x \u2227 f x \u2264 \u2016f\u2016\nhle\u2082 : f x \u2264 \u2016f\u2016 / 3\nhf3 : -(\u2016f\u2016 / 3) < \u2016f\u2016 / 3\nhc\u2081 : IsClosed (\u21d1e '' (\u21d1f \u207b\u00b9' Iic (-(\u2016f\u2016 / 3))))\nhd : Disjoint (\u21d1e '' (\u21d1f \u207b\u00b9' Iic (-(\u2016f\u2016 / 3)))) (\u21d1e '' (\u21d1f \u207b\u00b9' Ici (\u2016f\u2016 / 3)))\nhg\u2081 : EqOn (\u21d1g) (Function.const Y (-(\u2016f\u2016 / 3))) (\u21d1e '' (\u21d1f \u207b\u00b9' Iic (-(\u2016f\u2016 / 3))))\nhgf : \u2200 (x : Y), g x \u2208 Icc (-(\u2016f\u2016 / 3)) (\u2016f\u2016 / 3)\nhle\u2081 : -(\u2016f\u2016 / 3) \u2264 f x\n\u22a2 \u2016f\u2016 / 3 + \u2016f\u2016 / 3 = 2 / 3 * \u2016f\u2016",["linarith","ring"]],["Topology/TietzeExtension.lean",342,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : NormalSpace Y\ninst\u271d : Nonempty X\nf : X \u2192\u1d47 \u211d\ne : X \u2192 Y\nhe : IsClosedEmbedding e\ninhabited_h : Inhabited X\na : \u211d\nha : IsGLB (range \u21d1f) a\nb : \u211d\nhb : IsLUB (range \u21d1f) b\nhmem : \u2200 (x : X), f x \u2208 Icc a b\nhle : a \u2264 b\nhlt : a < b\nc : \u211d := (a + b) / 2\nhac : a < c\nhcb : c < b\n\u22a2 a + b - 2 * a = b * 2 - (a + b)",["ring","linarith"]],["MeasureTheory/Integral/VitaliCaratheodory.lean",149,"case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : \u03bc.WeaklyRegular\nf\u2081 f\u2082 : \u03b1 \u2192\u209b \u211d\u22650\na\u271d : Disjoint (Function.support \u21d1f\u2081) (Function.support \u21d1f\u2082)\nh\u2081 :\n  \u2200 {\u03b5 : \u211d\u22650\u221e},\n    \u03b5 \u2260 0 \u2192 \u2203 g, (\u2200 (x : \u03b1), f\u2081 x \u2264 g x) \u2227 LowerSemicontinuous g \u2227 \u222b\u207b (x : \u03b1), \u2191(g x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), \u2191(f\u2081 x) \u2202\u03bc + \u03b5\nh\u2082 :\n  \u2200 {\u03b5 : \u211d\u22650\u221e},\n    \u03b5 \u2260 0 \u2192 \u2203 g, (\u2200 (x : \u03b1), f\u2082 x \u2264 g x) \u2227 LowerSemicontinuous g \u2227 \u222b\u207b (x : \u03b1), \u2191(g x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), \u2191(f\u2082 x) \u2202\u03bc + \u03b5\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 \u2260 0\ng\u2081 : \u03b1 \u2192 \u211d\u22650\nf\u2081_le_g\u2081 : \u2200 (x : \u03b1), f\u2081 x \u2264 g\u2081 x\ng\u2081cont : LowerSemicontinuous g\u2081\ng\u2081int : \u222b\u207b (x : \u03b1), \u2191(g\u2081 x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), \u2191(f\u2081 x) \u2202\u03bc + \u03b5 / 2\ng\u2082 : \u03b1 \u2192 \u211d\u22650\nf\u2082_le_g\u2082 : \u2200 (x : \u03b1), f\u2082 x \u2264 g\u2082 x\ng\u2082cont : LowerSemicontinuous g\u2082\ng\u2082int : \u222b\u207b (x : \u03b1), \u2191(g\u2082 x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), \u2191(f\u2082 x) \u2202\u03bc + \u03b5 / 2\n\u22a2 \u222b\u207b (a : \u03b1), \u2191(f\u2081 a) \u2202\u03bc + \u222b\u207b (a : \u03b1), \u2191(f\u2082 a) \u2202\u03bc + (\u03b5 / 2 + \u03b5 / 2) =\n    \u222b\u207b (x : \u03b1), \u2191(f\u2081 x) \u2202\u03bc + \u03b5 / 2 + (\u222b\u207b (x : \u03b1), \u2191(f\u2082 x) \u2202\u03bc + \u03b5 / 2)",["abel","ring"]],["MeasureTheory/Integral/VitaliCaratheodory.lean",364,"case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : \u03bc.WeaklyRegular\nf\u2081 f\u2082 : \u03b1 \u2192\u209b \u211d\u22650\na\u271d : Disjoint (Function.support \u21d1f\u2081) (Function.support \u21d1f\u2082)\nh\u2081 :\n  \u222b\u207b (x : \u03b1), \u2191(f\u2081 x) \u2202\u03bc \u2260 \u22a4 \u2192\n    \u2200 {\u03b5 : \u211d\u22650\u221e},\n      \u03b5 \u2260 0 \u2192 \u2203 g, (\u2200 (x : \u03b1), g x \u2264 f\u2081 x) \u2227 UpperSemicontinuous g \u2227 \u222b\u207b (x : \u03b1), \u2191(f\u2081 x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), \u2191(g x) \u2202\u03bc + \u03b5\nh\u2082 :\n  \u222b\u207b (x : \u03b1), \u2191(f\u2082 x) \u2202\u03bc \u2260 \u22a4 \u2192\n    \u2200 {\u03b5 : \u211d\u22650\u221e},\n      \u03b5 \u2260 0 \u2192 \u2203 g, (\u2200 (x : \u03b1), g x \u2264 f\u2082 x) \u2227 UpperSemicontinuous g \u2227 \u222b\u207b (x : \u03b1), \u2191(f\u2082 x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), \u2191(g x) \u2202\u03bc + \u03b5\nint_f : \u222b\u207b (x : \u03b1), \u2191((f\u2081 + f\u2082) x) \u2202\u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 \u2260 0\nA : \u222b\u207b (x : \u03b1), \u2191(f\u2081 x) \u2202\u03bc + \u222b\u207b (x : \u03b1), \u2191(f\u2082 x) \u2202\u03bc \u2260 \u22a4\ng\u2081 : \u03b1 \u2192 \u211d\u22650\nf\u2081_le_g\u2081 : \u2200 (x : \u03b1), g\u2081 x \u2264 f\u2081 x\ng\u2081cont : UpperSemicontinuous g\u2081\ng\u2081int : \u222b\u207b (x : \u03b1), \u2191(f\u2081 x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), \u2191(g\u2081 x) \u2202\u03bc + \u03b5 / 2\ng\u2082 : \u03b1 \u2192 \u211d\u22650\nf\u2082_le_g\u2082 : \u2200 (x : \u03b1), g\u2082 x \u2264 f\u2082 x\ng\u2082cont : UpperSemicontinuous g\u2082\ng\u2082int : \u222b\u207b (x : \u03b1), \u2191(f\u2082 x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), \u2191(g\u2082 x) \u2202\u03bc + \u03b5 / 2\n\u22a2 \u222b\u207b (a : \u03b1), \u2191(g\u2081 a) \u2202\u03bc + \u222b\u207b (a : \u03b1), \u2191(g\u2082 a) \u2202\u03bc + (\u03b5 / 2 + \u03b5 / 2) =\n    \u222b\u207b (x : \u03b1), \u2191(g\u2081 x) \u2202\u03bc + \u03b5 / 2 + (\u222b\u207b (x : \u03b1), \u2191(g\u2082 x) \u2202\u03bc + \u03b5 / 2)",["abel","ring"]],["MeasureTheory/Integral/VitaliCaratheodory.lean",478,"\u03b1 : Type u_1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : BorelSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : \u03bc.WeaklyRegular\ninst\u271d : SigmaFinite \u03bc\nf : \u03b1 \u2192 \u211d\nhf : Integrable f \u03bc\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\u22650 := \u27e8\u03b5 / 2, \u22ef\u27e9\n\u03b4pos : 0 < \u03b4\nfp : \u03b1 \u2192 \u211d\u22650 := fun x \u21a6 (f x).toNNReal\nint_fp : Integrable (fun x \u21a6 \u2191(fp x)) \u03bc\ngp : \u03b1 \u2192 \u211d\u22650\u221e\nfp_lt_gp : \u2200 (x : \u03b1), \u2191(fp x) < gp x\ngpcont : LowerSemicontinuous gp\ngp_lt_top : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, gp x < \u22a4\ngp_integrable : Integrable (fun x \u21a6 (gp x).toReal) \u03bc\ngpint : \u222b (x : \u03b1), (gp x).toReal \u2202\u03bc < \u222b (x : \u03b1), \u2191(fp x) \u2202\u03bc + (fun a \u21a6 \u2191a) \u03b4\nfm : \u03b1 \u2192 \u211d\u22650 := fun x \u21a6 (-f x).toNNReal\nint_fm : Integrable (fun x \u21a6 \u2191(fm x)) \u03bc\ngm : \u03b1 \u2192 \u211d\u22650\ngm_le_fm : \u2200 (x : \u03b1), gm x \u2264 fm x\ngmcont : UpperSemicontinuous gm\ngm_integrable : Integrable (fun x \u21a6 \u2191(gm x)) \u03bc\ngmint : \u222b (x : \u03b1), \u2191(fm x) \u2202\u03bc - (fun a \u21a6 \u2191a) \u03b4 \u2264 \u222b (x : \u03b1), \u2191(gm x) \u2202\u03bc\ng : \u03b1 \u2192 EReal := fun x \u21a6 \u2191(gp x) - \u2191\u2191(gm x)\nae_g : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, (g x).toReal = (\u2191(gp x)).toReal - (\u2191\u2191(gm x)).toReal\n\u22a2 \u222b (x : \u03b1), \u2191(fp x) \u2202\u03bc + \u2191\u03b4 - (\u222b (x : \u03b1), \u2191(fm x) \u2202\u03bc - \u2191\u03b4) =\n    \u222b (a : \u03b1), \u2191(f a).toNNReal \u2202\u03bc - \u222b (a : \u03b1), \u2191(-f a).toNNReal \u2202\u03bc + 2 * \u2191\u03b4",["ring","linarith"]],["Analysis/Calculus/UniformLimitsDeriv.lean",345,"case h.e_a\n\u03b9 : Type u_1\nl : Filter \u03b9\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\n\ud835\udd5c : Type u_3\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : IsRCLikeNormedField \ud835\udd5c\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\nf : \u03b9 \u2192 E \u2192 G\ng : E \u2192 G\nf' : \u03b9 \u2192 E \u2192 E \u2192L[\ud835\udd5c] G\ng' : E \u2192 E \u2192L[\ud835\udd5c] G\nx : E\ninst\u271d : l.NeBot\nhf' : TendstoUniformlyOnFilter f' g' l (\ud835\udcdd x)\nhf : \u2200\u1da0 (n : \u03b9 \u00d7 E) in l \u00d7\u02e2 \ud835\udcdd x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2\nhfg : \u2200\u1da0 (y : E) in \ud835\udcdd x, Tendsto (fun n \u21a6 f n y) l (\ud835\udcdd (g y))\nthis : RCLike \ud835\udd5c := IsRCLikeNormedField.rclike \ud835\udd5c\nx\u271d : \u03b9 \u00d7 E\n\u22a2 g x\u271d.2 - g x - ((g' x) x\u271d.2 - (g' x) x) =\n    g x\u271d.2 - g x - ((f' x\u271d.1 x) x\u271d.2 - (f' x\u271d.1 x) x) + ((f' x\u271d.1 x) x\u271d.2 - (g' x) x\u271d.2 - ((f' x\u271d.1 x) x - (g' x) x))",["abel"]],["NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean",442,"case e_a.e_z\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nn : \u2124\n\u22a2 2 * \u2191\u03c0 * I * \u2191n * (z + \u03c4) + \u2191\u03c0 * I * \u2191n ^ 2 * \u03c4 =\n    (2 * \u2191\u03c0 * I * \u2191n + 2 * \u2191\u03c0 * I) * z + \u2191\u03c0 * I * (\u2191n + 1) ^ 2 * \u03c4 + -\u2191\u03c0 * I * (\u03c4 + 2 * z)",["ring"]],["NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean",497,"case e_a.e_a.e_z\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nh0 : \u03c4 \u2260 0\nh2 : 0 < (-I * \u03c4).re\n\u22a2 \u2191\u03c0 * I * (-1 / \u03c4) * z ^ 2 = -\u2191\u03c0 * I * z ^ 2 / \u03c4",["ring"]],["NumberTheory/Pell.lean",383,"case intro.intro.intro.intro.intro.intro.intro.intro.refine_1\nd : \u2124\nh\u2080 : 0 < d\nhd : \u00acIsSquare d\n\u03be : \u211d := \u221a\u2191d\nh\u03be : Irrational \u03be\nM : \u2124\nhM\u2081 : 2 * |\u03be| + 1 < \u2191M\nhM : {q | |q.num ^ 2 - d * \u2191q.den ^ 2| < M}.Infinite\nm : \u2124\nhm : {q | q.num ^ 2 - d * \u2191q.den ^ 2 = m}.Infinite\nthis : NeZero m.natAbs\nf : \u211a \u2192 ZMod m.natAbs \u00d7 ZMod m.natAbs := fun q \u21a6 (\u2191q.num, \u2191q.den)\nq\u2081 : \u211a\nh\u2081 : q\u2081.num ^ 2 - d * \u2191q\u2081.den ^ 2 = m\nq\u2082 : \u211a\nh\u2082 : q\u2082.num ^ 2 - d * \u2191q\u2082.den ^ 2 = m\nhne : q\u2081 \u2260 q\u2082\nhqf : f q\u2081 = f q\u2082\nhq1 : \u2191q\u2081.num = \u2191q\u2082.num\nhq2 : \u2191q\u2081.den = \u2191q\u2082.den\nhd\u2081 : m \u2223 q\u2081.num * q\u2082.num - d * (\u2191q\u2081.den * \u2191q\u2082.den)\nhd\u2082 : m \u2223 q\u2081.num * \u2191q\u2082.den - q\u2082.num * \u2191q\u2081.den\nhm\u2080 : \u2191m \u2260 0\n\u22a2 (q\u2081.num * q\u2082.num - d * (\u2191q\u2081.den * \u2191q\u2082.den)) ^ 2 - d * (q\u2081.num * \u2191q\u2082.den - q\u2082.num * \u2191q\u2081.den) ^ 2 =\n    (q\u2081.num ^ 2 - d * \u2191q\u2081.den ^ 2) * (q\u2082.num ^ 2 - d * \u2191q\u2082.den ^ 2)",["ring","linarith"]],["NumberTheory/Pell.lean",535,"d : \u2124\na\u2081 : Solution\u2081 d\nh : IsFundamental a\u2081\na : Solution\u2081 d\nhax : 1 < a.x\nhay : 0 < a.y\n\u22a2 d * (a\u2081.y ^ 2 - a.y ^ 2) = 1 + d * a\u2081.y ^ 2 - (1 + d * a.y ^ 2)",["ring","linarith"]],["NumberTheory/Pell.lean",580,"case h.e'_3\nd : \u2124\na\u2081 : Solution\u2081 d\nh : IsFundamental a\u2081\na : Solution\u2081 d\nhax : 1 < a.x\nhay : 0 < a.y\nthis : a.y - a.x * a\u2081.y < 0\n\u22a2 a.y * (1 + d * a\u2081.y ^ 2) - a\u2081.y * (d * (a.y * a\u2081.y) + a.x) = a.y - a.x * a\u2081.y",["ring","linarith"]],["LinearAlgebra/AffineSpace/AffineMap.lean",453,"k : Type u_1\nV1 : Type u_2\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V1\ninst\u271d : Module k V1\np\u2080 p\u2081 : V1\nc : k\n\u22a2 c \u2022 p\u2081 - c \u2022 p\u2080 + p\u2080 = p\u2080 - c \u2022 p\u2080 + c \u2022 p\u2081",["abel"]],["RingTheory/Polynomial/Chebyshev.lean",138,"case add_two\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval 1 (T R (\u2191n + 1)) = 1\nih2 : eval 1 (T R \u2191n) = 1\n\u22a2 2 - 1 = 1",["norm_num","ring"]],["RingTheory/Polynomial/Chebyshev.lean",139,"case neg_add_one\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval 1 (T R (-\u2191n)) = 1\nih2 : eval 1 (T R (-\u2191n + 1)) = 1\n\u22a2 2 - 1 = 1",["norm_num"]],["RingTheory/Polynomial/Chebyshev.lean",228,"case one\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 2 = 1 + 1",["norm_num","ring"]],["RingTheory/Polynomial/Chebyshev.lean",243,"case one\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 -2 = -1 + -1",["norm_num","ring"]],["RingTheory/Polynomial/Chebyshev.lean",359,"case add_two\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval 2 (C R (\u2191n + 1)) = 2\nih2 : eval 2 (C R \u2191n) = 2\n\u22a2 2 * 2 - 2 = 2",["norm_num","ring"]],["RingTheory/Polynomial/Chebyshev.lean",360,"case neg_add_one\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval 2 (C R (-\u2191n)) = 2\nih2 : eval 2 (C R (-\u2191n + 1)) = 2\n\u22a2 2 * 2 - 2 = 2",["norm_num"]],["RingTheory/Polynomial/Chebyshev.lean",460,"case one\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 2 = 1 + 1",["norm_num","ring"]],["RingTheory/Polynomial/Chebyshev.lean",475,"case one\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 -2 = -1 + -1",["norm_num","ring"]],["RingTheory/Polynomial/Chebyshev.lean",109,"R : Type u_1\ninst\u271d : CommRing R\n\u22a2 2 * X * 1 - X = X",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",118,"case one\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 2 * X * 1 - X = X",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",152,"case add_two\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval (-1) (T R (\u2191n + 1)) = \u2191\u2191(\u2191n + 1).negOnePow\nih2 : eval (-1) (T R \u2191n) = \u2191\u2191(\u2191n).negOnePow\n\u22a2 2 * \u2191\u2191(\u2191n).negOnePow - \u2191\u2191(\u2191n).negOnePow = \u2191\u2191(\u2191n).negOnePow",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",157,"case neg_add_one\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval (-1) (T R (-\u2191n)) = \u2191\u2191(-\u2191n).negOnePow\nih2 : eval (-1) (T R (-\u2191n + 1)) = \u2191\u2191(-\u2191n + 1).negOnePow\n\u22a2 -(2 * \u2191\u2191(-\u2191n).negOnePow) + \u2191\u2191(-\u2191n).negOnePow = -\u2191\u2191(-\u2191n).negOnePow",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",232,"case add_two\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval 1 (U R (\u2191n + 1)) = \u2191(\u2191n + 1) + 1\nih2 : eval 1 (U R \u2191n) = \u2191\u2191n + 1\n\u22a2 2 * (\u2191n + 1 + 1) - (\u2191n + 1) = \u2191n + 2 + 1",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",237,"case neg_add_one\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval 1 (U R (-\u2191n)) = \u2191(-\u2191n) + 1\nih2 : eval 1 (U R (-\u2191n + 1)) = \u2191(-\u2191n + 1) + 1\n\u22a2 2 * (-\u2191n + 1) - (-\u2191n + 1 + 1) = -\u2191n",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",250,"case add_two\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval (-1) (U R (\u2191n + 1)) = \u2191\u2191(\u2191n + 1).negOnePow * (\u2191(\u2191n + 1) + 1)\nih2 : eval (-1) (U R \u2191n) = \u2191\u2191(\u2191n).negOnePow * (\u2191\u2191n + 1)\n\u22a2 2 * (\u2191\u2191(\u2191n).negOnePow * (\u2191n + 1 + 1)) - \u2191\u2191(\u2191n).negOnePow * (\u2191n + 1) = \u2191\u2191(\u2191n).negOnePow * (\u2191n + 2 + 1)",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",257,"case neg_add_one\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval (-1) (U R (-\u2191n)) = \u2191\u2191(-\u2191n).negOnePow * (\u2191(-\u2191n) + 1)\nih2 : eval (-1) (U R (-\u2191n + 1)) = \u2191\u2191(-\u2191n + 1).negOnePow * (\u2191(-\u2191n + 1) + 1)\n\u22a2 -(2 * (\u2191\u2191(\u2191n).negOnePow * (-\u2191n + 1))) + \u2191\u2191(\u2191n).negOnePow * (-\u2191n + 1 + 1) = \u2191\u2191(\u2191n).negOnePow * \u2191n",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",262,"case one\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 4 * X ^ 2 - 1 = X * (2 * X) + (2 * X ^ 2 - 1)",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",319,"R : Type u_1\ninst\u271d : CommRing R\n\u22a2 X * 2 - X = X",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",328,"case one\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 X * 2 - X = X",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",349,"case add_two\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : (C R (\u2191n + 1)).comp (2 * X) = 2 * T R (\u2191n + 1)\nih2 : (C R \u2191n).comp (2 * X) = 2 * T R \u2191n\n\u22a2 2 * X * (2 * T R (\u2191n + 1)) - 2 * T R \u2191n = 2 * (2 * X * T R (\u2191n + 1) - T R \u2191n)",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",352,"case neg_add_one\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : (C R (-\u2191n)).comp (2 * X) = 2 * T R (-\u2191n)\nih2 : (C R (-\u2191n + 1)).comp (2 * X) = 2 * T R (-\u2191n + 1)\n\u22a2 2 * X * (2 * T R (-\u2191n)) - 2 * T R (-\u2191n + 1) = 2 * (2 * X * T R (-\u2191n) - T R (-\u2191n + 1))",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",373,"case add_two\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval (-2) (C R (\u2191n + 1)) = 2 * \u2191\u2191(\u2191n + 1).negOnePow\nih2 : eval (-2) (C R \u2191n) = 2 * \u2191\u2191(\u2191n).negOnePow\n\u22a2 2 * (2 * \u2191\u2191(\u2191n).negOnePow) - 2 * \u2191\u2191(\u2191n).negOnePow = 2 * \u2191\u2191(\u2191n).negOnePow",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",378,"case neg_add_one\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval (-2) (C R (-\u2191n)) = 2 * \u2191\u2191(-\u2191n).negOnePow\nih2 : eval (-2) (C R (-\u2191n + 1)) = 2 * \u2191\u2191(-\u2191n + 1).negOnePow\n\u22a2 -(2 * (2 * \u2191\u2191(-\u2191n).negOnePow)) + 2 * \u2191\u2191(-\u2191n).negOnePow = -(2 * \u2191\u2191(-\u2191n).negOnePow)",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",464,"case add_two\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval 2 (S R (\u2191n + 1)) = \u2191(\u2191n + 1) + 1\nih2 : eval 2 (S R \u2191n) = \u2191\u2191n + 1\n\u22a2 2 * (\u2191n + 1 + 1) - (\u2191n + 1) = \u2191n + 2 + 1",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",469,"case neg_add_one\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval 2 (S R (-\u2191n)) = \u2191(-\u2191n) + 1\nih2 : eval 2 (S R (-\u2191n + 1)) = \u2191(-\u2191n + 1) + 1\n\u22a2 2 * (-\u2191n + 1) - (-\u2191n + 1 + 1) = -\u2191n",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",482,"case add_two\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval (-2) (S R (\u2191n + 1)) = \u2191\u2191(\u2191n + 1).negOnePow * (\u2191(\u2191n + 1) + 1)\nih2 : eval (-2) (S R \u2191n) = \u2191\u2191(\u2191n).negOnePow * (\u2191\u2191n + 1)\n\u22a2 2 * (\u2191\u2191(\u2191n).negOnePow * (\u2191n + 1 + 1)) - \u2191\u2191(\u2191n).negOnePow * (\u2191n + 1) = \u2191\u2191(\u2191n).negOnePow * (\u2191n + 2 + 1)",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",489,"case neg_add_one\nR : Type u_1\ninst\u271d : CommRing R\nn : \u2115\nih1 : eval (-2) (S R (-\u2191n)) = \u2191\u2191(-\u2191n).negOnePow * (\u2191(-\u2191n) + 1)\nih2 : eval (-2) (S R (-\u2191n + 1)) = \u2191\u2191(-\u2191n + 1).negOnePow * (\u2191(-\u2191n + 1) + 1)\n\u22a2 -(2 * (\u2191\u2191(\u2191n).negOnePow * (-\u2191n + 1))) + \u2191\u2191(\u2191n).negOnePow * (-\u2191n + 1 + 1) = \u2191\u2191(\u2191n).negOnePow * \u2191n",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",500,"case hz\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 1 + X ^ 2 - X * X = 1",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",518,"case one\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 2 * (X ^ 2 - 1) = X * X + (X ^ 2 - 2)",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",659,"case one\nR : Type u_1\ninst\u271d : CommRing R\nm : \u2124\n\u22a2 2 * T R m * X = 2 * X * T R m - T R (m - 1) + T R (m - 1)",["ring"]],["RingTheory/Polynomial/Chebyshev.lean",678,"case one\nR : Type u_1\ninst\u271d : CommRing R\nm : \u2124\n\u22a2 C R m * X = X * C R m - C R (m - 1) + C R (m - 1)",["ring"]],["Topology/MetricSpace/Gluing.lean",357,"\u03b9 : Type u_1\nE : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 MetricSpace (E i)\ni : \u03b9\nx : E i\nk : \u03b9\nz : E k\nhik : i \u2260 k\ny : E i\n\u22a2 dist x y + dist y \u22ef.some + 1 + dist \u22ef.some z = dist x y + (dist y \u22ef.some + 1 + dist \u22ef.some z)",["abel","ring","linarith"]],["Topology/MetricSpace/Gluing.lean",364,"\u03b9 : Type u_1\nE : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 MetricSpace (E i)\ni : \u03b9\nx : E i\nj : \u03b9\ny : E j\nhij : i \u2260 j\nz : E j\nhik : i \u2260 j\n\u22a2 dist x \u22ef.some + 1 + (dist \u22ef.some y + dist y z) = dist x \u22ef.some + 1 + dist \u22ef.some y + dist y z",["abel","ring","linarith"]],["Topology/MetricSpace/Gluing.lean",408,"case refine_2.mk.mk.inr\n\u03b9 : Type u_1\nE : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 MetricSpace (E i)\ni : \u03b9\nx : E i\nj : \u03b9\ny : E j\nh : i \u2260 j\n\u22a2 dist x \u22ef.some + 1 + dist y \u22ef.some = dist y \u22ef.some + 1 + dist x \u22ef.some",["abel","ring","linarith"]],["Algebra/Algebra/Quasispectrum.lean",99,"R : Type u_1\ninst\u271d : NonUnitalSemiring R\nx y z : PreQuasiregular R\n\u22a2 z.val + (y.val + x.val + x.val * y.val) + (y.val * z.val + x.val * z.val + x.val * (y.val * z.val)) =\n    z.val + y.val + y.val * z.val + x.val + (x.val * z.val + x.val * y.val + x.val * (y.val * z.val))",["abel"]],["Algebra/Algebra/Quasispectrum.lean",160,"case h.e'_2\nR : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\nx : (PreQuasiregular A)\u02e3\n\u22a2 1 + \u2191(\u2191x).val + (\u2191(\u2191x\u207b\u00b9).val + \u2191(\u2191x).val * \u2191(\u2191x\u207b\u00b9).val) = 1 + (\u2191(\u2191x\u207b\u00b9).val + \u2191(\u2191x).val + \u2191(\u2191x).val * \u2191(\u2191x\u207b\u00b9).val)",["abel"]],["Algebra/Algebra/Quasispectrum.lean",166,"case h.e'_2\nR : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\nx : (PreQuasiregular A)\u02e3\n\u22a2 1 + \u2191(\u2191x\u207b\u00b9).val + (\u2191(\u2191x).val + \u2191(\u2191x\u207b\u00b9).val * \u2191(\u2191x).val) = 1 + (\u2191(\u2191x).val + \u2191(\u2191x\u207b\u00b9).val + \u2191(\u2191x\u207b\u00b9).val * \u2191(\u2191x).val)",["abel"]],["Analysis/NormedSpace/Multilinear/Curry.lean",63,"\ud835\udd5c : Type u\nn : \u2115\nEi : Fin n.succ \u2192 Type wEi\nG : Type wG\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : (i : Fin n.succ) \u2192 NormedAddCommGroup (Ei i)\ninst\u271d\u00b2 : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nf : Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i \u21a6 Ei i.succ) G\nm : (i : Fin n.succ) \u2192 Ei i\n\u22a2 \u2016f\u2016 * \u2016m 0\u2016 * \u220f i : Fin n, \u2016tail m i\u2016 = \u2016f\u2016 * (\u2016m 0\u2016 * \u220f i : Fin n, \u2016tail m i\u2016)",["ring","linarith"]],["NumberTheory/LSeries/HurwitzZetaOdd.lean",403,"a : \u211d\ns : \u2102\nhs : 1 < s.re\nc : \u2124 \u2192 \u2102 := fun n \u21a6 -I * cexp (2 * \u2191\u03c0 * I * \u2191a * \u2191n) / 2\nhc : \u2200 (n : \u2124), \u2016c n\u2016 = 1 / 2\nhF : \u2200 (t : \u211d), 0 < t \u2192 HasSum (fun n \u21a6 c n * \u2191n * \u2191(rexp (-\u03c0 * \u2191n ^ 2 * t))) (\u2191(sinKernel (\u2191a) t) / 2)\nh_sum : Summable fun i \u21a6 \u2016c i\u2016 / |\u2191i| ^ s.re\nn : \u2124\n\u22a2 -((s + 1).Gamma\u211d * I * \u2191(SignType.sign n) * cexp (2 * \u2191\u03c0 * I * \u2191a * \u2191n)) / \u2191|n| ^ s / 2 =\n    (s + 1).Gamma\u211d * c n * \u2191(SignType.sign n) / \u2191|n| ^ s",["ring"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",141,"case e_f.h.e_z\ns t : \u2102\nhs : 0 < s.re\nht : 0 < t.re\nconv_int :\n  \u222b (x : \u211d) in Ioi 0,\n      \u222b (t_1 : \u211d) in 0 ..x, \u2191(rexp (-t_1)) * \u2191t_1 ^ (s - 1) * (\u2191(rexp (-(x - t_1))) * \u2191(x - t_1) ^ (t - 1)) \u2202volume =\n    (\u222b (x : \u211d) in Ioi 0, \u2191(rexp (-x)) * \u2191x ^ (s - 1) \u2202volume) * \u222b (x : \u211d) in Ioi 0, \u2191(rexp (-x)) * \u2191x ^ (t - 1) \u2202volume\nhst : 0 < (s + t).re\nx : \u211d\nhx : x \u2208 Ioi 0\ny : \u211d\n\u22a2 -\u2191x = -\u2191y + -(\u2191x - \u2191y)",["abel","ring"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",216,"case succ.refine_2.e_a.e_a.e_f.h\nn : \u2115\nIH : \u2200 {u : \u2102}, 0 < u.re \u2192 u.betaIntegral (\u2191n + 1) = \u2191n ! / \u220f j \u2208 Finset.range (n + 1), (u + \u2191j)\nu : \u2102\nhu : 0 < u.re\nthis : u.betaIntegral (\u2191n.succ + 1) = \u2191n.succ * (u + 1).betaIntegral \u2191n.succ / u\nj : \u2115\n\u22a2 u + 1 + \u2191j = u + (\u2191j + 1)",["abel","ring"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",82,"case h.e'_3.h.e_a.e_a\nu v : \u2102\nhu : 0 < u.re\nhv : 0 < v.re\nx : \u211d\n\u22a2 1 - -\u2191x = \u2191x + 1\n```\n---\n```lean\ncase h.e'_3.h.e_a.e_a\nu v : \u2102\nhu : 0 < u.re\nhv : 0 < v.re\nx : \u211d\n\u22a2 -\u2191x = 1 - (\u2191x + 1)",["ring","abel"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",140,"s t : \u2102\nhs : 0 < s.re\nht : 0 < t.re\nconv_int :\n  \u222b (x : \u211d) in Ioi 0,\n      \u222b (t_1 : \u211d) in 0 ..x, \u2191(rexp (-t_1)) * \u2191t_1 ^ (s - 1) * (\u2191(rexp (-(x - t_1))) * \u2191(x - t_1) ^ (t - 1)) \u2202volume =\n    (\u222b (x : \u211d) in Ioi 0, \u2191(rexp (-x)) * \u2191x ^ (s - 1) \u2202volume) * \u222b (x : \u211d) in Ioi 0, \u2191(rexp (-x)) * \u2191x ^ (t - 1) \u2202volume\nhst : 0 < (s + t).re\nx : \u211d\nhx : x \u2208 Ioi 0\ny : \u211d\nthis : cexp (-\u2191x) = cexp (-\u2191y) * cexp (-(\u2191x - \u2191y))\n\u22a2 cexp (-\u2191y) * \u2191y ^ (s - 1) * (cexp (-(\u2191x - \u2191y)) * (\u2191x - \u2191y) ^ (t - 1)) =\n    cexp (-\u2191y) * cexp (-(\u2191x - \u2191y)) * (\u2191y ^ (s - 1) * (\u2191x - \u2191y) ^ (t - 1))",["ring"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",179,"case h.e'_9\nu v : \u2102\nhu : 0 < u.re\nhv : 0 < v.re\nF : \u211d \u2192 \u2102 := fun x \u21a6 \u2191x ^ u * (1 - \u2191x) ^ v\nhu' : 0 < (u + 1).re\nhv' : 0 < (v + 1).re\nhc : ContinuousOn F (Icc 0 1)\nx : \u211d\nhx : x \u2208 Ioo 0 1\nU : HasDerivAt (fun y \u21a6 y ^ u) (u * \u2191x ^ (u - 1)) \u2191x\nV : HasDerivAt (fun y \u21a6 (1 - y) ^ v) (-v * (1 - \u2191x) ^ (v - 1)) \u2191x\n\u22a2 u * (\u2191x ^ (u - 1) * (1 - \u2191x) ^ v) - v * (\u2191x ^ u * (1 - \u2191x) ^ (v - 1)) =\n    u * \u2191x ^ (u - 1) * (1 - \u2191x) ^ v + \u2191x ^ u * (-v * (1 - \u2191x) ^ (v - 1))",["ring"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",247,"case e_a.e_a.e_a\ns : \u2102\nn : \u2115\nhn : n \u2260 0\nx : \u2115\nx\u271d : x \u2208 Finset.range n\n\u22a2 s + 1 + \u2191x = s + (\u2191x + 1)",["ring","abel"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",271,"s : \u2102\nhs : 0 < s.re\nn : \u2115\nhn : n \u2260 0\nthis\u271d : \u2200 (x : \u211d), x = x / \u2191n * \u2191n\nthis :\n  \u222b (x : \u211d) in 0 ..\u2191n, \u2191((1 - x / \u2191n) ^ n) * \u2191(x / \u2191n * \u2191n) ^ (s - 1) =\n    \u2191n \u2022 \u222b (x : \u211d) in 0 / \u2191n..\u2191n / \u2191n, \u2191((1 - x) ^ n) * \u2191(x * \u2191n) ^ (s - 1)\nx : \u211d\nhx : x \u2208 Ioc 0 1\nhn' : \u2191n \u2260 0\nA : \u2191n ^ s = \u2191n ^ (s - 1) * \u2191n\nB : (\u2191x * \u2191n) ^ (s - 1) = \u2191x ^ (s - 1) * \u2191n ^ (s - 1)\n\u22a2 \u2191n ^ (s - 1) * \u2191n * (\u2191x ^ (s - 1) * (1 - \u2191x) ^ n) = \u2191n * ((1 - \u2191x) ^ n * (\u2191x ^ (s - 1) * \u2191n ^ (s - 1)))",["ring"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",380,"z : \u2102\nn : \u2115\nhn : n \u2260 0\na\u271d b\u271d c\u271d d\u271d : \u2102\n\u22a2 a\u271d * b\u271d * (c\u271d * d\u271d) = a\u271d * c\u271d * (b\u271d * d\u271d)",["ring"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",391,"z : \u2102\nn : \u2115\nhn : n \u2260 0\naux : \u2200 (a b c d : \u2102), a * b * (c * d) = a * c * (b * d)\nthis\u271d : \u2191n ^ z * \u2191n ^ (1 - z) = \u2191n\nj : \u2115\nthis : \u2191j + 1 \u2260 0\n\u22a2 (z + (\u2191j + 1)) * (1 - z + \u2191j) = (\u2191j + 1) ^ 2 - z ^ 2",["ring"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",241,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\ni j k : \u2124\nhij : i + -1 = j\nhik : k + -1 = i\n\u22a2 -F.d i k \u226b homotopyCofiber.inlX \u03c6 k i \u22ef + \u03c6.f i \u226b homotopyCofiber.inrX \u03c6 i =\n    \u03c6.f i \u226b homotopyCofiber.inrX \u03c6 i - F.d i k \u226b homotopyCofiber.inlX \u03c6 k i \u22ef",["abel"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",335,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : Cochain F K m\n\u03b2 : Cochain G K n\nh : m + 1 = n\nn' : \u2124\nhn' : n + 1 = n'\n\u22a2 (\u2191(fst \u03c6)).comp (\u03b4 m n \u03b1) \u22ef +\n      ((snd \u03c6).comp (\u03b4 n n' \u03b2) \u22ef + -(n.negOnePow \u2022 (\u2191(fst \u03c6)).comp ((Cochain.ofHom \u03c6).comp \u03b2 \u22ef) \u22ef)) =\n    (\u2191(fst \u03c6)).comp (\u03b4 m n \u03b1) \u22ef + -(n.negOnePow \u2022 (\u2191(fst \u03c6)).comp ((Cochain.ofHom \u03c6).comp \u03b2 \u22ef) \u22ef) +\n      (snd \u03c6).comp (\u03b4 n n' \u03b2) \u22ef",["abel"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",449,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : Cochain K F m\n\u03b2 : Cochain K G n\nh : n + 1 = m\nm' : \u2124\nhm' : m + 1 = m'\n\u22a2 \u03b1.comp ((Cochain.ofHom \u03c6).comp (Cochain.ofHom (inr \u03c6)) \u22ef) \u22ef + -(\u03b4 m m' \u03b1).comp (inl \u03c6) \u22ef +\n      (\u03b4 n m \u03b2).comp (Cochain.ofHom (inr \u03c6)) \u22ef =\n    -(\u03b4 m m' \u03b1).comp (inl \u03c6) \u22ef +\n      ((\u03b4 n m \u03b2).comp (Cochain.ofHom (inr \u03c6)) \u22ef + \u03b1.comp ((Cochain.ofHom \u03c6).comp (Cochain.ofHom (inr \u03c6)) \u22ef) \u22ef)",["abel"]],["NumberTheory/LSeries/ZMod.lean",346,"N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\ns : \u2102\n\u22a2 \u2191N ^ (-s) * \u2211 x : ZMod N, \u03a6 x * completedHurwitzZetaEven\u2080 (toAddCircle x) s - \u2191N ^ (-s) * (\u03a6 0 * s\u207b\u00b9) -\n        \u2191N ^ (-s) * ((\u2211 i : ZMod N, \u03a6 i) * (1 - s)\u207b\u00b9) +\n      \u2191N ^ (-s) * \u2211 j : ZMod N, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s =\n    \u2191N ^ (-s) * \u2211 j : ZMod N, \u03a6 j * completedHurwitzZetaEven\u2080 (toAddCircle j) s +\n          \u2191N ^ (-s) * \u2211 j : ZMod N, \u03a6 j * completedHurwitzZetaOdd (toAddCircle j) s -\n        \u2191N ^ (-s) * (\u03a6 0 * s\u207b\u00b9) -\n      \u2191N ^ (-s) * ((\u2211 i : ZMod N, \u03a6 i) * (1 - s)\u207b\u00b9)",["abel","ring"]],["NumberTheory/LSeries/ZMod.lean",449,"N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\nh\u03a6 : Function.Odd \u03a6\ns : \u2102\nhs : 1 < s.re\n\u22a2 (-\u2211 x : ZMod N, \u03a6 x * expZeta (toAddCircle (-x)) s) / (2 * I) -\n      (\u2211 x : ZMod N, \u03a6 x * expZeta (toAddCircle (-x)) s) / (2 * I) =\n    -(I\u207b\u00b9 * \u2211 x : ZMod N, \u03a6 x * expZeta (toAddCircle (-x)) s)",["ring"]],["Data/Complex/Exponential.lean",605,"x : \u211d\nh1 : 0 < x\nh2 : x < 1\n\u22a2 x ^ 3 = 1 - (1 + x + x ^ 2) * (1 - x)",["ring","linarith"]],["Algebra/Homology/ShortComplex/Preadditive.lean",416,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.100018, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 \u03c6\u2082.\u03c4\u2081 = -S\u2081.f \u226b h.h\u2081 + -h.h\u2080 + (S\u2081.f \u226b h.h\u2081 + h.h\u2080 + \u03c6\u2082.\u03c4\u2081)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",417,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.100018, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 \u03c6\u2082.\u03c4\u2082 = -S\u2081.g \u226b h.h\u2082 + -h.h\u2081 \u226b S\u2082.f + (S\u2081.g \u226b h.h\u2082 + h.h\u2081 \u226b S\u2082.f + \u03c6\u2082.\u03c4\u2082)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",418,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.100018, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 \u03c6\u2082.\u03c4\u2083 = -h.h\u2083 + -h.h\u2082 \u226b S\u2082.g + (h.h\u2083 + h.h\u2082 \u226b S\u2082.g + \u03c6\u2082.\u03c4\u2083)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",427,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.104862, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 -\u03c6\u2082.\u03c4\u2081 + -(S\u2081.f \u226b h.h\u2081 + h.h\u2080) = -S\u2081.f \u226b h.h\u2081 + -h.h\u2080 + -\u03c6\u2082.\u03c4\u2081",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",428,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.104862, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 -\u03c6\u2082.\u03c4\u2082 + -(S\u2081.g \u226b h.h\u2082 + h.h\u2081 \u226b S\u2082.f) = -S\u2081.g \u226b h.h\u2082 + -h.h\u2081 \u226b S\u2082.f + -\u03c6\u2082.\u03c4\u2082",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",429,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.104862, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 -(h.h\u2083 + h.h\u2082 \u226b S\u2082.g + \u03c6\u2082.\u03c4\u2083) = -h.h\u2083 + -h.h\u2082 \u226b S\u2082.g + -\u03c6\u2082.\u03c4\u2083",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",438,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.113332, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh\u2081\u2082 : Homotopy \u03c6\u2081 \u03c6\u2082\nh\u2082\u2083 : Homotopy \u03c6\u2082 \u03c6\u2083\n\u22a2 S\u2081.f \u226b h\u2081\u2082.h\u2081 + h\u2081\u2082.h\u2080 + (S\u2081.f \u226b h\u2082\u2083.h\u2081 + h\u2082\u2083.h\u2080 + \u03c6\u2083.\u03c4\u2081) = S\u2081.f \u226b h\u2081\u2082.h\u2081 + S\u2081.f \u226b h\u2082\u2083.h\u2081 + (h\u2081\u2082.h\u2080 + h\u2082\u2083.h\u2080) + \u03c6\u2083.\u03c4\u2081",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",439,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.113332, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh\u2081\u2082 : Homotopy \u03c6\u2081 \u03c6\u2082\nh\u2082\u2083 : Homotopy \u03c6\u2082 \u03c6\u2083\n\u22a2 S\u2081.g \u226b h\u2081\u2082.h\u2082 + h\u2081\u2082.h\u2081 \u226b S\u2082.f + (S\u2081.g \u226b h\u2082\u2083.h\u2082 + h\u2082\u2083.h\u2081 \u226b S\u2082.f + \u03c6\u2083.\u03c4\u2082) =\n    S\u2081.g \u226b h\u2081\u2082.h\u2082 + S\u2081.g \u226b h\u2082\u2083.h\u2082 + (h\u2081\u2082.h\u2081 \u226b S\u2082.f + h\u2082\u2083.h\u2081 \u226b S\u2082.f) + \u03c6\u2083.\u03c4\u2082",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",440,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.113332, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh\u2081\u2082 : Homotopy \u03c6\u2081 \u03c6\u2082\nh\u2082\u2083 : Homotopy \u03c6\u2082 \u03c6\u2083\n\u22a2 h\u2081\u2082.h\u2083 + h\u2081\u2082.h\u2082 \u226b S\u2082.g + (h\u2082\u2083.h\u2083 + h\u2082\u2083.h\u2082 \u226b S\u2082.g + \u03c6\u2083.\u03c4\u2083) = h\u2081\u2082.h\u2083 + h\u2082\u2083.h\u2083 + (h\u2081\u2082.h\u2082 \u226b S\u2082.g + h\u2082\u2083.h\u2082 \u226b S\u2082.g) + \u03c6\u2083.\u03c4\u2083",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",449,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.122236, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\nh' : Homotopy \u03c6\u2083 \u03c6\u2084\n\u22a2 S\u2081.f \u226b h.h\u2081 + h.h\u2080 + \u03c6\u2082.\u03c4\u2081 + (S\u2081.f \u226b h'.h\u2081 + h'.h\u2080 + \u03c6\u2084.\u03c4\u2081) =\n    S\u2081.f \u226b h.h\u2081 + S\u2081.f \u226b h'.h\u2081 + (h.h\u2080 + h'.h\u2080) + (\u03c6\u2082.\u03c4\u2081 + \u03c6\u2084.\u03c4\u2081)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",450,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.122236, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\nh' : Homotopy \u03c6\u2083 \u03c6\u2084\n\u22a2 S\u2081.g \u226b h.h\u2082 + h.h\u2081 \u226b S\u2082.f + \u03c6\u2082.\u03c4\u2082 + (S\u2081.g \u226b h'.h\u2082 + h'.h\u2081 \u226b S\u2082.f + \u03c6\u2084.\u03c4\u2082) =\n    S\u2081.g \u226b h.h\u2082 + S\u2081.g \u226b h'.h\u2082 + (h.h\u2081 \u226b S\u2082.f + h'.h\u2081 \u226b S\u2082.f) + (\u03c6\u2082.\u03c4\u2082 + \u03c6\u2084.\u03c4\u2082)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",451,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.122236, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\nh' : Homotopy \u03c6\u2083 \u03c6\u2084\n\u22a2 h.h\u2083 + h.h\u2082 \u226b S\u2082.g + \u03c6\u2082.\u03c4\u2083 + (h'.h\u2083 + h'.h\u2082 \u226b S\u2082.g + \u03c6\u2084.\u03c4\u2083) =\n    h.h\u2083 + h'.h\u2083 + (h.h\u2082 \u226b S\u2082.g + h'.h\u2082 \u226b S\u2082.g) + (\u03c6\u2082.\u03c4\u2083 + \u03c6\u2084.\u03c4\u2083)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",460,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.133288, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\nh' : Homotopy \u03c6\u2083 \u03c6\u2084\n\u22a2 S\u2081.f \u226b h.h\u2081 + h.h\u2080 + \u03c6\u2082.\u03c4\u2081 - (S\u2081.f \u226b h'.h\u2081 + h'.h\u2080 + \u03c6\u2084.\u03c4\u2081) =\n    S\u2081.f \u226b h.h\u2081 - S\u2081.f \u226b h'.h\u2081 + (h.h\u2080 - h'.h\u2080) + (\u03c6\u2082.\u03c4\u2081 - \u03c6\u2084.\u03c4\u2081)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",461,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.133288, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\nh' : Homotopy \u03c6\u2083 \u03c6\u2084\n\u22a2 S\u2081.g \u226b h.h\u2082 + h.h\u2081 \u226b S\u2082.f + \u03c6\u2082.\u03c4\u2082 - (S\u2081.g \u226b h'.h\u2082 + h'.h\u2081 \u226b S\u2082.f + \u03c6\u2084.\u03c4\u2082) =\n    S\u2081.g \u226b h.h\u2082 - S\u2081.g \u226b h'.h\u2082 + (h.h\u2081 \u226b S\u2082.f - h'.h\u2081 \u226b S\u2082.f) + (\u03c6\u2082.\u03c4\u2082 - \u03c6\u2084.\u03c4\u2082)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",462,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.133288, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\nh' : Homotopy \u03c6\u2083 \u03c6\u2084\n\u22a2 h.h\u2083 + h.h\u2082 \u226b S\u2082.g + \u03c6\u2082.\u03c4\u2083 - (h'.h\u2083 + h'.h\u2082 \u226b S\u2082.g + \u03c6\u2084.\u03c4\u2083) =\n    h.h\u2083 - h'.h\u2083 + (h.h\u2082 \u226b S\u2082.g - h'.h\u2082 \u226b S\u2082.g) + (\u03c6\u2082.\u03c4\u2083 - \u03c6\u2084.\u03c4\u2083)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",503,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.168534, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 h.h\u2083 + h.h\u2082 \u226b S\u2082.g + \u03c6\u2082.\u03c4\u2083 = h.h\u2082 \u226b S\u2082.g + h.h\u2083 + \u03c6\u2082.\u03c4\u2083",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",504,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.168534, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 S\u2081.g \u226b h.h\u2082 + h.h\u2081 \u226b S\u2082.f + \u03c6\u2082.\u03c4\u2082 = h.h\u2081 \u226b S\u2082.f + S\u2081.g \u226b h.h\u2082 + \u03c6\u2082.\u03c4\u2082",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",505,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.168534, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 S\u2081.f \u226b h.h\u2081 + h.h\u2080 + \u03c6\u2082.\u03c4\u2081 = h.h\u2080 + S\u2081.f \u226b h.h\u2081 + \u03c6\u2082.\u03c4\u2081",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",518,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.173543, u_1} C\ninst\u271d : Preadditive C\nS\u2081\u271d S\u2082\u271d S\u2083 : ShortComplex C\n\u03c6\u2081\u271d \u03c6\u2082\u271d \u03c6\u2083 \u03c6\u2084 : S\u2081\u271d \u27f6 S\u2082\u271d\nS\u2081 S\u2082 : ShortComplex C\u1d52\u1d56\n\u03c6\u2081 \u03c6\u2082 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 h.h\u2083 + h.h\u2082 \u226b S\u2082.g + \u03c6\u2082.\u03c4\u2083 = h.h\u2082 \u226b S\u2082.g + h.h\u2083 + \u03c6\u2082.\u03c4\u2083",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",519,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.173543, u_1} C\ninst\u271d : Preadditive C\nS\u2081\u271d S\u2082\u271d S\u2083 : ShortComplex C\n\u03c6\u2081\u271d \u03c6\u2082\u271d \u03c6\u2083 \u03c6\u2084 : S\u2081\u271d \u27f6 S\u2082\u271d\nS\u2081 S\u2082 : ShortComplex C\u1d52\u1d56\n\u03c6\u2081 \u03c6\u2082 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 S\u2081.g \u226b h.h\u2082 + h.h\u2081 \u226b S\u2082.f + \u03c6\u2082.\u03c4\u2082 = h.h\u2081 \u226b S\u2082.f + S\u2081.g \u226b h.h\u2082 + \u03c6\u2082.\u03c4\u2082",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",520,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.173543, u_1} C\ninst\u271d : Preadditive C\nS\u2081\u271d S\u2082\u271d S\u2083 : ShortComplex C\n\u03c6\u2081\u271d \u03c6\u2082\u271d \u03c6\u2083 \u03c6\u2084 : S\u2081\u271d \u27f6 S\u2082\u271d\nS\u2081 S\u2082 : ShortComplex C\u1d52\u1d56\n\u03c6\u2081 \u03c6\u2082 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 S\u2081.f \u226b h.h\u2081 + h.h\u2080 + \u03c6\u2082.\u03c4\u2081 = h.h\u2080 + S\u2081.f \u226b h.h\u2081 + \u03c6\u2082.\u03c4\u2081",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",539,"case h\u2081\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 S\u2081.f \u226b h.h\u2081 + h.h\u2080 + \u03c6\u2082.\u03c4\u2081 = \u03c6\u2082.\u03c4\u2081 + (h.h\u2080 + S\u2081.f \u226b h.h\u2081)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",540,"case h\u2082\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 S\u2081.g \u226b h.h\u2082 + h.h\u2081 \u226b S\u2082.f + \u03c6\u2082.\u03c4\u2082 = \u03c6\u2082.\u03c4\u2082 + (h.h\u2081 \u226b S\u2082.f + S\u2081.g \u226b h.h\u2082)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",541,"case h\u2083\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 : S\u2081 \u27f6 S\u2082\nh : Homotopy \u03c6\u2081 \u03c6\u2082\n\u22a2 h.h\u2083 + h.h\u2082 \u226b S\u2082.g + \u03c6\u2082.\u03c4\u2083 = \u03c6\u2082.\u03c4\u2083 + (h.h\u2082 \u226b S\u2082.g + h.h\u2083)",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",556,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.189401, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh\u2080 : S\u2081.X\u2081 \u27f6 S\u2082.X\u2081\nh\u2080_f : h\u2080 \u226b S\u2082.f = 0\nh\u2081 : S\u2081.X\u2082 \u27f6 S\u2082.X\u2081\nh\u2082 : S\u2081.X\u2083 \u27f6 S\u2082.X\u2082\nh\u2083 : S\u2081.X\u2083 \u27f6 S\u2082.X\u2083\ng_h\u2083 : S\u2081.g \u226b h\u2083 = 0\n\u22a2 h\u2080 + S\u2081.f \u226b h\u2081 = S\u2081.f \u226b h\u2081 + h\u2080",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",557,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.189401, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh\u2080 : S\u2081.X\u2081 \u27f6 S\u2082.X\u2081\nh\u2080_f : h\u2080 \u226b S\u2082.f = 0\nh\u2081 : S\u2081.X\u2082 \u27f6 S\u2082.X\u2081\nh\u2082 : S\u2081.X\u2083 \u27f6 S\u2082.X\u2082\nh\u2083 : S\u2081.X\u2083 \u27f6 S\u2082.X\u2083\ng_h\u2083 : S\u2081.g \u226b h\u2083 = 0\n\u22a2 h\u2081 \u226b S\u2082.f + S\u2081.g \u226b h\u2082 = S\u2081.g \u226b h\u2082 + h\u2081 \u226b S\u2082.f",["abel"]],["Algebra/Homology/ShortComplex/Preadditive.lean",558,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.189401, u_1} C\ninst\u271d : Preadditive C\nS\u2081 S\u2082 S\u2083 : ShortComplex C\n\u03c6\u2081 \u03c6\u2082 \u03c6\u2083 \u03c6\u2084 : S\u2081 \u27f6 S\u2082\nh\u2080 : S\u2081.X\u2081 \u27f6 S\u2082.X\u2081\nh\u2080_f : h\u2080 \u226b S\u2082.f = 0\nh\u2081 : S\u2081.X\u2082 \u27f6 S\u2082.X\u2081\nh\u2082 : S\u2081.X\u2083 \u27f6 S\u2082.X\u2082\nh\u2083 : S\u2081.X\u2083 \u27f6 S\u2082.X\u2083\ng_h\u2083 : S\u2081.g \u226b h\u2083 = 0\n\u22a2 h\u2082 \u226b S\u2082.g + h\u2083 = h\u2083 + h\u2082 \u226b S\u2082.g",["abel"]],["MeasureTheory/Integral/PeakFunction.lean",425,"E : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : CompleteSpace E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \u211d F\ninst\u271d\u00b3 : FiniteDimensional \u211d F\ninst\u271d\u00b2 : MeasurableSpace F\ninst\u271d\u00b9 : BorelSpace F\n\u03bc : Measure F\ninst\u271d : \u03bc.IsAddHaarMeasure\n\u03c6 : F \u2192 \u211d\nh\u03c6 : \u2200 (x : F), 0 \u2264 \u03c6 x\nh'\u03c6 : \u222b (x : F), \u03c6 x \u2202\u03bc = 1\nh : Tendsto (fun x \u21a6 \u2016x\u2016 ^ finrank \u211d F * \u03c6 x) (cobounded F) (\ud835\udcdd 0)\ng : F \u2192 E\nhg : Integrable g \u03bc\nh'g : ContinuousAt g 0\nI : Integrable \u03c6 \u03bc\nu : Set F\nu_open : IsOpen u\nhu : 0 \u2208 u\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\nh'u : ball 0 \u03b4 \u2286 u\nM : \u211d\nMpos : M > 0\nhM : \u2200 \u2983x : F\u2984, x \u2208 (closedBall 0 M)\u1d9c \u2192 \u2016x\u2016 ^ finrank \u211d F * \u03c6 x < \u03b4 ^ finrank \u211d F * \u03b5\nc : \u211d\nhc : M / \u03b4 < c\nx : F\nhx : x \u2208 u\u1d9c\ncpos : 0 < c\nh\u03b4x : \u03b4 \u2264 \u2016x\u2016\n\u22a2 \u2016x\u2016 ^ finrank \u211d F * (c ^ finrank \u211d F * \u03c6 (c \u2022 x)) = c ^ finrank \u211d F * \u2016x\u2016 ^ finrank \u211d F * \u03c6 (c \u2022 x)",["ring","linarith"]],["Geometry/Manifold/Instances/Sphere.lean",133,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nv : E\nhv : \u2016v\u2016 = 1\nw : E\nhw : inner w v = 0\nh\u2081 : 0 < \u2016w\u2016 ^ 2 + 4\n\u22a2 4 ^ 2 * \u2016w\u2016 ^ 2 + (\u2016w\u2016 ^ 2 - 4) ^ 2 = (\u2016w\u2016 ^ 2 + 4) ^ 2",["ring","linarith"]],["Geometry/Manifold/Instances/Sphere.lean",244,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nv : E\nhv : \u2016v\u2016 = 1\nw : \u21a5(Submodule.span \u211d {v})\u15ee\nh\u2081 : (orthogonalProjection (Submodule.span \u211d {v})\u15ee) v = 0\nh\u2082 : inner v \u2191w = 0\nh\u2083 : inner v v = 1\n\u22a2 2 * (\u2016\u2191w\u2016 ^ 2 + 4) * 4 = (4 + 4) * (\u2016\u2191w\u2016 ^ 2 + 4)",["ring","linarith"]],["Analysis/CStarAlgebra/CStarMatrix.lean",618,"A : Type u_1\ninst\u271d\u2074 : NonUnitalCStarAlgebra A\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : StarOrderedRing A\nm : Type u_2\nn : Type u_3\ninst\u271d\u00b9 : Fintype m\ninst\u271d : Fintype n\nM : CStarMatrix n n A\nv : C\u22c6\u1d50\u1d52\u1d48 (n \u2192 A)\n\u22a2 \u2016v\u2016 * \u2016(toCLM M\u1d34).comp (toCLM M)\u2016 * \u2016v\u2016 = \u2016(toCLM M\u1d34).comp (toCLM M)\u2016 * \u2016v\u2016 ^ 2",["ring","linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",372,"case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhUV' : U \u2260 V\nhUV : \u00acG.IsUniform \u03b5 U V\n\u22a2 \u03b5 / 5 = 2 * (\u03b5 / 10)",["linarith","ring"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",132,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nU : Finset \u03b1\nhU : U \u2208 P.parts\nV : Finset \u03b1\nhV : V \u2208 P.parts\nhUV : U \u2260 V\nhunif : \u00acG.IsUniform \u03b5 U V\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhP\u2081 : 0 < #P.parts\n\u22a2 (2 * 2) ^ #P.parts * \u2191m / \u2191(#U) = 4 ^ #P.parts * \u2191m / \u2191(#U)",["norm_num","ring","linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",139,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nU : Finset \u03b1\nhU : U \u2208 P.parts\nV : Finset \u03b1\nhV : V \u2208 P.parts\nhUV : U \u2260 V\nhunif : \u00acG.IsUniform \u03b5 U V\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhP\u2081 : 0 < #P.parts\n\u22a2 10 ^ 2 = 100",["norm_num","ring","linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",144,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nU : Finset \u03b1\nhU : U \u2208 P.parts\nV : Finset \u03b1\nhV : V \u2208 P.parts\nhUV : U \u2260 V\nhunif : \u00acG.IsUniform \u03b5 U V\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhP\u2081 : 0 < #P.parts\n\u22a2 4 ^ #P.parts * \u03b5 ^ 4 = (2 ^ 2) ^ #P.parts * \u03b5 ^ (2 * 2)",["norm_num","ring"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",239,"case bc.h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\nP : Finpartition univ\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nthis : 0 \u2264 \u03b5\n\u22a2 50\u207b\u00b9 + 1 ^ 5 / 10000 \u2264 49\u207b\u00b9",["norm_num","linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",345,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP : P.IsEquipartition\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhG\u03b5 : \u2191(G.edgeDensity U V) \u2264 \u03b5 ^ 5 / 50\n\u22a2 25 \u2264 50",["norm_num","linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",383,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhUV : U \u2260 V\nhunif : \u00acG.IsUniform \u03b5 U V\nhm : 0 \u2264 1 - (\u2191m)\u207b\u00b9\nh\u03b5 : 0 \u2264 1 - \u03b5 / 10\nh\u03b5\u2080 : 0 < \u03b5\n\u22a2 4 / 5 * \u03b5 = (1 - 1 / 10) * (1 - 9\u207b\u00b9) * \u03b5",["norm_num","ring","linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",237,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\nP : Finpartition univ\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nthis : 0 \u2264 \u03b5\n\u22a2 (1 + \u03b5 ^ 5 / 100) ^ 2 = 1 + \u03b5 ^ 5 * (50\u207b\u00b9 + \u03b5 ^ 5 / 10000)",["ring","linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",352,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP : P.IsEquipartition\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhG\u03b5 : 0 \u2264 \u2191(G.edgeDensity U V) - \u03b5 ^ 5 / 50\nthis : 0 \u2264 \u03b5\n\u22a2 \u2191(G.edgeDensity U V) ^ 2 - \u2191(G.edgeDensity U V) * \u03b5 ^ 5 / 25 + \u03b5 ^ 10 / 2500 = (\u2191(G.edgeDensity U V) - \u03b5 ^ 5 / 50) ^ 2",["ring","linarith"]],["Analysis/Calculus/TangentCone.lean",212,"case refine_3\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \u211d G\ns : Set G\nx y : G\nh : openSegment \u211d x y \u2286 s\nn : \u2115\nhn : n \u2260 0\n\u22a2 x - (1 / 2) ^ n \u2022 x + (1 / 2) ^ n \u2022 y = x + ((1 / 2) ^ n \u2022 y - (1 / 2) ^ n \u2022 x)",["abel"]],["Analysis/Calculus/TangentCone.lean",253,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\ns : Set E\nx : E\nhx : (\ud835\udcdd[s \\ {x}] x).NeBot\nu : \u2115 \u2192 \u211d\nu_pos : \u2200 (n : \u2115), 0 < u n\nu_lim : Tendsto u atTop (\ud835\udcdd 0)\nv : \u2115 \u2192 E\nhv : \u2200 (n : \u2115), v n \u2208 s \\ {x} \u2229 Metric.ball x (u n * u n)\nd : \u2115 \u2192 E := fun n \u21a6 v n - x\nM : \u2200 (n : \u2115), x + d n \u2208 s \\ {x}\nr : \ud835\udd5c\nhr : 1 < \u2016r\u2016\nc : \u2115 \u2192 \ud835\udd5c\nc_ne : \u2200 (n : \u2115), c n \u2260 0\nc_le : \u2200 (n : \u2115), \u2016c n \u2022 d n\u2016 < u n\nle_c : \u2200 (n : \u2115), u n / \u2016r\u2016 \u2264 \u2016c n \u2022 d n\u2016\nhc : \u2200 (n : \u2115), \u2016c n\u2016\u207b\u00b9 \u2264 (u n)\u207b\u00b9 * \u2016r\u2016 * \u2016d n\u2016\nn : \u2115\n\u22a2 \u2016r\u2016 * (u n * u n) = \u2016r\u2016 * u n * u n",["ring","linarith"]],["Analysis/InnerProductSpace/TwoDim.lean",355,"case neg.\u00ab_@\u00bb.Mathlib.Analysis.InnerProductSpace.TwoDim._hyg.6483.\u00ab0\u00bb\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\na x : E\nha : \u00aca = 0\n\u22a2 inner a x * \u2016a\u2016 ^ 2 = \u2016a\u2016 ^ 2 * inner a x",["ring","linarith"]],["Analysis/InnerProductSpace/TwoDim.lean",362,"case neg.\u00ab_@\u00bb.Mathlib.Analysis.InnerProductSpace.TwoDim._hyg.6483.\u00ab1\u00bb\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\na x : E\nha : \u00aca = 0\n\u22a2 -(o.areaForm x) a * \u2016a\u2016 ^ 2 = -(\u2016a\u2016 ^ 2 * (o.areaForm x) a)",["ring","linarith"]],["Analysis/InnerProductSpace/TwoDim.lean",384,"case neg.\u00ab_@\u00bb.Mathlib.Analysis.InnerProductSpace.TwoDim._hyg.6897.\u00ab0\u00bb\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\na x : E\nha : \u00aca = 0\n\u22a2 (o.areaForm x) a * \u2016a\u2016 ^ 2 = \u2016a\u2016 ^ 2 * (o.areaForm x) a",["ring","linarith"]],["Analysis/InnerProductSpace/TwoDim.lean",390,"case neg.\u00ab_@\u00bb.Mathlib.Analysis.InnerProductSpace.TwoDim._hyg.6897.\u00ab1\u00bb\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\na x : E\nha : \u00aca = 0\n\u22a2 inner a x * \u2016a\u2016 ^ 2 = \u2016a\u2016 ^ 2 * inner a x",["ring","linarith"]],["Analysis/InnerProductSpace/TwoDim.lean",541,"w z : \u2102\no : Orientation \u211d \u2102 (Fin 2) := Complex.orientation\n\u22a2 w.re * z.im - z.re * w.im = w.re * z.im + -w.im * z.re",["ring","linarith"]],["Analysis/InnerProductSpace/TwoDim.lean",551,"z w : \u2102\n\u22a2 z.re * w.im + -z.im * w.re = w.re * (-0 * z.re - -1 * -z.im) - w.im * (-0 * -z.im + -1 * z.re)",["ring","linarith"]],["Topology/EMetricSpace/Lipschitz.lean",456,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\ns s' : Set \u03b1\nt : Set \u03b2\nhs' : s' \u2286 s\nhss' : s \u2286 closure s'\nK : \u211d\u22650\nha : \u2200 a \u2208 s', ContinuousOn (fun y \u21a6 f (a, y)) t\nhb : \u2200 b \u2208 t, LipschitzOnWith K (fun x \u21a6 f (x, b)) s\nx : \u03b1\ny : \u03b2\nhx : x \u2208 s\nhy : y \u2208 t\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : 0 < \u03b5 / 2\n\u03b4 : \u211d\u22650\n\u03b4pos : 0 < \u2191\u03b4\nh\u03b4 : \u2191\u03b4 * \u2191(3 * K) < \u03b5 / 2\nx' : \u03b1\nhx' : x' \u2208 s'\nhxx' : edist x x' < \u2191\u03b4\nA : s \u2229 EMetric.ball x \u2191\u03b4 \u2208 \ud835\udcdd[s] x\nB : t \u2229 {b | edist (f (x', b)) (f (x', y)) \u2264 \u03b5 / 2} \u2208 \ud835\udcdd[t] y\na : \u03b1\nb : \u03b2\nhas : (a, b).1 \u2208 s\nhax : (a, b).1 \u2208 EMetric.ball x \u2191\u03b4\nhbt : (a, b).2 \u2208 t\nhby : (a, b).2 \u2208 {b | edist (f (x', b)) (f (x', y)) \u2264 \u03b5 / 2}\n\u22a2 \u2191K * (\u2191\u03b4 + \u2191\u03b4) + \u03b5 / 2 + \u2191K * \u2191\u03b4 = \u2191\u03b4 * (3 * \u2191K) + \u03b5 / 2",["ring"]],["Algebra/Polynomial/Derivative.lean",520,"case succ\nR : Type u\ninst\u271d : CommSemiring R\nn : \u2115\nc : R\nk : \u2115\nIH : (\u21d1derivative)^[k] ((X + C c) ^ n) = n.descFactorial k \u2022 (X + C c) ^ (n - k)\n\u22a2 \u2191(n.descFactorial k) * (\u2191(n - k) * (X + C c) ^ (n - k - 1)) = \u2191(n - k) * \u2191(n.descFactorial k) * (X + C c) ^ (n - k - 1)",["ring"]],["Algebra/Polynomial/Derivative.lean",528,"case h_monomial\nR : Type u\ninst\u271d : CommSemiring R\nq : R[X]\nn\u271d : \u2115\na\u271d : R\n\u22a2 C a\u271d * (\u2191n\u271d * q ^ (n\u271d - 1) * derivative q) = derivative q * (C a\u271d * \u2191n\u271d * q ^ (n\u271d - 1))",["ring"]],["NumberTheory/LegendreSymbol/JacobiSymbol.lean",469,"case h\na b : \u2115\nhb : Odd b\nha\u2080 : a \u2260 0\nhb' : Odd (b % (4 * a))\na' : \u2115\nha\u2081' : \u00ac2 \u2223 a'\nha\u2081 : Odd a'\ne : \u2115\nha\u2082 : a = 2 ^ (e + 1) * a'\n\u22a2 4 * (2 ^ e * 2 * a') = 8 * (2 ^ e * a')",["ring","linarith"]],["LinearAlgebra/Matrix/SchurComplement.lean",459,"m : Type u_2\nn : Type u_3\n\ud835\udd5c : Type u_5\ninst\u271d\u2075 : CommRing \ud835\udd5c\ninst\u271d\u2074 : StarRing \ud835\udd5c\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype n\nA : Matrix m m \ud835\udd5c\nB : Matrix m n \ud835\udd5c\nD : Matrix n n \ud835\udd5c\nx : m \u2192 \ud835\udd5c\ny : n \u2192 \ud835\udd5c\ninst\u271d : Invertible A\nhA : A.IsHermitian\n\u22a2 star x \u1d65* A \u2b1d\u1d65 x + star y \u1d65* B\u1d34 \u2b1d\u1d65 x + (star x \u1d65* B \u2b1d\u1d65 y + star y \u1d65* D \u2b1d\u1d65 y) =\n    star x \u1d65* A \u2b1d\u1d65 x + star y \u1d65* B\u1d34 \u2b1d\u1d65 x + (star x \u1d65* B \u2b1d\u1d65 y + star y \u1d65* (B\u1d34 * (A\u207b\u00b9 * B)) \u2b1d\u1d65 y) +\n      (star y \u1d65* D \u2b1d\u1d65 y - star y \u1d65* (B\u1d34 * (A\u207b\u00b9 * B)) \u2b1d\u1d65 y)",["abel","ring"]],["LinearAlgebra/Matrix/SchurComplement.lean",470,"m : Type u_2\nn : Type u_3\n\ud835\udd5c : Type u_5\ninst\u271d\u2075 : CommRing \ud835\udd5c\ninst\u271d\u2074 : StarRing \ud835\udd5c\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\nA : Matrix m m \ud835\udd5c\nB : Matrix m n \ud835\udd5c\nD : Matrix n n \ud835\udd5c\nx : m \u2192 \ud835\udd5c\ny : n \u2192 \ud835\udd5c\ninst\u271d : Invertible D\nhD : D.IsHermitian\n\u22a2 star x \u1d65* A \u2b1d\u1d65 x + star y \u1d65* B\u1d34 \u2b1d\u1d65 x + (star x \u1d65* B \u2b1d\u1d65 y + star y \u1d65* D \u2b1d\u1d65 y) =\n    star x \u1d65* (B * (D\u207b\u00b9 * B\u1d34)) \u2b1d\u1d65 x + star y \u1d65* B\u1d34 \u2b1d\u1d65 x + (star x \u1d65* B \u2b1d\u1d65 y + star y \u1d65* D \u2b1d\u1d65 y) +\n      (star x \u1d65* A \u2b1d\u1d65 x - star x \u1d65* (B * (D\u207b\u00b9 * B\u1d34)) \u2b1d\u1d65 x)",["abel","ring"]],["NumberTheory/PythagoreanTriples.lean",265,"K : Type u_1\ninst\u271d : Field K\nhk : \u2200 (x : K), 1 + x ^ 2 \u2260 0\nx : K\n\u22a2 1 + 1 = 2",["norm_num","ring"]],["NumberTheory/PythagoreanTriples.lean",66,"x y z : \u2124\nh : PythagoreanTriple x y z\nk : \u2124\n\u22a2 k * x * (k * x) + k * y * (k * y) = k ^ 2 * (x * x + y * y)",["ring","linarith"]],["NumberTheory/PythagoreanTriples.lean",68,"x y z : \u2124\nh : PythagoreanTriple x y z\nk : \u2124\n\u22a2 k ^ 2 * (z * z) = k * z * (k * z)",["ring"]],["NumberTheory/PythagoreanTriples.lean",275,"K : Type u_1\ninst\u271d : Field K\nhk : \u2200 (x : K), 1 + x ^ 2 \u2260 0\nx\u271d : { p // p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1 }\nx y : K\nhy : (x, y).2 \u2260 -1\nhxy : x ^ 2 + y ^ 2 = 1\nh2 : y + 1 \u2260 0\n\u22a2 (y + 1) ^ 2 + (1 + -y ^ 2) = 2 * (y + 1)",["ring"]],["NumberTheory/PythagoreanTriples.lean",279,"case h.e'_2\nK : Type u_1\ninst\u271d : Field K\nhk : \u2200 (x : K), 1 + x ^ 2 \u2260 0\nx\u271d : { p // p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1 }\nx y : K\nhy : (x, y).2 \u2260 -1\nhxy : x ^ 2 + y ^ 2 = 1\nh2 : y + 1 \u2260 0\nh3 : (y + 1) ^ 2 + x ^ 2 = 2 * (y + 1)\n\u22a2 2 = 1 + 1",["ring"]],["NumberTheory/PythagoreanTriples.lean",283,"case left\nK : Type u_1\ninst\u271d : Field K\nhk : \u2200 (x : K), 1 + x ^ 2 \u2260 0\nx\u271d : { p // p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1 }\nx y : K\nhy : (x, y).2 \u2260 -1\nhxy : x ^ 2 + y ^ 2 = 1\nh2 : y + 1 \u2260 0\nh3 : (y + 1) ^ 2 + x ^ 2 = 2 * (y + 1)\nh4 : 2 \u2260 0\n\u22a2 2 * x * (y + 1) ^ 2 = x * ((y + 1) * (2 * (y + 1)))",["ring"]],["NumberTheory/PythagoreanTriples.lean",286,"case right\nK : Type u_1\ninst\u271d : Field K\nhk : \u2200 (x : K), 1 + x ^ 2 \u2260 0\nx\u271d : { p // p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1 }\nx y : K\nhy : (x, y).2 \u2260 -1\nhxy : x ^ 2 + y ^ 2 = 1\nh2 : y + 1 \u2260 0\nh3 : (y + 1) ^ 2 + x ^ 2 = 2 * (y + 1)\nh4 : 2 \u2260 0\n\u22a2 (y + 1) ^ 2 - (1 + -y ^ 2) = y * (2 * (y + 1))",["ring"]],["NumberTheory/PythagoreanTriples.lean",308,"case h.e'_4\nm n : \u2124\nh : m.gcd n = 1\nhm : m % 2 = 0\nhn : n % 2 = 1\nH : \u00ac(m ^ 2 - n ^ 2).gcd (m ^ 2 + n ^ 2) = 1\np : \u2115\nhp : Nat.Prime p\nhp1 : \u2191p \u2223 m ^ 2 - n ^ 2\nhp2 : \u2191p \u2223 m ^ 2 + n ^ 2\n\u22a2 2 * m ^ 2 = m ^ 2 + n ^ 2 + (m ^ 2 - n ^ 2)",["ring","omega","linarith"]],["NumberTheory/PythagoreanTriples.lean",311,"case h.e'_4\nm n : \u2124\nh : m.gcd n = 1\nhm : m % 2 = 0\nhn : n % 2 = 1\nH : \u00ac(m ^ 2 - n ^ 2).gcd (m ^ 2 + n ^ 2) = 1\np : \u2115\nhp : Nat.Prime p\nhp1 : \u2191p \u2223 m ^ 2 - n ^ 2\nhp2 : \u2191p \u2223 m ^ 2 + n ^ 2\nh2m : \u2191p \u2223 2 * m ^ 2\n\u22a2 2 * n ^ 2 = m ^ 2 + n ^ 2 - (m ^ 2 - n ^ 2)",["ring"]],["NumberTheory/PythagoreanTriples.lean",389,"m0 n0 : \u2124\nhm : (m0 * 2 + 1) % 2 = 1\nhn : (n0 * 2 + 1) % 2 = 1\nh : (m0 * 2 + 1).gcd (n0 * 2 + 1) = 1\n\u22a2 (m0 * 2 + 1) ^ 2 + (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1)",["ring","linarith"]],["NumberTheory/PythagoreanTriples.lean",390,"m0 n0 : \u2124\nhm : (m0 * 2 + 1) % 2 = 1\nhn : (n0 * 2 + 1) % 2 = 1\nh : (m0 * 2 + 1).gcd (n0 * 2 + 1) = 1\nh1 : (m0 * 2 + 1) ^ 2 + (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1)\n\u22a2 (m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0))",["ring"]],["NumberTheory/PythagoreanTriples.lean",405,"case h.e'_4\nm0 n0 : \u2124\nhm : (m0 * 2 + 1) % 2 = 1\nhn : (n0 * 2 + 1) % 2 = 1\nh : (m0 * 2 + 1).gcd (n0 * 2 + 1) = 1\nh1 : (m0 * 2 + 1) ^ 2 + (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1)\nh2 : (m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0))\nh3 : ((m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2) / 2 % 2 = 0\nh20 : 2 \u2260 0\nh4 : \u00ac(2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0)).gcd (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1) = 1\np : \u2115\nhp : Nat.Prime p\nhp1 : \u2191p \u2223 2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0)\nhp2 : \u2191p \u2223 2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1\n\u22a2 (m0 * 2 + 1) ^ 2 = 2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0) + (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1)",["ring"]],["NumberTheory/PythagoreanTriples.lean",408,"case h.e'_4\nm0 n0 : \u2124\nhm : (m0 * 2 + 1) % 2 = 1\nhn : (n0 * 2 + 1) % 2 = 1\nh : (m0 * 2 + 1).gcd (n0 * 2 + 1) = 1\nh1 : (m0 * 2 + 1) ^ 2 + (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1)\nh2 : (m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0))\nh3 : ((m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2) / 2 % 2 = 0\nh20 : 2 \u2260 0\nh4 : \u00ac(2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0)).gcd (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1) = 1\np : \u2115\nhp : Nat.Prime p\nhp1 : \u2191p \u2223 2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0)\nhp2 : \u2191p \u2223 2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1\n\u22a2 (n0 * 2 + 1) ^ 2 = 2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1 - 2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0)",["ring"]],["NumberTheory/PythagoreanTriples.lean",480,"x y z : \u2124\nh : PythagoreanTriple x y z\nhc : x.gcd y = 1\nhyo : y % 2 = 1\nhzpos : 0 < z\nh0 : \u00acx = 0\nv : \u211a := \u2191x / \u2191z\nw : \u211a := \u2191y / \u2191z\nhq : v ^ 2 + w ^ 2 = 1\nhvz : v \u2260 0\nhw1 : w \u2260 -1\nhQ : \u2200 (x : \u211a), 1 + x ^ 2 \u2260 0\nhp : (v, w) \u2208 {p | p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1}\nq : \u211a := (circleEquivGen hQ).symm \u27e8(v, w), hp\u27e9\nht4 : v = 2 * q / (1 + q ^ 2) \u2227 w = (1 - q ^ 2) / (1 + q ^ 2)\nm : \u2124 := \u2191q.den\nn : \u2124 := q.num\nhm0 : m \u2260 0\nhq2 : q = \u2191n / \u2191m\nhm2n2 : 0 < m ^ 2 + n ^ 2\nhm2n20 : \u2191m ^ 2 + \u2191n ^ 2 \u2260 0\nhx1 : \u2200 {j k : \u211a}, k \u2260 0 \u2192 k ^ 2 + j ^ 2 \u2260 0 \u2192 (1 - (j / k) ^ 2) / (1 + (j / k) ^ 2) = (k ^ 2 - j ^ 2) / (k ^ 2 + j ^ 2)\nhw2 : w = (\u2191m ^ 2 - \u2191n ^ 2) / (\u2191m ^ 2 + \u2191n ^ 2)\nj k : \u211a\nh\u2081 : k \u2260 0\nh\u2082 : k ^ 2 + j ^ 2 \u2260 0\nh\u2083 : k * (k ^ 2 + j ^ 2) \u2260 0\n\u22a2 2 * j * k ^ 2 * (k ^ 2 + j ^ 2) = 2 * k * j * (k * (k ^ 2 + j ^ 2))",["ring"]],["NumberTheory/PythagoreanTriples.lean",571,"z m n : \u2124\nh : PythagoreanTriple (m ^ 2 - n ^ 2) (2 * m * n) z \u2227 (m ^ 2 - n ^ 2).gcd (2 * m * n) = 1\nco : m.gcd n = 1\npp : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0\n\u22a2 (m ^ 2 - n ^ 2) * (m ^ 2 - n ^ 2) + 2 * m * n * (2 * m * n) = (m ^ 2 + n ^ 2) ^ 2",["ring","linarith"]],["NumberTheory/PythagoreanTriples.lean",576,"z m n : \u2124\nh : PythagoreanTriple (2 * m * n) (m ^ 2 - n ^ 2) z \u2227 (2 * m * n).gcd (m ^ 2 - n ^ 2) = 1\nco : m.gcd n = 1\npp : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0\n\u22a2 2 * m * n * (2 * m * n) + (m ^ 2 - n ^ 2) * (m ^ 2 - n ^ 2) = (m ^ 2 + n ^ 2) ^ 2",["ring"]],["NumberTheory/PythagoreanTriples.lean",651,"z k m n : \u2124\nright\u271d : m.gcd n = 1\nh : PythagoreanTriple (k * (m ^ 2 - n ^ 2)) (k * (2 * m * n)) z\n\u22a2 k * (m ^ 2 - n ^ 2) * (k * (m ^ 2 - n ^ 2)) + k * (2 * m * n) * (k * (2 * m * n)) = (k * (m ^ 2 + n ^ 2)) ^ 2",["ring","linarith"]],["NumberTheory/PythagoreanTriples.lean",656,"z k m n : \u2124\nright\u271d : m.gcd n = 1\nh : PythagoreanTriple (k * (2 * m * n)) (k * (m ^ 2 - n ^ 2)) z\n\u22a2 k * (2 * m * n) * (k * (2 * m * n)) + k * (m ^ 2 - n ^ 2) * (k * (m ^ 2 - n ^ 2)) = (k * (m ^ 2 + n ^ 2)) ^ 2",["ring"]],["Analysis/InnerProductSpace/l2Space.lean",104,"case refine_1\n\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\nf g : \u21a5(lp G 2)\n\u22a2 1 < ENNReal.toReal 2 \u2227 (ENNReal.toReal 2)\u207b\u00b9 + (ENNReal.toReal 2)\u207b\u00b9 = 1",["norm_num"]],["Topology/Algebra/UniformGroup/Basic.lean",361,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nG : Type u_5\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalAddGroup \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b2\ninst\u271d\u2078 : AddCommGroup \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : AddCommGroup \u03b3\ninst\u271d\u2075 : IsTopologicalAddGroup \u03b3\ninst\u271d\u2074 : TopologicalSpace \u03b4\ninst\u271d\u00b3 : AddCommGroup \u03b4\ninst\u271d\u00b2 : UniformSpace G\ninst\u271d\u00b9 : AddCommGroup G\ne : \u03b2 \u2192+ \u03b1\nde : IsDenseInducing \u21d1e\nf : \u03b4 \u2192+ \u03b3\ndf : IsDenseInducing \u21d1f\n\u03c6 : \u03b2 \u2192+ \u03b4 \u2192+ G\nh\u03c6 : Continuous fun p \u21a6 (\u03c6 p.1) p.2\nW' : Set G\nW'_nhd : W' \u2208 \ud835\udcdd 0\ninst\u271d : UniformAddGroup G\nx\u2080 : \u03b1\ny\u2080 : \u03b3\nee : \u03b2 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b1 := fun u \u21a6 (e u.1, e u.2)\nff : \u03b4 \u00d7 \u03b4 \u2192 \u03b3 \u00d7 \u03b3 := fun u \u21a6 (f u.1, f u.2)\nlim_\u03c6 : Tendsto (fun p \u21a6 (\u03c6 p.1) p.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nlim_\u03c6_sub_sub :\n  Tendsto (fun p \u21a6 (fun p \u21a6 (\u03c6 p.1) p.2) (p.1.2 - p.1.1, p.2.2 - p.2.1)) (comap ee (\ud835\udcdd (x\u2080, x\u2080)) \u00d7\u02e2 comap ff (\ud835\udcdd (y\u2080, y\u2080)))\n    (\ud835\udcdd 0)\nW : Set G\nW_nhd : W \u2208 \ud835\udcdd 0\nW4 : \u2200 {v w s t : G}, v \u2208 W \u2192 w \u2208 W \u2192 s \u2208 W \u2192 t \u2208 W \u2192 v + w + s + t \u2208 W'\nU\u2081 : Set \u03b2\nU\u2081_nhd : U\u2081 \u2208 comap (\u21d1e) (\ud835\udcdd x\u2080)\nV\u2081 : Set \u03b4\nV\u2081_nhd : V\u2081 \u2208 comap (\u21d1f) (\ud835\udcdd y\u2080)\nH : \u2200 x \u2208 U\u2081, \u2200 x' \u2208 U\u2081, \u2200 y \u2208 V\u2081, \u2200 y' \u2208 V\u2081, (fun p \u21a6 (\u03c6 p.1) p.2) (x' - x, y' - y) \u2208 W\nx\u2081 : \u03b2\nx\u2081_in : x\u2081 \u2208 U\u2081\ny\u2081 : \u03b4\ny\u2081_in : y\u2081 \u2208 V\u2081\ncont_flip : Continuous fun p \u21a6 (\u03c6.flip p.1) p.2\nU\u2082 : Set \u03b2\nU\u2082_nhd : U\u2082 \u2208 comap (\u21d1e) (\ud835\udcdd x\u2080)\nHU : \u2200 x \u2208 U\u2082, \u2200 x' \u2208 U\u2082, (fun p \u21a6 (\u03c6 p.1) p.2) (x' - x, y\u2081) \u2208 W\nV\u2082 : Set \u03b4\nV\u2082_nhd : V\u2082 \u2208 comap (\u21d1f) (\ud835\udcdd y\u2080)\nHV : \u2200 x \u2208 V\u2082, \u2200 x' \u2208 V\u2082, (fun p \u21a6 (\u03c6.flip p.1) p.2) (x' - x, x\u2081) \u2208 W\nx : \u03b2\nxU\u2081 : x \u2208 U\u2081\nxU\u2082 : x \u2208 U\u2082\nx' : \u03b2\nx'U\u2081 : x' \u2208 U\u2081\nx'U\u2082 : x' \u2208 U\u2082\ny : \u03b4\nyV\u2081 : y \u2208 V\u2081\nyV\u2082 : y \u2208 V\u2082\ny' : \u03b4\ny'V\u2081 : y' \u2208 V\u2081\ny'V\u2082 : y' \u2208 V\u2082\n\u22a2 (\u03c6 x') y' - (\u03c6 x) y = (\u03c6 x') y\u2081 - (\u03c6 x) y\u2081 + ((\u03c6 x') y' - (\u03c6 x') y\u2081 - ((\u03c6 x) y' - (\u03c6 x) y\u2081)) + ((\u03c6 x) y' - (\u03c6 x) y)",["abel"]],["NumberTheory/LSeries/PrimesInAP.lean",190,"p : Nat.Primes\nk : \u2115\n\u22a2 2 * (\u2191\u2191p)\u207b\u00b9 ^ (\u2191k + (2 + -1 / 2)) = 2 * (\u2191\u2191p)\u207b\u00b9 ^ (\u2191k + 3 / 2)",["norm_num","ring","linarith"]],["MeasureTheory/Integral/MeanInequalities.lean",113,"\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhpq : p.IsConjExponent q\nf g : \u03b1 \u2192 \u211d\u22650\u221e\nhf : AEMeasurable f \u03bc\nhf_nontop : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 \u22a4\nhg_nontop : \u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc \u2260 \u22a4\nhf_nonzero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 0\nhg_nonzero : \u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc \u2260 0\nnpf : \u211d\u22650\u221e := (\u222b\u207b (c : \u03b1), f c ^ p \u2202\u03bc) ^ (1 / p)\nnqg : \u211d\u22650\u221e := (\u222b\u207b (c : \u03b1), g c ^ q \u2202\u03bc) ^ (1 / q)\na : \u03b1\n\u22a2 funMulInvSnorm f p \u03bc a * (\u222b\u207b (c : \u03b1), f c ^ p \u2202\u03bc) ^ (1 / p) *\n      (funMulInvSnorm g q \u03bc a * (\u222b\u207b (c : \u03b1), g c ^ q \u2202\u03bc) ^ (1 / q)) =\n    funMulInvSnorm f p \u03bc a * funMulInvSnorm g q \u03bc a * (npf * nqg)",["ring"]],["NumberTheory/DiophantineApproximation/Basic.lean",523,"case h.e'_3\n\u03be : \u211d\nu : \u2124\nih : \u2200 m < 1, \u2200 {\u03be : \u211d} {u : \u2124}, ContfracLegendre.Ass \u03be u \u2191m \u2192 \u2203 n, \u2191u / \u2191m = \u03be.convergent n\nleft\u271d : IsCoprime u \u21911\nh\u2082 : |\u03be - \u2191u / \u2191\u21911| < (\u2191\u21911 * (2 * \u2191\u21911 - 1))\u207b\u00b9\nht : \u03be < \u2191u\nh\u2081 : \u2191u + -(1 / 2) < \u03be\nh\u03be\u2081 : \u230a\u03be\u230b = u - 1\nH\u03be : \u03be \u2260 \u2191\u230a\u03be\u230b\n\u22a2 \u2191u + -(1 - 2\u207b\u00b9) = \u2191u + -(1 / 2)",["norm_num","ring","linarith"]],["NumberTheory/DiophantineApproximation/Basic.lean",124,"case h.e'_3.e_a\n\u03be : \u211d\nn : \u2115\nn_pos : 0 < n\nf : \u2124 \u2192 \u2124 := fun m \u21a6 \u230afract (\u03be * \u2191m) * (\u2191n + 1)\u230b\nhn : 0 < \u2191n + 1\nhfu : \u2200 (m : \u2124), fract (\u03be * \u2191m) * (\u2191n + 1) < \u2191n + 1\nD : Finset \u2124 := Icc 0 \u2191n\nH : \u2200 x \u2208 D, \u00acf x = \u2191n\nhD : #(Ico 0 \u2191n) < #D\nhfu' : \u2200 (m : \u2124), f m \u2264 \u2191n\nhwd : \u2200 m \u2208 D, f m \u2208 Ico 0 \u2191n\nx : \u2124\nhx : x \u2208 D\ny : \u2124\nhy : y \u2208 D\nx_lt_y : x < y\nhxy : f x = f y\n\u22a2 (\u03be * (\u2191y - \u2191x) - (\u2191\u230a\u03be * \u2191y\u230b - \u2191\u230a\u03be * \u2191x\u230b)) * (\u2191n + 1) = (\u03be * \u2191y - \u2191\u230a\u03be * \u2191y\u230b) * (\u2191n + 1) - (\u03be * \u2191x - \u2191\u230a\u03be * \u2191x\u230b) * (\u2191n + 1)",["ring","linarith"]],["NumberTheory/DiophantineApproximation/Basic.lean",451,"\u03be : \u211d\nu v : \u2124\nhv : 2 \u2264 v\nh\u03be\u2080 : 0 < fract \u03be\nu' : \u2124 := u - \u230a\u03be\u230b * v\nhu\u2080 : 0 < u'\nhuv : u' < v\nhu' : u' = u - \u230a\u03be\u230b * v\nhu'\u211d : \u2191u = \u2191u' + \u2191\u230a\u03be\u230b * \u2191v\nHu : 0 < \u2191u'\nHu' : 0 < 2 * \u2191u' - 1\nHv : 0 < \u2191v\nHv' : 0 < 2 * \u2191v - 1\nH\u2081 : 0 < \u2191v / \u2191u' / fract \u03be\nh' : |fract \u03be - \u2191u' / \u2191v| < (\u2191v * (2 * \u2191v - 1))\u207b\u00b9\nh : -(\u2191v * (2 * \u2191v - 1))\u207b\u00b9 < \u03be - \u2191u / \u2191v\n\u22a2 (2 * \u2191v - 1) * (-\u2191v + \u2191u' * (\u2191v * (2 * \u2191v - 1))) * \u2191v = (2 * \u2191u' * \u2191v - (1 + \u2191u')) * (\u2191v * (2 * \u2191v - 1) * \u2191v)",["ring","linarith"]],["NumberTheory/DiophantineApproximation/Basic.lean",458,"case e_a\n\u03be : \u211d\nu v : \u2124\nhv : 2 \u2264 v\nh\u03be\u2080 : 0 < fract \u03be\nu' : \u2124 := u - \u230a\u03be\u230b * v\nhu\u2080 : 0 < u'\nhuv : u' < v\nhu' : u' = u - \u230a\u03be\u230b * v\nhu'\u211d : \u2191u = \u2191u' + \u2191\u230a\u03be\u230b * \u2191v\nHu : 0 < \u2191u'\nHu' : 0 < 2 * \u2191u' - 1\nHv : 0 < \u2191v\nHv' : 0 < 2 * \u2191v - 1\nH\u2081 : 0 < \u2191v / \u2191u' / fract \u03be\nh : |\u03be - \u2191u / \u2191v| < (\u2191v * (2 * \u2191v - 1))\u207b\u00b9\nh' : |fract \u03be - \u2191u' / \u2191v| < (\u2191v * (2 * \u2191v - 1))\u207b\u00b9\nH : 2 * \u2191u' - 1 \u2264 (2 * \u2191v - 1) * fract \u03be\na b c : \u211d\na\u271d\u00b2 : a \u2260 0\na\u271d\u00b9 : b \u2260 0\na\u271d : c \u2260 0\n\u22a2 b * a = a * b",["ring","linarith"]],["NumberTheory/DiophantineApproximation/Basic.lean",461,"\u03be : \u211d\nu v : \u2124\nhv : 2 \u2264 v\nh\u03be\u2080 : 0 < fract \u03be\nu' : \u2124 := u - \u230a\u03be\u230b * v\nhu\u2080 : 0 < u'\nhuv : u' < v\nhu' : u' = u - \u230a\u03be\u230b * v\nhu'\u211d : \u2191u = \u2191u' + \u2191\u230a\u03be\u230b * \u2191v\nHu : 0 < \u2191u'\nHu' : 0 < 2 * \u2191u' - 1\nHv : 0 < \u2191v\nHv' : 0 < 2 * \u2191v - 1\nH\u2081 : 0 < \u2191v / \u2191u' / fract \u03be\nh : |\u03be - \u2191u / \u2191v| < (\u2191v * (2 * \u2191v - 1))\u207b\u00b9\nh' : |fract \u03be - \u2191u' / \u2191v| < (\u2191v * (2 * \u2191v - 1))\u207b\u00b9\nH : 2 * \u2191u' - 1 \u2264 (2 * \u2191v - 1) * fract \u03be\nhelp\u2081 : \u2200 {a b c : \u211d}, a \u2260 0 \u2192 b \u2260 0 \u2192 c \u2260 0 \u2192 |a\u207b\u00b9 - b / c| = |(a - c / b) * (b / c / a)|\na\u271d\u2074 b\u271d c\u271d d\u271d : \u211d\na\u271d\u00b3 : a\u271d\u2074 \u2260 0\na\u271d\u00b2 : b\u271d \u2260 0\na\u271d\u00b9 : c\u271d \u2260 0\na\u271d : d\u271d \u2260 0\n\u22a2 b\u271d * (d\u271d * c\u271d * a\u271d\u2074) = b\u271d * c\u271d * (d\u271d * a\u271d\u2074)",["ring","linarith"]],["NumberTheory/DiophantineApproximation/Basic.lean",479,"\u03be : \u211d\nu v : \u2124\nhv : 2 \u2264 v\nh : ContfracLegendre.Ass \u03be u v\nhuv : u - \u230a\u03be\u230b * v = 1\nhv\u2080' : 0 < 2 * \u2191v - 1\n\u22a2 (\u2191v + \u2191v * (2 * \u2191v - 1)) * (2 * \u2191v - 1) = 2 * (\u2191v * (2 * \u2191v - 1) * \u2191v)",["ring","linarith"]],["SetTheory/Surreal/Multiplication.lean",304,"x\u2081 x\u2082 y : PGame\nih' :\n  \u2200 (a : Args),\n    TransGen (CutExpand IsOption)\n        (match a with\n        | Args.P1 x y => {y} + {x}\n        | Args.P24 x\u2081 x\u2082 y => {x\u2081} + ({y} + {x\u2082}))\n        ({x\u2081} + ({y} + {x\u2082})) \u2192\n      P124 a\n\u22a2 {x\u2081} + ({y} + {x\u2082}) = {x\u2082} + ({y} + {x\u2081})",["abel"]],["Topology/Homotopy/Basic.lean",244,"case neg.h.e_6.h.e_fst.a\nX : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf\u2080 f\u2081 f\u2082 : C(X, Y)\nF : f\u2080.Homotopy f\u2081\nG : f\u2081.Homotopy f\u2082\nt : \u2191I\nsnd\u271d : X\nh\u2081 : 1 - \u2191t \u2264 1 / 2\nh\u2082 : \u00ac\u2191t \u2264 1 / 2\n\u22a2 2 * (1 - \u2191t) = 1 - (2 * \u2191t - 1)",["linarith","ring"]],["Topology/Homotopy/Basic.lean",248,"case pos.h.e_6.h.e_fst.a\nX : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf\u2080 f\u2081 f\u2082 : C(X, Y)\nF : f\u2080.Homotopy f\u2081\nG : f\u2081.Homotopy f\u2082\nt : \u2191I\nsnd\u271d : X\nh\u2081 : \u00ac1 - \u2191t \u2264 1 / 2\nh\u2082 : \u2191t \u2264 1 / 2\n\u22a2 2 * (1 - \u2191t) - 1 = 1 - 2 * \u2191t",["linarith","ring"]],["Topology/Homotopy/Basic.lean",220,"F\u271d : Type u_1\nX : Type u\nY : Type v\nZ : Type w\nZ' : Type x\n\u03b9 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace Z'\nf\u2080 f\u2081 f\u2082 : C(X, Y)\nF : f\u2080.Homotopy f\u2081\nG : f\u2081.Homotopy f\u2082\nx : X\n\u22a2 { toFun := fun x \u21a6 if \u2191x.1 \u2264 1 / 2 then (F.extend (2 * \u2191x.1)) x.2 else (G.extend (2 * \u2191x.1 - 1)) x.2,\n          continuous_toFun := \u22ef }.toFun\n      (1, x) =\n    f\u2082 x",["norm_num"]],["Analysis/Convex/Segment.lean",191,"case h.e'_3.h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : OrderedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nx y : E\na\u271d\u00b9 : \ud835\udd5c\na\u271d : a\u271d\u00b9 \u2208 Icc 0 1\n\u22a2 x + (a\u271d\u00b9 \u2022 y - a\u271d\u00b9 \u2022 x) = x - a\u271d\u00b9 \u2022 x + a\u271d\u00b9 \u2022 y",["abel"]],["Analysis/Convex/Segment.lean",197,"case h.e'_3.h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : OrderedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nx y : E\na\u271d\u00b9 : \ud835\udd5c\na\u271d : a\u271d\u00b9 \u2208 Ioo 0 1\n\u22a2 x + (a\u271d\u00b9 \u2022 y - a\u271d\u00b9 \u2022 x) = x - a\u271d\u00b9 \u2022 x + a\u271d\u00b9 \u2022 y",["abel"]],["Analysis/Convex/Segment.lean",265,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : OrderedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nc x y : E\nh : LinearIndependent \ud835\udd5c ![x - c, y - c]\np : \ud835\udd5c\np0 : 0 \u2264 p\np1 : p \u2264 1\nq : \ud835\udd5c\nH : (1 - q) \u2022 c + q \u2022 y = (1 - p) \u2022 c + p \u2022 x\nq0 : 0 \u2264 q\nq1 : q \u2264 1\nHx : x = x - c + c\n\u22a2 y = y - c + c",["abel"]],["NumberTheory/Padics/RingHoms.lean",236,"case h.e'_5\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nr : \u211a\nx\u271d : \u2124_[p]\nv : \u2115\nf : \u2124_[p] \u2192 \u2115\nf_spec : \u2200 (x : \u2124_[p]), x - \u2191(f x) \u2208 Ideal.span {\u2191v}\nf_congr : \u2200 (x : \u2124_[p]) (a b : \u2115), x - \u2191a \u2208 Ideal.span {\u2191v} \u2192 x - \u2191b \u2208 Ideal.span {\u2191v} \u2192 \u2191a = \u2191b\nx y : \u2124_[p]\n\u22a2 x + y - (\u2191(f x) + \u2191(f y)) = x - \u2191(f x) + (y - \u2191(f y))",["ring","abel"]],["NumberTheory/Padics/RingHoms.lean",245,"case h.e'_5\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nr : \u211a\nx\u271d : \u2124_[p]\nv : \u2115\nf : \u2124_[p] \u2192 \u2115\nf_spec : \u2200 (x : \u2124_[p]), x - \u2191(f x) \u2208 Ideal.span {\u2191v}\nf_congr : \u2200 (x : \u2124_[p]) (a b : \u2115), x - \u2191a \u2208 Ideal.span {\u2191v} \u2192 x - \u2191b \u2208 Ideal.span {\u2191v} \u2192 \u2191a = \u2191b\nx y : \u2124_[p]\nI : Ideal \u2124_[p] := Ideal.span {\u2191v}\n\u22a2 x * y - \u2191(f x) * \u2191(f y) = x * (y - \u2191(f y)) + (x - \u2191(f x)) * \u2191(f y)",["ring"]],["Geometry/Euclidean/Angle/Sphere.lean",42,"V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y z : V\nhxyne : x \u2260 y\nhxzne : x \u2260 z\nhxy : \u2016x\u2016 = \u2016y\u2016\nhxz : \u2016x\u2016 = \u2016z\u2016\nhy : y \u2260 0\nhx : x \u2260 0\nhz : z \u2260 0\n\u22a2 \u2191\u03c0 - 2 \u2022 o.oangle (x - z) x - (\u2191\u03c0 - 2 \u2022 o.oangle (x - y) x) = 2 \u2022 (o.oangle (x - y) x - o.oangle (x - z) x)",["abel"]],["Geometry/Euclidean/Angle/Sphere.lean",196,"V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\nhd2 : Fact (finrank \u211d V = 2)\ninst\u271d : Oriented \u211d V (Fin 2)\ns : Sphere P\np\u2081 p\u2082 : P\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nh : p\u2081 \u2260 p\u2082\n\u22a2 (1 + (\u2221 p\u2082 p\u2081 s.center).tan ^ 2) * \u2016midpoint \u211d p\u2081 p\u2082 -\u1d65 p\u2081\u2016 * \u2016midpoint \u211d p\u2081 p\u2082 -\u1d65 p\u2081\u2016 =\n    \u2016midpoint \u211d p\u2081 p\u2082 -\u1d65 p\u2081\u2016 * \u2016midpoint \u211d p\u2081 p\u2082 -\u1d65 p\u2081\u2016 +\n      (\u2221 p\u2082 p\u2081 s.center).tan * (\u2221 p\u2082 p\u2081 s.center).tan * \u2016midpoint \u211d p\u2081 p\u2082 -\u1d65 p\u2081\u2016 * \u2016midpoint \u211d p\u2081 p\u2082 -\u1d65 p\u2081\u2016",["ring","linarith"]],["MeasureTheory/Measure/Lebesgue/VolumeOfBalls.lean",62,"E : Type u_1\np : \u211d\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nhp : 0 < p\nhE : Nontrivial E\nthis : 0 < \u2191(finrank \u211d E)\n\u22a2 Real.Gamma (\u2191(finrank \u211d E) / p) * \u2191(finrank \u211d E) = \u2191(finrank \u211d E) * Real.Gamma (\u2191(finrank \u211d E) / p)",["ring","linarith"]],["MeasureTheory/Measure/Lebesgue/VolumeOfBalls.lean",397,"case e_a.e_r.e_a\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \u211d E\ninst\u271d\u00b2 : FiniteDimensional \u211d E\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : BorelSpace E\nk : \u2115\nhk : finrank \u211d E = 2 * k + 1\nx : E\nr : \u211d\nthis : Nontrivial E\n\u22a2 \u221a\u03c0 * 2 ^ (k + 1) * \u2191(2 * k + 1)\u203c = 2 ^ (k + 1) * (\u2191(2 * k + 1)\u203c * \u221a\u03c0)",["ring","linarith"]],["Topology/UrysohnsLemma.lean",263,"X : Type u_1\ninst\u271d : TopologicalSpace X\nP : Set X \u2192 Prop\nc : CU P\n\u22a2 0 < 2\u207b\u00b9 \u2227 2\u207b\u00b9 < 3 / 4 \u2227 3 / 4 < 1",["norm_num"]],["Topology/UrysohnsLemma.lean",298,"X : Type u_1\ninst\u271d : TopologicalSpace X\nP : Set X \u2192 Prop\nh0 : 0 < 2\u207b\u00b9\nh1234 : 2\u207b\u00b9 < 3 / 4\nh1 : 3 / 4 < 1\nx : X\nx\u271d : True\nn : \u2115\nc : CU P\ny : X\nhxl : x \u2209 c.left.left.U\nhyl : y \u2209 c.left.left.U\nr : \u211d := (3 / 4) ^ n\nihn : \u2200 (c : CU P), \u2200\u1da0 (x_1 : X) in \ud835\udcdd x, dist (c.lim x_1) (c.lim x) \u2264 r\nhydl : dist (c.left.right.lim y) (c.left.right.lim x) \u2264 r\nhydr : dist (c.right.lim y) (c.right.lim x) \u2264 r\n\u22a2 (r + r * 2) * 4 = r * 3 * (2 * 2)",["ring","linarith"]],["Analysis/MellinTransform.lean",244,"case intro.intro.intro.intro.refine_2.h.e_a.e_a\nb : \u211d\nf : \u211d \u2192 \u211d\nhfc : AEStronglyMeasurable f (volume.restrict (Ioi 0))\nhf : f =O[\ud835\udcdd[>] 0] fun x \u21a6 x ^ (-b)\ns : \u211d\nhs : b < s\nd : \u211d\nleft\u271d : d > 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nt : \u211d\nht : t \u2208 Ioo 0 \u03b5\nh\u03b5' : \u2016f t\u2016 \u2264 d * \u2016t ^ (-b)\u2016\n\u22a2 -b + (s - 1) = s - b - 1",["abel","ring","linarith"]],["Analysis/MellinTransform.lean",304,"case e_a\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nhab : a < b\nhf : f =O[\ud835\udcdd[>] 0] fun x \u21a6 x ^ (-a)\nthis : log =o[\ud835\udcdd[>] 0] fun t \u21a6 t ^ (a - b)\nt : \u211d\nht : t \u2208 Ioi 0\n\u22a2 a - b + -a = -b",["abel","ring","linarith"]],["Analysis/Normed/Operator/Banach.lean",123,"case e_a\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomIsometric \u03c3\ninst\u271d\u00b9 : RingHomIsometric \u03c3'\ninst\u271d : CompleteSpace F\nsurj : Surjective \u21d1f\nA : \u22c3 n, closure (\u21d1f '' ball 0 \u2191n) = Set.univ\nn : \u2115\na : F\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nH : ball a \u03b5 \u2286 closure (\u21d1f '' ball 0 \u2191n)\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\ny : F\nhy : y \u2260 0\nhc' : 1 < \u2016\u03c3 c\u2016\nd : \ud835\udd5c'\nhd : d \u2260 0\nydlt : \u2016d \u2022 y\u2016 < \u03b5 / 2\ndinv : \u2016d\u2016\u207b\u00b9 \u2264 (\u03b5 / 2)\u207b\u00b9 * \u2016\u03c3 c\u2016 * \u2016y\u2016\n\u03b4 : \u211d := \u2016d\u2016 * \u2016y\u2016 / 4\n\u03b4pos : 0 < \u03b4\nthis\u271d : a + d \u2022 y \u2208 ball a \u03b5\nz\u2081 : F\nz\u2081im : z\u2081 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2081 : E\nh\u2081 : dist (a + d \u2022 y) (f x\u2081) < \u03b4\nhx\u2081 : \u2016x\u2081\u2016 < \u2191n\nxz\u2081 : f x\u2081 = z\u2081\nthis : a \u2208 ball a \u03b5\nz\u2082 : F\nz\u2082im : z\u2082 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2082 : E\nh\u2082 : dist a (f x\u2082) < \u03b4\nhx\u2082 : \u2016x\u2082\u2016 < \u2191n\nxz\u2082 : f x\u2082 = z\u2082\nx : E := x\u2081 - x\u2082\n\u22a2 f x\u2081 - f x\u2082 - d \u2022 y = f x\u2081 - (a + d \u2022 y) - (f x\u2082 - a)",["abel"]],["Analysis/Normed/Operator/Banach.lean",137,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomIsometric \u03c3\ninst\u271d\u00b9 : RingHomIsometric \u03c3'\ninst\u271d : CompleteSpace F\nsurj : Surjective \u21d1f\nA : \u22c3 n, closure (\u21d1f '' ball 0 \u2191n) = Set.univ\nn : \u2115\na : F\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nH : ball a \u03b5 \u2286 closure (\u21d1f '' ball 0 \u2191n)\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\ny : F\nhy : y \u2260 0\nhc' : 1 < \u2016\u03c3 c\u2016\nd : \ud835\udd5c'\nhd : d \u2260 0\nydlt : \u2016d \u2022 y\u2016 < \u03b5 / 2\ndinv : \u2016d\u2016\u207b\u00b9 \u2264 (\u03b5 / 2)\u207b\u00b9 * \u2016\u03c3 c\u2016 * \u2016y\u2016\n\u03b4 : \u211d := \u2016d\u2016 * \u2016y\u2016 / 4\n\u03b4pos : 0 < \u03b4\nthis\u271d : a + d \u2022 y \u2208 ball a \u03b5\nz\u2081 : F\nz\u2081im : z\u2081 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2081 : E\nh\u2081 : dist (a + d \u2022 y) (f x\u2081) < \u03b4\nhx\u2081 : \u2016x\u2081\u2016 < \u2191n\nxz\u2081 : f x\u2081 = z\u2081\nthis : a \u2208 ball a \u03b5\nz\u2082 : F\nz\u2082im : z\u2082 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2082 : E\nh\u2082 : dist a (f x\u2082) < \u03b4\nhx\u2082 : \u2016x\u2082\u2016 < \u2191n\nxz\u2082 : f x\u2082 = z\u2082\nx : E := x\u2081 - x\u2082\nI : \u2016f x - d \u2022 y\u2016 \u2264 2 * \u03b4\n\u22a2 \u2016d\u2016\u207b\u00b9 * (2 * (\u2016d\u2016 * \u2016y\u2016 / 4)) = \u2016d\u2016\u207b\u00b9 * \u2016d\u2016 * \u2016y\u2016 / 2",["ring","linarith"]],["Analysis/Normed/Operator/Banach.lean",141,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomIsometric \u03c3\ninst\u271d\u00b9 : RingHomIsometric \u03c3'\ninst\u271d : CompleteSpace F\nsurj : Surjective \u21d1f\nA : \u22c3 n, closure (\u21d1f '' ball 0 \u2191n) = Set.univ\nn : \u2115\na : F\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nH : ball a \u03b5 \u2286 closure (\u21d1f '' ball 0 \u2191n)\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\ny : F\nhy : y \u2260 0\nhc' : 1 < \u2016\u03c3 c\u2016\nd : \ud835\udd5c'\nhd : d \u2260 0\nydlt : \u2016d \u2022 y\u2016 < \u03b5 / 2\ndinv : \u2016d\u2016\u207b\u00b9 \u2264 (\u03b5 / 2)\u207b\u00b9 * \u2016\u03c3 c\u2016 * \u2016y\u2016\n\u03b4 : \u211d := \u2016d\u2016 * \u2016y\u2016 / 4\n\u03b4pos : 0 < \u03b4\nthis\u271d : a + d \u2022 y \u2208 ball a \u03b5\nz\u2081 : F\nz\u2081im : z\u2081 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2081 : E\nh\u2081 : dist (a + d \u2022 y) (f x\u2081) < \u03b4\nhx\u2081 : \u2016x\u2081\u2016 < \u2191n\nxz\u2081 : f x\u2081 = z\u2081\nthis : a \u2208 ball a \u03b5\nz\u2082 : F\nz\u2082im : z\u2082 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2082 : E\nh\u2082 : dist a (f x\u2082) < \u03b4\nhx\u2082 : \u2016x\u2082\u2016 < \u2191n\nxz\u2082 : f x\u2082 = z\u2082\nx : E := x\u2081 - x\u2082\nI : \u2016f x - d \u2022 y\u2016 \u2264 2 * \u03b4\n\u22a2 \u2016y\u2016 / 2 = 1 / 2 * \u2016y\u2016",["ring","linarith"]],["Analysis/Normed/Operator/Banach.lean",150,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomIsometric \u03c3\ninst\u271d\u00b9 : RingHomIsometric \u03c3'\ninst\u271d : CompleteSpace F\nsurj : Surjective \u21d1f\nA : \u22c3 n, closure (\u21d1f '' ball 0 \u2191n) = Set.univ\nn : \u2115\na : F\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nH : ball a \u03b5 \u2286 closure (\u21d1f '' ball 0 \u2191n)\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\ny : F\nhy : y \u2260 0\nhc' : 1 < \u2016\u03c3 c\u2016\nd : \ud835\udd5c'\nhd : d \u2260 0\nydlt : \u2016d \u2022 y\u2016 < \u03b5 / 2\ndinv : \u2016d\u2016\u207b\u00b9 \u2264 (\u03b5 / 2)\u207b\u00b9 * \u2016\u03c3 c\u2016 * \u2016y\u2016\n\u03b4 : \u211d := \u2016d\u2016 * \u2016y\u2016 / 4\n\u03b4pos : 0 < \u03b4\nthis\u271d : a + d \u2022 y \u2208 ball a \u03b5\nz\u2081 : F\nz\u2081im : z\u2081 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2081 : E\nh\u2081 : dist (a + d \u2022 y) (f x\u2081) < \u03b4\nhx\u2081 : \u2016x\u2081\u2016 < \u2191n\nxz\u2081 : f x\u2081 = z\u2081\nthis : a \u2208 ball a \u03b5\nz\u2082 : F\nz\u2082im : z\u2082 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2082 : E\nh\u2082 : dist a (f x\u2082) < \u03b4\nhx\u2082 : \u2016x\u2082\u2016 < \u2191n\nxz\u2082 : f x\u2082 = z\u2082\nx : E := x\u2081 - x\u2082\nI : \u2016f x - d \u2022 y\u2016 \u2264 2 * \u03b4\nJ : dist (f (\u03c3' d\u207b\u00b9 \u2022 x)) y \u2264 1 / 2 * \u2016y\u2016\n\u22a2 (\u03b5 / 2)\u207b\u00b9 * \u2016c\u2016 * \u2016y\u2016 * (\u2191n + \u2191n) = (\u03b5 / 2)\u207b\u00b9 * \u2016c\u2016 * 2 * \u2191n * \u2016y\u2016",["ring","linarith"]],["Analysis/Normed/Operator/Banach.lean",190,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u2074 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b3 : RingHomIsometric \u03c3\ninst\u271d\u00b2 : RingHomIsometric \u03c3'\ninst\u271d\u00b9 : CompleteSpace F\ninst\u271d : CompleteSpace E\nsurj : Surjective \u21d1f\nC : \u211d\nC0 : C \u2265 0\ng : F \u2192 E\nhg : \u2200 (y : F), dist (f (g y)) y \u2264 1 / 2 * \u2016y\u2016 \u2227 \u2016g y\u2016 \u2264 C * \u2016y\u2016\nh : F \u2192 F := fun y \u21a6 y - f (g y)\nhle : \u2200 (y : F), \u2016h y\u2016 \u2264 1 / 2 * \u2016y\u2016\ny : F\nhnle : \u2200 (n : \u2115), \u2016h^[n] y\u2016 \u2264 (1 / 2) ^ n * \u2016y\u2016\nu : \u2115 \u2192 E := fun n \u21a6 g (h^[n] y)\nn : \u2115\n\u22a2 C * ((1 / 2) ^ n * \u2016y\u2016) = (1 / 2) ^ n * (C * \u2016y\u2016)",["ring","linarith"]],["Analysis/Normed/Operator/Banach.lean",204,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u2074 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b3 : RingHomIsometric \u03c3\ninst\u271d\u00b2 : RingHomIsometric \u03c3'\ninst\u271d\u00b9 : CompleteSpace F\ninst\u271d : CompleteSpace E\nsurj : Surjective \u21d1f\nC : \u211d\nC0 : C \u2265 0\ng : F \u2192 E\nhg : \u2200 (y : F), dist (f (g y)) y \u2264 1 / 2 * \u2016y\u2016 \u2227 \u2016g y\u2016 \u2264 C * \u2016y\u2016\nh : F \u2192 F := fun y \u21a6 y - f (g y)\nhle : \u2200 (y : F), \u2016h y\u2016 \u2264 1 / 2 * \u2016y\u2016\ny : F\nhnle : \u2200 (n : \u2115), \u2016h^[n] y\u2016 \u2264 (1 / 2) ^ n * \u2016y\u2016\nu : \u2115 \u2192 E := fun n \u21a6 g (h^[n] y)\nule : \u2200 (n : \u2115), \u2016u n\u2016 \u2264 (1 / 2) ^ n * (C * \u2016y\u2016)\nsNu : Summable fun n \u21a6 \u2016u n\u2016\nsu : Summable u\nx : E := tsum u\n\u22a2 2 * C * \u2016y\u2016 + \u2016y\u2016 = (2 * C + 1) * \u2016y\u2016",["ring","linarith"]],["Topology/MetricSpace/GromovHausdorffRealized.lean",124,"X : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nf : GromovHausdorff.ProdSpaceFun X Y\nx y : X \u2295 Y\nfA : f \u2208 candidates X Y\n\u22a2 f (x, y) + f (x, y) = 2 * f (x, y)",["ring","linarith"]],["Topology/MetricSpace/GromovHausdorffRealized.lean",183,"X : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nf : GromovHausdorff.ProdSpaceFun X Y\nx y z t : X \u2295 Y\nfA : f \u2208 candidates X Y\n\u22a2 \u2191(GromovHausdorff.maxVar X Y) * (dist x z \u2294 dist y t) + \u2191(GromovHausdorff.maxVar X Y) * (dist x z \u2294 dist y t) =\n    2 * \u2191(GromovHausdorff.maxVar X Y) * (dist x z \u2294 dist y t)",["ring","linarith"]],["NumberTheory/Modular.lean",222,"case h.e'_3\nf\u2081 : SL(2, \u2124) \u2192 Matrix (Fin 2) (Fin 2) \u211d := fun g \u21a6 (\u2191g).map Int.cast\ncocompact_\u211d_to_cofinite_\u2124_matrix : Tendsto (fun m \u21a6 m.map Int.cast) cofinite (cocompact (Matrix (Fin 2) (Fin 2) \u211d))\nhf\u2081 : Tendsto f\u2081 cofinite (cocompact (Matrix (Fin 2) (Fin 2) \u211d))\ng : SL(2, \u2124)\nhcd : IsCoprime (\u2191g 1 0) (\u2191g 1 1)\nmB : \u211d \u2192 Matrix (Fin 2) (Fin 2) \u211d := fun t \u21a6 of ![![t, -\u21911], Int.cast \u2218 \u2191g 1]\nhmB : Continuous mB\nhf\u2082 : IsClosedEmbedding \u21d1(lcRow0Extend hcd)\n\u22a2 -(\u2191(\u2191g 1 1) * \u2191(\u2191g 0 0)) + \u2191(\u2191g 1 0) * \u2191(\u2191g 0 1) = \u2191(\u2191g 0 1) * \u2191(\u2191g 1 0) - \u2191(\u2191g 0 0) * \u2191(\u2191g 1 1)",["ring","linarith"]],["NumberTheory/Modular.lean",241,"g : SL(2, \u2124)\nz : \u210d\np : Fin 2 \u2192 \u2124\nhp : IsCoprime (p 0) (p 1)\nhg : \u2191g 1 = p\nnonZ1 : \u2191(p 0) ^ 2 + \u2191(p 1) ^ 2 \u2260 0\nthis : Int.cast \u2218 p \u2260 0\nnonZ2 : \u2191(p 0) * \u2191z + \u2191(p 1) \u2260 0\n\u22a2 (\u2191(\u2191g 0 0) * \u2191z + \u2191(\u2191g 0 1)) *\n      ((\u2191(\u2191g 1 0) ^ 2 + \u2191(\u2191g 1 1) ^ 2) * ((\u2191(\u2191g 1 0) ^ 2 + \u2191(\u2191g 1 1) ^ 2) * (\u2191(\u2191g 1 0) * \u2191z + \u2191(\u2191g 1 1)))) =\n    ((\u2191(\u2191g 1 0) * \u2191(\u2191g 0 0) + \u2191(\u2191g 1 1) * \u2191(\u2191g 0 1)) * ((\u2191(\u2191g 1 0) ^ 2 + \u2191(\u2191g 1 1) ^ 2) * (\u2191(\u2191g 1 0) * \u2191z + \u2191(\u2191g 1 1))) +\n        (\u2191(\u2191g 1 1) * \u2191z - \u2191(\u2191g 1 0)) * (\u2191(\u2191g 0 0) * \u2191(\u2191g 1 1) - \u2191(\u2191g 0 1) * \u2191(\u2191g 1 0)) *\n          (\u2191(\u2191g 1 0) ^ 2 + \u2191(\u2191g 1 1) ^ 2)) *\n      (\u2191(\u2191g 1 0) * \u2191z + \u2191(\u2191g 1 1))",["ring"]],["NumberTheory/Modular.lean",470,"g : SL(2, \u2124)\nz : \u210d\nhz : z \u2208 \ud835\udc9f\u1d52\nhg : g \u2022 z \u2208 \ud835\udc9f\u1d52\nc' : \u2124 := \u2191g 1 0\nc : \u211d := \u2191c'\nhc : c \u2260 0\nh\u2081 : 3 * 3 * c ^ 4 < 4 * (g \u2022 z).im ^ 2 * (4 * z.im ^ 2) * c ^ 4\nh\u2082 : (c * z.im) ^ 4 / normSq (denom (\u2191g) z) ^ 2 \u2264 1\nnsq : \u211d := normSq (denom (\u2191g) z)\n\u22a2 c ^ 4 * z.im ^ 2 * (z.im ^ 2 / normSq (denom (\u2191g) z) ^ 2) * 16 = c ^ 4 * z.im ^ 4 / nsq ^ 2 * 16",["ring"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",114,"E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Finset E\nhs : \u2200 c \u2208 s, \u2016c\u2016 \u2264 2\nh : \u2200 c \u2208 s, \u2200 d \u2208 s, c \u2260 d \u2192 1 \u2264 \u2016c - d\u2016\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\n\u03bc : Measure E := Measure.addHaar\n\u03b4 : \u211d := 1 / 2\n\u03c1 : \u211d := 5 / 2\n\u22a2 0 < \u03c1",["norm_num","aesop","positivity"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",121,"case h.e'_3\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Finset E\nhs : \u2200 c \u2208 s, \u2016c\u2016 \u2264 2\nh : \u2200 c \u2208 s, \u2200 d \u2208 s, c \u2260 d \u2192 1 \u2264 \u2016c - d\u2016\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\n\u03bc : Measure E := Measure.addHaar\n\u03b4 : \u211d := 1 / 2\n\u03c1 : \u211d := 5 / 2\n\u03c1pos : 0 < \u03c1\nA : Set E := \u22c3 c \u2208 s, ball c \u03b4\nhA : A = \u22c3 c \u2208 s, ball c \u03b4\nc : E\nhc : c \u2208 \u2191s\nd : E\nhd : d \u2208 \u2191s\nhcd : c \u2260 d\n\u22a2 \u03b4 + \u03b4 = 1",["norm_num","ring"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",127,"E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Finset E\nhs : \u2200 c \u2208 s, \u2016c\u2016 \u2264 2\nh : \u2200 c \u2208 s, \u2200 d \u2208 s, c \u2260 d \u2192 1 \u2264 \u2016c - d\u2016\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\n\u03bc : Measure E := Measure.addHaar\n\u03b4 : \u211d := 1 / 2\n\u03c1 : \u211d := 5 / 2\n\u03c1pos : 0 < \u03c1\nA : Set E := \u22c3 c \u2208 s, ball c \u03b4\nhA : A = \u22c3 c \u2208 s, ball c \u03b4\nD : (\u2191s).Pairwise (Disjoint on fun c \u21a6 ball c \u03b4)\nx : E\nhx : x \u2208 s\n\u22a2 \u03b4 + 2 = 5 / 2",["norm_num","ring","linarith"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",134,"E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Finset E\nhs : \u2200 c \u2208 s, \u2016c\u2016 \u2264 2\nh : \u2200 c \u2208 s, \u2200 d \u2208 s, c \u2260 d \u2192 1 \u2264 \u2016c - d\u2016\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\n\u03bc : Measure E := Measure.addHaar\n\u03b4 : \u211d := 1 / 2\n\u03c1 : \u211d := 5 / 2\n\u03c1pos : 0 < \u03c1\nA : Set E := \u22c3 c \u2208 s, ball c \u03b4\nhA : A = \u22c3 c \u2208 s, ball c \u03b4\nD : (\u2191s).Pairwise (Disjoint on fun c \u21a6 ball c \u03b4)\nA_subset : A \u2286 ball 0 \u03c1\n\u22a2 0 < \u03b4",["norm_num","aesop","positivity"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",368,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastc : a.c (last N) = 0\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\nh\u03b42 : \u03b4 \u2264 1\ni j : Fin N.succ\ninej : i \u2260 j\nhi : \u2016a.c i\u2016 \u2264 2\nhj : 2 < \u2016a.c j\u2016\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nD : 0 \u2264 1 - \u03b4 / 4\nhcrj : \u2016a.c j\u2016 \u2264 a.r j + 1\nI : a.r i \u2264 2\nJ : (1 - \u03b4 / 4) * \u03c4 \u2264 1\nH : a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i\n\u22a2 5 / 4 * 2 \u2264 4",["norm_num","linarith"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",320,"E : Type u_1\ninst\u271d : NormedAddCommGroup E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\nh\u03b42 : \u03b4 \u2264 1\ni j : Fin N.succ\ninej : i \u2260 j\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nD : 0 \u2264 1 - \u03b4 / 4\n\u03c4pos : 0 < \u03c4\n\u22a2 (1 - \u03b4 / 4) * (1 + \u03b4 / 4) = 1 - \u03b4 ^ 2 / 16",["ring","linarith"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",359,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastc : a.c (last N) = 0\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\nh\u03b42 : \u03b4 \u2264 1\ni j : Fin N.succ\ninej : i \u2260 j\nhi : \u2016a.c i\u2016 \u2264 2\nhj : 2 < \u2016a.c j\u2016\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nD : 0 \u2264 1 - \u03b4 / 4\nhcrj : \u2016a.c j\u2016 \u2264 a.r j + 1\nI : a.r i \u2264 2\n\u22a2 (1 - \u03b4 / 4) * (1 + \u03b4 / 4) = 1 - \u03b4 ^ 2 / 16",["ring","linarith"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",373,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastc : a.c (last N) = 0\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\nh\u03b42 : \u03b4 \u2264 1\ni j : Fin N.succ\ninej : i \u2260 j\nhi : \u2016a.c i\u2016 \u2264 2\nhj : 2 < \u2016a.c j\u2016\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nD : 0 \u2264 1 - \u03b4 / 4\nhcrj : \u2016a.c j\u2016 \u2264 a.r j + 1\nI : a.r i \u2264 2\nJ : (1 - \u03b4 / 4) * \u03c4 \u2264 1\nH : a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i\nC : a.r j \u2264 4\n\u22a2 a.r j - a.r j / 4 * \u03b4 = (1 - \u03b4 / 4) * a.r j",["ring","linarith"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",432,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastc : a.c (last N) = 0\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\ni j : Fin N.succ\ninej : i \u2260 j\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nhcrj : \u2016a.c j\u2016 \u2264 a.r j + 1\nhj : 2 < \u2016a.c j\u2016\ns : \u211d := \u2016a.c i\u2016\nhi : 2 < s\nhij : s \u2264 \u2016a.c j\u2016\nA : a.r i \u2264 s\nspos : 0 < s\nd : E := (s / \u2016a.c j\u2016) \u2022 a.c j\nhd : d = (s / \u2016a.c j\u2016) \u2022 a.c j\nI : \u2016a.c j - a.c i\u2016 \u2264 \u2016a.c j\u2016 - s + \u2016d - a.c i\u2016\nH : a.r i \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i\n\u22a2 \u03c4 * a.r i - a.r i = a.r i * (\u03c4 - 1)",["ring","linarith"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",435,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastc : a.c (last N) = 0\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\ni j : Fin N.succ\ninej : i \u2260 j\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nhcrj : \u2016a.c j\u2016 \u2264 a.r j + 1\nhj : 2 < \u2016a.c j\u2016\ns : \u211d := \u2016a.c i\u2016\nhi : 2 < s\nhij : s \u2264 \u2016a.c j\u2016\nA : a.r i \u2264 s\nspos : 0 < s\nd : E := (s / \u2016a.c j\u2016) \u2022 a.c j\nhd : d = (s / \u2016a.c j\u2016) \u2022 a.c j\nI : \u2016a.c j - a.c i\u2016 \u2264 \u2016a.c j\u2016 - s + \u2016d - a.c i\u2016\n\u22a2 s * (\u03b4 / 2) = s / 2 * \u03b4",["ring","linarith"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",438,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastc : a.c (last N) = 0\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\ni j : Fin N.succ\ninej : i \u2260 j\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nhcrj : \u2016a.c j\u2016 \u2264 a.r j + 1\nhj : 2 < \u2016a.c j\u2016\ns : \u211d := \u2016a.c i\u2016\nhi : 2 < s\nhij : s \u2264 \u2016a.c j\u2016\nA : a.r i \u2264 s\nspos : 0 < s\nd : E := (s / \u2016a.c j\u2016) \u2022 a.c j\nhd : d = (s / \u2016a.c j\u2016) \u2022 a.c j\nI : \u2016a.c j - a.c i\u2016 \u2264 \u2016a.c j\u2016 - s + \u2016d - a.c i\u2016\nJ : a.r j - \u2016a.c j - a.c i\u2016 \u2264 s / 2 * \u03b4\ninvs_nonneg : 0 \u2264 2 / s\n\u22a2 (1 - \u03b4) * (s * 2) = 2 * (s - s * \u03b4)",["ring","linarith"]],["Topology/Path.lean",259,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\n\u03b3' : Path y z\n\u22a2 { toFun := (fun t \u21a6 if t \u2264 1 / 2 then \u03b3.extend (2 * t) else \u03b3'.extend (2 * t - 1)) \u2218 Subtype.val,\n          continuous_toFun := \u22ef }.toFun\n      1 =\n    z",["norm_num","infer_instance"]],["Topology/Path.lean",278,"case pos\nX : Type u_1\ninst\u271d : TopologicalSpace X\nx y z : X\n\u03b3 : Path x y\n\u03b3' : Path y z\nt : \u2191I\nh\u271d : \u00ac\u2191(\u03c3 t) \u2264 1 / 2\nh : \u00ac1 - \u2191t \u2264 1 / 2\nh\u2082 : \u2191t \u2264 1 / 2\n\u22a2 2 - 2 * \u2191t - 1 = 1 - 2 * \u2191t",["ring","linarith"]],["Geometry/Euclidean/Angle/Unoriented/Affine.lean",284,"case h.e'_3.h.e'_5\nV : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 -\u1d65 p\u2082 \u2260 0\nr : \u211d\nhr : r < 0\nhp\u2083p\u2082 : p\u2083 = r \u2022 (p\u2081 -\u1d65 p\u2082) +\u1d65 p\u2082\n\u22a2 -(r * (1 - r)) + (1 - r) = (1 - r) * (1 - r)",["ring","linarith"]],["Analysis/Fourier/AddCircle.lean",117,"case e_z\nT : \u211d\nn : \u2124\nx : \u211d\n\u22a2 2 * \u2191\u03c0 / \u2191T * (\u2191n * \u2191x) * Complex.I = 2 * \u2191\u03c0 * Complex.I * \u2191n * \u2191x / \u2191T",["ring"]],["Analysis/Fourier/AddCircle.lean",177,"case h.e'_2.h.e'_1.h.e'_5\nT : \u211d\nn : \u2124\nhn : n \u2260 0\nx : AddCircle T\nthis : \u2191n \u2260 0\nhT : \u2191T \u2260 0\n\u22a2 2 * \u2191\u03c0 * (\u2191n * \u2191T) = \u2191\u03c0 * (\u2191T * (2 * \u2191n))",["ring"]],["Analysis/Fourier/AddCircle.lean",446,"case h.e'_8.h\nT : \u211d\nn : \u2124\nx : \u211d\ny : \u2102\n\u22a2 2 * \u2191\u03c0 * I * \u2191n * y / \u2191T = y * (2 * \u2191\u03c0 * I * \u2191n / \u2191T)",["ring"]],["Analysis/Fourier/AddCircle.lean",459,"case h.e'_8.h\nT : \u211d\nhT : Fact (0 < T)\nn : \u2124\nhn : n \u2260 0\nx y : \u211d\n\u22a2 \u2191T / (-2 * \u2191\u03c0 * I * \u2191n) * (fourier (-n)) \u2191y = (fourier (-n)) \u2191y * \u2191T / (-2 * \u2191\u03c0 * I * \u2191n)",["ring"]],["Analysis/Fourier/AddCircle.lean",478,"a b : \u211d\nhab : a < b\nf f' : \u211d \u2192 \u2102\nn : \u2124\nhn : n \u2260 0\nhf : ContinuousOn f [[a, b]]\nhff' : \u2200 x \u2208 Ioo (a \u2293 b) (a \u2294 b), HasDerivWithinAt f (f' x) (Ioi x) x\nhf' : IntervalIntegrable f' volume a b\nhT : Fact (0 < b - a)\nu\u271d v\u271d w\u271d : \u2102\n\u22a2 u\u271d * (\u2191(b - a) / v\u271d * w\u271d) = \u2191(b - a) / v\u271d * (u\u271d * w\u271d)",["ring"]],["Analysis/Fourier/AddCircle.lean",487,"case e_a\na b : \u211d\nhab : a < b\nf f' : \u211d \u2192 \u2102\nn : \u2124\nhn : n \u2260 0\nhf : ContinuousOn f [[a, b]]\nhff' : \u2200 x \u2208 Ioo (a \u2293 b) (a \u2294 b), HasDerivWithinAt f (f' x) (Ioi x) x\nhf' : IntervalIntegrable f' volume a b\nhT : Fact (0 < b - a)\nthis : \u2200 (u v w : \u2102), u * (\u2191(b - a) / v * w) = \u2191(b - a) / v * (u * w)\ns2 : \u2191b = \u2191a\n\u22a2 (f b - f a) * (\u2191(b - a) * (1 / (-2 * \u2191\u03c0 * I * \u2191n)) * (fourier (-n)) \u2191a) =\n    1 / (-2 * \u2191\u03c0 * I * \u2191n) * ((f b - f a) * (fourier (-n)) \u2191a) * \u2191(b - a)",["ring"]],["Algebra/ContinuedFractions/Computation/Approximations.lean",392,"K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nifp : IntFractPair K\nstream_nth_eq : IntFractPair.stream v n = some ifp\ng : GenContFract K := of v\nconts : Pair K := g.contsAux (n + 1)\npred_conts : Pair K := g.contsAux n\nifp_fr_ne_zero : ifp.fr \u2260 0\nA : K := conts.a\nB : K := conts.b\npA : K := pred_conts.a\npB : K := pred_conts.b\ng_finite_correctness : v = (pA + ifp.fr\u207b\u00b9 * A) / (pB + ifp.fr\u207b\u00b9 * B)\nn_eq_zero_or_not_terminatedAt_pred_n : n = 0 \u2228 \u00acg.TerminatedAt (n - 1)\ndeterminant_eq : pA * B - pB * A = (-1) ^ n\npB_ineq : \u2191(fib n) \u2264 pB\nB_ineq : \u2191(fib (n + 1)) \u2264 B\nzero_lt_B : 0 < B\nthis\u271d\u00b9 : 0 \u2264 pB\nthis\u271d : 0 < ifp.fr\nthis : pB + ifp.fr\u207b\u00b9 * B \u2260 0\n\u22a2 (pA * B + ifp.fr\u207b\u00b9 * A * B - (pB * A + ifp.fr\u207b\u00b9 * B * A)) / ((pB + ifp.fr\u207b\u00b9 * B) * B) =\n    (pA * B - pB * A) / ((pB + ifp.fr\u207b\u00b9 * B) * B)",["ring"]],["Algebra/ContinuedFractions/Computation/Approximations.lean",430,"K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nnot_terminatedAt_n : \u00ac(of v).TerminatedAt n\ng : GenContFract K := of v\nnextConts : Pair K := g.contsAux (n + 2)\nconts : Pair K := g.contsAux (n + 1)\nconts_eq : conts = g.contsAux (n + 1)\npred_conts : Pair K := g.contsAux n\npred_conts_eq : pred_conts = g.contsAux n\ngp : Pair K\ns_nth_eq : g.s.get? n = some gp\ngp_a_eq_one : gp.a = 1\nnextConts_b_eq : nextConts.b = pred_conts.b + gp.b * conts.b\nden : K := conts.b * (pred_conts.b + gp.b * conts.b)\nifp_succ_n : IntFractPair K\nsucc_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n\nifp_succ_n_b_eq_gp_b : \u2191ifp_succ_n.b = gp.b\nifp_n : IntFractPair K\nstream_nth_eq : IntFractPair.stream v n = some ifp_n\nstream_nth_fr_ne_zero : ifp_n.fr \u2260 0\nif_of_eq_ifp_succ_n : IntFractPair.of ifp_n.fr\u207b\u00b9 = ifp_succ_n\nden' : K := conts.b * (pred_conts.b + ifp_n.fr\u207b\u00b9 * conts.b)\nthis : |(-1) ^ n / den'| \u2264 1 / den\ntmp :\n  v - (of v).convs n =\n    (-1) ^ n / (((of v).contsAux (n + 1)).b * (ifp_n.fr\u207b\u00b9 * ((of v).contsAux (n + 1)).b + ((of v).contsAux n).b))\n\u22a2 (-1) ^ n / (((of v).contsAux (n + 1)).b * (ifp_n.fr\u207b\u00b9 * ((of v).contsAux (n + 1)).b + ((of v).contsAux n).b)) =\n    (-1) ^ n / den'",["ring"]],["Analysis/Calculus/BumpFunction/FiniteDimension.lean",513,"E\u271d : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\ninst\u271d\u2074 : NormedSpace \u211d E\u271d\ninst\u271d\u00b3 : FiniteDimensional \u211d E\u271d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\nIR : \u2200 (R : \u211d), 1 < R \u2192 0 < (R - 1) / (R + 1)\nR : \u211d\nhR : 1 < R\nx : E\nhx : \u2016x\u2016 \u2264 1\nA : 0 < R + 1\n\u22a2 2 = 1 + 1",["ring","linarith","norm_num"]],["Analysis/Calculus/BumpFunction/FiniteDimension.lean",520,"E\u271d : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\ninst\u271d\u2074 : NormedSpace \u211d E\u271d\ninst\u271d\u00b3 : FiniteDimensional \u211d E\u271d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\nIR : \u2200 (R : \u211d), 1 < R \u2192 0 < (R - 1) / (R + 1)\nR : \u211d\nhR : 1 < R\nA : 0 < (R + 1) / 2\nC : (R - 1) / (R + 1) < 1\n\u22a2 (R + 1) * (R + R) = R * (2 * (R + 1))",["ring","linarith"]],["Analysis/InnerProductSpace/Defs.lean",293,"\ud835\udd5c : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\n\u22a2 \u27eax, x\u27eb_\ud835\udd5c + \u27eay, x\u27eb_\ud835\udd5c + (\u27eax, y\u27eb_\ud835\udd5c + \u27eay, y\u27eb_\ud835\udd5c) = \u27eax, x\u27eb_\ud835\udd5c + \u27eax, y\u27eb_\ud835\udd5c + \u27eay, x\u27eb_\ud835\udd5c + \u27eay, y\u27eb_\ud835\udd5c",["ring","abel"]],["Analysis/InnerProductSpace/Defs.lean",297,"\ud835\udd5c : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\n\u22a2 \u27eax, x\u27eb_\ud835\udd5c - \u27eay, x\u27eb_\ud835\udd5c - (\u27eax, y\u27eb_\ud835\udd5c - \u27eay, y\u27eb_\ud835\udd5c) = \u27eax, x\u27eb_\ud835\udd5c - \u27eax, y\u27eb_\ud835\udd5c - \u27eay, x\u27eb_\ud835\udd5c + \u27eay, y\u27eb_\ud835\udd5c",["ring","abel"]],["Analysis/InnerProductSpace/Defs.lean",326,"\ud835\udd5c : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\nt : \u211d\n\u22a2 normSq x * t * t + re \u27eax, y\u27eb_\ud835\udd5c * t + re \u27eax, y\u27eb_\ud835\udd5c * t + normSq y = normSq x * t * t + 2 * re \u27eax, y\u27eb_\ud835\udd5c * t + normSq y",["ring","linarith"]],["Analysis/InnerProductSpace/Defs.lean",339,"\ud835\udd5c : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\n\u22a2 \u2191\u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 ^ 2 * \u2191(normSq x) - \u2191(normSq x) * \u2191\u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 ^ 2 - \u2191(normSq x) * \u2191\u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 ^ 2 +\n      \u2191(normSq x) * (\u2191(normSq x) * \u2191(normSq y)) =\n    \u2191(normSq x) * (\u2191(normSq x) * \u2191(normSq y)) - \u2191(normSq x) * \u2191\u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 ^ 2",["ring"]],["Analysis/InnerProductSpace/Defs.lean",365,"case h.e'_4.h.e'_5.h.e'_5\n\ud835\udd5c : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\nt : \u211d\nhzero : \u00ac\u27eax, y\u27eb_\ud835\udd5c = 0\nhzero' : \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 \u2260 0\n\u22a2 re \u27eax, x\u27eb_\ud835\udd5c * t ^ 2 * (\u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016) = \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * re \u27eax, x\u27eb_\ud835\udd5c * t * t",["ring","linarith"]],["Analysis/InnerProductSpace/Defs.lean",368,"case h.e'_4.h.e'_5.h.e'_6\n\ud835\udd5c : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\nt : \u211d\nhzero : \u00ac\u27eax, y\u27eb_\ud835\udd5c = 0\nhzero' : \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 \u2260 0\n\u22a2 2 * \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * t * \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 = 2 * \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 ^ 2 * t",["ring","linarith"]],["Analysis/InnerProductSpace/Defs.lean",389,"\ud835\udd5c : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\n\u22a2 \u2016x\u2016 * \u2016x\u2016 * (\u2016y\u2016 * \u2016y\u2016) = \u2016x\u2016 * \u2016y\u2016 * (\u2016x\u2016 * \u2016y\u2016)",["ring","linarith"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",58,"case h.h\ns x : \u211d\n\u22a2 x = x * 2 + -x",["ring","linarith"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",167,"case h\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nx\u271d : \u211d\n\u22a2 \u2191(rexp (-x\u271d)) * (s * \u2191x\u271d ^ (s - 1)) = s * (\u2191(rexp (-x\u271d)) * \u2191x\u271d ^ (s - 1))",["ring"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",211,"case h\ns : \u2102\nhs : 0 < s.re\nX : \u211d\nhX : 0 \u2264 X\nF_der_I :\n  \u2200 x \u2208 Ioo 0 X,\n    HasDerivAt (fun x \u21a6 \u2191(rexp (-x)) * \u2191x ^ s) (-(\u2191(rexp (-x)) * \u2191x ^ s) + \u2191(rexp (-x)) * (s * \u2191x ^ (s - 1))) x\ncont : Continuous fun x \u21a6 (ofReal \u2218 fun y \u21a6 rexp (-y)) x * \u2191x ^ s\nder_ible : IntervalIntegrable (fun x \u21a6 -(\u2191(rexp (-x)) * \u2191x ^ s) + \u2191(rexp (-x)) * (s * \u2191x ^ (s - 1))) volume 0 X\nint_eval :\n  (\u222b (x : \u211d) in 0 ..X, \u2191(rexp (-x)) * \u2191x ^ s) + -\u222b (x : \u211d) in 0 ..X, \u2191(rexp (-x)) * (s * \u2191x ^ (s - 1)) =\n    -((ofReal \u2218 fun y \u21a6 rexp (-y)) X * \u2191X ^ s - (ofReal \u2218 fun y \u21a6 rexp (-y)) 0 * \u21910 ^ s)\nx\u271d : \u211d\n\u22a2 \u2191(rexp (-x\u271d)) * (s * \u2191x\u271d ^ (s - 1)) = s * \u2191(rexp (-x\u271d)) * \u2191x\u271d ^ (s - 1)",["ring"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",215,"case e_a.e_f.h\ns : \u2102\nhs : 0 < s.re\nX : \u211d\nhX : 0 \u2264 X\nF_der_I :\n  \u2200 x \u2208 Ioo 0 X,\n    HasDerivAt (fun x \u21a6 \u2191(rexp (-x)) * \u2191x ^ s) (-(\u2191(rexp (-x)) * \u2191x ^ s) + \u2191(rexp (-x)) * (s * \u2191x ^ (s - 1))) x\ncont : Continuous fun x \u21a6 (ofReal \u2218 fun y \u21a6 rexp (-y)) x * \u2191x ^ s\nder_ible : IntervalIntegrable (fun x \u21a6 -(\u2191(rexp (-x)) * \u2191x ^ s) + \u2191(rexp (-x)) * (s * \u2191x ^ (s - 1))) volume 0 X\nint_eval :\n  (\u222b (x : \u211d) in 0 ..X, \u2191(rexp (-x)) * \u2191x ^ s) + -\u222b (x : \u211d) in 0 ..X, \u2191(rexp (-x)) * (s * \u2191x ^ (s - 1)) =\n    -((ofReal \u2218 fun y \u21a6 rexp (-y)) X * \u2191X ^ s - (ofReal \u2218 fun y \u21a6 rexp (-y)) 0 * \u21910 ^ s)\nthis : (fun x \u21a6 \u2191(rexp (-x)) * (s * \u2191x ^ (s - 1))) = fun x \u21a6 s * \u2191(rexp (-x)) * \u2191x ^ (s - 1)\nt : \u222b (x : \u211d) in 0 ..X, s * (\u2191(rexp (-x)) * \u2191x ^ (s - 1)) = s * \u222b (x : \u211d) in 0 ..X, \u2191(rexp (-x)) * \u2191x ^ (s - 1)\nx\u271d : \u211d\n\u22a2 s * \u2191(rexp (-x\u271d)) * \u2191x\u271d ^ (s - 1) = s * (\u2191(rexp (-x\u271d)) * \u2191x\u271d ^ (s - 1))",["ring"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",522,"case hs\nn\u271d : \u2115\nn_ih : \u2200 {s : \u211d}, (\u2200 (m : \u2115), s \u2260 -\u2191m) \u2192 -\u2191n\u271d < s \u2192 Gamma s \u2260 0\ns : \u211d\nhs' : -\u2191(n\u271d + 1) < s\nm : \u2115\nhs : s = -\u2191m - 1\n\u22a2 -\u2191m - 1 = -(1 + \u2191m)",["ring","aesop","linarith","abel"]],["NumberTheory/NumberField/Discriminant/Basic.lean",133,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nI : (FractionalIdeal (\ud835\udcde K)\u2070 K)\u02e3\nB : \u211d := (minkowskiBound K I * \u2191(convexBodySumFactor K)\u207b\u00b9).toReal ^ (1 / \u2191(finrank \u211a K))\nh_le : minkowskiBound K I \u2264 volume (convexBodySum K B)\nx\u271d : K\n\u22a2 \u2191(FractionalIdeal.absNorm \u2191I) * 2 ^ (-\u2191(nrComplexPlaces K)) * \u221a\u2016discr K\u2016 * 2 ^ \u2191(finrank \u211a K) *\n      (\u2191(finrank \u211a K).factorial * (2 ^ (-\u2191(nrRealPlaces K)) * (\u03c0 ^ (-\u2191(nrComplexPlaces K)) * 2 ^ \u2191(nrComplexPlaces K)))) =\n    \u2191(FractionalIdeal.absNorm \u2191I) *\n            (2 ^ \u2191(finrank \u211a K) * 2 ^ (-\u2191(nrComplexPlaces K)) * 2 ^ (-\u2191(nrRealPlaces K)) * 2 ^ \u2191(nrComplexPlaces K)) *\n          \u221a\u2016discr K\u2016 *\n        \u2191(finrank \u211a K).factorial *\n      \u03c0 ^ (-\u2191(nrComplexPlaces K))",["ring","linarith"]],["NumberTheory/NumberField/Discriminant/Basic.lean",138,"case e_a.e_a.e_a.e_a.e_a\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nI : (FractionalIdeal (\ud835\udcde K)\u2070 K)\u02e3\nB : \u211d := (minkowskiBound K I * \u2191(convexBodySumFactor K)\u207b\u00b9).toReal ^ (1 / \u2191(finrank \u211a K))\nh_le : minkowskiBound K I \u2264 volume (convexBodySum K B)\nx\u271d : K\n\u22a2 \u2191(nrRealPlaces K) + 2 * \u2191(nrComplexPlaces K) - \u2191(nrComplexPlaces K) - \u2191(nrRealPlaces K) + \u2191(nrComplexPlaces K) =\n    2 * \u2191(nrComplexPlaces K)",["ring","omega","linarith","abel"]],["NumberTheory/NumberField/Discriminant/Basic.lean",143,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nI : (FractionalIdeal (\ud835\udcde K)\u2070 K)\u02e3\nB : \u211d := (minkowskiBound K I * \u2191(convexBodySumFactor K)\u207b\u00b9).toReal ^ (1 / \u2191(finrank \u211a K))\nh_le : minkowskiBound K I \u2264 volume (convexBodySum K B)\nx\u271d : K\n\u22a2 \u2191(FractionalIdeal.absNorm \u2191I) * 4 ^ nrComplexPlaces K * \u221a|\u2191(discr K)| * \u2191(finrank \u211a K).factorial *\n      (1 / \u03c0 ^ nrComplexPlaces K) =\n    \u2191(FractionalIdeal.absNorm \u2191I) * (4 ^ nrComplexPlaces K / \u03c0 ^ nrComplexPlaces K) * \u2191(finrank \u211a K).factorial *\n      \u221a|\u2191(discr K)|",["ring"]],["NumberTheory/NumberField/Discriminant/Basic.lean",182,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nh : 1 < finrank \u211a K\nx : \ud835\udcde K\nh_nz : x \u2260 0\nh_nm : 1 \u2264 \u2191|(Algebra.norm \u211a) \u2191x|\nh_bd :\n  \u2191(finrank \u211a K) ^ (finrank \u211a K * 2) / ((4 / \u03c0) ^ (nrComplexPlaces K * 2) * \u2191(finrank \u211a K).factorial ^ 2) \u2264 \u2191|discr K|\na : \u2115 \u2192 \u211d := fun n \u21a6 \u2191n ^ (n * 2) / ((4 / \u03c0) ^ n * \u2191n.factorial ^ 2)\nn : \u2115\n\u22a2 4 * (3 * \u03c0) ^ 2 * (4 ^ 2 * 4) = 16 * \u03c0 ^ 2 * (9 * 4 ^ 2)",["ring","linarith"]],["NumberTheory/NumberField/Discriminant/Basic.lean",187,"case h.e'_4\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nh : 1 < finrank \u211a K\nx : \ud835\udcde K\nh_nz : x \u2260 0\nh_nm : 1 \u2264 \u2191|(Algebra.norm \u211a) \u2191x|\nh_bd :\n  \u2191(finrank \u211a K) ^ (finrank \u211a K * 2) / ((4 / \u03c0) ^ (nrComplexPlaces K * 2) * \u2191(finrank \u211a K).factorial ^ 2) \u2264 \u2191|discr K|\na : \u2115 \u2192 \u211d := fun n \u21a6 \u2191n ^ (n * 2) / ((4 / \u03c0) ^ n * \u2191n.factorial ^ 2)\nn m : \u2115\nhmn\u271d : 2 \u2264 m\nh_m : 4 / 9 * (3 * \u03c0 / 4) ^ m \u2264 a m\nthis : 3 \u2264 (1 + 1 / \u2191m) ^ (2 * m)\n\u22a2 (\u2191m + 1) ^ (m * 2) * (\u2191m + 1) * (\u2191m + 1) * (\u03c0 ^ m * \u03c0) * (4 ^ m * (\u2191m.factorial * \u2191m.factorial) * \u2191m ^ (2 * m) * 4) =\n    \u2191m ^ (m * 2) * \u03c0 ^ m * (\u2191m + 1) ^ (2 * m) * \u03c0 * (4 ^ m * 4 * ((\u2191m + 1) * \u2191m.factorial * ((\u2191m + 1) * \u2191m.factorial)))",["ring"]],["NumberTheory/NumberField/Discriminant/Basic.lean",190,"case h.e'_3\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nh : 1 < finrank \u211a K\nx : \ud835\udcde K\nh_nz : x \u2260 0\nh_nm : 1 \u2264 \u2191|(Algebra.norm \u211a) \u2191x|\nh_bd :\n  \u2191(finrank \u211a K) ^ (finrank \u211a K * 2) / ((4 / \u03c0) ^ (nrComplexPlaces K * 2) * \u2191(finrank \u211a K).factorial ^ 2) \u2264 \u2191|discr K|\na : \u2115 \u2192 \u211d := fun n \u21a6 \u2191n ^ (n * 2) / ((4 / \u03c0) ^ n * \u2191n.factorial ^ 2)\nn m : \u2115\nhmn\u271d : 2 \u2264 m\nh_m : 4 / 9 * (3 * \u03c0 / 4) ^ m \u2264 a m\nthis : 3 \u2264 (1 + 1 / \u2191m) ^ (2 * m)\n\u22a2 4 * ((3 * \u03c0) ^ m * (3 * \u03c0)) * 4 * (9 * 4 ^ m) = 4 * (3 * \u03c0) ^ m * 3 * (9 * (4 ^ m * 4) * \u03c0)",["ring","linarith"]],["Analysis/Calculus/Rademacher.lean",300,"case e_a\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\nC : \u211d\u22650\ninst\u271d : FiniteDimensional \u211d E\nf : E \u2192 F\nhf : LipschitzWith C f\ns : Set E\nhs : sphere 0 1 \u2286 closure s\nL : E \u2192L[\u211d] F\nx : E\nhL : \u2200 v \u2208 s, HasLineDerivAt \u211d f (L v) x v\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : (\u2191C + \u2016L\u2016 + 1) * \u03b4 = \u03b5\nq : Set E\nhqs : q \u2286 s\nq_fin : q.Finite\nhq : sphere 0 1 \u2286 \u22c3 y \u2208 q, ball y \u03b4\nI : \u2200\u1da0 (t : \u211d) in \ud835\udcdd 0, \u2200 v \u2208 q, \u2016f (x + t \u2022 v) - f x - t \u2022 L v\u2016 \u2264 \u03b4 * \u2016t\u2016\nr : \u211d\nr_pos : 0 < r\nhr : \u2200 (t : \u211d), \u2016t\u2016 < r \u2192 \u2200 v \u2208 q, \u2016f (x + t \u2022 v) - f x - t \u2022 L v\u2016 \u2264 \u03b4 * \u2016t\u2016\nv : E\nhv : v \u2208 ball 0 r\nv_ne : v \u2260 0\nw : E\n\u03c1 : \u211d\nw_mem : w \u2208 sphere 0 1\nhvw : v = \u03c1 \u2022 w\nh\u03c1 : \u03c1 = \u2016v\u2016\nnorm_rho : \u2016\u03c1\u2016 = \u03c1\nrho_pos : 0 \u2264 \u03c1\ny : E\nyq : y \u2208 q\nhy : \u2016w - y\u2016 < \u03b4\nthis : \u2016y - w\u2016 < \u03b4\n\u22a2 f (x + \u03c1 \u2022 w) - f x - \u03c1 \u2022 L w = f (x + \u03c1 \u2022 w) - f (x + \u03c1 \u2022 y) + (\u03c1 \u2022 L y - \u03c1 \u2022 L w) + (f (x + \u03c1 \u2022 y) - f x - \u03c1 \u2022 L y)",["abel"]],["Analysis/Calculus/Rademacher.lean",120,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : BorelSpace E\nC : \u211d\u22650\nf g : E \u2192 \u211d\n\u03bc : Measure E\ninst\u271d\u00b9 : FiniteDimensional \u211d E\ninst\u271d : \u03bc.IsAddHaarMeasure\nhf : LipschitzWith C f\nhg : Integrable g \u03bc\nv : E\nt : \u211d\nht : 0 < t\nx : E\n\u22a2 \u2191C * (t * \u2016v\u2016) * |g x| = \u2191C * \u2016v\u2016 * |g x| * t",["ring","linarith"]],["Analysis/Calculus/Rademacher.lean",147,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : BorelSpace E\nC : \u211d\u22650\nf g : E \u2192 \u211d\n\u03bc : Measure E\ninst\u271d\u00b9 : FiniteDimensional \u211d E\ninst\u271d : \u03bc.IsAddHaarMeasure\nhf : LipschitzWith C f\nh'f : HasCompactSupport f\nhg : Continuous g\nv : E\nK : Set E := cthickening \u2016v\u2016 (tsupport f)\nK_compact : IsCompact K\nt : \u211d\nht : t \u2208 Ioc 0 1\nt_pos : 0 < t\nx : E\nhx : x \u2208 K\n\u22a2 \u2191C * (t * \u2016v\u2016) * |g x| = \u2191C * \u2016v\u2016 * |g x| * t",["ring","linarith"]],["Analysis/Calculus/Rademacher.lean",314,"E : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\nC : \u211d\u22650\ninst\u271d : FiniteDimensional \u211d E\nf : E \u2192 F\nhf : LipschitzWith C f\ns : Set E\nhs : sphere 0 1 \u2286 closure s\nL : E \u2192L[\u211d] F\nx : E\nhL : \u2200 v \u2208 s, HasLineDerivAt \u211d f (L v) x v\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : (\u2191C + \u2016L\u2016 + 1) * \u03b4 = \u03b5\nq : Set E\nhqs : q \u2286 s\nq_fin : q.Finite\nhq : sphere 0 1 \u2286 \u22c3 y \u2208 q, ball y \u03b4\nI : \u2200\u1da0 (t : \u211d) in \ud835\udcdd 0, \u2200 v \u2208 q, \u2016f (x + t \u2022 v) - f x - t \u2022 L v\u2016 \u2264 \u03b4 * \u2016t\u2016\nr : \u211d\nr_pos : 0 < r\nhr : \u2200 (t : \u211d), \u2016t\u2016 < r \u2192 \u2200 v \u2208 q, \u2016f (x + t \u2022 v) - f x - t \u2022 L v\u2016 \u2264 \u03b4 * \u2016t\u2016\nv : E\nhv : v \u2208 ball 0 r\nv_ne : v \u2260 0\nw : E\n\u03c1 : \u211d\nw_mem : w \u2208 sphere 0 1\nhvw : v = \u03c1 \u2022 w\nh\u03c1 : \u03c1 = \u2016v\u2016\nnorm_rho : \u2016\u03c1\u2016 = \u03c1\nrho_pos : 0 \u2264 \u03c1\ny : E\nyq : y \u2208 q\nhy : \u2016w - y\u2016 < \u03b4\nthis : \u2016y - w\u2016 < \u03b4\n\u22a2 \u2191C * (\u03c1 * \u03b4) + \u03c1 * (\u2016L\u2016 * \u03b4) + \u03b4 * \u03c1 = (\u2191C + \u2016L\u2016 + 1) * \u03b4 * \u03c1",["ring","linarith"]],["Topology/Algebra/UniformGroup/Defs.lean",534,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nG : Type u_5\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalAddGroup \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b2\ninst\u271d\u2078 : AddCommGroup \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : AddCommGroup \u03b3\ninst\u271d\u2075 : IsTopologicalAddGroup \u03b3\ninst\u271d\u2074 : TopologicalSpace \u03b4\ninst\u271d\u00b3 : AddCommGroup \u03b4\ninst\u271d\u00b2 : UniformSpace G\ninst\u271d\u00b9 : AddCommGroup G\ne : \u03b2 \u2192+ \u03b1\nde : IsDenseInducing \u21d1e\nf : \u03b4 \u2192+ \u03b3\ndf : IsDenseInducing \u21d1f\n\u03c6 : \u03b2 \u2192+ \u03b4 \u2192+ G\nh\u03c6 : Continuous fun p \u21a6 (\u03c6 p.1) p.2\nW' : Set G\nW'_nhd : W' \u2208 \ud835\udcdd 0\ninst\u271d : UniformAddGroup G\nx\u2080 : \u03b1\ny\u2080 : \u03b3\nee : \u03b2 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b1 := fun u \u21a6 (e u.1, e u.2)\nff : \u03b4 \u00d7 \u03b4 \u2192 \u03b3 \u00d7 \u03b3 := fun u \u21a6 (f u.1, f u.2)\nlim_\u03c6 : Tendsto (fun p \u21a6 (\u03c6 p.1) p.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nlim_\u03c6_sub_sub :\n  Tendsto (fun p \u21a6 (fun p \u21a6 (\u03c6 p.1) p.2) (p.1.2 - p.1.1, p.2.2 - p.2.1)) (comap ee (\ud835\udcdd (x\u2080, x\u2080)) \u00d7\u02e2 comap ff (\ud835\udcdd (y\u2080, y\u2080)))\n    (\ud835\udcdd 0)\nW : Set G\nW_nhd : W \u2208 \ud835\udcdd 0\nW4 : \u2200 {v w s t : G}, v \u2208 W \u2192 w \u2208 W \u2192 s \u2208 W \u2192 t \u2208 W \u2192 v + w + s + t \u2208 W'\nU\u2081 : Set \u03b2\nU\u2081_nhd : U\u2081 \u2208 comap (\u21d1e) (\ud835\udcdd x\u2080)\nV\u2081 : Set \u03b4\nV\u2081_nhd : V\u2081 \u2208 comap (\u21d1f) (\ud835\udcdd y\u2080)\nH : \u2200 x \u2208 U\u2081, \u2200 x' \u2208 U\u2081, \u2200 y \u2208 V\u2081, \u2200 y' \u2208 V\u2081, (fun p \u21a6 (\u03c6 p.1) p.2) (x' - x, y' - y) \u2208 W\nx\u2081 : \u03b2\nx\u2081_in : x\u2081 \u2208 U\u2081\ny\u2081 : \u03b4\ny\u2081_in : y\u2081 \u2208 V\u2081\ncont_flip : Continuous fun p \u21a6 (\u03c6.flip p.1) p.2\nU\u2082 : Set \u03b2\nU\u2082_nhd : U\u2082 \u2208 comap (\u21d1e) (\ud835\udcdd x\u2080)\nHU : \u2200 x \u2208 U\u2082, \u2200 x' \u2208 U\u2082, (fun p \u21a6 (\u03c6 p.1) p.2) (x' - x, y\u2081) \u2208 W\nV\u2082 : Set \u03b4\nV\u2082_nhd : V\u2082 \u2208 comap (\u21d1f) (\ud835\udcdd y\u2080)\nHV : \u2200 x \u2208 V\u2082, \u2200 x' \u2208 V\u2082, (fun p \u21a6 (\u03c6.flip p.1) p.2) (x' - x, x\u2081) \u2208 W\nx : \u03b2\nxU\u2081 : x \u2208 U\u2081\nxU\u2082 : x \u2208 U\u2082\nx' : \u03b2\nx'U\u2081 : x' \u2208 U\u2081\nx'U\u2082 : x' \u2208 U\u2082\ny : \u03b4\nyV\u2081 : y \u2208 V\u2081\nyV\u2082 : y \u2208 V\u2082\ny' : \u03b4\ny'V\u2081 : y' \u2208 V\u2081\ny'V\u2082 : y' \u2208 V\u2082\n\u22a2 (\u03c6 x') y' - (\u03c6 x) y = (\u03c6 x') y\u2081 - (\u03c6 x) y\u2081 + ((\u03c6 x') y' - (\u03c6 x') y\u2081 - ((\u03c6 x) y' - (\u03c6 x) y\u2081)) + ((\u03c6 x) y' - (\u03c6 x) y)",["abel"]],["NumberTheory/LSeries/SumCoeff.lean",245,"l : \u2102\ns T \u03b5 : \u211d\nS : \u211d \u2192 \u2102\nhS : LocallyIntegrableOn (fun t \u21a6 S t - l * \u2191t) (Set.Ici 1) volume\nh\u03b5 : 0 < \u03b5\nhs : 1 < s\nhT\u2081 : 1 \u2264 T\nhT : \u2200 t \u2265 T, \u2016S t - l * \u2191t\u2016 \u2264 \u03b5 * t\nhT\u2080 : 0 < T\nh : \u2200 {t : \u211d}, 0 < t \u2192 t ^ (-s) = t * t ^ (-s - 1)\n\u22a2 1 - s = -s + 1",["ring","linarith","abel"]],["NumberTheory/LSeries/SumCoeff.lean",294,"case e_a\nf : \u2115 \u2192 \u2102\nl : \u2102\nhlim : Tendsto (fun n \u21a6 (\u2211 k \u2208 Icc 1 n, f k) / \u2191n) atTop (\ud835\udcdd l)\nhfS : \u2200 (s : \u211d), 1 < s \u2192 LSeriesSummable f \u2191s\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nT : \u211d\nhT\u2081 : T \u2265 1\nhT : \u2200 (y : \u211d), T \u2264 y \u2192 \u2016\u2211 k \u2208 Icc 1 \u230ay\u230b\u208a, f k - l * \u2191y\u2016 < \u03b5 * y\nS : \u211d \u2192 \u2102 := fun t \u21a6 \u2211 k \u2208 Icc 1 \u230at\u230b\u208a, f k\nC : \u211d := \u222b (t : \u211d) in Set.Ioc 1 T, \u2016S t - l * \u2191t\u2016 * t ^ (-1 - 1)\nhC : 0 \u2264 C\ns : \u211d\nhs : 1 < s\nhs' : 0 \u2264 (s - 1) * s\nh\u2080 : LocallyIntegrableOn (fun t \u21a6 S t - l * \u2191t) (Set.Ici 1) volume\nh\u2081 : IntegrableOn (fun t \u21a6 \u2016S t - l * \u2191t\u2016 * t ^ (-s - 1)) (Set.Ici 1) volume\nh\u2082 : IntegrableOn (fun t \u21a6 \u2016S t - l * \u2191t\u2016 * t ^ (-1 - 1)) (Set.Ioc 1 T) volume\nh\u2083 : (\u2191s - 1) * \u222b (t : \u211d) in Set.Ioi 1, \u2191t ^ (-\u2191s) = 1\nCs : \u211d := \u222b (t : \u211d) in Set.Ioc 1 T, \u2016S t - l * \u2191t\u2016 * t ^ (-s - 1)\nh\u2084 : Cs \u2264 C\n\u22a2 ((\u2191s - 1) * \u2191s * \u222b (t : \u211d) in Set.Ioi 1, S t * \u2191t ^ (-\u2191s - 1)) -\n      l * \u2191s * ((\u2191s - 1) * \u222b (t : \u211d) in Set.Ioi 1, \u2191t ^ (-\u2191s)) =\n    (\u2191s - 1) * \u2191s * ((\u222b (a : \u211d) in Set.Ioi 1, S a * \u2191a ^ (-\u2191s - 1)) - l * \u222b (a : \u211d) in Set.Ioi 1, \u2191a ^ (-\u2191s))",["ring"]],["Analysis/PSeries.lean",409,"\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\nk n : \u2115\n\u22a2 1 / (\u2191k + 1) + 1 / (\u2191k + 1) = 2 / (\u2191k + 1)",["ring"]],["Combinatorics/Additive/AP/Three/Behrend.lean",275,"\u22a2 8 = 2 ^ 3",["norm_num","ring","linarith"]],["Combinatorics/Additive/AP/Three/Behrend.lean",287,"\u22a2 2 < 2.7182818283\n```\n---\n```lean\n\u22a2 0 < 2.7182818283",["norm_num","linarith"]],["Combinatorics/Additive/AP/Three/Behrend.lean",300,"N : \u2115\nhN : 4096 \u2264 N\nthis : \u219112 * log 2 \u2264 log \u2191N\n\u22a2 log 8 = log (2 ^ 3)",["norm_num","ring"]],["Combinatorics/Additive/AP/Three/Behrend.lean",333,"x : \u211d\nhx : 50 / 19 \u2264 x\n\u22a2 1.38 = 69 / 50",["norm_num","ring","linarith"]],["Combinatorics/Additive/AP/Three/Behrend.lean",445,"N : \u2115\nhN : 4096 \u2264 N\nn : \u2115 := nValue N\nhn : 0 < \u2191n\nhd : 0 < dValue N\nhN\u2080 : 0 < \u2191N\nhn\u2082 : 2 < n\nthis : (2 * dValue N - 1) ^ n \u2264 N\n\u22a2 rexp (-4 * \u221a(log \u2191N)) = rexp ((-2 + -2) * \u221a(log \u2191N))",["norm_num","ring"]],["Analysis/Complex/Basic.lean",338,"z : \u2102\nE : Type u_1\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\n\ud835\udd5c : Type u_2\ninst\u271d : RCLike \ud835\udd5c\nh : RCLike.im RCLike.I = 1\nx y : \ud835\udd5c\n\u22a2 \u2191(RCLike.re x) + \u2191(RCLike.re y) + (\u2191(RCLike.im x) + \u2191(RCLike.im y)) * I =\n    \u2191(RCLike.re x) + \u2191(RCLike.im x) * I + (\u2191(RCLike.re y) + \u2191(RCLike.im y) * I)",["ring"]],["Analysis/Complex/Basic.lean",343,"z : \u2102\nE : Type u_1\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\n\ud835\udd5c : Type u_2\ninst\u271d : RCLike \ud835\udd5c\nh : RCLike.im RCLike.I = 1\nx y : \ud835\udd5c\n\u22a2 \u2191(RCLike.re x) * \u2191(RCLike.re y) + \u2191(RCLike.re x) * \u2191(RCLike.im y) * I +\n      (\u2191(RCLike.re y) * \u2191(RCLike.im x) * I - \u2191(RCLike.im x) * \u2191(RCLike.im y)) =\n    \u2191(RCLike.re x) * \u2191(RCLike.re y) + \u2191(RCLike.re x) * \u2191(RCLike.im y) * I + \u2191(RCLike.re y) * \u2191(RCLike.im x) * I +\n      \u2191(RCLike.im x) * \u2191(RCLike.im y) * -1",["ring"]],["Analysis/Complex/Basic.lean",350,"z : \u2102\nE : Type u_1\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\n\ud835\udd5c : Type u_2\ninst\u271d : RCLike \ud835\udd5c\nh : RCLike.im RCLike.I = 1\nx\u271d\u00b9 : \u211d\nx\u271d : \ud835\udd5c\n\u22a2 \u2191x\u271d\u00b9 * \u2191(RCLike.im x\u271d) * I = \u2191x\u271d\u00b9 * (\u2191(RCLike.im x\u271d) * I)",["ring"]],["NumberTheory/Ostrowski.lean",383,"f : AbsoluteValue \u211a \u211d\nm\u271d n\u271d : \u2115\nhm\u271d : 1 < m\u271d\nhn\u271d : 1 < n\u271d\nnotbdd : \u00ac\u2200 (n : \u2115), f \u2191n \u2264 1\nk : \u2115\nhk : k \u2260 0\nm n : \u2115\nhm : 1 < m\nhn : 1 < n\nd : \u2115 := Nat.log m n\n\u22a2 \u2191m * (f \u2191m ^ (d + 1) / (f \u2191m - 1)) = \u2191m * f \u2191m / (f \u2191m - 1) * f \u2191m ^ d",["ring"]],["NumberTheory/LucasLehmer.lean",513,"p : \u2115\nhp : 2 \u2264 p\nh1 : 4 \u2264 2 ^ p\nh2 : 1 \u2264 2 ^ p\nk : \u2115\nih : \u2191(sModNat (2 ^ p - 1) k) = sMod p k\n\u22a2 2 \u2264 4 - 1",["norm_num"]],["NumberTheory/LucasLehmer.lean",337,"case h\u2081\nq : \u2115+\n\u22a2 2 * 2 + -3 = 1",["ring","norm_num"]],["NumberTheory/LucasLehmer.lean",353,"q : \u2115+\ni : \u2115\nih : \u2191(s i) = \u03c9 ^ 2 ^ i + \u03c9b ^ 2 ^ i\n\u22a2 (\u03c9 ^ 2 ^ i + \u03c9b ^ 2 ^ i) ^ 2 - 2 = (\u03c9 ^ 2 ^ i) ^ 2 + (\u03c9b ^ 2 ^ i) ^ 2 + 2 * (\u03c9b ^ 2 ^ i * \u03c9 ^ 2 ^ i) - 2",["ring"]],["NumberTheory/LucasLehmer.lean",390,"p' : \u2115\nk : \u2124\nh : \u03c9 ^ 2 ^ p' * (\u03c9 ^ 2 ^ p' + \u03c9b ^ 2 ^ p') = \u03c9 ^ 2 ^ p' * \u2191((2 ^ (p' + 2) - 1) * k)\n\u22a2 2 ^ p' + 2 ^ p' = 2 ^ (p' + 1)",["ring","omega"]],["Algebra/Lie/Weights/RootSystem.lean",128,"case e_a.e_a\nK : Type u_1\nL : Type u_2\ninst\u271d\u2077 : Field K\ninst\u271d\u2076 : CharZero K\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : IsKilling K L\ninst\u271d\u00b2 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsTriangularizable K (\u21a5H) L\n\u03b1 \u03b2 : Weight K (\u21a5H) L\nh\u03b1 : \u03b1.IsNonZero\nn : \u2115\nhn : chainLength \u03b1 \u03b2 < n\ne : \u00acrootSpace H (-(n \u2022 \u21d1\u03b1) + \u21d1(chainTop (\u21d1\u03b1) \u03b2)) = \u22a5\nW : Weight K (\u21a5H) L := { toFun := -(n \u2022 \u21d1\u03b1) + \u21d1(chainTop (\u21d1\u03b1) \u03b2), genWeightSpace_ne_bot' := e }\nhW : \u21d1W = -(n \u2022 \u21d1\u03b1) + \u21d1(chainTop (\u21d1\u03b1) \u03b2)\nH\u2081 : 1 + n + chainTopCoeff (\u21d1(-\u03b1)) W \u2264 chainLength (-\u03b1) W\n\u22a2 1 + \u2191n + \u2191(chainTopCoeff (-\u21d1\u03b1) W) + (-\u2191(chainTopCoeff (-\u21d1\u03b1) W) - \u2191n) + \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2) =\n    \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2) + 1",["ring","omega","linarith","abel"]],["NumberTheory/LSeries/AbstractFuncEq.lean",326,"case inl\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nP : WeakFEPair E\nx : \u211d\nhx : 0 < x\nhx' : x < 1\n\u22a2 0 + (P.f x - (P.\u03b5 * \u2191(x ^ (-P.k))) \u2022 P.g\u2080) - P.f x + P.f\u2080 = P.f\u2080 - (P.\u03b5 * \u2191(x ^ (-P.k))) \u2022 P.g\u2080 + 0",["abel"]],["NumberTheory/LSeries/AbstractFuncEq.lean",384,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nP : WeakFEPair E\ns : \u2102\n\u22a2 mellin P.f_modif s =\n    mellin P.f_modif s - (1 / s) \u2022 P.f\u2080 - (P.\u03b5 / (\u2191P.k - s)) \u2022 P.g\u2080 + (1 / s) \u2022 P.f\u2080 + (P.\u03b5 / (\u2191P.k - s)) \u2022 P.g\u2080",["abel"]],["NumberTheory/LSeries/AbstractFuncEq.lean",155,"case h.e'_4\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nP : WeakFEPair E\nr C : \u211d\nhC :\n  \u2200\u1da0 (x : \u211d) in \ud835\udcdd 0,\n    x \u2208 Ioi 0 \u2192 \u2016((fun x \u21a6 P.g x - P.g\u2080) \u2218 fun x \u21a6 x\u207b\u00b9) x\u2016 \u2264 C * \u2016((fun x \u21a6 x ^ (-(r + P.k))) \u2218 fun x \u21a6 x\u207b\u00b9) x\u2016\nx : \u211d\nhx : 0 < x\nh_nv2 : \u2191(x ^ P.k) \u2260 0\nh_nv : P.\u03b5\u207b\u00b9 * \u2191(x ^ P.k) \u2260 0\nhC' : \u2016P.f x - (P.\u03b5\u207b\u00b9 * \u2191(x ^ P.k))\u207b\u00b9 \u2022 P.g\u2080\u2016 \u2264 C * \u2016(1 / x) ^ (-(r + P.k))\u2016 / \u2016P.\u03b5\u207b\u00b9 * \u2191(x ^ P.k)\u2016\n\u22a2 \u2016P.\u03b5\u2016 * C * x ^ r * x ^ P.k = C * (x ^ r * x ^ P.k) * \u2016P.\u03b5\u2016",["ring","linarith"]],["NumberTheory/LSeries/AbstractFuncEq.lean",444,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nP : WeakFEPair E\ns : \u2102\nhs : s \u2260 \u2191P.k\n\u22a2 -(P.\u03b5 * (\u2191P.k - s)) = (s - \u2191P.k) * P.\u03b5",["ring"]],["RingTheory/Kaehler/JacobiZariski.lean",224,"case monomial.add\nR : Type u\nS : Type v\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\nT : Type uT\ninst\u271d\u00b3 : CommRing T\ninst\u271d\u00b2 : Algebra R T\ninst\u271d\u00b9 : Algebra S T\ninst\u271d : IsScalarTower R S T\nQ : Generators S T\nn : Q.vars \u2192\u2080 \u2115\nr : S\ny\u2081 y\u2082 : MvPolynomial Q.vars S\nhy\u2081 : (\u03b4Aux R Q) ((monomial n) r * y\u2081) = (monomial n) r \u2022 (\u03b4Aux R Q) y\u2081 + y\u2081 \u2022 (\u03b4Aux R Q) ((monomial n) r)\nhy\u2082 : (\u03b4Aux R Q) ((monomial n) r * y\u2082) = (monomial n) r \u2022 (\u03b4Aux R Q) y\u2082 + y\u2082 \u2022 (\u03b4Aux R Q) ((monomial n) r)\n\u22a2 (monomial n) r \u2022 (\u03b4Aux R Q) y\u2081 + y\u2081 \u2022 (\u03b4Aux R Q) ((monomial n) r) +\n      ((monomial n) r \u2022 (\u03b4Aux R Q) y\u2082 + y\u2082 \u2022 (\u03b4Aux R Q) ((monomial n) r)) =\n    (monomial n) r \u2022 (\u03b4Aux R Q) y\u2081 + (monomial n) r \u2022 (\u03b4Aux R Q) y\u2082 +\n      (y\u2081 \u2022 (\u03b4Aux R Q) ((monomial n) r) + y\u2082 \u2022 (\u03b4Aux R Q) ((monomial n) r))",["abel"]],["RingTheory/Kaehler/JacobiZariski.lean",225,"case add\nR : Type u\nS : Type v\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : Algebra R S\nT : Type uT\ninst\u271d\u00b3 : CommRing T\ninst\u271d\u00b2 : Algebra R T\ninst\u271d\u00b9 : Algebra S T\ninst\u271d : IsScalarTower R S T\nQ : Generators S T\ny : Q.Ring\nx\u2081 x\u2082 : MvPolynomial Q.vars S\nhx\u2081 : (\u03b4Aux R Q) (x\u2081 * y) = x\u2081 \u2022 (\u03b4Aux R Q) y + y \u2022 (\u03b4Aux R Q) x\u2081\nhx\u2082 : (\u03b4Aux R Q) (x\u2082 * y) = x\u2082 \u2022 (\u03b4Aux R Q) y + y \u2022 (\u03b4Aux R Q) x\u2082\n\u22a2 x\u2081 \u2022 (\u03b4Aux R Q) y + y \u2022 (\u03b4Aux R Q) x\u2081 + (x\u2082 \u2022 (\u03b4Aux R Q) y + y \u2022 (\u03b4Aux R Q) x\u2082) =\n    x\u2081 \u2022 (\u03b4Aux R Q) y + x\u2082 \u2022 (\u03b4Aux R Q) y + (y \u2022 (\u03b4Aux R Q) x\u2081 + y \u2022 (\u03b4Aux R Q) x\u2082)",["abel"]],["RingTheory/AdicCompletion/Basic.lean",556,"case h.e'_5\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nI : Ideal R\ninst\u271d : IsAdicComplete I R\nx : R\nhx : x \u2208 I\ny : R\nf : \u2115 \u2192 R := fun n \u21a6 \u2211 i \u2208 range n, (x * y) ^ i\nhf : \u2200 (m n : \u2115), m \u2264 n \u2192 f m \u2261 f n [SMOD I ^ m \u2022 \u22a4]\nL : R\nn : \u2115\nhL : f n - L \u2208 I ^ n\nthis : (1 - x * y) * f n - 1 \u2208 I ^ n\n\u22a2 (1 + -(x * y)) * L - 1 = (1 - x * y) * f n - 1 - (1 + -(x * y)) * (f n - L)",["ring"]],["Algebra/Homology/HomotopyCofiber.lean",289,"case pos\nC : Type u_1\ninst\u271d\u00b3 : Category.{?u.76538, u_1} C\ninst\u271d\u00b2 : Preadditive C\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\nF G K : HomologicalComplex C c\n\u03c6 : F \u27f6 G\ninst\u271d\u00b9 : HasHomotopyCofiber \u03c6\ninst\u271d : DecidableRel c.Rel\n\u03b1 : G \u27f6 K\nh\u03b1 : Homotopy (\u03c6 \u226b \u03b1) 0\nj : \u03b9\nhjk : c.Rel j (c.next j)\nH : \u03c6.f (c.next j) \u226b \u03b1.f (c.next j) = (dNext (c.next j)) h\u03b1.hom + h\u03b1.hom (c.next j) j \u226b K.d j (c.next j)\nhj : c.Rel (c.next j) (c.next (c.next j))\n\u22a2 fstX \u03c6 j (c.next j) hjk \u226b h\u03b1.hom (c.next j) j \u226b K.d j (c.next j) + sndX \u03c6 j \u226b G.d j (c.next j) \u226b \u03b1.f (c.next j) =\n    -fstX \u03c6 j (c.next j) hjk \u226b F.d (c.next j) (c.next (c.next j)) \u226b h\u03b1.hom (c.next (c.next j)) (c.next j) +\n      (fstX \u03c6 j (c.next j) hjk \u226b F.d (c.next j) (c.next (c.next j)) \u226b h\u03b1.hom (c.next (c.next j)) (c.next j) +\n          fstX \u03c6 j (c.next j) hjk \u226b h\u03b1.hom (c.next j) j \u226b K.d j (c.next j) +\n        sndX \u03c6 j \u226b G.d j (c.next j) \u226b \u03b1.f (c.next j))",["abel"]],["Geometry/Manifold/Instances/Real.lean",485,"case h.inl.inr.intro.intro.intro.mk.h\nx\u271d y\u271d : \u211d\nhxy : Fact (x\u271d < y\u271d)\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\nH : Type u_2\ninst\u271d\u00b3 : TopologicalSpace H\nI : ModelWithCorners \u211d E H\nM\u271d : Type u_3\ninst\u271d\u00b2 : TopologicalSpace M\u271d\ninst\u271d\u00b9 : ChartedSpace H M\u271d\nx y : \u211d\ninst\u271d : Fact (x < y)\nn : WithTop \u2115\u221e\nM :\n  ContDiff \u211d n\n    (let_fun this := fun z i \u21a6 -z i + (y - x);\n    this)\nz : EuclideanSpace \u211d (Fin 1)\nhz\u2080 : 0 \u2264 z 0\nhz\u2081 : z 0 + x < y\nhz\u2082 : 0 < z 0\ni : Fin 1\n\u22a2 y - (z 0 + x) = -z 0 + (y - x)",["abel","ring","linarith"]],["Geometry/Manifold/Instances/Real.lean",496,"case h.inr.inl.intro.intro.intro.mk.h\nx\u271d y\u271d : \u211d\nhxy : Fact (x\u271d < y\u271d)\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\nH : Type u_2\ninst\u271d\u00b3 : TopologicalSpace H\nI : ModelWithCorners \u211d E H\nM\u271d : Type u_3\ninst\u271d\u00b2 : TopologicalSpace M\u271d\ninst\u271d\u00b9 : ChartedSpace H M\u271d\nx y : \u211d\ninst\u271d : Fact (x < y)\nn : WithTop \u2115\u221e\nM :\n  ContDiff \u211d n\n    (let_fun this := fun z i \u21a6 -z i + (y - x);\n    this)\nz : EuclideanSpace \u211d (Fin 1)\nhz\u2080 : 0 \u2264 z 0\nhz\u2081 : x < y - z 0\nhz\u2082 : y - z 0 < y \u2227 x < y\ni : Fin 1\n\u22a2 y - z 0 - x = -z 0 + (y - x)",["abel","ring","linarith"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",95,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\ns : Set E\nc : \u211d\u22650\nx y : E\n\u22a2 f x - f y - (f' x - f' y) = f x - f' x - (f y - f' y)",["abel"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",366,"case e_a.e_a\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2243L[\ud835\udd5c] F\ns : Set E\nc : \u211d\u22650\nhf : ApproximatesLinearOn f (\u2191f') s c\nhc : Subsingleton E \u2228 c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9\nA : PartialEquiv E F := hf.toPartialEquiv hc\nAf : \u2200 (z : E), \u2191A z = f z\nx' : E\nx's : x' \u2208 s\nhx : f x' \u2208 f '' s\ny' : E\ny's : y' \u2208 s\nhy : f y' \u2208 f '' s\n\u22a2 f' x' - f' y' - (\u2191A x' - \u2191A y') = \u2191A y' - \u2191A x' - (f' y' - f' x')",["abel"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",186,"\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : \u211d\u22650\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\n\u03b5 : \u211d\nb : E\n\u03b50 : 0 \u2264 \u03b5\nh\u03b5 : closedBall b \u03b5 \u2286 s\ny : F\nhy : y \u2208 closedBall (f b) (((\u2191f'symm.nnnorm)\u207b\u00b9 - \u2191c) * \u03b5)\nhc : \u2191c < (\u2191f'symm.nnnorm)\u207b\u00b9\nIf' : 0 < \u2191f'symm.nnnorm\nIcf' : \u2191c * \u2191f'symm.nnnorm < 1\nJf' : \u2191f'symm.nnnorm \u2260 0\nJcf' : 1 - \u2191c * \u2191f'symm.nnnorm \u2260 0\ng : E \u2192 E := fun x \u21a6 x + f'symm.toFun (y - f x)\nhg : g = fun x \u21a6 x + f'symm.toFun (y - f x)\nu : \u2115 \u2192 E := fun n \u21a6 g^[n] b\nhu : u = fun n \u21a6 g^[n] b\nusucc : \u2200 (n : \u2115), u (n + 1) = g (u n)\nA : \u2200 (z : E), dist (g z) z \u2264 \u2191f'symm.nnnorm * dist (f z) y\nz : E\nhz : z \u2208 closedBall b \u03b5\nhgz : g z \u2208 closedBall b \u03b5\nv : E := f'symm.toFun (y - f z)\n\u22a2 \u2191c * (\u2191f'symm.nnnorm * dist (f z) y) = \u2191c * \u2191f'symm.nnnorm * dist (f z) y",["ring","linarith"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",197,"\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : \u211d\u22650\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\n\u03b5 : \u211d\nb : E\n\u03b50 : 0 \u2264 \u03b5\nh\u03b5 : closedBall b \u03b5 \u2286 s\ny : F\nhy : y \u2208 closedBall (f b) (((\u2191f'symm.nnnorm)\u207b\u00b9 - \u2191c) * \u03b5)\nhc : \u2191c < (\u2191f'symm.nnnorm)\u207b\u00b9\nIf' : 0 < \u2191f'symm.nnnorm\nIcf' : \u2191c * \u2191f'symm.nnnorm < 1\nJf' : \u2191f'symm.nnnorm \u2260 0\nJcf' : 1 - \u2191c * \u2191f'symm.nnnorm \u2260 0\ng : E \u2192 E := fun x \u21a6 x + f'symm.toFun (y - f x)\nhg : g = fun x \u21a6 x + f'symm.toFun (y - f x)\nu : \u2115 \u2192 E := fun n \u21a6 g^[n] b\nhu : u = fun n \u21a6 g^[n] b\nusucc : \u2200 (n : \u2115), u (n + 1) = g (u n)\nA : \u2200 (z : E), dist (g z) z \u2264 \u2191f'symm.nnnorm * dist (f z) y\nB : \u2200 z \u2208 closedBall b \u03b5, g z \u2208 closedBall b \u03b5 \u2192 dist (f (g z)) y \u2264 \u2191c * \u2191f'symm.nnnorm * dist (f z) y\nn : \u2115\nw : E\nhw : dist w b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y\n\u22a2 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) * dist (f b) y =\n    \u2191f'symm.nnnorm * dist (f b) y * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n)",["ring","linarith"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",206,"\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : \u211d\u22650\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\n\u03b5 : \u211d\nb : E\n\u03b50 : 0 \u2264 \u03b5\nh\u03b5 : closedBall b \u03b5 \u2286 s\ny : F\nhy : y \u2208 closedBall (f b) (((\u2191f'symm.nnnorm)\u207b\u00b9 - \u2191c) * \u03b5)\nhc : \u2191c < (\u2191f'symm.nnnorm)\u207b\u00b9\nIf' : 0 < \u2191f'symm.nnnorm\nIcf' : \u2191c * \u2191f'symm.nnnorm < 1\nJf' : \u2191f'symm.nnnorm \u2260 0\nJcf' : 1 - \u2191c * \u2191f'symm.nnnorm \u2260 0\ng : E \u2192 E := fun x \u21a6 x + f'symm.toFun (y - f x)\nhg : g = fun x \u21a6 x + f'symm.toFun (y - f x)\nu : \u2115 \u2192 E := fun n \u21a6 g^[n] b\nhu : u = fun n \u21a6 g^[n] b\nusucc : \u2200 (n : \u2115), u (n + 1) = g (u n)\nA : \u2200 (z : E), dist (g z) z \u2264 \u2191f'symm.nnnorm * dist (f z) y\nB : \u2200 z \u2208 closedBall b \u03b5, g z \u2208 closedBall b \u03b5 \u2192 dist (f (g z)) y \u2264 \u2191c * \u2191f'symm.nnnorm * dist (f z) y\nn : \u2115\nw : E\nhw : dist w b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y\n\u22a2 (1 - \u2191f'symm.nnnorm * \u2191c) * \u03b5 = \u03b5 * (1 - \u2191c * \u2191f'symm.nnnorm)",["ring","linarith"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",230,"\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : \u211d\u22650\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\n\u03b5 : \u211d\nb : E\n\u03b50 : 0 \u2264 \u03b5\nh\u03b5 : closedBall b \u03b5 \u2286 s\ny : F\nhy : y \u2208 closedBall (f b) (((\u2191f'symm.nnnorm)\u207b\u00b9 - \u2191c) * \u03b5)\nhc : \u2191c < (\u2191f'symm.nnnorm)\u207b\u00b9\nIf' : 0 < \u2191f'symm.nnnorm\nIcf' : \u2191c * \u2191f'symm.nnnorm < 1\nJf' : \u2191f'symm.nnnorm \u2260 0\nJcf' : 1 - \u2191c * \u2191f'symm.nnnorm \u2260 0\ng : E \u2192 E := fun x \u21a6 x + f'symm.toFun (y - f x)\nhg : g = fun x \u21a6 x + f'symm.toFun (y - f x)\nu : \u2115 \u2192 E := fun n \u21a6 g^[n] b\nhu : u = fun n \u21a6 g^[n] b\nusucc : \u2200 (n : \u2115), u (n + 1) = g (u n)\nA : \u2200 (z : E), dist (g z) z \u2264 \u2191f'symm.nnnorm * dist (f z) y\nB : \u2200 z \u2208 closedBall b \u03b5, g z \u2208 closedBall b \u03b5 \u2192 dist (f (g z)) y \u2264 \u2191c * \u2191f'symm.nnnorm * dist (f z) y\nC :\n  \u2200 (n : \u2115) (w : E),\n    dist w b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y \u2192\n      w \u2208 closedBall b \u03b5\nn : \u2115\nIH :\n  dist (f (u n)) y \u2264 (\u2191c * \u2191f'symm.nnnorm) ^ n * dist (f b) y \u2227\n    dist (u n) b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y\n\u22a2 \u2191f'symm.nnnorm * ((\u2191c * \u2191f'symm.nnnorm) ^ n * dist (f b) y) * (1 - \u2191c * \u2191f'symm.nnnorm) +\n      \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) * dist (f b) y =\n    \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n * (\u2191c * \u2191f'symm.nnnorm)) * dist (f b) y",["ring","linarith"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",238,"\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : \u211d\u22650\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\n\u03b5 : \u211d\nb : E\n\u03b50 : 0 \u2264 \u03b5\nh\u03b5 : closedBall b \u03b5 \u2286 s\ny : F\nhy : y \u2208 closedBall (f b) (((\u2191f'symm.nnnorm)\u207b\u00b9 - \u2191c) * \u03b5)\nhc : \u2191c < (\u2191f'symm.nnnorm)\u207b\u00b9\nIf' : 0 < \u2191f'symm.nnnorm\nIcf' : \u2191c * \u2191f'symm.nnnorm < 1\nJf' : \u2191f'symm.nnnorm \u2260 0\nJcf' : 1 - \u2191c * \u2191f'symm.nnnorm \u2260 0\ng : E \u2192 E := fun x \u21a6 x + f'symm.toFun (y - f x)\nhg : g = fun x \u21a6 x + f'symm.toFun (y - f x)\nu : \u2115 \u2192 E := fun n \u21a6 g^[n] b\nhu : u = fun n \u21a6 g^[n] b\nusucc : \u2200 (n : \u2115), u (n + 1) = g (u n)\nA : \u2200 (z : E), dist (g z) z \u2264 \u2191f'symm.nnnorm * dist (f z) y\nB : \u2200 z \u2208 closedBall b \u03b5, g z \u2208 closedBall b \u03b5 \u2192 dist (f (g z)) y \u2264 \u2191c * \u2191f'symm.nnnorm * dist (f z) y\nC :\n  \u2200 (n : \u2115) (w : E),\n    dist w b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y \u2192\n      w \u2208 closedBall b \u03b5\nn : \u2115\nIH :\n  dist (f (u n)) y \u2264 (\u2191c * \u2191f'symm.nnnorm) ^ n * dist (f b) y \u2227\n    dist (u n) b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y\nIgn :\n  dist (g (u n)) b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n.succ) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y\n\u22a2 \u2191c * \u2191f'symm.nnnorm * ((\u2191c * \u2191f'symm.nnnorm) ^ n * dist (f b) y) =\n    \u2191c * \u2191f'symm.nnnorm * (\u2191c * \u2191f'symm.nnnorm) ^ n * dist (f b) y",["ring","linarith"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",248,"\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : \u211d\u22650\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\n\u03b5 : \u211d\nb : E\n\u03b50 : 0 \u2264 \u03b5\nh\u03b5 : closedBall b \u03b5 \u2286 s\ny : F\nhy : y \u2208 closedBall (f b) (((\u2191f'symm.nnnorm)\u207b\u00b9 - \u2191c) * \u03b5)\nhc : \u2191c < (\u2191f'symm.nnnorm)\u207b\u00b9\nIf' : 0 < \u2191f'symm.nnnorm\nIcf' : \u2191c * \u2191f'symm.nnnorm < 1\nJf' : \u2191f'symm.nnnorm \u2260 0\nJcf' : 1 - \u2191c * \u2191f'symm.nnnorm \u2260 0\ng : E \u2192 E := fun x \u21a6 x + f'symm.toFun (y - f x)\nhg : g = fun x \u21a6 x + f'symm.toFun (y - f x)\nu : \u2115 \u2192 E := fun n \u21a6 g^[n] b\nhu : u = fun n \u21a6 g^[n] b\nusucc : \u2200 (n : \u2115), u (n + 1) = g (u n)\nA : \u2200 (z : E), dist (g z) z \u2264 \u2191f'symm.nnnorm * dist (f z) y\nB : \u2200 z \u2208 closedBall b \u03b5, g z \u2208 closedBall b \u03b5 \u2192 dist (f (g z)) y \u2264 \u2191c * \u2191f'symm.nnnorm * dist (f z) y\nC :\n  \u2200 (n : \u2115) (w : E),\n    dist w b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y \u2192\n      w \u2208 closedBall b \u03b5\nD :\n  \u2200 (n : \u2115),\n    dist (f (u n)) y \u2264 (\u2191c * \u2191f'symm.nnnorm) ^ n * dist (f b) y \u2227\n      dist (u n) b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y\nn : \u2115\n\u22a2 \u2191f'symm.nnnorm * ((\u2191c * \u2191f'symm.nnnorm) ^ n * dist (f b) y) = \u2191f'symm.nnnorm * dist (f b) y * (\u2191c * \u2191f'symm.nnnorm) ^ n",["ring","linarith"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",373,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2243L[\ud835\udd5c] F\ns : Set E\nc : \u211d\u22650\nhf : ApproximatesLinearOn f (\u2191f') s c\nhc : Subsingleton E \u2228 c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9\nA : PartialEquiv E F := hf.toPartialEquiv hc\nAf : \u2200 (z : E), \u2191A z = f z\nx' : E\nx's : x' \u2208 s\nhx : f x' \u2208 f '' s\ny' : E\ny's : y' \u2208 s\nhy : f y' \u2208 f '' s\n\u22a2 \u2191\u2016\u2191f'.symm\u2016\u208a * (\u2191c * (\u2191(\u2016\u2191f'.symm\u2016\u208a\u207b\u00b9 - c)\u207b\u00b9 * \u2016\u2191A x' - \u2191A y'\u2016)) =\n    \u2191\u2016\u2191f'.symm\u2016\u208a * \u2191(\u2016\u2191f'.symm\u2016\u208a\u207b\u00b9 - c)\u207b\u00b9 * \u2191c * \u2016\u2191A x' - \u2191A y'\u2016",["ring","linarith"]],["MeasureTheory/Integral/Periodic.lean",327,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\nT : \u211d\ninst\u271d : NormedSpace \u211d E\nhf : Periodic f T\nt : \u211d\nh_int : \u2200 (t\u2081 t\u2082 : \u211d), IntervalIntegrable f volume t\u2081 t\u2082\nthis : \u2200 (m : \u2115), \u222b (x : \u211d) in 0 ..m \u2022 T, f x = m \u2022 \u222b (x : \u211d) in 0 ..T, f x\nn : \u2115\n\u22a2 (-1 + -\u2191n) * T + (\u2191n + 1) * T = 0",["linarith","ring"]],["MeasureTheory/Integral/Periodic.lean",266,"case h.e'_6\nE : Type u_1\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nT t : \u211d\nh\u2081f : Periodic f T\nhT : 0 < T\nh\u2082f : IntervalIntegrable f volume t (t + T)\na\u2081 a\u2082 : \u211d\nn\u2081 : \u2115\nhn\u2081 : (t - a\u2081 \u2293 a\u2082) / T \u2264 \u2191n\u2081\nn\u2082 : \u2115\nhn\u2082 : (a\u2081 \u2294 a\u2082 - t) / T \u2264 \u2191n\u2082\nthis : uIcc a\u2081 a\u2082 \u2286 uIcc (t - \u2191n\u2081 * T) (t + \u2191n\u2082 * T)\na : \u2115 \u2192 \u211d := fun n \u21a6 t + (\u2191n - \u2191n\u2081) * T\nk : \u2115\nhk : k < n\u2081 + n\u2082\n\u22a2 t + (\u2191k + 1 - \u2191n\u2081) * T = t + T + (\u2191k - \u2191n\u2081) * T",["ring","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",161,"case succ\nf : \u211d \u2192 \u211d\nx : \u211d\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhx : 0 < x\nn : \u2115\nhn : f (x + \u2191n) = f x + \u2211 m \u2208 Finset.range n, log (x + \u2191m)\nthis : x + \u2191n.succ = x + \u2191n + 1\n\u22a2 f x + \u2211 m \u2208 Finset.range n, log (x + \u2191m) + log (x + \u2191n) = f x + (log (x + \u2191n) + \u2211 x_1 \u2208 Finset.range n, log (x + \u2191x_1))",["abel","ring","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",199,"case a.h.e'_1\nx : \u211d\nn m : \u2115\na\u271d : m \u2208 Finset.range (n + 1)\n\u22a2 x + 1 + \u2191m = x + (\u2191m + 1)",["abel","ring","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",342,"case refine_2\nA : 0 < 3 / 2\nthis : Gamma (3 / 2) \u2264 rexp (1 / 2 * log 2 - log (3 / 2))\n\u22a2 2 < (3 / 2) ^ 2\n```\n---\n```lean\ncase refine_2\nA : 0 < 3 / 2\nthis : Gamma (3 / 2) \u2264 rexp (1 / 2 * log 2 - log (3 / 2))\n\u22a2 0 < (3 / 2) ^ 2",["norm_num","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",70,"case e_a.e_x\ns t a b : \u211d\nhs : 0 < s\nht : 0 < t\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nf : \u211d \u2192 \u211d \u2192 \u211d \u2192 \u211d := fun c u x \u21a6 rexp (-c * x) * x ^ (c * (u - 1))\ne : (1 / a).IsConjExponent (1 / b)\nhab' : b = 1 - a\nhst : 0 < a * s + b * t\nposf : \u2200 (c u x : \u211d), x \u2208 Ioi 0 \u2192 0 \u2264 f c u x\nposf' : \u2200 (c u : \u211d), \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 f c u x\nc x : \u211d\nhc : 0 < c\nu : \u211d\nhx : 0 < x\n\u22a2 x * c = c * x",["ring","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",102,"case e_a\ns t a b : \u211d\nhs : 0 < s\nht : 0 < t\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nf : \u211d \u2192 \u211d \u2192 \u211d \u2192 \u211d := fun c u x \u21a6 rexp (-c * x) * x ^ (c * (u - 1))\ne : (1 / a).IsConjExponent (1 / b)\nhab' : b = 1 - a\nhst : 0 < a * s + b * t\nposf : \u2200 (c u x : \u211d), x \u2208 Ioi 0 \u2192 0 \u2264 f c u x\nposf' : \u2200 (c u : \u211d), \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 f c u x\nfpow : \u2200 {c x : \u211d}, 0 < c \u2192 \u2200 (u : \u211d), 0 < x \u2192 rexp (-x) * x ^ (u - 1) = f c u x ^ (1 / c)\nf_mem_Lp : \u2200 {c u : \u211d}, 0 < c \u2192 0 < u \u2192 MemLp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0))\nx : \u211d\nhx : x \u2208 Ioi 0\nA : rexp (-x) = rexp (-a * x) * rexp (-b * x)\n\u22a2 a * s + (1 - a) * t - 1 = a * (s - 1) + (1 - a) * (t - 1)",["ring","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",104,"case h.e'_3\ns t a b : \u211d\nhs : 0 < s\nht : 0 < t\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nf : \u211d \u2192 \u211d \u2192 \u211d \u2192 \u211d := fun c u x \u21a6 rexp (-c * x) * x ^ (c * (u - 1))\ne : (1 / a).IsConjExponent (1 / b)\nhab' : b = 1 - a\nhst : 0 < a * s + b * t\nposf : \u2200 (c u x : \u211d), x \u2208 Ioi 0 \u2192 0 \u2264 f c u x\nposf' : \u2200 (c u : \u211d), \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 f c u x\nfpow : \u2200 {c x : \u211d}, 0 < c \u2192 \u2200 (u : \u211d), 0 < x \u2192 rexp (-x) * x ^ (u - 1) = f c u x ^ (1 / c)\nf_mem_Lp : \u2200 {c u : \u211d}, 0 < c \u2192 0 < u \u2192 MemLp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0))\nx : \u211d\nhx : x \u2208 Ioi 0\nA : rexp (-x) = rexp (-a * x) * rexp (-b * x)\nB : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1))\n\u22a2 rexp (-a * x) * rexp (-b * x) * (x ^ (a * (s - 1)) * x ^ (b * (t - 1))) = f a s x * f b t x",["ring"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",158,"f : \u211d \u2192 \u211d\nx : \u211d\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhx : 0 < x\nn : \u2115\nhn : f (x + \u2191n) = f x + \u2211 m \u2208 Finset.range n, log (x + \u2191m)\n\u22a2 x + (\u2191n + 1) = x + \u2191n + 1",["ring","linarith","abel"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",169,"f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhn : n \u2260 0\nhx : 0 < x\nhx' : x \u2264 1\nhn' : 0 < \u2191n\n\u22a2 f \u2191n + x * log \u2191n = (1 - x) * f \u2191n + x * (f \u2191n + log \u2191n)",["ring","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",201,"x : \u211d\nn : \u2115\nthis : \u2211 m \u2208 Finset.range (n + 1), log (x + 1 + \u2191m) = \u2211 k \u2208 Finset.range (n + 1), log (x + \u2191(k + 1))\n\u22a2 (x + 1) * log \u2191n + log \u2191n ! - \u2211 m \u2208 Finset.range (n + 1), log (x + 1 + \u2191m) =\n    x * log (\u2191n + 1) + (log (\u2191n + 1) + log \u2191n !) - (\u2211 m \u2208 Finset.range (n + 1), log (x + 1 + \u2191m) + log x) + log x -\n      (x + 1) * (log (\u2191n + 1) - log \u2191n)",["ring","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",209,"f : \u211d \u2192 \u211d\nx : \u211d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhx : 0 < x\nhx' : x \u2264 1\nn : \u2115\n\u22a2 f 1 + log \u2191n ! + x * log (\u2191n + 1) = f 1 + x * log (\u2191n + 1) - x * log \u2191n + (x * log \u2191n + log \u2191n !)",["ring","linarith","abel"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",233,"case h.e'_4\nf : \u211d \u2192 \u211d\nx : \u211d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhx : 0 < x\nhx' : x \u2264 1\nn : \u2115\n\u22a2 f 1 + (x * (log (\u2191n + 1) - log \u2191n) + logGammaSeq x n) = f 1 + x * log (\u2191n + 1) - x * log \u2191n + logGammaSeq x n",["ring","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",286,"case h.e'_5.h.e'_3\nf : \u211d \u2192 \u211d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nm : \u2115\nx : \u211d\nhx : 0 < x\nhy : \u2191m < x - 1\nhy' : x - 1 \u2264 \u2191m + 1\nthis\u271d\u00b9 :\n  \u2200\u1da0 (n : \u2115) in atTop,\n    logGammaSeq (x - 1) n = logGammaSeq x (n - 1) + x * (log (\u2191(n - 1) + 1) - log \u2191(n - 1)) - log (x - 1)\nhm : Tendsto (fun n \u21a6 logGammaSeq x n + x * (log (\u2191n + 1) - log \u2191n)) atTop (\ud835\udcdd (f (x - 1) - f 1 + log (x - 1)))\nthis\u271d :\n  ((fun x_1 \u21a6\n        (fun n \u21a6 logGammaSeq x (n - 1) + x * (log (\u2191(n - 1) + 1) - log \u2191(n - 1)) - log (x - 1)) x_1 +\n          (fun b \u21a6 log (x - 1)) x_1) \u2218\n      fun a \u21a6 a + 1) =\n    fun n \u21a6 logGammaSeq x n + x * (log (\u2191n + 1) - log \u2191n)\nthis : f x = f (x - 1) + log (x - 1)\n\u22a2 f (x - 1) + log (x - 1) - f 1 = f (x - 1) - f 1 + log (x - 1) - x * 0",["ring","linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",313,"case refine_1\nf : \u211d \u2192 \u211d\nhf_conv : ConvexOn \u211d (Ioi 0) (log \u2218 f)\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = y * f y\nhf_pos : \u2200 {y : \u211d}, 0 < y \u2192 0 < f y\nhf_one : f 1 = 1\nx : \u211d\nhx : x \u2208 Ioi 0\ny : \u211d\nhy : 0 < y\n\u22a2 log y + log (f y) = log (f y) + log y",["ring","linarith","abel"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",373,"s : \u211d\nhs : s \u2260 0\n\u22a2 Gamma (s / 2 + 1 / 2) * (s / 2 * Gamma (s / 2)) * (2 ^ (s - 1) * 2) / \u221a\u03c0 =\n    s * (Gamma (s / 2) * Gamma (s / 2 + 1 / 2) * 2 ^ (s - 1) / \u221a\u03c0)",["ring"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",432,"s : \u211d\nhs : 0 < s\n\u22a2 Gamma s * Gamma ((s * 2 + 1) / 2) * (\u221a\u03c0 * 2 ^ (2 * s - 1)) = Gamma s * Gamma ((s * 2 + 1) / 2) * 2 ^ (2 * s - 1) * \u221a\u03c0",["ring","linarith"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",75,"case h.a\nX : Type u_1\ninst\u271d : TopologicalSpace X\nf g : C(X, \u211d)\nx : X\n\u22a2 (f x + g x) \u2294 0 + (-f x + f x \u2294 0) + (-g x + g x \u2294 0) = -(f x + g x) + (f x + g x) \u2294 0 + f x \u2294 0 + g x \u2294 0",["abel","ring","linarith"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",82,"case h.a\nX : Type u_1\ninst\u271d : TopologicalSpace X\nf g : C(X, \u211d)\nx : X\n\u22a2 f x * g x \u2294 0 + (-(f x * (g x \u2294 0)) + (f x \u2294 0) * (g x \u2294 0)) + (-((f x \u2294 0) * g x) + (f x \u2294 0) * (g x \u2294 0)) =\n    -(f x * g x) + f x * g x \u2294 0 + (f x \u2294 0) * (g x \u2294 0) +\n      (-((f x \u2294 0) * g x) + f x * g x + (-(f x * (g x \u2294 0)) + (f x \u2294 0) * (g x \u2294 0)))",["abel","ring","linarith"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",122,"case h.e'_2\nX : Type u_1\ninst\u271d\u2075 : TopologicalSpace X\nA : Type u_2\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : Algebra \u211d A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : IsTopologicalRing A\n\u03c6 : C(X, \u211d\u22650) \u2192\u22c6\u2090[\u211d\u22650] A\nf g : C(X, \u211d)\nthis :\n  \u03c6 (f * g).toNNReal + \u03c6 (-f).toNNReal * \u03c6 g.toNNReal + \u03c6 f.toNNReal * \u03c6 (-g).toNNReal -\n      (\u03c6 (-(f * g)).toNNReal + \u03c6 f.toNNReal * \u03c6 g.toNNReal + \u03c6 (-f).toNNReal * \u03c6 (-g).toNNReal) =\n    0\n\u22a2 \u03c6 (f * g).toNNReal - \u03c6 (-(f * g)).toNNReal -\n      (\u03c6 f.toNNReal * \u03c6 g.toNNReal - \u03c6 (-f).toNNReal * \u03c6 g.toNNReal -\n        (\u03c6 f.toNNReal * \u03c6 (-g).toNNReal - \u03c6 (-f).toNNReal * \u03c6 (-g).toNNReal)) =\n    \u03c6 (f * g).toNNReal + \u03c6 (-f).toNNReal * \u03c6 g.toNNReal + \u03c6 f.toNNReal * \u03c6 (-g).toNNReal -\n      (\u03c6 (-(f * g)).toNNReal + \u03c6 f.toNNReal * \u03c6 g.toNNReal + \u03c6 (-f).toNNReal * \u03c6 (-g).toNNReal)",["abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",128,"case h.e'_2\nX : Type u_1\ninst\u271d\u2075 : TopologicalSpace X\nA : Type u_2\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : Algebra \u211d A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : IsTopologicalRing A\n\u03c6 : C(X, \u211d\u22650) \u2192\u22c6\u2090[\u211d\u22650] A\nf g : C(X, \u211d)\nthis :\n  \u03c6 (f + g).toNNReal + \u03c6 (-f).toNNReal + \u03c6 (-g).toNNReal - (\u03c6 (-(f + g)).toNNReal + \u03c6 f.toNNReal + \u03c6 g.toNNReal) = 0\n\u22a2 \u03c6 (f + g).toNNReal - \u03c6 (-(f + g)).toNNReal - (\u03c6 f.toNNReal - \u03c6 (-f).toNNReal + (\u03c6 g.toNNReal - \u03c6 (-g).toNNReal)) =\n    \u03c6 (f + g).toNNReal + \u03c6 (-f).toNNReal + \u03c6 (-g).toNNReal - (\u03c6 (-(f + g)).toNNReal + \u03c6 f.toNNReal + \u03c6 g.toNNReal)",["abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",306,"X : Type u_1\ninst\u271d\u2076 : TopologicalSpace X\ninst\u271d\u2075 : Zero X\nA : Type u_2\ninst\u271d\u2074 : NonUnitalRing A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : Module \u211d A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : IsTopologicalRing A\n\u03c6 : C(X, \u211d\u22650)\u2080 \u2192\u22c6\u2099\u2090[\u211d\u22650] A\nf g : C(X, \u211d)\u2080\nthis :\n  \u03c6 (f * g).toNNReal + \u03c6 (-f).toNNReal * \u03c6 g.toNNReal + \u03c6 f.toNNReal * \u03c6 (-g).toNNReal -\n      (\u03c6 (-(f * g)).toNNReal + \u03c6 f.toNNReal * \u03c6 g.toNNReal + \u03c6 (-f).toNNReal * \u03c6 (-g).toNNReal) =\n    0\n\u22a2 \u03c6 (f * g).toNNReal - \u03c6 (-(f * g)).toNNReal -\n      (\u03c6 f.toNNReal * \u03c6 g.toNNReal - \u03c6 (-f).toNNReal * \u03c6 g.toNNReal -\n        (\u03c6 f.toNNReal * \u03c6 (-g).toNNReal - \u03c6 (-f).toNNReal * \u03c6 (-g).toNNReal)) =\n    \u03c6 (f * g).toNNReal + \u03c6 (-f).toNNReal * \u03c6 g.toNNReal + \u03c6 f.toNNReal * \u03c6 (-g).toNNReal -\n      (\u03c6 (-(f * g)).toNNReal + \u03c6 f.toNNReal * \u03c6 g.toNNReal + \u03c6 (-f).toNNReal * \u03c6 (-g).toNNReal)",["abel"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",312,"X : Type u_1\ninst\u271d\u2076 : TopologicalSpace X\ninst\u271d\u2075 : Zero X\nA : Type u_2\ninst\u271d\u2074 : NonUnitalRing A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : Module \u211d A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : IsTopologicalRing A\n\u03c6 : C(X, \u211d\u22650)\u2080 \u2192\u22c6\u2099\u2090[\u211d\u22650] A\nf g : C(X, \u211d)\u2080\nthis :\n  \u03c6 (f + g).toNNReal + \u03c6 (-f).toNNReal + \u03c6 (-g).toNNReal - (\u03c6 (-(f + g)).toNNReal + \u03c6 f.toNNReal + \u03c6 g.toNNReal) = 0\n\u22a2 \u03c6 (f + g).toNNReal - \u03c6 (-(f + g)).toNNReal - (\u03c6 f.toNNReal - \u03c6 (-f).toNNReal + (\u03c6 g.toNNReal - \u03c6 (-g).toNNReal)) =\n    \u03c6 (f + g).toNNReal + \u03c6 (-f).toNNReal + \u03c6 (-g).toNNReal - (\u03c6 (-(f + g)).toNNReal + \u03c6 f.toNNReal + \u03c6 g.toNNReal)",["abel"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",143,"p\u271d p : \u211d\nh : p \u2260 2\u207b\u00b9\nhp : p < 2\u207b\u00b9\nhp\u2080 : 0 < p\n\u22a2 2\u207b\u00b9 < 1",["norm_num","linarith"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",431,"case h.e'_6\n\u22a2 Icc (1 / 2) 1 = Icc (1 - 1 / \u21912) 1",["norm_num","ring"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",62,"\u22a2 2\u207b\u00b9 * log 2 + 2\u207b\u00b9 * log 2 = log 2",["ring","linarith"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",293,"case h\nq : \u2115\nx\u271d : \u211d\n\u22a2 log (\u2191q - 1) + log (1 - x\u271d) - log x\u271d = log (\u2191q - 1) + (log (1 - x\u271d) - log x\u271d)",["ring","linarith","abel"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",311,"case h\nq : \u2115\nx\u271d : \u211d\n\u22a2 log (\u2191q - 1) + log (1 - x\u271d) - log x\u271d = log (\u2191q - 1) + (log (1 - x\u271d) - log x\u271d)",["ring","linarith","abel"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",340,"q : \u2115\np : \u211d\nxne0 : p \u2260 0\nxne1 : p \u2260 1\nthis\u271d : \u2200\u1da0 (y : \u211d) in \ud835\udcdd p, deriv (fun p \u21a6 qaryEntropy q p) y = log (\u2191q - 1) + log (1 - y) - log y\nthis : \u2200 {q : \u211d} (p : \u211d), DifferentiableAt \u211d (fun p \u21a6 q - p) p\nd_oneminus : \u2200 (p : \u211d), deriv (fun y \u21a6 1 - y) p = -1\n\u22a2 (-p - (1 - p)) * (p * (1 - p)) = -((1 - p) * p)",["ring","linarith"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",415,"q : \u2115\nqLe2 : 2 \u2264 q\np1 : \u211d\nhp1 : p1 \u2208 Icc (1 - 1 / \u2191q) 1\np2 : \u211d\nhp2 : p2 \u2208 Icc (1 - 1 / \u2191q) 1\np1le2 : p1 < p2\np : \u211d\nthis\u271d : 2 \u2264 \u2191q\nqinv_lt_1 : (\u2191q)\u207b\u00b9 < 1\nzero_lt_1_sub_p : 0 < 1 - p\nhp : 1 - (\u2191q)\u207b\u00b9 < p \u2227 p < 1\nqpos : 0 < \u2191q\ntmp : (1 - (\u2191q)\u207b\u00b9) * \u2191q < p * \u2191q\nthis : \u2191q \u2260 0\n\u22a2 (1 - (\u2191q)\u207b\u00b9) * \u2191q = \u2191q - (\u2191q)\u207b\u00b9 * \u2191q",["ring","linarith"]],["LinearAlgebra/Reflection.lean",89,"case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nf : Dual R M\ny : M\ng : Dual R M\nh : f x = 2\nm : M\n\u22a2 m - (g m \u2022 y - (f m * g x) \u2022 y - ((g m * f y) \u2022 x - (f m * (g x * f y)) \u2022 x)) =\n    m - f m \u2022 x - (g m \u2022 y - (g m * f y) \u2022 x) -\n      (f m \u2022 x - (f m \u2022 x + f m \u2022 x) - ((f m * g x) \u2022 y - (f m * (g x * f y)) \u2022 x))",["abel"]],["LinearAlgebra/Reflection.lean",328,"case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : CharZero R\ninst\u271d : NoZeroSMulDivisors R M\nx : M\n\u03a6 : Set M\nh\u03a6\u2081 : \u03a6.Finite\nh\u03a6\u2082 : span R \u03a6 = \u22a4\nf g : Dual R M\nhf\u2081 : f x = 2\nhf\u2082 : MapsTo (\u21d1(preReflection x f)) \u03a6 \u03a6\nhg\u2081 : g x = 2\nhg\u2082 : MapsTo (\u21d1(preReflection x g)) \u03a6 \u03a6\nhx : x \u2260 0\nu : M \u2243\u2097[R] M := reflection hg\u2081 * reflection hf\u2081\ny : M\n\u22a2 y - g y \u2022 x + f y \u2022 x = y + (f y \u2022 x - g y \u2022 x)",["abel"]],["LinearAlgebra/Reflection.lean",389,"case succ\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\nf : Dual R M\ny : M\ng : Dual R M\nhfx : f x = 2\nhgy : g y = 2\nhgxfy : f y * g x = 4\nn : \u2115\nih : (\u21d1(reflection hgy \u226a\u226b\u2097 reflection hfx))^[n] y = y + n \u2022 (f y \u2022 x - 2 \u2022 y)\nhz : \u2200 (z : M), f y \u2022 g x \u2022 z = 2 \u2022 2 \u2022 z\n\u22a2 f y \u2022 x - y +\n      (-(n \u2022 f y \u2022 x) - (n \u2022 y + n \u2022 y + (n \u2022 y + n \u2022 y) - (n \u2022 f y \u2022 x + n \u2022 f y \u2022 x + (n \u2022 f y \u2022 x + n \u2022 f y \u2022 x))) -\n        (n \u2022 f y \u2022 x - n \u2022 y + (n \u2022 f y \u2022 x - n \u2022 y))) =\n    y + (n \u2022 f y \u2022 x + 1 \u2022 f y \u2022 x - (n \u2022 y + 1 \u2022 y + (n \u2022 y + 1 \u2022 y)))",["abel"]],["Data/Complex/Module.lean",502,"A : Type u_2\ninst\u271d\u2075 : NonUnitalRing A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : Module \u2102 A\ninst\u271d\u00b2 : IsScalarTower \u2102 A A\ninst\u271d\u00b9 : SMulCommClass \u2102 A A\ninst\u271d : StarModule \u2102 A\na : A\na_eq : a = \u2191(\u211c a) + I \u2022 \u2191(\u2111 a)\n\u22a2 \u2191(\u211c a) * \u2191(\u211c a) + -(I \u2022 (\u2191(\u2111 a) * \u2191(\u211c a))) + (I \u2022 (\u2191(\u211c a) * \u2191(\u2111 a)) + \u2191(\u2111 a) * \u2191(\u2111 a)) +\n      (\u2191(\u211c a) * \u2191(\u211c a) + I \u2022 (\u2191(\u2111 a) * \u2191(\u211c a)) + (\u2191(\u2111 a) * \u2191(\u2111 a) + -(I \u2022 (\u2191(\u211c a) * \u2191(\u2111 a))))) =\n    \u2191(\u211c a) * \u2191(\u211c a) + \u2191(\u211c a) * \u2191(\u211c a) + (\u2191(\u2111 a) * \u2191(\u2111 a) + \u2191(\u2111 a) * \u2191(\u2111 a))",["abel"]],["Analysis/SpecialFunctions/Exp.lean",36,"case e_a\nx z : \u2102\nhz : \u2016z\u2016 \u2264 1\n\u22a2 cexp x * cexp z - cexp x - z * cexp x = cexp x * (cexp z - 1 - z)",["ring"]],["Analysis/SpecialFunctions/Exp.lean",57,"r : \u211d\nhr_nonneg : 0 \u2264 r\nhr_le : r \u2264 1\nx y : \u2102\nhyx : \u2016y - x\u2016 < r\nhy_eq : y = x + (y - x)\nhyx_sq_le : \u2016y - x\u2016 ^ 2 \u2264 r * \u2016y - x\u2016\nh_sq : \u2200 (z : \u2102), \u2016z\u2016 \u2264 1 \u2192 \u2016cexp (x + z) - cexp x\u2016 \u2264 \u2016z\u2016 * \u2016cexp x\u2016 + \u2016cexp x\u2016 * \u2016z\u2016 ^ 2\n\u22a2 \u2016y - x\u2016 * \u2016cexp x\u2016 + \u2016cexp x\u2016 * (r * \u2016y - x\u2016) = (1 + r) * \u2016cexp x\u2016 * \u2016y - x\u2016",["ring","linarith"]],["MeasureTheory/Function/ConvergenceInMeasure.lean",209,"\u03b1 : Type u_1\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : MetricSpace E\nf : \u2115 \u2192 \u03b1 \u2192 E\ng : \u03b1 \u2192 E\nhfg : TendstoInMeasure \u03bc f atTop g\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 2\u207b\u00b9 < 1",["norm_num","linarith"]],["MeasureTheory/Function/ConvergenceInMeasure.lean",211,"case intro\n\u03b1 : Type u_1\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : MetricSpace E\nf : \u2115 \u2192 \u03b1 \u2192 E\ng : \u03b1 \u2192 E\nhfg : TendstoInMeasure \u03bc f atTop g\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nk : \u2115\nh_k : 2\u207b\u00b9 ^ k < \u03b5\n\u22a2 2 * (2\u207b\u00b9 ^ k * 2\u207b\u00b9 ^ 1) = 2\u207b\u00b9 ^ k",["ring","linarith"]],["NumberTheory/Harmonic/ZetaAsymp.lean",134,"this : Tendsto (fun x \u21a6 -(eulerMascheroniSeq' \u2218 fun a \u21a6 a + 1) x) atTop (\ud835\udcdd (-\u03b3))\nn : \u2115\n\u22a2 -(\u2191(harmonic (n + 1)) - log (\u2191n + 1)) = -\u2191(harmonic (n + 1)) + log (\u2191n + 1)",["abel","ring","linarith"]],["NumberTheory/Harmonic/ZetaAsymp.lean",417,"\u22a2 2 / 3 < 1",["norm_num","linarith"]],["NumberTheory/Harmonic/ZetaAsymp.lean",83,"n : \u2115\nhn : 0 < n\nhv : \u2200 x \u2208 uIcc (\u2191n) (\u2191n + 1), 0 < x\nx : \u211d\nhx : x \u2208 uIcc (\u2191n) (\u2191n + 1)\n\u22a2 (x - \u2191n) * (x * x ^ 2) = (x ^ 2 - x * \u2191n) * x ^ 2",["ring","linarith"]],["Probability/Variance.lean",199,"\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsProbabilityMeasure \u03bc\nX : \u03a9 \u2192 \u211d\nhX : MemLp X 2 \u03bc\n\u22a2 \u222b (a : \u03a9), X a ^ 2 \u2202\u03bc + (\u222b (x : \u03a9), X x \u2202\u03bc) ^ 2 - (2 * \u222b (x : \u03a9), X x \u2202\u03bc) * \u222b (x : \u03a9), X x \u2202\u03bc =\n    \u222b (x : \u03a9), X x ^ 2 \u2202\u03bc - (\u222b (x : \u03a9), X x \u2202\u03bc) ^ 2",["ring","linarith"]],["Probability/Variance.lean",289,"\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsProbabilityMeasure \u03bc\nX Y : \u03a9 \u2192 \u211d\nhX : MemLp X 2 \u03bc\nhY : MemLp Y 2 \u03bc\nh : IndepFun X Y \u03bc\n\u22a2 \u222b (x : \u03a9), X x ^ 2 \u2202\u03bc + \u222b (x : \u03a9), Y x ^ 2 \u2202\u03bc + 2 * ((\u222b (x : \u03a9), X x \u2202\u03bc) * \u222b (x : \u03a9), Y x \u2202\u03bc) -\n      (\u222b (x : \u03a9), X x \u2202\u03bc + \u222b (x : \u03a9), Y x \u2202\u03bc) ^ 2 =\n    \u222b (x : \u03a9), X x ^ 2 \u2202\u03bc - (\u222b (x : \u03a9), X x \u2202\u03bc) ^ 2 + (\u222b (x : \u03a9), Y x ^ 2 \u2202\u03bc - (\u222b (x : \u03a9), Y x \u2202\u03bc) ^ 2)",["ring","linarith"]],["Probability/Variance.lean",330,"\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsProbabilityMeasure \u03bc\n\u03b9 : Type u_2\nX : \u03b9 \u2192 \u03a9 \u2192 \u211d\nk : \u03b9\ns : Finset \u03b9\nks : k \u2209 s\nIH :\n  (\u2200 i \u2208 s, MemLp (X i) 2 \u03bc) \u2192\n    ((\u2191s).Pairwise fun i j \u21a6 IndepFun (X i) (X j) \u03bc) \u2192 Var[\u2211 i \u2208 s, X i; \u03bc] = \u2211 i \u2208 s, Var[X i; \u03bc]\nhs : \u2200 i \u2208 insert k s, MemLp (X i) 2 \u03bc\nh : (\u2191(insert k s)).Pairwise fun i j \u21a6 IndepFun (X i) (X j) \u03bc\n\u22a2 \u222b (x : \u03a9), (X k ^ 2) x \u2202\u03bc + \u222b (x : \u03a9), ((\u2211 i \u2208 s, X i) ^ 2) x \u2202\u03bc + \u222b (x : \u03a9), (2 * X k * \u2211 i \u2208 s, X i) x \u2202\u03bc -\n      (\u222b (x : \u03a9), X k x \u2202\u03bc + \u222b (x : \u03a9), (\u2211 i \u2208 s, X i) x \u2202\u03bc) ^ 2 =\n    \u222b (x : \u03a9), (X k ^ 2) x \u2202\u03bc - (\u222b (x : \u03a9), X k x \u2202\u03bc) ^ 2 +\n        (\u222b (x : \u03a9), ((\u2211 i \u2208 s, X i) ^ 2) x \u2202\u03bc - (\u222b (x : \u03a9), (\u2211 i \u2208 s, X i) x \u2202\u03bc) ^ 2) +\n      (\u222b (x : \u03a9), (2 * X k * \u2211 i \u2208 s, X i) x \u2202\u03bc - (2 * \u222b (x : \u03a9), X k x \u2202\u03bc) * \u222b (x : \u03a9), (\u2211 i \u2208 s, X i) x \u2202\u03bc)",["ring","linarith"]],["Probability/Variance.lean",374,"\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 \u21a6 -X \u03c9 ^ 2) \u03bc\nhX_int\u2081 : Integrable (fun \u03c9 \u21a6 (a + b) * X \u03c9) \u03bc\n\u03c9 : \u03a9\n\u22a2 (fun \u03c9 \u21a6 (b - X \u03c9) * (X \u03c9 - a)) \u03c9 = (fun \u03c9 \u21a6 -X \u03c9 ^ 2 + (a + b) * X \u03c9 - a * b) \u03c9",["ring"]],["Probability/Variance.lean",384,"\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 \u21a6 -X \u03c9 ^ 2) \u03bc\nhX_int\u2081 : Integrable (fun \u03c9 \u21a6 (a + b) * X \u03c9) \u03bc\nh0 : 0 \u2264 -\u222b (x : \u03a9), (X ^ 2) x \u2202\u03bc + (a + b) * \u222b (x : \u03a9), X x \u2202\u03bc - a * b\n\u22a2 (a + b) * \u222b (x : \u03a9), X x \u2202\u03bc - a * b - (\u222b (x : \u03a9), X x \u2202\u03bc) ^ 2 = (b - \u222b (x : \u03a9), X x \u2202\u03bc) * (\u222b (x : \u03a9), X x \u2202\u03bc - a)",["ring","linarith"]],["Probability/Variance.lean",395,"\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\n\u22a2 (b - \u222b (x : \u03a9), X x \u2202\u03bc) * (\u222b (x : \u03a9), X x \u2202\u03bc - a) = ((b - a) / 2) ^ 2 - (\u222b (x : \u03a9), X x \u2202\u03bc - (b + a) / 2) ^ 2",["ring","linarith"]],["Combinatorics/SetFamily/AhlswedeZhang.lean",70,"m n : \u2115\nh : n < m\nf : \u2115 \u2192 \u211a := fun i \u21a6 \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\nhf : f = fun i \u21a6 \u2191(n.choose i) * (\u2191(m.choose i))\u207b\u00b9\ni : \u2115\nh\u2081\u271d : i < n + 1\nh\u2081 : i \u2264 n\nh\u2082 : i < m\nh\u2083 : i \u2264 m\nhi\u2084 : \u2191i + 1 \u2260 0\nthis\u271d\u00b2 : \u2191(m.choose (i + 1)) * (\u2191i + 1) = \u2191(m.choose i) * \u2191(m - i)\nthis\u271d\u00b9 : \u2191(n.choose (i + 1)) * (\u2191i + 1) = \u2191(n.choose i) * \u2191(n - i)\nthis\u271d : \u2191m - \u2191i \u2260 0\nthis : \u2191(m.choose i) \u2260 0\n\u22a2 (\u2191(n.choose i) * (\u2191(m.choose i) * (\u2191m - \u2191i)) - \u2191(m.choose i) * (\u2191(n.choose i) * (\u2191n - \u2191i))) *\n      ((\u2191m - \u2191i) * \u2191(m.choose i)) =\n    \u2191(n.choose i) * (\u2191m - \u2191n) * (\u2191(m.choose i) * (\u2191(m.choose i) * (\u2191m - \u2191i)))",["ring","linarith"]],["Topology/MetricSpace/Polish.lean",293,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MetricSpace \u03b1\ns : Opens \u03b1\ninst\u271d : CompleteSpace \u03b1\nu : \u2115 \u2192 s.CompleteCopy\nhu : \u2200 (N n m : \u2115), N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) < (fun x \u21a6 (1 / 2) ^ x) N\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["RingTheory/Polynomial/Eisenstein/IsIntegral.lean",188,"case h.a.calc_1\nR : Type u\nK : Type v\nL : Type z\np : R\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : Field K\ninst\u271d\u2078 : Field L\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra R L\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsScalarTower R K L\ninst\u271d\u00b3 : Algebra.IsSeparable K L\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsFractionRing R K\ninst\u271d : IsIntegrallyClosed R\nB : PowerBasis K L\nhp : _root_.Prime p\nhBint : IsIntegral R B.gen\nz : L\nQ : R[X]\nhQ : (aeval B.gen) Q = p \u2022 z\nhzint : IsIntegral R z\nhei : (minpoly R B.gen).IsEisensteinAt (Submodule.span R {p})\nthis : Module.Finite K L := finite B\nP : R[X] := minpoly R B.gen\nn : \u2115\nhn : B.dim = n.succ\nfinrank_K_L : Module.finrank K L = B.dim\ndeg_K_P : (minpoly K B.gen).natDegree = B.dim\ndeg_R_P : P.natDegree = B.dim\nf : \u2115 \u2192 L\nhf : \u2200 (i : \u2115), B.dim \u2264 i \u2192 f i \u2208 adjoin R {B.gen} \u2227 (algebraMap R L) p * f i = B.gen ^ i\naux : \u2200 i \u2208 (range (Q.natDegree + 1)).erase 0, B.dim \u2264 i + n\nhintsum : IsIntegral R (z * B.gen ^ n - \u2211 x \u2208 (range (Q.natDegree + 1)).erase 0, Q.coeff x \u2022 f (x + n))\nr : R\nhr :\n  (algebraMap R K) r = (Algebra.norm K) (z * B.gen ^ n - \u2211 x \u2208 (range (Q.natDegree + 1)).erase 0, Q.coeff x \u2022 f (x + n))\n\u22a2 (algebraMap R K) (Q.coeff 0) ^ B.dim * ((-1) ^ (B.dim * n) * (algebraMap R K) ((minpoly R B.gen).coeff 0) ^ n) =\n    (algebraMap R K) (Q.coeff 0) ^ B.dim * ((-1) ^ B.dim * (algebraMap R K) ((minpoly R B.gen).coeff 0)) ^ n",["ring"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",286,"b : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 (\u2191\u03c0 / c) ^ 1 = (\u2191\u03c0 / c) ^ (1 / 2 + 1 / 2)",["norm_num","ring"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",38,"p b : \u211d\nhb : 0 < b\nhp : 1 < p\nthis : Tendsto (fun x \u21a6 x * (b * x ^ (p - 1) + -1)) atTop atTop\nx : \u211d\nhx : 0 < x\n\u22a2 b * x ^ p + -x = -x + b * x ^ p",["ring","linarith","abel"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",176,"case h.e'_9\nb : \u2102\nhb : 0 < b.re\nhb' : b \u2260 0\nx : \u2102\n\u22a2 x * cexp (-(b * x ^ 2)) * (2 * b) = cexp (-(b * x ^ 2)) * (b * (2 * x))",["ring"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",212,"case e_f.h.e_a.e_z.e_a\nb : \u2102\nhb : 0 < b.re\np : \u211d \u00d7 \u211d\n\u22a2 (\u2191p.1 * Complex.cos \u2191p.2) ^ 2 + (\u2191p.1 * Complex.sin \u2191p.2) ^ 2 = (Complex.sin \u2191p.2 ^ 2 + Complex.cos \u2191p.2 ^ 2) * \u2191p.1 ^ 2",["ring"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",219,"b : \u2102\nhb : 0 < b.re\nthis : 0 \u2264 \u03c0 + \u03c0\n\u22a2 2 * \u2191\u03c0 * b = \u2191\u03c0 * (2 * b)",["ring"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",344,"case h.e'_2\nx : \u211d\nhx : x \u2208 Ioi 0\nthis : (x ^ 2) ^ (1 / 2 - 1) = x\u207b\u00b9\n\u22a2 2 * x * rexp (-x ^ 2) = 2 * rexp (-x ^ 2) * x",["ring","linarith"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",359,"case zero\n\u22a2 1 / 2 * \u221a\u03c0 = \u221a\u03c0 / 2",["ring","linarith"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",363,"case succ\nk : \u2115\nih : Gamma (\u2191k + 1 + 1 / 2) = \u2191(2 * k + 1)\u203c * \u221a\u03c0 / 2 ^ (k + 1)\n\u22a2 ((\u2191k + 1) * 2 + 1) * (\u2191(2 * k + 1)\u203c * \u221a\u03c0) * 2 ^ (k + 1 + 1) = (2 * \u2191k + 1 + 2) * \u2191(2 * k + 1)\u203c * \u221a\u03c0 * (2 * 2 ^ (k + 1))",["ring"]],["RingTheory/Polynomial/Pochhammer.lean",139,"S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 (\u2191n + X + 1) * (ascPochhammer \u2115 n).comp (X + 1) = (X + (\u2191n + 1)) * (ascPochhammer \u2115 n).comp (X + 1)",["ring","abel"]],["RingTheory/Polynomial/Pochhammer.lean",329,"R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (X - 1 - \u2191n) * (descPochhammer \u2124 n).comp (X - 1) = (X - (\u2191n + 1)) * (descPochhammer \u2124 n).comp (X - 1)",["ring","abel"]],["Algebra/Module/Injective.lean",326,"R : Type u\ninst\u271d\u2077 : Ring R\nQ : Type v\ninst\u271d\u2076 : AddCommGroup Q\ninst\u271d\u2075 : Module R Q\nM : Type u_1\nN : Type u_2\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\ni : M \u2192\u2097[R] N\nf : M \u2192\u2097[R] Q\ninst\u271d : Fact (Function.Injective \u21d1i)\nh : Baer R Q\ny : N\na b : \u21a5(supExtensionOfMaxSingleton i f y)\neq1 :\n  \u2191a + \u2191b =\n    \u2191(ExtensionOfMaxAdjoin.fst i a + ExtensionOfMaxAdjoin.fst i b) +\n      (ExtensionOfMaxAdjoin.snd i a + ExtensionOfMaxAdjoin.snd i b) \u2022 y\n\u22a2 \u2191(extensionOfMax i f).toLinearPMap (ExtensionOfMaxAdjoin.fst i a) +\n        \u2191(extensionOfMax i f).toLinearPMap (ExtensionOfMaxAdjoin.fst i b) +\n      ((ExtensionOfMaxAdjoin.extendIdealTo i f h y) (ExtensionOfMaxAdjoin.snd i a) +\n        (ExtensionOfMaxAdjoin.extendIdealTo i f h y) (ExtensionOfMaxAdjoin.snd i b)) =\n    \u2191(extensionOfMax i f).toLinearPMap (ExtensionOfMaxAdjoin.fst i a) +\n        (ExtensionOfMaxAdjoin.extendIdealTo i f h y) (ExtensionOfMaxAdjoin.snd i a) +\n      (\u2191(extensionOfMax i f).toLinearPMap (ExtensionOfMaxAdjoin.fst i b) +\n        (ExtensionOfMaxAdjoin.extendIdealTo i f h y) (ExtensionOfMaxAdjoin.snd i b))",["abel"]],["Combinatorics/SimpleGraph/Regularity/Uniform.lean",297,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \ud835\udd5c\nhP : P.IsEquipartition\nh\u03b5 : 0 \u2264 \u03b5\n\u22a2 \u03b5 * (\u2191(#A) + \u2191(#A)) ^ 2 = 4 * \u03b5 * \u2191(#A) ^ 2",["ring"]],["Combinatorics/SimpleGraph/Regularity/Uniform.lean",367,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \ud835\udd5c\nhA : A.Nonempty\nh\u03b5 : 0 < \u03b5\nhP : P.IsEquipartition\nhG : P.IsUniform G \u03b5\n\u22a2 \u03b5 * (\u2191(#A) + \u2191(#A)) ^ 2 = 4 * \u03b5 * \u2191(#A) ^ 2",["ring"]],["FieldTheory/PrimitiveElement.lean",157,"F : Type u_1\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Infinite F\nE : Type u_2\ninst\u271d\u00b2 : Field E\n\u03b1 \u03b2 : E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : Algebra.IsSeparable F E\nh\u03b1 : IsIntegral F \u03b1\nh\u03b2 : IsIntegral F \u03b2\nf : F[X] := minpoly F \u03b1\ng : F[X] := minpoly F \u03b2\n\u03b9FE : F \u2192+* E := algebraMap F E\n\u03b9EE' : E \u2192+* (Polynomial.map \u03b9FE g).SplittingField := algebraMap E (Polynomial.map \u03b9FE g).SplittingField\nc : F\n\u03b3 : E := \u03b1 + c \u2022 \u03b2\np : (\u21a5F\u27ee\u03b3\u27ef)[X] :=\n  EuclideanDomain.gcd\n    ((Polynomial.map (algebraMap F \u21a5F\u27ee\u03b3\u27ef) f).comp (C (AdjoinSimple.gen F \u03b3) - C \u27e8(algebraMap F E) c, \u22ef\u27e9 * X))\n    (Polynomial.map (algebraMap F \u21a5F\u27ee\u03b3\u27ef) g)\nh : E[X] := EuclideanDomain.gcd ((Polynomial.map \u03b9FE f).comp (C \u03b3 - C (\u03b9FE c) * X)) (Polynomial.map \u03b9FE g)\nmap_g_ne_zero : Polynomial.map \u03b9FE g \u2260 0\nh_ne_zero : h \u2260 0\nh_sep : h.Separable\nh_root : eval \u03b2 h = 0\nh_splits : Splits \u03b9EE' h\nx : (Polynomial.map \u03b9FE g).SplittingField\nhx : eval\u2082 \u03b9EE' x h = 0\nhc : -(\u03b9EE' \u03b3 - \u03b9EE' (\u03b9FE c) * x - \u03b9EE' \u03b1) / (x - \u03b9EE' \u03b2) \u2260 (\u03b9EE'.comp \u03b9FE) c\na : \u00acx = \u03b9EE' \u03b2\n\u22a2 -(\u03b9EE' \u03b1 + \u03b9EE' ((algebraMap F E) c) * \u03b9EE' \u03b2 - \u03b9EE' (\u03b9FE c) * x - \u03b9EE' \u03b1) = \u03b9EE' (\u03b9FE c) * (x - \u03b9EE' \u03b2)",["ring"]],["NumberTheory/LSeries/DirichletContinuation.lean",306,"N : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\nh\u03c7 : \u03c7.IsPrimitive\ns : \u2102\nhN : N \u2260 1\nh_sum : \u2211 j : ZMod N, \u03c7 j = 0\n\u03b5 : \u2102 := I ^ if \u03c7.Even then 0 else 1\n\u22a2 \u2191N ^ (s - 1) * \u03c7 (-1) / \u03b5 * (\u03c7\u207b\u00b9 (-1) * gaussSum \u03c7 stdAddChar * ZMod.completedLFunction (\u21d1\u03c7\u207b\u00b9) s) =\n    \u2191N ^ (s - 1) / \u03b5 * gaussSum \u03c7 stdAddChar * ZMod.completedLFunction (\u21d1\u03c7\u207b\u00b9) s * (\u03c7 (-1) * \u03c7\u207b\u00b9 (-1))",["ring"]],["LinearAlgebra/Matrix/SpecialLinearGroup.lean",380,"case refine_1\nR : Type v\ninst\u271d : CommRing R\nA : SL(2, R)\ni : Fin 2\n\u22a2 \u2191A 1 1 * \u2191A 0 0 + -\u2191A 1 0 * \u2191A 0 1 = \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0\n```\n---\n```lean\ncase refine_2\nR : Type v\ninst\u271d : CommRing R\nA : SL(2, R)\ni : Fin 2\n\u22a2 -\u2191A 0 1 * \u2191A 1 0 + \u2191A 0 0 * \u2191A 1 1 = \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0",["ring"]],["LinearAlgebra/Matrix/SpecialLinearGroup.lean",387,"case refine_1\nR : Type v\ninst\u271d : CommRing R\nA : SL(2, R)\nj : Fin 2\n\u22a2 \u2191A 1 1 * \u2191A 0 0 + -\u2191A 0 1 * \u2191A 1 0 = \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0\n```\n---\n```lean\ncase refine_2\nR : Type v\ninst\u271d : CommRing R\nA : SL(2, R)\nj : Fin 2\n\u22a2 -\u2191A 1 0 * \u2191A 0 1 + \u2191A 0 0 * \u2191A 1 1 = \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0",["ring"]],["LinearAlgebra/Matrix/SpecialLinearGroup.lean",410,"case intro.intro.refine_1\nR : Type u_1\ninst\u271d : CommRing R\na b : R\nj : Fin 2\nu v : R\nh : u * a + v * b = 1\n\u22a2 a * u - -v * b = u * a + v * b\n```\n---\n```lean\ncase intro.intro.refine_2\nR : Type u_1\ninst\u271d : CommRing R\na b : R\nj : Fin 2\nu v : R\nh : u * a + v * b = 1\n\u22a2 v * b - a * -u = u * a + v * b",["ring"]],["LinearAlgebra/Matrix/SpecialLinearGroup.lean",421,"case intro.intro.refine_1\nR : Type u_1\ninst\u271d : CommRing R\na b : R\ni : Fin 2\nu v : R\nh : u * a + v * b = 1\n\u22a2 a * u - b * -v = u * a + v * b\n```\n---\n```lean\ncase intro.intro.refine_2\nR : Type u_1\ninst\u271d : CommRing R\na b : R\ni : Fin 2\nu v : R\nh : u * a + v * b = 1\n\u22a2 v * b - -u * a = u * a + v * b",["ring"]],["Analysis/NormedSpace/OperatorNorm/Bilinear.lean",359,"\ud835\udd5c : Type u_1\nE : Type u_4\nF\u2097 : Type u_7\nG\u2097 : Type u_9\ninst\u271d\u2076 : SeminormedAddCommGroup E\ninst\u271d\u2075 : SeminormedAddCommGroup F\u2097\ninst\u271d\u2074 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d : NormedSpace \ud835\udd5c G\u2097\nf : E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097\nx x' : E\ny y' : F\u2097\n\u22a2 (f x) y + ((f x') y + ((f x) y' + (f x') y')) = (f x) y + ((f x) y' + ((f x') y + (f x') y'))",["abel"]],["Analysis/NormedSpace/OperatorNorm/Bilinear.lean",370,"\ud835\udd5c : Type u_1\nE : Type u_4\nF\u2097 : Type u_7\ninst\u271d\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b3 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \ud835\udd5c F\u2097\nc : E \u2192L[\ud835\udd5c] \ud835\udd5c\nf : F\u2097\nx : E\n\u22a2 \u2016c\u2016 * \u2016x\u2016 * \u2016f\u2016 = \u2016c\u2016 * \u2016f\u2016 * \u2016x\u2016",["ring","linarith"]],["NumberTheory/Multiplicity.lean",61,"case h.e'_4\nR : Type u_1\ninst\u271d : CommRing R\np x : R\nn : \u2115\nthis : p ^ 2 \u2223 \u2211 i \u2208 range n, x ^ i * p ^ (n + 1 - i) * \u2191((n + 1).choose i)\n\u22a2 \u2211 m \u2208 range n, x ^ m * p ^ (n + 1 - m) * \u2191((n + 1).choose m) + x ^ n * p * (\u2191n + 1) + x ^ (n + 1) -\n        x ^ n * p * (\u2191n + 1) -\n      x ^ (n + 1) =\n    \u2211 i \u2208 range n, x ^ i * p ^ (n + 1 - i) * \u2191((n + 1).choose i)",["abel","ring"]],["NumberTheory/Multiplicity.lean",274,"case succ\nR : Type u_1\ninst\u271d : CommRing R\nx y : R\nd : \u2115\nhd : x ^ 2 ^ d - y ^ 2 ^ d = (\u220f i \u2208 range d, (x ^ 2 ^ i + y ^ 2 ^ i)) * (x - y)\n\u22a2 x ^ 2 ^ (d + 1) - y ^ 2 ^ (d + 1) = (x ^ 2 ^ d + y ^ 2 ^ d) * (x ^ 2 ^ d - y ^ 2 ^ d)",["ring"]],["Probability/Moments/SubGaussian.lean",265,"case e_x\n\u03a9 : Type u_1\n\u03a9' : Type u_2\nm\u03a9 : MeasurableSpace \u03a9\nm\u03a9' : MeasurableSpace \u03a9'\n\u03bd : Measure \u03a9'\n\u03ba : Kernel \u03a9' \u03a9\nX : \u03a9 \u2192 \u211d\nc : \u211d\u22650\nh\u271d : HasSubgaussianMGF X c \u03ba \u03bd\n\u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nhc0 : \u00acc = 0\n\u03c9' : \u03a9'\nh : \u2200 (t : \u211d), 0 \u2264 t \u2192 ((\u03ba \u03c9') {\u03c9 | \u03b5 \u2264 X \u03c9}).toReal \u2264 rexp (-t * \u03b5 + \u2191c * t ^ 2 / 2)\n\u22a2 (-(\u03b5 * \u03b5 * (\u2191c ^ 2 * 2)) + \u2191c * \u03b5 ^ 2 * \u2191c) * (2 * \u2191c) = -(\u03b5 ^ 2 * (\u2191c * (\u2191c ^ 2 * 2)))",["ring","linarith"]],["RingTheory/Ideal/Norm/AbsNorm.lean",103,"case h.e'_5\nS : Type u_1\ninst\u271d : CommRing S\nP : Ideal S\ni : \u2115\na d d' e e' : S\na_mem : a \u2208 P ^ i\ne_mem : e \u2208 P ^ (i + 1)\ne'_mem : e' \u2208 P ^ (i + 1)\nh : d - d' \u2208 P\nthis : a * d - a * d' \u2208 P ^ (i + 1)\n\u22a2 a * d + e - (a * d' + e') = a * d - a * d' + (e - e')",["ring","abel"]],["RingTheory/Ideal/Norm/AbsNorm.lean",142,"case h.e'_5\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\nP : Ideal S\nP_prime : P.IsPrime\ninst\u271d : IsDedekindDomain S\nhP : P \u2260 \u22a5\ni : \u2115\na d d' e e' : S\na_not_mem : a \u2209 P ^ (i + 1)\ne_mem : e \u2208 P ^ (i + 1)\ne'_mem : e' \u2208 P ^ (i + 1)\nh : a * d + e - (a * d' + e') \u2208 P ^ (i + 1)\n\u22a2 a * (d - d') = a * d + e - (a * d' + e') + (e' - e)",["ring"]],["RingTheory/Polynomial/Content.lean",361,"R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np q : R[X]\nh0 : \u00acC (p * q).content = 0\n\u22a2 C p.content * p.primPart * (C q.content * q.primPart) = C p.content * C q.content * (p.primPart * q.primPart)",["ring"]],["Analysis/Calculus/Taylor.lean",151,"E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nx y : \u211d\nk : \u2115\ns t : Set \u211d\nht : UniqueDiffWithinAt \u211d t y\nhs : s \u2208 \ud835\udcdd[t] y\nhf : HasDerivWithinAt (iteratedDerivWithin (k + 1) f s) (iteratedDerivWithin (k + 2) f s y) t y\n\u22a2 -((x - y) ^ k * ((\u2191k + 1) * \u2191k !)) = (-1 + -\u2191k) * (x - y) ^ k * \u2191k !",["ring","linarith"]],["Analysis/Calculus/Taylor.lean",240,"case right\nf g g' : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\ngcont : ContinuousOn g (Icc x\u2080 x)\ngdiff : \u2200 x_1 \u2208 Ioo x\u2080 x, HasDerivAt g (g' x_1) x_1\ng'_ne : \u2200 x_1 \u2208 Ioo x\u2080 x, g' x_1 \u2260 0\ny : \u211d\nhy : y \u2208 Ioo x\u2080 x\nh :\n  ((\u2191n !)\u207b\u00b9 * (x - y) ^ n) \u2022 iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y * (g x - g x\u2080) / g' y =\n    f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x\n\u22a2 (x - y) ^ n * iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y * (g x - g x\u2080) =\n    (x - y) ^ n * (g x - g x\u2080) * iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y",["ring","linarith"]],["Analysis/Calculus/Taylor.lean",269,"case right\nf : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\ngcont : ContinuousOn (fun t \u21a6 (x - t) ^ (n + 1)) (Icc x\u2080 x)\nxy_ne : \u2200 y \u2208 Ioo x\u2080 x, (x - y) ^ n \u2260 0\nhg' : \u2200 y \u2208 Ioo x\u2080 x, -(\u2191n + 1) * (x - y) ^ n \u2260 0\ny : \u211d\nhy : y \u2208 Ioo x\u2080 x\nh :\n  f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n    (-((x - y) ^ n / \u2191n ! * (x - x\u2080) ^ (n + 1)) / (-(\u2191n + 1) * (x - y) ^ n)) \u2022 iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y\n\u22a2 (x - y) ^ n * (x - x\u2080) ^ (n + 1) * iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y * ((\u2191n + 1) * \u2191n !) =\n    iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y * (x - x\u2080) ^ (n + 1) * (\u2191n ! * ((\u2191n + 1) * (x - y) ^ n))",["ring","linarith"]],["Analysis/Calculus/Taylor.lean",291,"case right\nf : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\ngcont : ContinuousOn id (Icc x\u2080 x)\ngdiff : \u2200 x_1 \u2208 Ioo x\u2080 x, HasDerivAt id ((fun x \u21a6 1) x_1) x_1\ny : \u211d\nhy : y \u2208 Ioo x\u2080 x\nh :\n  f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n    ((x - y) ^ n / \u2191n ! * (id x - id x\u2080) / 1) \u2022 iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y\n\u22a2 (x - y) ^ n * (x - x\u2080) * iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y =\n    iteratedDerivWithin (n + 1) f (Icc x\u2080 x) y * (x - y) ^ n * (x - x\u2080)",["ring","linarith"]],["Analysis/Calculus/Taylor.lean",332,"case inr\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b C x : \u211d\nn : \u2115\nhab : a \u2264 b\nhf : ContDiffOn \u211d (\u2191n + 1) f (Icc a b)\nhx : x \u2208 Icc a b\nhC : \u2200 y \u2208 Icc a b, \u2016iteratedDerivWithin (n + 1) f (Icc a b) y\u2016 \u2264 C\nh : a < b\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc a b)) (Icc a b)\nh' : \u2200 y \u2208 Ico a x, \u2016((\u2191n !)\u207b\u00b9 * (x - y) ^ n) \u2022 iteratedDerivWithin (n + 1) f (Icc a b) y\u2016 \u2264 (\u2191n !)\u207b\u00b9 * |x - a| ^ n * C\nA :\n  \u2200 t \u2208 Icc a x,\n    HasDerivWithinAt (fun y \u21a6 taylorWithinEval f n (Icc a b) y x)\n      (((\u2191n !)\u207b\u00b9 * (x - t) ^ n) \u2022 iteratedDerivWithin (n + 1) f (Icc a b) t) (Icc a x) t\nthis : \u2016f x - taylorWithinEval f n (Icc a b) a x\u2016 \u2264 (\u2191n !)\u207b\u00b9 * |x - a| ^ n * C * (x - a)\n\u22a2 (\u2191n !)\u207b\u00b9 * (x - a) ^ n * C * (x - a) = C * (x - a) ^ (n + 1) / \u2191n !",["ring"]],["Probability/Distributions/Gaussian.lean",111,"\u03bc : \u211d\nv : \u211d\u22650\nh : v \u2260 0\nhfm : AEStronglyMeasurable (gaussianPDFReal \u03bc v) \u2119\nhf : 0 \u2264\u1da0[ae \u2119] gaussianPDFReal \u03bc v\n\u22a2 \u221a\u03c0 * (\u221a\u2191v * \u221a2) = \u221a2 * \u221a\u03c0 * \u221a\u2191v",["ring","linarith"]],["Probability/Distributions/Gaussian.lean",144,"\u03bc : \u211d\nv : \u211d\u22650\nc : \u211d\nhc : c \u2260 0\nx : \u211d\n\u22a2 (\u221a\u2191v)\u207b\u00b9 * (\u221a2)\u207b\u00b9 * (\u221a\u03c0)\u207b\u00b9 * (|c| * |c|\u207b\u00b9) = (\u221a\u2191v)\u207b\u00b9 * (\u221a2)\u207b\u00b9 * (\u221a\u03c0)\u207b\u00b9 * |c| * |c|\u207b\u00b9",["ring","aesop","linarith"]],["Probability/Distributions/Gaussian.lean",148,"case refine_2.e_x.e_a\n\u03bc : \u211d\nv : \u211d\u22650\nc : \u211d\nhc : c \u2260 0\nx : \u211d\n\u22a2 c ^ 2 * (2 * \u2191v) = 2 * (c ^ 2 * \u2191v)",["ring","linarith"]],["Algebra/Homology/TotalComplexShift.lean",287,"case pos.h.e_a.e_n\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\ny : \u2124\ninst\u271d : K.HasTotal (up \u2124)\nn\u2080 n\u2081 n\u2080' n\u2081' : \u2124\nh\u2080 : n\u2080 + y = n\u2080'\nh\u2081 : n\u2081 + y = n\u2081'\nh : n\u2080 + 1 = n\u2081\np q : \u2124\nhpq : p + q = n\u2080\n\u22a2 p + y + p * y = y + p * y + p",["omega","linarith","abel"]],["Data/Real/Archimedean.lean",382,"a : \u211d\nha : 1 < a\nk : \u2115\nposk : 0 < k\nhk : 1 / \u2191k + 1 < a\n\u22a2 2 = 1 + 1",["norm_num","ring","linarith"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",61,"b : \u2102\nhb : b.re \u2260 0\nc T : \u211d\n\u22a2 (b.re * T ^ 2 - 2 * b.im * c * T - b.re * c ^ 2) * (b.re ^ 2 * b.re) =\n    b.re * (T * b.re - b.im * c) ^ 2 * b.re - b.re ^ 2 * (c ^ 2 * (b.im ^ 2 + b.re * b.re))",["ring","linarith"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",221,"b : \u2102\nhb : 0 < b.re\nc : \u2102\nthis : b \u2260 0\nh : (-\u2191\u03c0 * b).re < 0\nt x : \u211d\n\u22a2 -2 * \u2191\u03c0 * \u2191x * \u2191t * I + -\u2191\u03c0 * b * \u2191x ^ 2 + 2 * \u2191\u03c0 * c * \u2191x = -\u2191\u03c0 * b * \u2191x ^ 2 + (-2 * \u2191\u03c0 * I * \u2191t + 2 * \u2191\u03c0 * c) * \u2191x + 0",["ring"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",230,"case h.e_a.e_z\nb : \u2102\nhb : 0 < b.re\nc : \u2102\nthis\u271d : b \u2260 0\nh : (-\u2191\u03c0 * b).re < 0\nt : \u211d\nthis :\n  \u2200 (x : \u211d),\n    \u2191(-2 * \u03c0 * x * t) * I + -\u2191\u03c0 * b * \u2191x ^ 2 + 2 * \u2191\u03c0 * c * \u2191x =\n      -\u2191\u03c0 * b * \u2191x ^ 2 + (-2 * \u2191\u03c0 * I * \u2191t + 2 * \u2191\u03c0 * c) * \u2191x + 0\n\u22a2 -(\u2191\u03c0 ^ 2 * I * \u2191t * c * b * 8) + \u2191\u03c0 ^ 2 * -1 * \u2191t ^ 2 * b * 4 + \u2191\u03c0 ^ 2 * c ^ 2 * b * 4 =\n    -(\u2191\u03c0 ^ 2 * I * \u2191t * c * b * 8) + (-(\u2191\u03c0 ^ 2 * -1 * c ^ 2 * b * 4) - \u2191\u03c0 ^ 2 * \u2191t ^ 2 * b * 4)",["ring"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",354,"case h.e'_2.h.e'_7.h.e_z\nb : \u2102\nV : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : FiniteDimensional \u211d V\ninst\u271d\u00b9 : MeasurableSpace V\ninst\u271d : BorelSpace V\nhb : 0 < b.re\nx w v : V\n\u22a2 -(2 * \u2191\u03c0 * \u2191(inner w v) * I) + (-(b * \u2191\u2016v\u2016 ^ 2) + 2 * \u2191\u03c0 * I * \u2191(inner x v)) =\n    -(b * \u2191\u2016v\u2016 ^ 2) + 2 * \u2191\u03c0 * I * (\u2191(inner x v) - \u2191(inner w v))",["ring"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",357,"case h.e'_3.h.e'_6.h.e'_1\nb : \u2102\nV : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : FiniteDimensional \u211d V\ninst\u271d\u00b9 : MeasurableSpace V\ninst\u271d : BorelSpace V\nhb : 0 < b.re\nx w : V\nthis : b \u2260 0\n\u22a2 \u2191\u03c0 ^ 2 * \u2191\u2016x - w\u2016 ^ 2 * (4 * b) = 2 ^ 2 * \u2191\u03c0 ^ 2 * \u2191\u2016x - w\u2016 ^ 2 * b",["ring"]],["NumberTheory/Bernoulli.lean",100,"\u22a2 1 - \u2211 k \u2208 range 1, \u2191(Nat.choose 1 k) / (\u21911 - \u2191k + 1) * bernoulli' k = 1 / 2",["norm_num"]],["NumberTheory/Bernoulli.lean",234,"case h.e'_3\nn : \u2115\nh\u2081 : (1, n) \u2208 antidiagonal n.succ\nh\u2082 : \u2191n + 1 \u2260 0\nh\u2083 : (1 + n).choose n = n + 1\nH :\n  \u2191(((1, n).1 + (1, n).2).choose (1, n).2) / (\u2191(1, n).2 + 1) * bernoulli' (1, n).1 +\n      \u2211 x \u2208 antidiagonal n.succ \\ {(1, n)}, \u2191((x.1 + x.2).choose x.2) / (\u2191x.2 + 1) * bernoulli' x.1 =\n    1\n\u22a2 1 = 2 - 1",["norm_num","ring","linarith"]],["NumberTheory/Bernoulli.lean",127,"n : \u2115\nthis :\n  \u2191(n + 1) * \u2211 x \u2208 range n, Rat.divInt (\u2191(n.choose x)) (Int.subNatNat n x + 1) * bernoulli' x =\n    \u2211 x \u2208 range n, \u2191(n.succ.choose x) * bernoulli' x\n\u22a2 \u2191(n + 1) * \u2211 x \u2208 range n, Rat.divInt (\u2191(n.choose x)) (Int.subNatNat n x + 1) * bernoulli' x +\n      \u2191(n + 1) * (1 - \u2211 x \u2208 range n, Rat.divInt (\u2191(n.choose x)) (Int.subNatNat n x + 1) * bernoulli' x) =\n    \u2191(n + 1)",["ring","linarith"]],["NumberTheory/Bernoulli.lean",204,"n : \u2115\nthis : \u2211 i \u2208 range n, \u2191((n + 2).choose (i + 2)) * bernoulli (i + 2) = \u2191n / 2\n\u22a2 \u2191n / 2 + (\u2191n + 1 + 1) * (-1 / 2) + 1 = 0",["ring","linarith"]],["NumberTheory/Bernoulli.lean",213,"case succ.succ.refine_2\nn : \u2115\nf :\n  \u2211 k \u2208 range n, \u2191(n.succ.succ.choose (k + 1 + 1)) * bernoulli' (k + 1 + 1) =\n    \u2191n + 1 + 1 - \u2191(n.succ.succ.choose 0) * bernoulli' 0 - \u2191(n.succ.succ.choose (0 + 1)) * bernoulli' (0 + 1)\n\u22a2 \u2191n + 1 + 1 - (\u21910 + 1) - (\u2191n + 1 + 1) * 2\u207b\u00b9 = \u2191n / 2",["ring"]],["NumberTheory/Bernoulli.lean",258,"case h.succ.succ.h.h\nA : Type u_1\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra \u211a A\nn : \u2115\nhfact : \u2200 (m : \u2115), \u2191m ! \u2260 0\nhite2 : (if n.succ = 0 then 1 else 0) = 0\nx : \u2115 \u00d7 \u2115\nh : x.1 + x.2 = n.succ\n\u22a2 \u2191x.2! * (\u2191x.2 + 1) = (\u2191x.2 + 1) * \u2191x.2!",["ring","linarith"]],["NumberTheory/Bernoulli.lean",329,"n p : \u2115\nhne : \u2200 (m : \u2115), \u2191m ! \u2260 0\nh_cauchy :\n  ((PowerSeries.mk fun p \u21a6 bernoulli p / \u2191p !) * PowerSeries.mk fun q \u21a6 (coeff \u211a (q + 1)) (exp \u211a ^ n)) =\n    PowerSeries.mk fun p \u21a6 \u2211 i \u2208 range (p + 1), bernoulli i * \u2191((p + 1).choose i) * \u2191n ^ (p + 1 - i) / \u2191(p + 1)!\nhps :\n  \u2211 k \u2208 range n, \u2191k ^ p = (\u2211 i \u2208 range (p + 1), bernoulli i * \u2191((p + 1).choose i) * \u2191n ^ (p + 1 - i) / \u2191(p + 1)!) * \u2191p !\nx : \u2115\nx\u271d : x \u2208 range (p + 1)\n\u22a2 bernoulli x * \u2191((p + 1).choose x) * \u2191n ^ (p + 1 - x) * \u2191p ! * (\u2191p + 1) =\n    bernoulli x * \u2191((p + 1).choose x) * \u2191n ^ (p + 1 - x) * ((\u2191p + 1) * \u2191p !)",["ring"]],["NumberTheory/Bernoulli.lean",350,"n p : \u2115\nf : \u2115 \u2192 \u211a := fun i \u21a6 bernoulli i * \u2191(p.succ.succ.choose i) * \u2191n ^ (p.succ.succ - i) / \u2191p.succ.succ\nf' : \u2115 \u2192 \u211a := fun i \u21a6 bernoulli' i * \u2191(p.succ.succ.choose i) * \u2191n ^ (p.succ.succ - i) / \u2191p.succ.succ\nhle : 1 \u2264 n + 1\nhne : \u2191p + 1 + 1 \u2260 0\nh1 : \u2200 (r : \u211a), r * (\u2191p + 1 + 1) * \u2191n ^ p.succ / (\u2191p + 1 + 1) = r * \u2191n ^ p.succ\n\u22a2 -1 / 2 * \u2191n ^ p.succ + \u2191n ^ p.succ = 1 / 2 * \u2191n ^ p.succ",["ring","linarith"]],["NumberTheory/Bernoulli.lean",366,"n p : \u2115\nf : \u2115 \u2192 \u211a := fun i \u21a6 bernoulli i * \u2191(p.succ.succ.choose i) * \u2191n ^ (p.succ.succ - i) / \u2191p.succ.succ\nf' : \u2115 \u2192 \u211a := fun i \u21a6 bernoulli' i * \u2191(p.succ.succ.choose i) * \u2191n ^ (p.succ.succ - i) / \u2191p.succ.succ\nhle : 1 \u2264 n + 1\nhne : \u2191p + 1 + 1 \u2260 0\nh1 : \u2200 (r : \u211a), r * (\u2191p + 1 + 1) * \u2191n ^ p.succ / (\u2191p + 1 + 1) = r * \u2191n ^ p.succ\nh2 : f 1 + \u2191n ^ p.succ = 1 / 2 * \u2191n ^ p.succ\nthis :\n  \u2211 i \u2208 range p, bernoulli (i + 2) * \u2191((p + 2).choose (i + 2)) * \u2191n ^ (p - i) / \u2191(p + 2) =\n    \u2211 i \u2208 range p, bernoulli' (i + 2) * \u2191((p + 2).choose (i + 2)) * \u2191n ^ (p - i) / \u2191(p + 2)\n\u22a2 \u2211 i \u2208 range p, f i.succ.succ + f 1 + f 0 + \u2191n ^ p.succ = \u2211 i \u2208 range p, f i.succ.succ + (f 1 + \u2191n ^ p.succ) + f 0",["ring"]],["LinearAlgebra/CliffordAlgebra/Basic.lean",221,"R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\nQ : QuadraticForm R M\nA : Type u_4\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nf : M \u2192\u2097[R] A\nhf : \u2200 (x : M), f x * f x = (algebraMap R A) (Q x)\na b : M\n\u22a2 f a * f b + f b * f a = f a * f a + f b * f a + (f a * f b + f b * f b) - f a * f a - f b * f b",["abel"]],["Analysis/NormedSpace/HahnBanach/Separation.lean",223,"case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2076 : TopologicalSpace E\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns t : Set E\nx y : E\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : IsScalarTower \u211d \ud835\udd5c E\ninst\u271d : ContinuousConstSMul \ud835\udd5c E\nto\ud835\udd5c : (E \u2192L[\u211d] \u211d) \u2192 E \u2192L[\ud835\udd5c] \ud835\udd5c := fun fr \u21a6 { toLinearMap := (\u2191fr).extendTo\ud835\udd5c', cont := \u22ef }\nh : \u2200 (fr : E \u2192L[\u211d] \u211d) (x : E), (to\ud835\udd5c fr) x = \u2191(fr x) - I * \u2191(fr (I \u2022 x))\nx\u271d\u00b9 y\u271d : E \u2192L[\u211d] \u211d\nx\u271d : E\n\u22a2 (algebraMap \u211d \ud835\udd5c) (x\u271d\u00b9 x\u271d) + (algebraMap \u211d \ud835\udd5c) (y\u271d x\u271d) -\n      I * ((algebraMap \u211d \ud835\udd5c) (x\u271d\u00b9 (I \u2022 x\u271d)) + (algebraMap \u211d \ud835\udd5c) (y\u271d (I \u2022 x\u271d))) =\n    \u2191(x\u271d\u00b9 x\u271d) - I * \u2191(x\u271d\u00b9 (I \u2022 x\u271d)) + (\u2191(y\u271d x\u271d) - I * \u2191(y\u271d (I \u2022 x\u271d)))",["ring"]],["Analysis/NormedSpace/HahnBanach/Separation.lean",224,"case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2076 : TopologicalSpace E\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns t : Set E\nx y : E\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : IsScalarTower \u211d \ud835\udd5c E\ninst\u271d : ContinuousConstSMul \ud835\udd5c E\nto\ud835\udd5c : (E \u2192L[\u211d] \u211d) \u2192 E \u2192L[\ud835\udd5c] \ud835\udd5c := fun fr \u21a6 { toLinearMap := (\u2191fr).extendTo\ud835\udd5c', cont := \u22ef }\nh : \u2200 (fr : E \u2192L[\u211d] \u211d) (x : E), (to\ud835\udd5c fr) x = \u2191(fr x) - I * \u2191(fr (I \u2022 x))\nm\u271d : \u211d\nx\u271d\u00b9 : E \u2192L[\u211d] \u211d\nx\u271d : E\n\u22a2 (algebraMap \u211d \ud835\udd5c) m\u271d * (algebraMap \u211d \ud835\udd5c) (x\u271d\u00b9 x\u271d) - I * ((algebraMap \u211d \ud835\udd5c) m\u271d * (algebraMap \u211d \ud835\udd5c) (x\u271d\u00b9 (I \u2022 x\u271d))) =\n    \u2191m\u271d * (\u2191(x\u271d\u00b9 x\u271d) - I * \u2191(x\u271d\u00b9 (I \u2022 x\u271d)))",["ring"]],["MeasureTheory/Measure/Tilted.lean",242,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 \u211d\nh0 : NeZero \u03bc\nx : \u03b1\n\u22a2 (rexp (f x) / \u222b (x : \u03b1), rexp (f x) \u2202\u03bc) * rexp (g x) = rexp (f x) * rexp (g x) / \u222b (x : \u03b1), rexp (f x) \u2202\u03bc",["ring"]],["NumberTheory/ZetaValues.lean",348,"\u22a2 1 * \u2191(Nat.choose 3 0) * (1 / 4) ^ (3 - 0) + -1 / 2 * \u2191(Nat.choose 3 1) * (1 / 4) ^ (3 - 1) +\n        1 / 6 * \u2191(Nat.choose 3 2) * (1 / 4) ^ (3 - 2) +\n      0 * \u2191(Nat.choose 3 3) * (1 / 4) ^ (3 - 3) =\n    3 / 64",["norm_num"]],["NumberTheory/ZetaValues.lean",57,"case pos\nk : \u2115\nh : k = 1\n\u22a2 1 / 2 = -1 / 2 + 1",["ring","linarith","norm_num"]],["NumberTheory/ZetaValues.lean",246,"case h.e'_6.h.e'_5.h.e'_5\nk : \u2115\nhk : k \u2260 0\nx : \u211d\nhx : x \u2208 Icc 0 1\n\u22a2 (-1) ^ k * -1 * (2 * \u2191\u03c0) ^ (2 * k) = -((2 * \u2191\u03c0) ^ (2 * k) * (-1) ^ k)",["ring"]],["NumberTheory/ZetaValues.lean",262,"case h.e'_3.h.e'_1\nk : \u2115\nhk : k \u2260 0\nx : \u211d\nhx : x \u2208 Icc 0 1\nthis :\n  HasSum (fun n \u21a6 1 / \u2191n ^ (2 * k) * ((fourier \u2191n) \u2191x + (fourier (-\u2191n)) \u2191x))\n    ((-1) ^ (k + 1) * (2 * \u2191\u03c0) ^ (2 * k) / \u2191(2 * k)! * \u2191(bernoulliFun (2 * k) x))\nofReal_two : \u21912 = 2\n\u22a2 (-1) ^ (k + 1) * (2 * \u2191\u03c0) ^ (2 * k) / \u2191(2 * k)! *\n        \u2191(Polynomial.eval x (Polynomial.map (algebraMap \u211a \u211d) (Polynomial.bernoulli (2 * k)))) /\n      2 =\n    (-1) ^ (k + 1) * (2 * \u2191\u03c0) ^ (2 * k) / 2 / \u2191(2 * k)! *\n      \u2191(Polynomial.eval x (Polynomial.map (algebraMap \u211a \u211d) (Polynomial.bernoulli (2 * k))))",["ring"]],["NumberTheory/ZetaValues.lean",286,"case h.e'_6.e_a.e_a\nk : \u2115\nhk : k \u2260 0\nx : \u211d\nhx : x \u2208 Icc 0 1\n\u22a2 (-1) ^ k * -1 * I * (2 * \u2191\u03c0) ^ (2 * k + 1) = -((2 * \u2191\u03c0) ^ (2 * k + 1) * ((-1) ^ k * I))",["ring"]],["NumberTheory/ZetaValues.lean",302,"k : \u2115\nhk : k \u2260 0\nx : \u211d\nhx : x \u2208 Icc 0 1\nthis :\n  HasSum (fun n \u21a6 1 / \u2191n ^ (2 * k + 1) * ((fourier \u2191n) \u2191x - (fourier (-\u2191n)) \u2191x))\n    ((-1) ^ (k + 1) * I * (2 * \u2191\u03c0) ^ (2 * k + 1) / \u2191(2 * k + 1)! * \u2191(bernoulliFun (2 * k + 1) x))\nofReal_two : \u21912 = 2\n\u03b1\u271d \u03b2\u271d \u03b3\u271d \u03b4\u271d : \u2102\n\u22a2 \u03b1\u271d * I * \u03b2\u271d / \u03b3\u271d * \u03b4\u271d * I = I ^ 2 * \u03b1\u271d * \u03b2\u271d / \u03b3\u271d * \u03b4\u271d",["ring"]],["NumberTheory/ZetaValues.lean",305,"case h.e'_3.h.e'_1\nk : \u2115\nhk : k \u2260 0\nx : \u211d\nhx : x \u2208 Icc 0 1\nthis\u271d :\n  HasSum (fun n \u21a6 1 / \u2191n ^ (2 * k + 1) * ((fourier \u2191n) \u2191x - (fourier (-\u2191n)) \u2191x))\n    ((-1) ^ (k + 1) * I * (2 * \u2191\u03c0) ^ (2 * k + 1) / \u2191(2 * k + 1)! * \u2191(bernoulliFun (2 * k + 1) x))\nofReal_two : \u21912 = 2\nthis : \u2200 (\u03b1 \u03b2 \u03b3 \u03b4 : \u2102), \u03b1 * I * \u03b2 / \u03b3 * \u03b4 * I = I ^ 2 * \u03b1 * \u03b2 / \u03b3 * \u03b4\n\u22a2 -(-1 * (-1) ^ (k + 1) * (2 * \u2191\u03c0) ^ (2 * k + 1) / \u2191(2 * k + 1)! *\n          \u2191(Polynomial.eval x (Polynomial.map (algebraMap \u211a \u211d) (Polynomial.bernoulli (2 * k + 1)))) /\n        2) =\n    (-1) ^ (k + 1) * (2 * \u2191\u03c0) ^ (2 * k + 1) / 2 / \u2191(2 * k + 1)! *\n      \u2191(Polynomial.eval x (Polynomial.map (algebraMap \u211a \u211d) (Polynomial.bernoulli (2 * k + 1))))",["ring"]],["NumberTheory/ZetaValues.lean",323,"case h.e'_6\nk : \u2115\nhk : k \u2260 0\nthis : 2 ^ (2 * k - 1) = 2 ^ (2 * k) / 2\n\u22a2 (-1) ^ (k + 1) * (2 ^ (2 * k) / 2) * \u03c0 ^ (2 * k) * \u2191(bernoulli (2 * k)) / \u2191(2 * k)! =\n    (-1) ^ (k + 1) * (2 ^ (2 * k) * \u03c0 ^ (2 * k)) / 2 / \u2191(2 * k)! * \u2191(bernoulli (2 * k))",["ring"]],["NumberTheory/ZetaValues.lean",332,"case h.e'_6\n\u22a2 \u03c0 ^ 2 * (6 * 2) = 2 * \u03c0 ^ 2 * 6",["ring","linarith"]],["NumberTheory/ZetaValues.lean",337,"case h.e'_6\n\u22a2 \u03c0 ^ 4 * (30 * 24) = 8 * \u03c0 ^ 4 * 90",["ring","linarith"]],["NumberTheory/ZetaValues.lean",360,"case h.h.e_x\nn : \u2115\n\u22a2 2 * \u03c0 * \u2191n * (1 / 4) = \u03c0 * \u2191n / 2",["ring","linarith"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",50,"case e_a\nz w : \u210d\n\u22a2 2 ^ 2 * (z.im * w.im) + (Complex.normSq \u2191z + Complex.normSq \u2191w - 2 * ((\u2191z).re * (\u2191w).re - z.im * -w.im)) =\n    Complex.normSq \u2191z + Complex.normSq \u2191w - 2 * ((\u2191z).re * (\u2191w).re - z.im * w.im)",["ring","linarith"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",120,"z w : \u210d\n\u22a2 2 * z.im * w.im + ((z.re - w.re) * (z.re - w.re) + (z.im - w.im) * (z.im - w.im)) =\n    (z.re - w.re) ^ 2 + z.im ^ 2 + w.im ^ 2",["ring","linarith"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",144,"z w : \u210d\nr : \u211d\nH : 2 * z.im * w.im \u2260 0\n\u22a2 (z.re - w.re) ^ 2 + (z.im ^ 2 - 2 * z.im * (w.im * Real.cosh r) + w.im ^ 2 * (Real.sinh r ^ 2 + 1)) =\n    (z.re - w.re) ^ 2 + z.im ^ 2 + w.im ^ 2 - 2 * z.im * w.im * Real.cosh r + w.im ^ 2 * Real.sinh r ^ 2",["ring","linarith"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",208,"case e_a\nz w : \u210d\nh : z.re = w.re\nh\u2080 : 0 < z.im / w.im\n\u22a2 z.im * (w.im * z.im * 2) - w.im * (z.im * z.im + w.im * w.im) = w.im * (z.im * z.im - w.im * w.im)",["ring","linarith"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",243,"z w : \u210d\n\u22a2 w.im * (1 - (Real.cosh (dist z w) - Real.sinh (dist z w))) =\n    w.im * Real.sinh (dist z w) - w.im * (Real.cosh (dist z w) - 1)",["ring","linarith"]],["Analysis/BoxIntegral/DivergenceTheorem.lean",100,"case h.e'_3.e_a\nE : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nn : \u2115\ninst\u271d : CompleteSpace E\nI : Box (Fin (n + 1))\ni : Fin (n + 1)\nf' : (Fin (n + 1) \u2192 \u211d) \u2192L[\u211d] E\nx : Fin (n + 1) \u2192 \u211d\nhxI : x \u2208 Box.Icc I\na : E\n\u03b5 : \u211d\nh0 : 0 < \u03b5\nc : \u211d\u22650\nhc : I.distortion \u2264 c\ne : \u211d \u2192 (Fin n \u2192 \u211d) \u2192 Fin (n + 1) \u2192 \u211d := i.insertNth\nHl : I.lower i \u2208 Set.Icc (I.lower i) (I.upper i)\nHu : I.upper i \u2208 Set.Icc (I.lower i) (I.upper i)\ny : Fin n \u2192 \u211d\nhy : y \u2208 Box.Icc (I.face i)\ng : (Fin (n + 1) \u2192 \u211d) \u2192 E\nh\u03b5 : \u2200 y \u2208 Box.Icc I, \u2016g y\u2016 \u2264 \u03b5 * \u2016y - x\u2016\nhfc : ContinuousOn (fun y \u21a6 a + f' (y - x) + g y) (Box.Icc I)\nHi :\n  \u2200 x_1 \u2208 Set.Icc (I.lower i) (I.upper i),\n    Integrable (I.face i) \u22a5 ((fun y \u21a6 a + f' (y - x) + g y) \u2218 e x_1) BoxAdditiveMap.volume\nhg : g = fun y \u21a6 (fun y \u21a6 a + f' (y - x) + g y) y - a - f' (y - x)\nthis : i.insertNth (I.upper i) y - i.insertNth (I.lower i) y = Pi.single i (I.upper i - I.lower i)\n\u22a2 f' (i.insertNth (I.upper i) y) - f' (i.insertNth (I.lower i) y) -\n      (a + (f' (e (I.upper i) y) - f' x) + g (e (I.upper i) y) -\n        (a + (f' (e (I.lower i) y) - f' x) + g (e (I.lower i) y))) =\n    g (e (I.lower i) y) - g (e (I.upper i) y)",["abel"]],["Analysis/Convex/Slope.lean",32,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : 0 < y - x\nhyz : 0 < z - y\nhxz : 0 < z - x\na : \ud835\udd5c := (z - y) / (z - x)\nb : \ud835\udd5c := (y - x) / (z - x)\n\u22a2 (z - y) * x + (y - x) * z = y * (z - x)",["ring"]],["Analysis/Convex/Slope.lean",66,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : 0 < y - x\nhyz : 0 < z - y\nhxz : 0 < z - x\nhxz' : x \u2260 z\na : \ud835\udd5c := (z - y) / (z - x)\nb : \ud835\udd5c := (y - x) / (z - x)\n\u22a2 (z - y) * x + (y - x) * z = y * (z - x)",["ring"]],["Analysis/Convex/Slope.lean",108,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhs : Convex \ud835\udd5c s\nhf : \u2200 {x y z : \ud835\udd5c}, x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) \u2264 (f z - f y) / (z - y)\nx : \ud835\udd5c\nhx : x \u2208 s\nz : \ud835\udd5c\nhz : z \u2208 s\nhxz\u271d : x < z\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : 1 - a = b\ny : \ud835\udd5c := a * x + b * z\nhxy : x < y\nhyz : y < z\nthis : (f y - f x) * (z - y) \u2264 (f z - f y) * (y - x)\nhxz : 0 < z - x\n\u22a2 z - (a * x + (1 - a) * z) = a * (z - x)",["ring","linarith"]],["Analysis/Convex/Slope.lean",113,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhs : Convex \ud835\udd5c s\nhf : \u2200 {x y z : \ud835\udd5c}, x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) \u2264 (f z - f y) / (z - y)\nx : \ud835\udd5c\nhx : x \u2208 s\nz : \ud835\udd5c\nhz : z \u2208 s\nhxz\u271d : x < z\na b : \ud835\udd5c\nha\u271d : 0 < a\nhb : 0 < b\nhab : 1 - b = a\ny : \ud835\udd5c := a * x + b * z\nhxy : x < y\nhyz : y < z\nthis : (f y - f x) * (z - y) \u2264 (f z - f y) * (y - x)\nhxz : 0 < z - x\nha : (z - y) / (z - x) = a\n\u22a2 (1 - b) * x + b * z - x = b * (z - x)",["ring"]],["Analysis/Convex/Slope.lean",153,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhs : Convex \ud835\udd5c s\nhf : \u2200 {x y z : \ud835\udd5c}, x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) < (f z - f y) / (z - y)\nx : \ud835\udd5c\nhx : x \u2208 s\nz : \ud835\udd5c\nhz : z \u2208 s\nhxz\u271d : x < z\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : 1 - a = b\ny : \ud835\udd5c := a * x + b * z\nhxy : x < y\nhyz : y < z\nthis : (f y - f x) * (z - y) < (f z - f y) * (y - x)\nhxz : 0 < z - x\n\u22a2 z - (a * x + (1 - a) * z) = a * (z - x)",["ring","linarith"]],["Analysis/Convex/Slope.lean",158,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhs : Convex \ud835\udd5c s\nhf : \u2200 {x y z : \ud835\udd5c}, x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) < (f z - f y) / (z - y)\nx : \ud835\udd5c\nhx : x \u2208 s\nz : \ud835\udd5c\nhz : z \u2208 s\nhxz\u271d : x < z\na b : \ud835\udd5c\nha\u271d : 0 < a\nhb : 0 < b\nhab : 1 - b = a\ny : \ud835\udd5c := a * x + b * z\nhxy : x < y\nhyz : y < z\nthis : (f y - f x) * (z - y) < (f z - f y) * (y - x)\nhxz : 0 < z - x\nha : (z - y) / (z - x) = a\n\u22a2 (1 - b) * x + b * z - x = b * (z - x)",["ring"]],["Analysis/Convex/Slope.lean",232,"case calc_1.e_a\n\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\nhyz' : 0 < z - y\nhxz' : 0 < z - x\nha : 0 \u2264 (z - y) / (z - x)\nhb : 0 \u2264 (y - x) / (z - x)\n\u22a2 y * (z - x) = (z - y) * x + (y - x) * z",["ring"]],["Analysis/Convex/Slope.lean",278,"case calc_1.e_a\n\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\nhyz' : 0 < z - y\nhxz' : 0 < z - x\nha : 0 < (z - y) / (z - x)\nhb : 0 < (y - x) / (z - x)\n\u22a2 y * (z - x) = (z - y) * x + (y - x) * z",["ring"]],["Combinatorics/SimpleGraph/Density.lean",206,"\ud835\udd5c : Type u_1\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : LinearOrderedField \ud835\udd5c\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\ninst\u271d : (a : \u03b1) \u2192 DecidablePred (r a)\ns\u2081 s\u2082 : Finset \u03b1\nt\u2081 t\u2082 : Finset \u03b2\n\u03b4 : \ud835\udd5c\nhs : s\u2082 \u2286 s\u2081\nht : t\u2082 \u2286 t\u2081\nh\u03b4\u2080 : 0 \u2264 \u03b4\nh\u03b4\u2081 : 0 < 1 - \u03b4\nhs\u2082 : (1 - \u03b4) * \u2191(#s\u2081) \u2264 \u2191(#s\u2082)\nht\u2082 : (1 - \u03b4) * \u2191(#t\u2081) \u2264 \u2191(#t\u2082)\nh\u03b4' : 0 \u2264 2 * \u03b4 - \u03b4 ^ 2\nhs\u2082' : s\u2082.Nonempty\nht\u2082' : t\u2082.Nonempty\n\u22a2 2 * \u03b4 - \u03b4 ^ 2 = 1 - (1 - \u03b4) * (1 - \u03b4)",["ring"]],["Algebra/Ring/BooleanRing.lean",89,"\u03b1 : Type u_1\ninst\u271d : BooleanRing \u03b1\na b : \u03b1\n\u22a2 a + a * b + (b * a + b) = a + b + (a * b + b * a)",["abel"]],["Algebra/Ring/BooleanRing.lean",169,"\u03b1 : Type u_1\ninst\u271d : BooleanRing \u03b1\na b : \u03b1\n\u22a2 a + b + a * b = b + a + b * a",["ring"]],["Algebra/Ring/BooleanRing.lean",173,"\u03b1 : Type u_1\ninst\u271d : BooleanRing \u03b1\na b : \u03b1\n\u22a2 a * b = b * a",["ring"]],["Algebra/Ring/BooleanRing.lean",177,"\u03b1 : Type u_1\ninst\u271d : BooleanRing \u03b1\na b c : \u03b1\n\u22a2 a + b + a * b + c + (a + b + a * b) * c = a + (b + c + b * c) + a * (b + c + b * c)",["ring"]],["Algebra/Ring/BooleanRing.lean",181,"\u03b1 : Type u_1\ninst\u271d : BooleanRing \u03b1\na b c : \u03b1\n\u22a2 a * b * c = a * (b * c)",["ring"]],["Algebra/Ring/BooleanRing.lean",195,"\u03b1 : Type u_1\ninst\u271d : BooleanRing \u03b1\na b c : \u03b1\n\u22a2 (a + b + a * b) * (a + c + a * c) =\n    a * a + b * c + a * (b * c) + (a * b + a * a * b) + (a * c + a * a * c) + (a * b * c + a * a * b * c)",["ring"]],["Algebra/Ring/BooleanRing.lean",268,"\u03b1 : Type u_1\ninst\u271d : BooleanRing \u03b1\na b : \u03b1\n\u22a2 (a + b + a * b) * (1 + a * b) = a + b + (a * b + a * b * (a * b)) + (a * (b * b) + a * a * b)",["ring"]],["Analysis/CStarAlgebra/Module/Constructions.lean",112,"A : Type u_1\ninst\u271d\u2079 : NonUnitalCStarAlgebra A\ninst\u271d\u2078 : PartialOrder A\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : Module \u2102 E\ninst\u271d\u2075 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : Module \u2102 F\ninst\u271d\u00b2 : SMul A\u1d50\u1d52\u1d56 F\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : CStarModule A F\nx : C\u22c6\u1d50\u1d52\u1d48 (E \u00d7 F)\n\u22a2 \u2016x.1\u2016 ^ 2 + 2 * \u2016x.1\u2016 * \u2016x.2\u2016 + \u2016x.2\u2016 ^ 2 = (\u2016x.1\u2016 + \u2016x.2\u2016) ^ 2",["ring","linarith"]],["Analysis/Complex/UpperHalfPlane/Basic.lean",227,"g : \u21a5GL(2, \u211d)\u207a\nz : \u210d\n\u22a2 (\u2191\u2191g 0 0 * z.im * (\u2191\u2191g 1 0 * z.re + \u2191\u2191g 1 1) - (\u2191\u2191g 0 0 * z.re + \u2191\u2191g 0 1) * (\u2191\u2191g 1 0 * z.im)) /\n      Complex.normSq (\u2191(\u2191\u2191g 1 0) * \u2191z + \u2191(\u2191\u2191g 1 1)) =\n    (\u2191\u2191g 0 0 * \u2191\u2191g 1 1 - \u2191\u2191g 0 1 * \u2191\u2191g 1 0) * z.im / Complex.normSq (\u2191(\u2191\u2191g 1 0) * \u2191z + \u2191(\u2191\u2191g 1 1))",["ring"]],["Analysis/Complex/UpperHalfPlane/Basic.lean",236,"case h.e'_4\ng : \u21a5GL(2, \u211d)\u207a\nz : \u210d\n\u22a2 (\u2191\u2191g).det * z.im / Complex.normSq (denom g z) = (\u2191\u2191g).det * (z.im / Complex.normSq (denom g z))",["ring"]],["Analysis/Complex/UpperHalfPlane/Basic.lean",245,"x y : \u21a5GL(2, \u211d)\u207a\nz : \u210d\n\u22a2 (\u2191(\u2191\u2191x 1 0) * \u2191(\u2191\u2191y 0 0) + \u2191(\u2191\u2191x 1 1) * \u2191(\u2191\u2191y 1 0)) * \u2191z + (\u2191(\u2191\u2191x 1 0) * \u2191(\u2191\u2191y 0 1) + \u2191(\u2191\u2191x 1 1) * \u2191(\u2191\u2191y 1 1)) =\n    \u2191(\u2191\u2191x 1 0) * (\u2191(\u2191\u2191y 0 0) * \u2191z + \u2191(\u2191\u2191y 0 1)) + \u2191(\u2191\u2191x 1 1) * (\u2191(\u2191\u2191y 1 0) * \u2191z + \u2191(\u2191\u2191y 1 1))",["ring"]],["Analysis/Complex/UpperHalfPlane/Basic.lean",255,"case h\nx y : \u21a5GL(2, \u211d)\u207a\nz : \u210d\n\u22a2 ((\u2191(\u2191\u2191x 0 0) * \u2191(\u2191\u2191y 0 0) + \u2191(\u2191\u2191x 0 1) * \u2191(\u2191\u2191y 1 0)) * \u2191z + (\u2191(\u2191\u2191x 0 0) * \u2191(\u2191\u2191y 0 1) + \u2191(\u2191\u2191x 0 1) * \u2191(\u2191\u2191y 1 1))) *\n      ((\u2191(\u2191\u2191y 1 0) * \u2191z + \u2191(\u2191\u2191y 1 1)) * (\u2191(\u2191\u2191x 1 0) * \u2191(smulAux y z) + \u2191(\u2191\u2191x 1 1))) =\n    (\u2191(\u2191\u2191x 0 0) * (\u2191(\u2191\u2191y 0 0) * \u2191z + \u2191(\u2191\u2191y 0 1)) + \u2191(\u2191\u2191x 0 1) * (\u2191(\u2191\u2191y 1 0) * \u2191z + \u2191(\u2191\u2191y 1 1))) *\n      ((\u2191(\u2191\u2191x 1 0) * \u2191(smulAux y z) + \u2191(\u2191\u2191x 1 1)) * (\u2191(\u2191\u2191y 1 0) * \u2191z + \u2191(\u2191\u2191y 1 1)))",["ring"]],["Analysis/Complex/UpperHalfPlane/Basic.lean",300,"g : \u21a5GL(2, \u211d)\u207a\nz : \u210d\nc : \u211d := \u2191\u2191g 1 0\nd : \u211d := \u2191\u2191g 1 1\n\u22a2 (\u2191\u2191g 1 0 * z.im) ^ 2 + (\u2191\u2191g 1 0 * z.re + \u2191\u2191g 1 1) ^ 2 =\n    (\u2191\u2191g 1 0 * z.re - 0 * z.im + \u2191\u2191g 1 1) * (\u2191\u2191g 1 0 * z.re - 0 * z.im + \u2191\u2191g 1 1) +\n      (\u2191\u2191g 1 0 * z.im + 0 * z.re + 0) * (\u2191\u2191g 1 0 * z.im + 0 * z.re + 0)",["ring","linarith"]],["Analysis/Complex/UpperHalfPlane/Basic.lean",380,"case intro.intro.intro.h.mk.h\na b : \u211d\nha : a \u2260 0\nhc : \u2191\u27e8!![a, b; 0, a\u207b\u00b9], \u22ef\u27e9 1 0 = 0\nz : \u2102\nhz : 0 < z.im\n\u22a2 \u2191a * z * \u2191a + \u2191b * \u2191a = \u2191b * \u2191a + \u2191a * \u2191a * z",["ring"]],["Order/Filter/CardinalInter.lean",171,"\u03b9 \u03b1 \u03b2 : Type u\nc : Cardinal.{u}\nl\u271d : Filter \u03b1\ninst\u271d : CardinalInterFilter l\u271d c\nl : Set (Set \u03b1)\nhc : 2 < c\nhl : \u2200 (S : Set (Set \u03b1)), #\u2191S < c \u2192 S \u2286 l \u2192 \u22c2\u2080 S \u2208 l\nh_mono : \u2200 (s t : Set \u03b1), s \u2208 l \u2192 s \u2286 t \u2192 t \u2208 l\ns t : Set \u03b1\nhs : s \u2208 l\nht : t \u2208 l\n\u22a2 #\u2191{t} + 1 = 2",["norm_num"]],["Analysis/Asymptotics/AsymptoticEquivalent.lean",242,"\u03b1 : Type u_1\nE : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na b : \u03b1 \u2192 \ud835\udd5c\nu v : \u03b1 \u2192 E\nl : Filter \u03b1\nhab : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u03b1) in l, \u2016(a - b) x\u2016 \u2264 c * \u2016b x\u2016\n\u03c6 : \u03b1 \u2192 \ud835\udd5c\nhab\u03c6 : a =\u1da0[l] \u03c6 * b\nthis : ((fun x \u21a6 a x \u2022 u x) - fun x \u21a6 b x \u2022 v x) =\u1da0[l] fun x \u21a6 b x \u2022 (\u03c6 x \u2022 u x - v x)\nC : \u211d\nhC : C > 0\nhCuv : \u2200\u1da0 (x : \u03b1) in l, \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nc : \u211d\nhc : 0 < c\nh\u03c6 : \u2200\u1da0 (x : \u03b1) in l, \u2016\u03c6 x - 1\u2016 < c / 2 / C\nhuv : \u2200\u1da0 (x : \u03b1) in l, \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nx : \u03b1\nhCuvx : \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nhuvx : \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nh\u03c6x : \u2016\u03c6 x - 1\u2016 < c / 2 / C\n\u22a2 c * (C * \u2016v x\u2016) * 2 = c * \u2016v x\u2016 * (2 * C)",["ring","linarith"]],["Analysis/Asymptotics/AsymptoticEquivalent.lean",250,"\u03b1 : Type u_1\nE : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na b : \u03b1 \u2192 \ud835\udd5c\nu v : \u03b1 \u2192 E\nl : Filter \u03b1\nhab : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u03b1) in l, \u2016(a - b) x\u2016 \u2264 c * \u2016b x\u2016\n\u03c6 : \u03b1 \u2192 \ud835\udd5c\nhab\u03c6 : a =\u1da0[l] \u03c6 * b\nthis : ((fun x \u21a6 a x \u2022 u x) - fun x \u21a6 b x \u2022 v x) =\u1da0[l] fun x \u21a6 b x \u2022 (\u03c6 x \u2022 u x - v x)\nC : \u211d\nhC : C > 0\nhCuv : \u2200\u1da0 (x : \u03b1) in l, \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nc : \u211d\nhc : 0 < c\nh\u03c6 : \u2200\u1da0 (x : \u03b1) in l, \u2016\u03c6 x - 1\u2016 < c / 2 / C\nhuv : \u2200\u1da0 (x : \u03b1) in l, \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nx : \u03b1\nhCuvx : \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nhuvx : \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nh\u03c6x : \u2016\u03c6 x - 1\u2016 < c / 2 / C\nkey : \u2016\u03c6 x - 1\u2016 * \u2016u x\u2016 \u2264 c / 2 * \u2016v x\u2016\n\u22a2 c / 2 * \u2016v x\u2016 + c / 2 * \u2016v x\u2016 = c * \u2016v x\u2016",["ring","linarith"]],["Algebra/Lie/Derivation/Basic.lean",312,"case H\nR : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nD1 D2 d e f : LieDerivation R L L\na : L\n\u22a2 d (f a) + e (f a) - (f (d a) + f (e a)) = d (f a) - f (d a) + (e (f a) - f (e a))",["abel"]],["Algebra/Lie/Derivation/Basic.lean",314,"case H\nR : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nD1 D2 d e f : LieDerivation R L L\na : L\n\u22a2 d (e a) + d (f a) - (e (d a) + f (d a)) = d (e a) - e (d a) + (d (f a) - f (d a))",["abel"]],["Algebra/Lie/Derivation/Basic.lean",316,"case H\nR : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nD1 D2 d : LieDerivation R L L\na : L\n\u22a2 d (d a) - d (d a) = 0",["abel"]],["Algebra/Lie/Derivation/Basic.lean",318,"case H\nR : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nD1 D2 d e f : LieDerivation R L L\na : L\n\u22a2 d (e (f a)) - d (f (e a)) - (e (f (d a)) - f (e (d a))) =\n    d (e (f a)) - e (d (f a)) - (f (d (e a)) - f (e (d a))) + (e (d (f a)) - e (f (d a)) - (d (f (e a)) - f (d (e a))))",["abel"]],["Analysis/SpecificLimits/FloorPow.lean",90,"u : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nhlim :\n  \u2200 (a : \u211d),\n    1 < a \u2192\n      \u2203 c,\n        (\u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 a * \u2191(c n)) \u2227\n          Tendsto c atTop atTop \u2227 Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nlnonneg : 0 \u2264 l\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nc : \u2115 \u2192 \u2115\ncgrowth : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 (1 + \u03b5) * \u2191(c n)\nctop : Tendsto c atTop atTop\nclim : Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nL : \u2200\u1da0 (n : \u2115) in atTop, u (c n) - \u2191(c n) * l \u2264 \u03b5 * \u2191(c n)\na : \u2115\nha : \u2200 (b : \u2115), a \u2264 b \u2192 \u2191(c (b + 1)) \u2264 (1 + \u03b5) * \u2191(c b) \u2227 u (c b) - \u2191(c b) * l \u2264 \u03b5 * \u2191(c b)\nM : \u2115 := (image (fun i \u21a6 c i) (range (a + 1))).max' \u22ef\nn : \u2115\nhn : n \u2208 Set.Ici M\nexN : \u2203 N, n < c N\nN : \u2115 := Nat.find exN\nncN : n < c N\naN : a + 1 \u2264 N\nNpos : 0 < N\ncNn : c (N - 1) \u2264 n\nIcN : \u2191(c N) \u2264 (1 + \u03b5) * \u2191(c (N - 1))\n\u22a2 u (c N) - \u2191(c (N - 1)) * l = u (c N) - \u2191(c N) * l + (\u2191(c N) - \u2191(c (N - 1))) * l",["ring","linarith"]],["Analysis/SpecificLimits/FloorPow.lean",96,"u : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nhlim :\n  \u2200 (a : \u211d),\n    1 < a \u2192\n      \u2203 c,\n        (\u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 a * \u2191(c n)) \u2227\n          Tendsto c atTop atTop \u2227 Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nlnonneg : 0 \u2264 l\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nc : \u2115 \u2192 \u2115\ncgrowth : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 (1 + \u03b5) * \u2191(c n)\nctop : Tendsto c atTop atTop\nclim : Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nL : \u2200\u1da0 (n : \u2115) in atTop, u (c n) - \u2191(c n) * l \u2264 \u03b5 * \u2191(c n)\na : \u2115\nha : \u2200 (b : \u2115), a \u2264 b \u2192 \u2191(c (b + 1)) \u2264 (1 + \u03b5) * \u2191(c b) \u2227 u (c b) - \u2191(c b) * l \u2264 \u03b5 * \u2191(c b)\nM : \u2115 := (image (fun i \u21a6 c i) (range (a + 1))).max' \u22ef\nn : \u2115\nhn : n \u2208 Set.Ici M\nexN : \u2203 N, n < c N\nN : \u2115 := Nat.find exN\nncN : n < c N\naN : a + 1 \u2264 N\nNpos : 0 < N\ncNn : c (N - 1) \u2264 n\nIcN : \u2191(c N) \u2264 (1 + \u03b5) * \u2191(c (N - 1))\n\u22a2 \u03b5 * ((1 + \u03b5) * \u2191(c (N - 1))) + \u03b5 * \u2191(c (N - 1)) * l = \u03b5 * (1 + \u03b5 + l) * \u2191(c (N - 1))",["ring","linarith"]],["Analysis/SpecificLimits/FloorPow.lean",147,"u : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nhlim :\n  \u2200 (a : \u211d),\n    1 < a \u2192\n      \u2203 c,\n        (\u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 a * \u2191(c n)) \u2227\n          Tendsto c atTop atTop \u2227 Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nlnonneg : 0 \u2264 l\nA : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2200\u1da0 (n : \u2115) in atTop, u n - \u2191n * l \u2264 \u03b5 * (1 + \u03b5 + l) * \u2191n\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nc : \u2115 \u2192 \u2115\ncgrowth : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 (1 + \u03b5) * \u2191(c n)\nctop : Tendsto c atTop atTop\nclim : Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nL : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c n) * l - u (c n) \u2264 \u03b5 * \u2191(c n)\na : \u2115\nha : \u2200 (b : \u2115), a \u2264 b \u2192 \u2191(c (b + 1)) \u2264 (1 + \u03b5) * \u2191(c b) \u2227 \u2191(c b) * l - u (c b) \u2264 \u03b5 * \u2191(c b)\nM : \u2115 := (image (fun i \u21a6 c i) (range (a + 1))).max' \u22ef\nn : \u2115\nhn : n \u2208 Set.Ici M\nexN : \u2203 N, n < c N\nN : \u2115 := Nat.find exN\nncN : n < c N\naN : a + 1 \u2264 N\nNpos : 0 < N\naN' : a \u2264 N - 1\ncNn : c (N - 1) \u2264 n\n\u22a2 (1 + \u03b5) * \u2191(c (N - 1)) * l - u (c (N - 1)) = \u2191(c (N - 1)) * l - u (c (N - 1)) + \u03b5 * \u2191(c (N - 1)) * l",["ring","linarith"]],["Analysis/SpecificLimits/FloorPow.lean",149,"u : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nhlim :\n  \u2200 (a : \u211d),\n    1 < a \u2192\n      \u2203 c,\n        (\u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 a * \u2191(c n)) \u2227\n          Tendsto c atTop atTop \u2227 Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nlnonneg : 0 \u2264 l\nA : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2200\u1da0 (n : \u2115) in atTop, u n - \u2191n * l \u2264 \u03b5 * (1 + \u03b5 + l) * \u2191n\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nc : \u2115 \u2192 \u2115\ncgrowth : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 (1 + \u03b5) * \u2191(c n)\nctop : Tendsto c atTop atTop\nclim : Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nL : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c n) * l - u (c n) \u2264 \u03b5 * \u2191(c n)\na : \u2115\nha : \u2200 (b : \u2115), a \u2264 b \u2192 \u2191(c (b + 1)) \u2264 (1 + \u03b5) * \u2191(c b) \u2227 \u2191(c b) * l - u (c b) \u2264 \u03b5 * \u2191(c b)\nM : \u2115 := (image (fun i \u21a6 c i) (range (a + 1))).max' \u22ef\nn : \u2115\nhn : n \u2208 Set.Ici M\nexN : \u2203 N, n < c N\nN : \u2115 := Nat.find exN\nncN : n < c N\naN : a + 1 \u2264 N\nNpos : 0 < N\naN' : a \u2264 N - 1\ncNn : c (N - 1) \u2264 n\n\u22a2 \u03b5 * \u2191(c (N - 1)) + \u03b5 * \u2191(c (N - 1)) * l = \u03b5 * (1 + l) * \u2191(c (N - 1))",["ring","linarith"]],["Analysis/SpecificLimits/FloorPow.lean",165,"u : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nhlim :\n  \u2200 (a : \u211d),\n    1 < a \u2192\n      \u2203 c,\n        (\u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 a * \u2191(c n)) \u2227\n          Tendsto c atTop atTop \u2227 Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nlnonneg : 0 \u2264 l\nA : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2200\u1da0 (n : \u2115) in atTop, u n - \u2191n * l \u2264 \u03b5 * (1 + \u03b5 + l) * \u2191n\nB : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2200\u1da0 (n : \u2115) in atTop, \u2191n * l - u n \u2264 \u03b5 * (1 + l) * \u2191n\nd : \u211d\nhd : d < l\n\u03b5 : \u211d\nh\u03b5 : d + \u03b5 * (1 + l) < l\n\u03b5pos : 0 < \u03b5\nn : \u2115\nhn : \u2191n * l - u n \u2264 \u03b5 * (1 + l) * \u2191n\nnpos : n \u2208 Set.Ioi 0\n\u22a2 (\u2191n)\u207b\u00b9 * \u2191n * (l - \u03b5 * (1 + l)) = (\u2191n)\u207b\u00b9 * (\u2191n * l - \u03b5 * (1 + l) * \u2191n)",["ring","linarith"]],["Analysis/SpecificLimits/FloorPow.lean",178,"u : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nhlim :\n  \u2200 (a : \u211d),\n    1 < a \u2192\n      \u2203 c,\n        (\u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 a * \u2191(c n)) \u2227\n          Tendsto c atTop atTop \u2227 Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nlnonneg : 0 \u2264 l\nA : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2200\u1da0 (n : \u2115) in atTop, u n - \u2191n * l \u2264 \u03b5 * (1 + \u03b5 + l) * \u2191n\nB : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2200\u1da0 (n : \u2115) in atTop, \u2191n * l - u n \u2264 \u03b5 * (1 + l) * \u2191n\nd : \u211d\nhd : d > l\n\u03b5 : \u211d\nh\u03b5 : l + \u03b5 * (1 + \u03b5 + l) < d\n\u03b5pos : 0 < \u03b5\nn : \u2115\nhn : u n - \u2191n * l \u2264 \u03b5 * (1 + \u03b5 + l) * \u2191n\nnpos : 0 < n\n\u22a2 \u2191n * l + \u03b5 * (1 + \u03b5 + l) * \u2191n = (l + \u03b5 * (1 + \u03b5 + l)) * \u2191n",["ring","linarith"]],["Analysis/SpecificLimits/FloorPow.lean",211,"case h.e'_3.h\nu : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nc : \u2115 \u2192 \u211d\ncone : \u2200 (k : \u2115), 1 < c k\nclim : Tendsto c atTop (\ud835\udcdd 1)\nhc : \u2200 (k : \u2115), Tendsto (fun n \u21a6 u \u230ac k ^ n\u230b\u208a / \u2191\u230ac k ^ n\u230b\u208a) atTop (\ud835\udcdd l)\na : \u211d\nha : 1 < a\nk : \u2115\nhk : c k < a\nH : \u2200 (n : \u2115), 0 < \u2191\u230ac k ^ n\u230b\u208a\nA : Tendsto (fun n \u21a6 \u2191\u230ac k ^ (n + 1)\u230b\u208a / c k ^ (n + 1) * c k / (\u2191\u230ac k ^ n\u230b\u208a / c k ^ n)) atTop (\ud835\udcdd (c k))\nn : \u2115\n\u22a2 \u2191\u230ac k ^ (n + 1)\u230b\u208a * (c k ^ (n + 1) * \u2191\u230ac k ^ n\u230b\u208a) = \u2191\u230ac k ^ (n + 1)\u230b\u208a * c k * c k ^ n * \u2191\u230ac k ^ n\u230b\u208a",["ring"]],["Analysis/SpecificLimits/FloorPow.lean",257,"case a\nN : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < c\u207b\u00b9 ^ 2\nB : c ^ 2 * (1 - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9\nC : c\u207b\u00b9 ^ 2 < 1\n\u22a2 Real.log j * (2 * Real.log c) = 2 * Real.log j * Real.log c",["ring","linarith"]],["Analysis/SpecificLimits/FloorPow.lean",261,"N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < c\u207b\u00b9 ^ 2\nB : c ^ 2 * (1 - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9\nC : c\u207b\u00b9 ^ 2 < 1\nI : (c\u207b\u00b9 ^ 2) ^ (Real.log j / Real.log c) = 1 / j ^ 2\nthis : c ^ 2 - 1 \u2260 0\n\u22a2 (c ^ 2 - 1) * j ^ 2 = j ^ 2 * (c ^ 2 - 1)",["ring","linarith"]],["Analysis/SpecificLimits/FloorPow.lean",269,"c : \u211d\nhc : 1 < c\ni : \u2115\ncpos : 0 < c\nhi : i \u2260 0\n\u22a2 (1 - c\u207b\u00b9) * c ^ i = c ^ i - c ^ i * c\u207b\u00b9",["ring","linarith"]],["Geometry/Euclidean/Angle/Unoriented/Basic.lean",241,"V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx y : V\nh : angle x y = \u03c0\n\u22a2 \u2016x\u2016 ^ 2 - 2 * -(\u2016x\u2016 * \u2016y\u2016) + \u2016y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2",["ring","linarith"]],["Geometry/Euclidean/Angle/Unoriented/Basic.lean",249,"V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx y : V\nh : angle x y = 0\n\u22a2 \u2016x\u2016 ^ 2 + 2 * (\u2016x\u2016 * \u2016y\u2016) + \u2016y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2",["ring","linarith"]],["Geometry/Euclidean/Angle/Unoriented/Basic.lean",257,"V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx y : V\nh : angle x y = 0\n\u22a2 \u2016x\u2016 ^ 2 - 2 * (\u2016x\u2016 * \u2016y\u2016) + \u2016y\u2016 ^ 2 = (\u2016x\u2016 - \u2016y\u2016) ^ 2",["ring","linarith"]],["Geometry/Euclidean/Angle/Unoriented/Basic.lean",269,"V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx y : V\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2016x\u2016 ^ 2 - 2 * inner x y + \u2016y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2\nhxy\u2081 : 0 \u2264 \u2016x - y\u2016\nhxy\u2082 : 0 \u2264 \u2016x\u2016 + \u2016y\u2016\n\u22a2 (\u2016x\u2016 ^ 2 + \u2016y\u2016 ^ 2 - (\u2016x\u2016 + \u2016y\u2016) ^ 2) / 2 = -(\u2016x\u2016 * \u2016y\u2016)",["ring","linarith"]],["Geometry/Euclidean/Angle/Unoriented/Basic.lean",281,"V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx y : V\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2016x\u2016 ^ 2 + 2 * inner x y + \u2016y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2\nhxy\u2081 : 0 \u2264 \u2016x + y\u2016\nhxy\u2082 : 0 \u2264 \u2016x\u2016 + \u2016y\u2016\n\u22a2 ((\u2016x\u2016 + \u2016y\u2016) ^ 2 - \u2016x\u2016 ^ 2 - \u2016y\u2016 ^ 2) / 2 = \u2016x\u2016 * \u2016y\u2016",["ring","linarith"]],["Geometry/Euclidean/Angle/Unoriented/Basic.lean",295,"V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx y : V\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016|\nh1 : \u2016x\u2016 ^ 2 - 2 * inner x y + \u2016y\u2016 ^ 2 = (\u2016x\u2016 - \u2016y\u2016) ^ 2\n\u22a2 ((\u2016x\u2016 + \u2016y\u2016) ^ 2 - \u2016x\u2016 ^ 2 - \u2016y\u2016 ^ 2) / 2 = \u2016x\u2016 * \u2016y\u2016",["ring","linarith"]],["Analysis/MeanInequalitiesPow.lean",122,"case h.e'_4\nz\u2081 z\u2082 : \u211d\u22650\np : \u211d\nhp : 1 \u2264 p\nh'p : 1 < p\nA : p - 1 \u2260 0\n\u22a2 2\u207b\u00b9 * 2 ^ p * (z\u2081 ^ p + z\u2082 ^ p) = 2\u207b\u00b9 * (2 ^ p * z\u2081 ^ p) + 2\u207b\u00b9 * (2 ^ p * z\u2082 ^ p)",["ring"]],["Analysis/MeanInequalitiesPow.lean",281,"case h.e'_4\nz\u2081 z\u2082 : \u211d\u22650\u221e\np : \u211d\nhp : 1 \u2264 p\n\u22a2 2\u207b\u00b9 * 2 ^ p * (z\u2081 ^ p + z\u2082 ^ p) = 2\u207b\u00b9 * (2 ^ p * z\u2081 ^ p) + 2\u207b\u00b9 * (2 ^ p * z\u2082 ^ p)",["ring"]],["LinearAlgebra/QuadraticForm/Prod.lean",210,"R : Type u_2\nM\u2081 : Type u_3\nM\u2082 : Type u_4\nP : Type u_7\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : AddCommGroup M\u2081\ninst\u271d\u2074 : AddCommGroup M\u2082\ninst\u271d\u00b3 : AddCommGroup P\ninst\u271d\u00b2 : Module R M\u2081\ninst\u271d\u00b9 : Module R M\u2082\ninst\u271d : Module R P\nQ\u2081 : QuadraticMap R M\u2081 P\nQ\u2082 : QuadraticMap R M\u2082 P\nx y : M\u2081 \u00d7 M\u2082\n\u22a2 Q\u2081 (x.1 + y.1) + Q\u2082 (x.2 + y.2) - (Q\u2081 x.1 + Q\u2082 x.2) - (Q\u2081 y.1 + Q\u2082 y.2) =\n    Q\u2081 (x.1 + y.1) - Q\u2081 x.1 - Q\u2081 y.1 + (Q\u2082 (x.2 + y.2) - Q\u2082 x.2 - Q\u2082 y.2)",["abel"]],["Analysis/NormedSpace/OperatorNorm/NormedSpace.lean",58,"\ud835\udd5c : Type u_1\nE : Type u_4\nF\u2097 : Type u_6\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedAddCommGroup F\u2097\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \ud835\udd5c F\u2097\nr : \u211d\nr_pos : 0 < r\nc : \u211d\nf : E \u2192\u2097[\ud835\udd5c] F\u2097\nh : \u2200 z \u2208 ball 0 r, \u2016f z\u2016 \u2264 c\nk : \ud835\udd5c\nhk : 1 < \u2016k\u2016\nz x : E\nhko : r / \u2016k\u2016 \u2264 \u2016x\u2016\nhxo : \u2016x\u2016 < r\n\u22a2 c * (\u2016x\u2016 * \u2016k\u2016 / r) = c * (\u2016k\u2016 / r) * \u2016x\u2016",["ring"]],["Analysis/Fourier/RiemannLebesgueLemma.lean",73,"E : Type u_1\nV : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u2102 E\nf : V \u2192 E\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : MeasurableSpace V\ninst\u271d\u00b2 : BorelSpace V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nw : V\nhw : w \u2260 0\nhiw : inner (i w) w = 1 / 2\nv : V\n\u22a2 2 * \u03c0 = \u03c0 * 2",["ring","linarith"]],["Analysis/Asymptotics/TVS.lean",289,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_3\nE : Type u_4\nF : Type u_5\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : SeminormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nl : Filter \u03b1\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\u208a\nhc\u2080 : 0 < \u2016c\u2016\u208a\nh :\n  \u2200 (i : \u211d),\n    0 < i \u2192 \u2203 j, 0 < j \u2227 \u2200 (\u03b5 : \u211d\u22650), \u03b5 \u2260 0 \u2192 \u2200\u1da0 (x : \u03b1) in l, egauge \ud835\udd5c (ball 0 i) (f x) \u2264 \u2191\u03b5 * egauge \ud835\udd5c (ball 0 j) (g x)\n\u03b5 \u03b4 : \u211d\u22650\nh\u03b4 : \u2200 (\u03b5_1 : \u211d\u22650), \u03b5_1 \u2260 0 \u2192 \u2200\u1da0 (x : \u03b1) in l, egauge \ud835\udd5c (ball 0 \u2191\u03b5) (f x) \u2264 \u2191\u03b5_1 * egauge \ud835\udd5c (ball 0 \u2191\u03b4) (g x)\nh\u03b5 : 0 < \u03b5\nh\u03b4\u2080 : 0 < \u03b4\nx : \u03b1\nhx : egauge \ud835\udd5c (ball 0 \u2191\u03b5) (f x) \u2264 \u2191(\u03b4 / \u2016c\u2016\u208a) * egauge \ud835\udd5c (ball 0 \u2191\u03b4) (g x)\n\u22a2 \u2191\u03b4 * (\u2191\u2016c\u2016\u208a)\u207b\u00b9 * (\u2191\u2016c\u2016\u208a * \u2191\u2016g x\u2016\u208a * (\u2191\u03b4)\u207b\u00b9) = \u2191\u03b4 * (\u2191\u03b4)\u207b\u00b9 * (\u2191\u2016c\u2016\u208a * (\u2191\u2016c\u2016\u208a)\u207b\u00b9) * \u2191\u2016g x\u2016\u208a",["ring"]],["Analysis/Asymptotics/TVS.lean",299,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_3\nE : Type u_4\nF : Type u_5\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : SeminormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nl : Filter \u03b1\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\u208a\nhc\u2080 : 0 < \u2016c\u2016\u208a\nh : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u03b1) in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016\n\u03b4 : \u211d\u22650\nh\u03b4 : \u03b4 \u2260 0\nx : \u03b1\n\u03b5 : \u211d\u22650\nh\u03b5 : 0 < \u2191\u03b5\nhx : \u2191\u2016f x\u2016\u208a \u2264 \u2191\u03b5 * \u2191\u03b4 / \u2191\u2016c\u2016\u208a * \u2191\u2016g x\u2016\u208a\n\u22a2 \u2191\u2016c\u2016\u208a * (\u2191\u03b5 * \u2191\u03b4 * (\u2191\u2016c\u2016\u208a)\u207b\u00b9 * \u2191\u2016g x\u2016\u208a) * (\u2191\u03b5)\u207b\u00b9 = \u2191\u2016c\u2016\u208a * (\u2191\u2016c\u2016\u208a)\u207b\u00b9 * (\u2191\u03b5 * (\u2191\u03b5)\u207b\u00b9) * \u2191\u03b4 * \u2191\u2016g x\u2016\u208a",["ring"]],["Analysis/CStarAlgebra/Module/Defs.lean",202,"A : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NonUnitalCStarAlgebra A\ninst\u271d\u2076 : PartialOrder A\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u2102 E\ninst\u271d\u00b3 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : StarOrderedRing A\nx y : E\nh : x \u2260 0\na : A\n\u22a2 star a * \u27eax, x\u27eb_A * a - \u2016x\u2016 ^ 2 \u2022> (\u27eay, x\u27eb_A * a) - (\u2016x\u2016 ^ 2 \u2022> (star a * \u27eax, y\u27eb_A) - \u2016x\u2016 ^ 2 \u2022> \u2016x\u2016 ^ 2 \u2022> \u27eay, y\u27eb_A) =\n    star a * \u27eax, x\u27eb_A * a - \u2016x\u2016 ^ 2 \u2022> (\u27eay, x\u27eb_A * a) - \u2016x\u2016 ^ 2 \u2022> (star a * \u27eax, y\u27eb_A) + \u2016x\u2016 ^ 2 \u2022> \u2016x\u2016 ^ 2 \u2022> \u27eay, y\u27eb_A",["abel"]],["Analysis/CStarAlgebra/Module/Defs.lean",244,"A : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NonUnitalCStarAlgebra A\ninst\u271d\u2076 : PartialOrder A\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u2102 E\ninst\u271d\u00b3 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : StarOrderedRing A\nx y : E\n\u22a2 \u2016x\u2016 ^ 2 + \u2016y\u2016 * \u2016x\u2016 + \u2016x\u2016 * \u2016y\u2016 = \u2016x\u2016 ^ 2 + 2 * \u2016x\u2016 * \u2016y\u2016",["ring","linarith"]],["NumberTheory/Transcendental/Liouville/LiouvilleWith.lean",219,"case h.e'_3.h.e'_4\np x C : \u211d\nhC : \u2203\u1da0 (n : \u2115) in atTop, \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p\nn : \u2115\nm : \u2124\nhne : x \u2260 \u2191m / \u2191n\nhlt : |x - \u2191m / \u2191n| < C / \u2191n ^ p\n\u22a2 -\u2191m / \u2191n - -x = x - \u2191m / \u2191n",["ring"]],["Analysis/SpecialFunctions/PolarCoord.lean",59,"case mk.intro.fst.e_x\nr \u03b8 : \u211d\nhr : r \u2208 Ioi 0\nh\u03b8 : \u03b8 \u2208 Ioo (-\u03c0) \u03c0\n\u22a2 (r * cos \u03b8) ^ 2 + (r * sin \u03b8) ^ 2 = (sin \u03b8 ^ 2 + cos \u03b8 ^ 2) * r ^ 2",["ring","linarith"]],["Analysis/SpecialFunctions/PolarCoord.lean",63,"case h.e'_2.h.e'_1\nr \u03b8 : \u211d\nhr : r \u2208 Ioi 0\nh\u03b8 : \u03b8 \u2208 Ioo (-\u03c0) \u03c0\n\u22a2 \u2191r * Complex.cos \u2191\u03b8 + \u2191r * Complex.sin \u2191\u03b8 * Complex.I = \u2191r * (Complex.cos \u2191\u03b8 + Complex.sin \u2191\u03b8 * Complex.I)",["ring"]],["Analysis/SpecialFunctions/PolarCoord.lean",112,"p : \u211d \u00d7 \u211d\n\u22a2 cos p.2 * (p.1 * cos p.2) + p.1 * sin p.2 * sin p.2 = (cos p.2 ^ 2 + sin p.2 ^ 2) * p.1",["ring","linarith"]],["Analysis/SpecialFunctions/Log/Deriv.lean",315,"case h.e'_6.e_x\na : \u211d\nh : 0 < a\nh\u2081 : |1 / (2 * a + 1)| < 1\nh\u2082 : 2 * a + 1 \u2260 0\nh\u2083 : a \u2260 0\n\u22a2 (a + 1) * (2 * a) = (2 * a + 1 + 1) * a",["linarith","ring"]],["Analysis/SpecialFunctions/Log/Deriv.lean",231,"x : \u211d\nh : |x| < 1\nn : \u2115\nF : \u211d \u2192 \u211d := fun x \u21a6 \u2211 i \u2208 Finset.range n, x ^ (i + 1) / (\u2191i + 1) + log (1 - x)\nF' : \u211d \u2192 \u211d := fun x \u21a6 -x ^ n / (1 - x)\ny : \u211d\nhy : y \u2208 Set.Ioo (-1) 1\nthis : HasDerivAt F (\u2211 i \u2208 Finset.range n, \u2191(i + 1) * y ^ i / (\u2191i + 1) + -1 / (1 - y)) y\n\u22a2 -(y ^ n * ((y - 1) * (1 - y))) = ((y ^ n - 1) * (1 - y) + (1 - y)) * (1 - y)",["ring","linarith"]],["Algebra/Lie/OfAssociative.lean",45,"A : Type v\ninst\u271d : Ring A\nx\u271d\u00b2 x\u271d\u00b9 x\u271d : A\n\u22a2 x\u271d\u00b2 * x\u271d + x\u271d\u00b9 * x\u271d - (x\u271d * x\u271d\u00b2 + x\u271d * x\u271d\u00b9) = x\u271d\u00b2 * x\u271d - x\u271d * x\u271d\u00b2 + (x\u271d\u00b9 * x\u271d - x\u271d * x\u271d\u00b9)",["abel"]],["Algebra/Lie/OfAssociative.lean",46,"A : Type v\ninst\u271d : Ring A\nx\u271d\u00b2 x\u271d\u00b9 x\u271d : A\n\u22a2 x\u271d\u00b2 * x\u271d\u00b9 + x\u271d\u00b2 * x\u271d - (x\u271d\u00b9 * x\u271d\u00b2 + x\u271d * x\u271d\u00b2) = x\u271d\u00b2 * x\u271d\u00b9 - x\u271d\u00b9 * x\u271d\u00b2 + (x\u271d\u00b2 * x\u271d - x\u271d * x\u271d\u00b2)",["abel"]],["Algebra/Lie/OfAssociative.lean",49,"A : Type v\ninst\u271d : Ring A\nx\u271d\u00b2 x\u271d\u00b9 x\u271d : A\n\u22a2 x\u271d\u00b2 * (x\u271d\u00b9 * x\u271d) - x\u271d\u00b2 * (x\u271d * x\u271d\u00b9) - (x\u271d\u00b9 * (x\u271d * x\u271d\u00b2) - x\u271d * (x\u271d\u00b9 * x\u271d\u00b2)) =\n    x\u271d\u00b2 * (x\u271d\u00b9 * x\u271d) - x\u271d\u00b9 * (x\u271d\u00b2 * x\u271d) - (x\u271d * (x\u271d\u00b2 * x\u271d\u00b9) - x\u271d * (x\u271d\u00b9 * x\u271d\u00b2)) +\n      (x\u271d\u00b9 * (x\u271d\u00b2 * x\u271d) - x\u271d\u00b9 * (x\u271d * x\u271d\u00b2) - (x\u271d\u00b2 * (x\u271d * x\u271d\u00b9) - x\u271d * (x\u271d\u00b2 * x\u271d\u00b9)))",["abel"]],["Data/Real/Pi/Irrational.lean",249,"n : \u2115\n\u22a2 1 * |1 - -1| \u2264 2",["norm_num"]],["Data/Real/Pi/Irrational.lean",85,"case h.e'_9\n\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\nhu\u2081d : Continuous u\u2081'\nhv\u2081d : Continuous v\u2081'\nhu\u2082d : Continuous u\u2082'\nhv\u2082d : Continuous v\u2082'\nhu\u2081_eval_one : u\u2081 1 = 0\nhu\u2081_eval_neg_one : u\u2081 (-1) = 0\nt : u\u2082 1 * v\u2082 1 - u\u2082 (-1) * v\u2082 (-1) = 2 * (0 ^ n * cos \u03b8)\nhf : \u2200 (x : \u211d), HasDerivAt f (-2 * x) x\nx : \u211d\n\u22a2 -(2 * (\u2191n + 1) * x * f x ^ n) = (\u2191n + 1) * f x ^ (n + 0) * (-2 * x)",["ring"]],["Data/Real/Pi/Irrational.lean",90,"case h.e'_9\n\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\nhu\u2081d : Continuous u\u2081'\nhv\u2081d : Continuous v\u2081'\nhu\u2082d : Continuous u\u2082'\nhv\u2082d : Continuous v\u2082'\nhu\u2081_eval_one : u\u2081 1 = 0\nhu\u2081_eval_neg_one : u\u2081 (-1) = 0\nt : u\u2082 1 * v\u2082 1 - u\u2082 (-1) * v\u2082 (-1) = 2 * (0 ^ n * cos \u03b8)\nhf : \u2200 (x : \u211d), HasDerivAt f (-2 * x) x\nhu\u2081 : \u2200 (x : \u211d), HasDerivAt u\u2081 (u\u2081' x) x\nhv\u2081 : \u2200 (x : \u211d), HasDerivAt v\u2081 (v\u2081' x) x\nx : \u211d\n\u22a2 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1) = 1 * f x ^ n + x * (\u2191n * f x ^ (n - 1) * (-2 * x))",["ring","linarith"]],["Data/Real/Pi/Irrational.lean",101,"case h.e'_2.e_f.h\n\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\nhu\u2081d : Continuous u\u2081'\nhv\u2081d : Continuous v\u2081'\nhu\u2082d : Continuous u\u2082'\nhv\u2082d : Continuous v\u2082'\nhu\u2081_eval_one : u\u2081 1 = 0\nhu\u2081_eval_neg_one : u\u2081 (-1) = 0\nt : u\u2082 1 * v\u2082 1 - u\u2082 (-1) * v\u2082 (-1) = 2 * (0 ^ n * cos \u03b8)\nhf : \u2200 (x : \u211d), HasDerivAt f (-2 * x) x\nhu\u2081 : \u2200 (x : \u211d), HasDerivAt u\u2081 (u\u2081' x) x\nhv\u2081 : \u2200 (x : \u211d), HasDerivAt v\u2081 (v\u2081' x) x\nhu\u2082 : \u2200 (x : \u211d), HasDerivAt u\u2082 (u\u2082' x) x\nhv\u2082 : \u2200 (x : \u211d), HasDerivAt v\u2082 (v\u2082' x) x\nx : \u211d\n\u22a2 -(-(2 * (\u2191n + 1) * x * f x ^ n) * sin (x * \u03b8)) * \u03b8 = -2 * (\u2191n + 1) * (x * f x ^ n * (-sin (x * \u03b8) * \u03b8))",["ring","linarith"]],["Data/Real/Pi/Irrational.lean",134,"\u03b8 : \u211d\n\u22a2 -(2 * 2 * ((\u21910 + 1) * (0 ^ 0 * cos \u03b8))) * \u03b8 + 2 * (\u21910 + 1) * (2 * \u21910 + 1) * (2 * sin \u03b8) -\n      4 * (\u21910 + 1) * \u21910 * I (0 - 1) \u03b8 * \u03b8 =\n    4 * sin \u03b8 - 4 * \u03b8 * cos \u03b8",["ring"]],["Data/Real/Pi/Irrational.lean",199,"\u03b8 : \u211d\nn : \u2115\n\u22a2 I (n + 2) \u03b8 * \u03b8 ^ (2 * (n + 2) + 1) = I (n + 2) \u03b8 * \u03b8 ^ 2 * \u03b8 ^ (2 * n + 3)",["ring"]],["Data/Real/Pi/Irrational.lean",201,"\u03b8 : \u211d\nn : \u2115\n\u22a2 (2 * (\u2191n + 2) * (2 * \u2191n + 3) * I (n + 1) \u03b8 - 4 * (\u2191n + 2) * (\u2191n + 1) * I n \u03b8) * \u03b8 ^ (2 * n + 3) =\n    2 * (\u2191n + 2) * (2 * \u2191n + 3) * (I (n + 1) \u03b8 * \u03b8 ^ (2 * (n + 1) + 1)) -\n      4 * (\u2191n + 2) * (\u2191n + 1) * \u03b8 ^ 2 * (I n \u03b8 * \u03b8 ^ (2 * n + 1))",["ring"]],["Data/Real/Pi/Irrational.lean",202,"\u03b8 : \u211d\nn : \u2115\n\u22a2 2 * (\u2191n + 2) * (2 * \u2191n + 3) *\n        ((\u2191n + 1) * \u2191n ! *\n          (eval\u2082 (Int.castRingHom \u211d) \u03b8 (sinPoly (n + 1)) * sin \u03b8 +\n            eval\u2082 (Int.castRingHom \u211d) \u03b8 (cosPoly (n + 1)) * cos \u03b8)) -\n      4 * (\u2191n + 2) * (\u2191n + 1) * \u03b8 ^ 2 *\n        (\u2191n ! * (eval\u2082 (Int.castRingHom \u211d) \u03b8 (sinPoly n) * sin \u03b8 + eval\u2082 (Int.castRingHom \u211d) \u03b8 (cosPoly n) * cos \u03b8)) =\n    (\u2191n + 1 + 1) * ((\u2191n + 1) * \u2191n !) *\n      ((2 * (2 * \u2191n + 3) * eval\u2082 (Int.castRingHom \u211d) \u03b8 (sinPoly (n + 1)) +\n            -(4 * \u03b8 ^ 2 * eval\u2082 (Int.castRingHom \u211d) \u03b8 (sinPoly n))) *\n          sin \u03b8 +\n        (2 * (2 * \u2191n + 3) * eval\u2082 (Int.castRingHom \u211d) \u03b8 (cosPoly (n + 1)) +\n            -(4 * \u03b8 ^ 2 * eval\u2082 (Int.castRingHom \u211d) \u03b8 (cosPoly n))) *\n          cos \u03b8)",["ring","linarith"]],["Analysis/NormedSpace/MStructure.lean",113,"X : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup X\nM : Type u_2\ninst\u271d\u00b2 : Ring M\ninst\u271d\u00b9 : Module M X\ninst\u271d : FaithfulSMul M X\nP Q : M\nh\u2081 : IsLprojection X P\nh\u2082 : IsLprojection X Q\nR : M\nh\u2083 : IsLprojection X R\nx : X\n\u22a2 \u2016R \u2022 P \u2022 R \u2022 x\u2016 + \u2016(1 - R) \u2022 P \u2022 R \u2022 x\u2016 + (\u2016R \u2022 x - R \u2022 P \u2022 R \u2022 x\u2016 + \u2016(1 - R) \u2022 P \u2022 R \u2022 x\u2016) =\n    \u2016R \u2022 P \u2022 R \u2022 x\u2016 + \u2016R \u2022 x - R \u2022 P \u2022 R \u2022 x\u2016 + 2 \u2022 \u2016(1 - R) \u2022 P \u2022 R \u2022 x\u2016",["abel","ring"]],["Analysis/Calculus/Monotone.lean",53,"case h\nf : \u211d \u2192 \u211d\nx a c d : \u211d\nl : Filter \u211d\nhl : l \u2264 \ud835\udcdd[\u2260] x\nhf : Tendsto (fun y \u21a6 (f y - d) / (y - x)) l (\ud835\udcdd a)\nh' : Tendsto (fun y \u21a6 y + c * (y - x) ^ 2) l l\nthis : Tendsto (fun y \u21a6 1 + c * (y - x)) l (\ud835\udcdd 1)\ny : \u211d\nhy : y \u2208 {x}\u1d9c\n\u22a2 (1 + c * (y - x)) * (y - x) = y + c * (y - x) ^ 2 - x",["ring","linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",213,"X : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u2191x \u2264 1 / 2\nh\u2082 : \u00ac2 * \u2191x \u2264 1 / 2\nh\u271d\u00b2 : \u00ac\u2191x \u2264 1 / 4\nh\u271d\u00b9 : \u00ac\u2191x + 1 / 4 \u2264 1 / 2\nh\u271d : 2 * (\u2191x + 1 / 4) - 1 \u2264 1 / 2\n\u22a2 2 * (2 * \u2191x) - 1 = 2 * (2 * (\u2191x + 1 / 4) - 1)",["linarith","ring"]],["Data/Nat/Choose/Multinomial.lean",116,"\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2260 b\n\u22a2 (f a + (f b).succ).choose (f a) + (f a + (f b).succ).choose (f a).succ =\n    (f a + (f b).succ).choose (f a).succ + (f a + (f b).succ).choose (f a)",["ring","omega","linarith"]],["Data/Nat/Choose/Multinomial.lean",317,"\u03b9 : Type u_1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u2115\n\u22a2 ((\u220f i \u2208 s, 2 ^ f i) * (\u2211 i \u2208 s, f i) ^ \u2211 i \u2208 s, f i) * (\u2211 i \u2208 s, f i)! * \u220f i \u2208 s, (f i)! =\n    ((\u2211 i \u2208 s, f i) ^ \u2211 i \u2208 s, f i) * (\u2211 i \u2208 s, f i)! * ((\u220f x \u2208 s, 2 ^ f x) * \u220f x \u2208 s, (f x)!)",["ring"]],["Algebra/Order/Antidiag/Nat.lean",263,"case h\nn : \u2115\nhn : Squarefree n\na : Fin 3 \u2192 \u2115\nha : a \u2208 finMulAntidiag 3 n\n\u22a2 a 0 * a 1 * a 2 = (a 0 * a 1, a 0 * a 2).2 * a 1",["ring","linarith"]],["Algebra/Order/Antidiag/Nat.lean",268,"case h\nn : \u2115\nhn : Squarefree n\na : Fin 3 \u2192 \u2115\nha : a \u2208 finMulAntidiag 3 n\n\u22a2 a 0 * a 1 * a 2 = a 1 * a 2 * a 0",["ring"]],["Computability/Ackermann.lean",328,"f\u271d f g : \u2115 \u2192 \u2115\nhf : Nat.Primrec f\nhg : Nat.Primrec g\na : \u2115\nha : \u2200 (n : \u2115), f n < ack a n\nb : \u2115\nhb : \u2200 (n : \u2115), g n < ack b n\nm n : \u2115\nIH : rec (f m) (fun y IH \u21a6 g (pair m (pair y IH))) n < ack (a \u2294 b + 9) (m + n)\nh\u2081 : m \u2264 pair n (rec (f m) (fun y IH \u21a6 g (pair m (pair y IH))) n)\nh\u2082 : rec (f m) (fun y IH \u21a6 g (pair m (pair y IH))) n < n\n\u22a2 4 + 4 \u2264 9",["norm_num"]],["Combinatorics/Additive/PluenneckeRuzsa.lean",227,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : CommGroup G\nA B : Finset G\nhAB : \u2200 A' \u2286 A, #(A * B) * #A' \u2264 #(A' * B) * #A\nhA : A.Nonempty\nn : \u2115\nih : \u2191(#(A * B ^ n)) \u2264 (\u2191(#(A * B)) / \u2191(#A)) ^ n * \u2191(#A)\n\u22a2 \u2191(#(A * B)) * (\u2191(#(A * B)) ^ n * \u2191(#A)) * \u2191(#A) ^ (n + 1) = \u2191(#(A * B)) ^ (n + 1) * \u2191(#A) * \u2191(#A) * \u2191(#A) ^ n",["ring"]],["Combinatorics/Additive/PluenneckeRuzsa.lean",247,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : CommGroup G\nA : Finset G\nhA : A.Nonempty\nB : Finset G\nm n : \u2115\nhA' : A \u2208 A.powerset.erase \u2205\nC : Finset G\nhCmin : \u2200 x' \u2208 A.powerset.erase \u2205, \u2191(#(C * B)) / \u2191(#C) \u2264 \u2191(#(x' * B)) / \u2191(#x')\nhC : C.Nonempty\nhCA : C \u2286 A\n\u22a2 (\u2191(#(C * B)) / \u2191(#C)) ^ m * \u2191(#C) * ((\u2191(#(C * B)) / \u2191(#C)) ^ n * \u2191(#C)) =\n    (\u2191(#(C * B)) / \u2191(#C)) ^ (m + n) * \u2191(#C) * \u2191(#C)",["ring"]],["Analysis/Complex/AbelLimit.lean",78,"case e_x\ns x y : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x < 1 / (1 + s ^ 2)\nhy : |y| < s * x\n\u22a2 (1 - x) ^ 2 + (s * x) ^ 2 = 1 - 2 * x + (1 + s ^ 2) * x * x",["ring","linarith"]],["Analysis/Complex/AbelLimit.lean",80,"case e_x\ns x y : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x < 1 / (1 + s ^ 2)\nhy : |y| < s * x\n\u22a2 1 - 2 * x + x = 1 - x",["ring","linarith"]],["Analysis/Complex/AbelLimit.lean",88,"case e_x\ns x y : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x < 1 / (1 + s ^ 2)\nhy : |y| < s * x\nH : \u221a((1 - x) ^ 2 + y ^ 2) \u2264 1 - x / 2\n\u22a2 x ^ 2 + (s * x) ^ 2 = (1 + s ^ 2) * x ^ 2",["ring","linarith"]],["Analysis/Complex/AbelLimit.lean",90,"s x y : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x < 1 / (1 + s ^ 2)\nhy : |y| < s * x\nH : \u221a((1 - x) ^ 2 + y ^ 2) \u2264 1 - x / 2\n\u22a2 \u221a(1 + s ^ 2) * x = 2 * \u221a(1 + s ^ 2) * (x / 2)",["ring","linarith"]],["Analysis/Analytic/Uniqueness.lean",70,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ny : E\nc : \u211d\nc_pos : c > 0\nt : Set E\nt_open : IsOpen t\n\u03b4 : \u211d\n\u03b4_pos : \u03b4 > 0\n\u03b4\u03b5 : Metric.ball 0 \u03b4 \u2286 t\nn : \u2115\np : ContinuousMultilinearMap \ud835\udd5c (fun i \u21a6 E) F\nht : \u2200 y \u2208 t, \u2016p fun x \u21a6 y\u2016 \u2264 c * \u2016\u2016y\u2016 ^ (n + 1 + 1)\u2016\nhy : 0 < \u2016y\u2016\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\nh\u2080 : 0 < c * \u2016y\u2016 ^ (n.succ + 1)\nk : \ud835\udd5c\nk_pos : 0 < \u2016k\u2016\nk_norm : \u2016k\u2016 < \u03b4 * \u2016y\u2016\u207b\u00b9 \u2293 \u03b5 * (c * \u2016y\u2016 ^ (n.succ + 1))\u207b\u00b9\nh\u2081 : \u2016k \u2022 y\u2016 < \u03b4\n\u22a2 c * (\u2016k\u2016 ^ (n.succ + 1) * \u2016y\u2016 ^ (n.succ + 1)) = \u2016k\u2016 ^ n.succ * (\u2016k\u2016 * (c * \u2016y\u2016 ^ (n.succ + 1)))",["ring"]],["Analysis/SpecialFunctions/Complex/LogBounds.lean",90,"case h.e'_9.h.e'_5\nz : \u2102\nn : \u2115\nih : HasDerivAt (logTaylor (n + 1)) (\u2211 j \u2208 Finset.range n, (-1) ^ j * z ^ j) z\nthis : HasDerivAt (fun x \u21a6 x ^ (n + 1) / (\u2191n + 1)) (z ^ n) z\n\u22a2 (-1) ^ n = (-1) ^ (n + 1 + 1)",["ring"]],["Analysis/ConstantSpeed.lean",90,"case mp.inr\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u211d \u2192 E\ns : Set \u211d\nl : \u211d\u22650\nh : \u2200 \u2983x : \u211d\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u211d\u2984, y \u2208 s \u2192 x \u2264 y \u2192 eVariationOn f (s \u2229 Icc x y) = ENNReal.ofReal (\u2191l * (y - x))\nx : \u211d\nxs : x \u2208 s\ny : \u211d\nys : y \u2208 s\nyx : y \u2264 x\nthis : (ENNReal.ofReal (\u2191l * (x - y))).toReal = \u2191l * (x - y)\n\u22a2 -(\u2191l * (x - y)) = \u2191l * (y - x)",["ring","linarith"]],["NumberTheory/ModularForms/JacobiTheta/Bounds.lean",79,"case h.e'_4\nk : \u2115\na t : \u211d\nha : 0 \u2264 a\nht : 0 < t\nn : \u2115\nu : \u2191n \u2264 \u2191n ^ 2\n\u22a2 (\u2191n + a) ^ 2 - (\u2191n + a ^ 2) = \u2191n ^ 2 - \u2191n + 2 * \u2191n * a",["ring","linarith"]],["NumberTheory/ModularForms/JacobiTheta/Bounds.lean",214,"k : \u2115\na : \u211d\nha : a \u2264 1\nt : \u211d\nn : \u2115\n\u22a2 -(\u2191n + 1) + a = -(\u2191n + (1 - a))",["ring","linarith","abel"]],["NumberTheory/ModularForms/JacobiTheta/Bounds.lean",258,"case h\na : \u211d\nha : a \u2208 Ico 0 1\np : \u211d\nhp : 0 < p\nhp' : (fun t \u21a6 F_nat 0 a t - if a = 0 then 1 else 0) =O[atTop] fun t \u21a6 rexp (-p * t)\nq : \u211d\nhq : 0 < q\nhq' : (fun t \u21a6 F_nat 0 (1 - a) t) =O[atTop] fun t \u21a6 rexp (-q * t)\nt : \u211d\nht : 0 < t\n\u22a2 (F_nat 0 a t + F_nat 0 (1 - a) t - if a = 0 then 1 else 0) = (F_nat 0 a t - if a = 0 then 1 else 0) + F_nat 0 (1 - a) t",["ring","linarith","abel"]],["LinearAlgebra/TensorProduct/Graded/External.lean",251,"case a.H.h.H.h.a.H.h.H.h.a.H.h.H.h.e_a.e_a\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9\u00b9 : CommSemiring \u03b9\ninst\u271d\u00b9\u2070 : Module \u03b9 (Additive \u2124\u02e3)\ninst\u271d\u2079 : DecidableEq \u03b9\n\ud835\udc9c : \u03b9 \u2192 Type u_3\n\u212c : \u03b9 \u2192 Type u_4\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : (i : \u03b9) \u2192 AddCommGroup (\ud835\udc9c i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddCommGroup (\u212c i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Module R (\ud835\udc9c i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Module R (\u212c i)\ninst\u271d\u00b3 : DirectSum.GRing \ud835\udc9c\ninst\u271d\u00b2 : DirectSum.GRing \u212c\ninst\u271d\u00b9 : DirectSum.GAlgebra R \ud835\udc9c\ninst\u271d : DirectSum.GAlgebra R \u212c\nx y z : DirectSum \u03b9 \ud835\udc9c \u2297[R] DirectSum \u03b9 \u212c\nmA : DirectSum \u03b9 \ud835\udc9c \u2297[R] DirectSum \u03b9 \u212c \u2192\u2097[R] DirectSum \u03b9 \ud835\udc9c \u2297[R] DirectSum \u03b9 \u212c \u2192\u2097[R] DirectSum \u03b9 \ud835\udc9c \u2297[R] DirectSum \u03b9 \u212c :=\n  gradedMul R \ud835\udc9c \u212c\nixa : \u03b9\nxa : \ud835\udc9c ixa\nixb : \u03b9\nxb : \u212c ixb\niya : \u03b9\nya : \ud835\udc9c iya\niyb : \u03b9\nyb : \u212c iyb\niza : \u03b9\nza : \ud835\udc9c iza\nizb : \u03b9\nzb : \u212c izb\n\u22a2 ixb * iya + (ixb * iza + iyb * iza) = iyb * iza + (ixb * iya + ixb * iza)",["abel","ring"]],["Analysis/Normed/Algebra/TrivSqZeroExt.lean",234,"\ud835\udd5c : Type u_1\nS : Type u_2\nR : Type u_3\nM : Type u_4\ninst\u271d\u00b9\u00b9 : SeminormedCommRing S\ninst\u271d\u00b9\u2070 : SeminormedRing R\ninst\u271d\u2079 : SeminormedAddCommGroup M\ninst\u271d\u2078 : Algebra S R\ninst\u271d\u2077 : Module S M\ninst\u271d\u2076 : IsBoundedSMul S R\ninst\u271d\u2075 : IsBoundedSMul S M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : IsBoundedSMul R M\ninst\u271d\u00b2 : Module R\u1d50\u1d52\u1d56 M\ninst\u271d\u00b9 : IsBoundedSMul R\u1d50\u1d52\u1d56 M\ninst\u271d : SMulCommClass R R\u1d50\u1d52\u1d56 M\nr\u2081 : R\nm\u2081 : M\nr\u2082 : R\nm\u2082 : M\n\u22a2 \u2016r\u2081\u2016 * \u2016r\u2082\u2016 + (\u2016r\u2081\u2016 * \u2016m\u2082\u2016 + \u2016r\u2082\u2016 * \u2016m\u2081\u2016) + \u2016m\u2081\u2016 * \u2016m\u2082\u2016 = (\u2016r\u2081\u2016 + \u2016m\u2081\u2016) * (\u2016r\u2082\u2016 + \u2016m\u2082\u2016)",["ring","linarith"]],["NumberTheory/FLT/Four.lean",90,"c : \u2124\np : \u2115\nhp : Nat.Prime p\na1 : \u2124\nhpa : p \u2223 (\u2191p * a1).natAbs\nb1 : \u2124\nhpb : p \u2223 (\u2191p * b1).natAbs\nh : Minimal (\u2191p * a1) (\u2191p * b1) c\nhab : \u00ac(\u2191p * a1).gcd (\u2191p * b1) = 1\n\u22a2 (\u2191p ^ 2) ^ 2 * (a1 ^ 4 + b1 ^ 4) = (\u2191p * a1) ^ 4 + (\u2191p * b1) ^ 4",["ring","linarith"]],["NumberTheory/FLT/Four.lean",262,"case inl\na b c : \u2124\nh : Minimal a b c\nha2 : a % 2 = 1\nhc : 0 < c\nht : PythagoreanTriple (a ^ 2) (b ^ 2) c\nh2 : (a ^ 2).gcd (b ^ 2) = 1\nha22 : a ^ 2 % 2 = 1\nm n : \u2124\nht1 : a ^ 2 = m ^ 2 - n ^ 2\nht2 : b ^ 2 = 2 * m * n\nht3 : c = m ^ 2 + n ^ 2\nht4 : m.gcd n = 1\nht5 : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0\nht6 : 0 \u2264 m\nhtt : PythagoreanTriple a n m\nh3 : a.gcd n = 1\nhb20 : b ^ 2 \u2260 0\nh4 : 0 < m\nr s : \u2124\nleft\u271d : a = r ^ 2 - s ^ 2\nhtt2 : n = 2 * r * s\nhtt3 : m = r ^ 2 + s ^ 2\nhtt4 : s.gcd r = 1\nhtt5 : r % 2 = 0 \u2227 s % 2 = 1 \u2228 r % 2 = 1 \u2227 s % 2 = 0\nhtt6 : 0 \u2264 r\nhcp : (r * s).gcd m = 1\nb' : \u2124\nhb2' : b = 2 * b'\nhs : b' ^ 2 = r * s * m\nhrsz : r * s \u2260 0\nh2b0 : b' \u2260 0\ni : \u2124\nhi' : \u00acm = -i ^ 2\nhi : m = i ^ 2\nd : \u2124\nhd' : \u00acr * s = -d ^ 2\nhd : s * r = d ^ 2\nj : \u2124\nhj0 : j \u2260 0\nk : \u2124\nhk : s = k ^ 2 \u2228 s = -k ^ 2\nhk0 : k \u2260 0\nhjp : r = j ^ 2\n\u22a2 (j ^ 2) ^ 2 = j ^ 4\n```\n---\n```lean\ncase inr\na b c : \u2124\nh : Minimal a b c\nha2 : a % 2 = 1\nhc : 0 < c\nht : PythagoreanTriple (a ^ 2) (b ^ 2) c\nh2 : (a ^ 2).gcd (b ^ 2) = 1\nha22 : a ^ 2 % 2 = 1\nm n : \u2124\nht1 : a ^ 2 = m ^ 2 - n ^ 2\nht2 : b ^ 2 = 2 * m * n\nht3 : c = m ^ 2 + n ^ 2\nht4 : m.gcd n = 1\nht5 : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0\nht6 : 0 \u2264 m\nhtt : PythagoreanTriple a n m\nh3 : a.gcd n = 1\nhb20 : b ^ 2 \u2260 0\nh4 : 0 < m\nr s : \u2124\nleft\u271d : a = r ^ 2 - s ^ 2\nhtt2 : n = 2 * r * s\nhtt3 : m = r ^ 2 + s ^ 2\nhtt4 : s.gcd r = 1\nhtt5 : r % 2 = 0 \u2227 s % 2 = 1 \u2228 r % 2 = 1 \u2227 s % 2 = 0\nhtt6 : 0 \u2264 r\nhcp : (r * s).gcd m = 1\nb' : \u2124\nhb2' : b = 2 * b'\nhs : b' ^ 2 = r * s * m\nhrsz : r * s \u2260 0\nh2b0 : b' \u2260 0\ni : \u2124\nhi' : \u00acm = -i ^ 2\nhi : m = i ^ 2\nd : \u2124\nhd' : \u00acr * s = -d ^ 2\nhd : s * r = d ^ 2\nj : \u2124\nhj0 : j \u2260 0\nk : \u2124\nhk : s = k ^ 2 \u2228 s = -k ^ 2\nhk0 : k \u2260 0\nhjp : r = -j ^ 2\n\u22a2 (-j ^ 2) ^ 2 = j ^ 4",["ring"]],["NumberTheory/FLT/Four.lean",266,"case inl\na b c : \u2124\nh : Minimal a b c\nha2 : a % 2 = 1\nhc : 0 < c\nht : PythagoreanTriple (a ^ 2) (b ^ 2) c\nh2 : (a ^ 2).gcd (b ^ 2) = 1\nha22 : a ^ 2 % 2 = 1\nm n : \u2124\nht1 : a ^ 2 = m ^ 2 - n ^ 2\nht2 : b ^ 2 = 2 * m * n\nht3 : c = m ^ 2 + n ^ 2\nht4 : m.gcd n = 1\nht5 : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0\nht6 : 0 \u2264 m\nhtt : PythagoreanTriple a n m\nh3 : a.gcd n = 1\nhb20 : b ^ 2 \u2260 0\nh4 : 0 < m\nr s : \u2124\nleft\u271d : a = r ^ 2 - s ^ 2\nhtt2 : n = 2 * r * s\nhtt3 : m = r ^ 2 + s ^ 2\nhtt4 : s.gcd r = 1\nhtt5 : r % 2 = 0 \u2227 s % 2 = 1 \u2228 r % 2 = 1 \u2227 s % 2 = 0\nhtt6 : 0 \u2264 r\nhcp : (r * s).gcd m = 1\nb' : \u2124\nhb2' : b = 2 * b'\nhs : b' ^ 2 = r * s * m\nhrsz : r * s \u2260 0\nh2b0 : b' \u2260 0\ni : \u2124\nhi' : \u00acm = -i ^ 2\nhi : m = i ^ 2\nd : \u2124\nhd' : \u00acr * s = -d ^ 2\nhd : s * r = d ^ 2\nj : \u2124\nhj : r = j ^ 2 \u2228 r = -j ^ 2\nhj0 : j \u2260 0\nk : \u2124\nhk0 : k \u2260 0\nhj2 : r ^ 2 = j ^ 4\nhkp : s = k ^ 2\n\u22a2 (k ^ 2) ^ 2 = k ^ 4\n```\n---\n```lean\ncase inr\na b c : \u2124\nh : Minimal a b c\nha2 : a % 2 = 1\nhc : 0 < c\nht : PythagoreanTriple (a ^ 2) (b ^ 2) c\nh2 : (a ^ 2).gcd (b ^ 2) = 1\nha22 : a ^ 2 % 2 = 1\nm n : \u2124\nht1 : a ^ 2 = m ^ 2 - n ^ 2\nht2 : b ^ 2 = 2 * m * n\nht3 : c = m ^ 2 + n ^ 2\nht4 : m.gcd n = 1\nht5 : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0\nht6 : 0 \u2264 m\nhtt : PythagoreanTriple a n m\nh3 : a.gcd n = 1\nhb20 : b ^ 2 \u2260 0\nh4 : 0 < m\nr s : \u2124\nleft\u271d : a = r ^ 2 - s ^ 2\nhtt2 : n = 2 * r * s\nhtt3 : m = r ^ 2 + s ^ 2\nhtt4 : s.gcd r = 1\nhtt5 : r % 2 = 0 \u2227 s % 2 = 1 \u2228 r % 2 = 1 \u2227 s % 2 = 0\nhtt6 : 0 \u2264 r\nhcp : (r * s).gcd m = 1\nb' : \u2124\nhb2' : b = 2 * b'\nhs : b' ^ 2 = r * s * m\nhrsz : r * s \u2260 0\nh2b0 : b' \u2260 0\ni : \u2124\nhi' : \u00acm = -i ^ 2\nhi : m = i ^ 2\nd : \u2124\nhd' : \u00acr * s = -d ^ 2\nhd : s * r = d ^ 2\nj : \u2124\nhj : r = j ^ 2 \u2228 r = -j ^ 2\nhj0 : j \u2260 0\nk : \u2124\nhk0 : k \u2260 0\nhj2 : r ^ 2 = j ^ 4\nhkp : s = -k ^ 2\n\u22a2 (-k ^ 2) ^ 2 = k ^ 4",["ring"]],["NumberTheory/FLT/Four.lean",301,"a b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\na\u271d : c \u2260 0\nheq : a ^ 4 + b ^ 4 = c ^ 4\n\u22a2 c ^ 4 = (c ^ 2) ^ 2",["ring","linarith"]],["Algebra/ContinuedFractions/Computation/CorrectnessTerminating.lean",75,"K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\na b c : K\nfract_a_ne_zero : Int.fract a \u2260 0\n\u22a2 \u2191\u230aa\u230b * b + c + b * (a - \u2191\u230aa\u230b) = b * a + c",["ring","linarith"]],["Algebra/Lie/Weights/Linear.lean",171,"k : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : LieAlgebra R L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieModule R L M\ninst\u271d\u00b9 : LieRing.IsNilpotent L\n\u03c7 : L \u2192 R\ninst\u271d : LinearWeights R L M\nx y : L\nm : \u21a5(shiftedGenWeightSpace R L M \u03c7)\na\u271d : Nontrivial \u21a5(shiftedGenWeightSpace R L M \u03c7)\n\u22a2 \u2045x, m\u2046 + \u2045y, m\u2046 - (\u03c7 x \u2022 m + \u03c7 y \u2022 m) = \u2045x, m\u2046 - \u03c7 x \u2022 m + (\u2045y, m\u2046 - \u03c7 y \u2022 m)",["abel"]],["Algebra/Lie/Weights/Linear.lean",175,"k : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : LieAlgebra R L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieModule R L M\ninst\u271d\u00b9 : LieRing.IsNilpotent L\n\u03c7 : L \u2192 R\ninst\u271d : LinearWeights R L M\nx : L\nm n : \u21a5(shiftedGenWeightSpace R L M \u03c7)\na\u271d : Nontrivial \u21a5(shiftedGenWeightSpace R L M \u03c7)\n\u22a2 \u2045x, m\u2046 + \u2045x, n\u2046 - (\u03c7 x \u2022 m + \u03c7 x \u2022 n) = \u2045x, m\u2046 - \u03c7 x \u2022 m + (\u2045x, n\u2046 - \u03c7 x \u2022 n)",["abel"]],["Algebra/Lie/Weights/Linear.lean",180,"k : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : LieAlgebra R L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieModule R L M\ninst\u271d\u00b9 : LieRing.IsNilpotent L\n\u03c7 : L \u2192 R\ninst\u271d : LinearWeights R L M\nx y : L\nm : \u21a5(shiftedGenWeightSpace R L M \u03c7)\na\u271d : Nontrivial \u21a5(shiftedGenWeightSpace R L M \u03c7)\n\u22a2 \u2045x, \u2045y, m\u2046\u2046 - \u03c7 y \u2022 \u2045x, m\u2046 - (\u03c7 x \u2022 \u2045y, m\u2046 - \u03c7 y \u2022 \u03c7 x \u2022 m) =\n    \u2045x, \u2045y, m\u2046\u2046 - \u2045y, \u2045x, m\u2046\u2046 + (\u2045y, \u2045x, m\u2046\u2046 - \u03c7 x \u2022 \u2045y, m\u2046 - (\u03c7 y \u2022 \u2045x, m\u2046 - \u03c7 y \u2022 \u03c7 x \u2022 m))",["abel"]],["Analysis/Convex/Continuous.lean",47,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nx\u2080 : E\n\u03b5 r M : \u211d\nhf : ConvexOn \u211d (ball x\u2080 r) f\nh\u03b5 : 0 < \u03b5\nhM : \u2200 (a : E), dist a x\u2080 < r \u2192 |f a| \u2264 M\nK : \u211d := 2 * M / \u03b5\nhK : K = 2 * M / \u03b5\nx y : E\nhx : x \u2208 ball x\u2080 (r - \u03b5)\nhy : y \u2208 ball x\u2080 (r - \u03b5)\nhx\u2080r : ball x\u2080 (r - \u03b5) \u2286 ball x\u2080 r\nhx' : x \u2208 ball x\u2080 r\nhy' : y \u2208 ball x\u2080 r\nz : E := x + (\u03b5 / \u2016x - y\u2016) \u2022 (x - y)\nhxy : 0 < \u2016x - y\u2016\nhz : z \u2208 ball x\u2080 r\na : \u211d := \u03b5 / (\u03b5 + \u2016x - y\u2016)\nb : \u211d := \u2016x - y\u2016 / (\u03b5 + \u2016x - y\u2016)\nhab : a + b = 1\n\u22a2 (\u03b5 / (\u03b5 + \u2016x - y\u2016)) \u2022 x + (\u2016x - y\u2016 / (\u03b5 + \u2016x - y\u2016)) \u2022 x =\n    (\u03b5 / (\u03b5 + \u2016x - y\u2016)) \u2022 y + ((\u2016x - y\u2016 / (\u03b5 + \u2016x - y\u2016)) \u2022 x + ((\u03b5 / (\u03b5 + \u2016x - y\u2016)) \u2022 x - (\u03b5 / (\u03b5 + \u2016x - y\u2016)) \u2022 y))",["abel"]],["NumberTheory/FLT/Polynomial.lean",61,"p q r a b c : \u2115\nhp : 0 < p\nhq : 0 < q\nhr : 0 < r\nhineq : q * r + r * p + p * q \u2264 p * q * r\nhpa : p * a < a + b + c\nhqb : q * b < a + b + c\nhrc : r * c < a + b + c\n\u22a2 p * q * r * (a + b + c) + 1 = p * a * (q * r) + q * b * (r * p) + r * c * (p * q) + 1",["ring","linarith"]],["NumberTheory/FLT/Polynomial.lean",65,"p q r a b c : \u2115\nhp : 0 < p\nhq : 0 < q\nhr : 0 < r\nhineq : q * r + r * p + p * q \u2264 p * q * r\nhpa : p * a < a + b + c\nhqb : q * b < a + b + c\nhrc : r * c < a + b + c\n\u22a2 (a + b + c) * (q * r) + (a + b + c) * (r * p) + (a + b + c) * (p * q) = (q * r + r * p + p * q) * (a + b + c)",["ring"]],["NumberTheory/FLT/Polynomial.lean",230,"k : Type u_1\ninst\u271d : Field k\nn : \u2115\nhn : 3 \u2264 n\nchn : \u2191n \u2260 0\na b c : k[X]\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\nhab : IsCoprime a b\nhn' : 0 < n\nhone : 1 = C 1\nhneg_one : -1 = C (-1)\nheq : C 1 * a ^ n + C 1 * b ^ n + C (-1) * c ^ n = 0\n\u22a2 n * n + n * n + n * n = 3 * n * n",["ring"]],["NumberTheory/LSeries/HurwitzZetaValues.lean",118,"case e_a\nk : \u2115\nx : \u211d\nhk : k \u2260 0\nhx : x \u2208 Icc 0 1\nthis : \u2191(2 * k + 1)! = (2 * \u2191k + 1) * Complex.Gamma (2 * \u2191k + 1)\n\u22a2 (-1) ^ (k + 1) * (2 * \u2191\u03c0) ^ (2 * k + 1) / (2 * \u2191(2 * k + 1) * Complex.Gamma \u2191(2 * k + 1)) =\n    (-1) ^ (k + 1) * (2 * \u2191\u03c0) ^ (2 * k + 1) / (\u2191(2 * k + 1) * 2 * Complex.Gamma \u2191(2 * k + 1))",["ring"]],["Analysis/Meromorphic/Order.lean",150,"case h\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nz\u2080 : \ud835\udd5c\nhf : MeromorphicAt f z\u2080\na : \u2124\nha : \u2191a = hf.order\ng : \ud835\udd5c \u2192 \ud835\udd5c\nh\u2081g : AnalyticAt \ud835\udd5c g z\u2080\nh\u2082g : g z\u2080 \u2260 0\nh\u2083g : \u2200\u1da0 (x : \ud835\udd5c) in \ud835\udcdd z\u2080, x \u2208 {z\u2080}\u1d9c \u2192 f x = (x - z\u2080) ^ a \u2022 g x\na\u271d : \ud835\udd5c\nh\u2081a : a\u271d \u2208 {z\u2080}\u1d9c \u2192 f a\u271d = (a\u271d - z\u2080) ^ a \u2022 g a\u271d\nh\u2082a : a\u271d \u2208 {z\u2080}\u1d9c\n\u22a2 (g a\u271d)\u207b\u00b9 * ((a\u271d - z\u2080) ^ a)\u207b\u00b9 = ((a\u271d - z\u2080) ^ a)\u207b\u00b9 * (g a\u271d)\u207b\u00b9",["ring"]],["LinearAlgebra/RootSystem/Basic.lean",237,"case a.hg\u2081\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : CharZero R\ninst\u271d : NoZeroSMulDivisors R M\np : PerfectPairing R M N\nroot : \u03b9 \u21aa M\ncoroot : \u03b9 \u21aa N\nhp : \u2200 (i : \u03b9), (p (root i)) (coroot i) = 2\nhs : \u2200 (i : \u03b9), MapsTo (\u21d1(preReflection (root i) (p.flip (coroot i)))) (range \u21d1root) (range \u21d1root)\nhsp : span R (range \u21d1root) = \u22a4\ni j k : \u03b9\n\u03b1 : M := root i\n\u03b2 : M := root j\n\u03b1' : N := coroot i\n\u03b2' : N := coroot j\ns\u03b1 : End R M := preReflection \u03b1 (p.flip \u03b1')\nhk : root k = s\u03b1 \u03b2\ns\u03b2 : End R M := preReflection \u03b2 (p.flip \u03b2')\ns\u03b1' : End R N := preReflection \u03b1' (p \u03b1)\nhij : preReflection (s\u03b1 \u03b2) (p.toLin.flip (s\u03b1' \u03b2')) = s\u03b1 \u2218\u2097 s\u03b2 \u2218\u2097 s\u03b1\nhk\u2080 : root k \u2260 0\n\u22a2 2 - (p (root j)) (coroot i) * (p (root i)) (coroot j) -\n      (p (root j)) (coroot i) * ((p (root i)) (coroot j) - 2 * (p (root i)) (coroot j)) =\n    2",["ring"]],["Analysis/Fourier/PoissonSummation.lean",95,"case e_f.h.e_a.e_z\nf : C(\u211d, \u2102)\nhf : \u2200 (K : Compacts \u211d), Summable fun n \u21a6 \u2016ContinuousMap.restrict (\u2191K) (f.comp (ContinuousMap.addRight \u2191n))\u2016\nm : \u2124\ne : C(\u211d, \u2102) := (fourier (-m)).comp { toFun := QuotientAddGroup.mk, continuous_toFun := \u22ef }\nneK : \u2200 (K : Compacts \u211d) (g : C(\u211d, \u2102)), \u2016ContinuousMap.restrict (\u2191K) (e * g)\u2016 = \u2016ContinuousMap.restrict (\u2191K) g\u2016\neadd : \u2200 (n : \u2124), e.comp (ContinuousMap.addRight \u2191n) = e\nx : \u211d\n\u22a2 2 * \u2191\u03c0 * I * -\u2191m * \u2191x / 1 = -2 * \u2191\u03c0 * \u2191x * \u2191m * I",["ring"]],["Analysis/InnerProductSpace/LinearMap.lean",59,"V : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup V\ninst\u271d : InnerProductSpace \u2102 V\nT : V \u2192\u2097[\u2102] V\nx y : V\n\u22a2 \u27eaT y, x\u27eb_\u2102 =\n    (\u27eaT x, x\u27eb_\u2102 + \u27eaT y, x\u27eb_\u2102 + (\u27eaT x, y\u27eb_\u2102 + \u27eaT y, y\u27eb_\u2102) - (\u27eaT x, x\u27eb_\u2102 - (\u27eaT y, x\u27eb_\u2102 + (\u27eaT x, y\u27eb_\u2102 - \u27eaT y, y\u27eb_\u2102))) +\n          (Complex.I * \u27eaT x, x\u27eb_\u2102 + \u27eaT y, x\u27eb_\u2102 + (-\u27eaT x, y\u27eb_\u2102 + Complex.I * \u27eaT y, y\u27eb_\u2102)) -\n        (Complex.I * \u27eaT x, x\u27eb_\u2102 - (\u27eaT y, x\u27eb_\u2102 + (-\u27eaT x, y\u27eb_\u2102 - Complex.I * \u27eaT y, y\u27eb_\u2102)))) /\n      4",["ring"]],["Analysis/InnerProductSpace/LinearMap.lean",70,"V : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup V\ninst\u271d : InnerProductSpace \u2102 V\nT : V \u2192\u2097[\u2102] V\nx y : V\n\u22a2 \u27eaT x, y\u27eb_\u2102 =\n    (\u27eaT x, x\u27eb_\u2102 + \u27eaT y, x\u27eb_\u2102 + (\u27eaT x, y\u27eb_\u2102 + \u27eaT y, y\u27eb_\u2102) -\n          (\u27eaT x, x\u27eb_\u2102 - (\u27eaT y, x\u27eb_\u2102 + (\u27eaT x, y\u27eb_\u2102 - \u27eaT y, y\u27eb_\u2102)) +\n            (Complex.I * \u27eaT x, x\u27eb_\u2102 + \u27eaT y, x\u27eb_\u2102 + (-\u27eaT x, y\u27eb_\u2102 + Complex.I * \u27eaT y, y\u27eb_\u2102))) +\n        (Complex.I * \u27eaT x, x\u27eb_\u2102 - (\u27eaT y, x\u27eb_\u2102 + (-\u27eaT x, y\u27eb_\u2102 - Complex.I * \u27eaT y, y\u27eb_\u2102)))) /\n      4",["ring"]],["Analysis/InnerProductSpace/LinearMap.lean",236,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nE' : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup E'\ninst\u271d : InnerProductSpace \ud835\udd5c E'\nf : E \u2192L[\ud835\udd5c] E'\nv : E'\nx : E\nh\u2081 : \u2016f x\u2016 \u2264 \u2016f\u2016 * \u2016x\u2016\nh\u2082 : \u2016\u27eav, f x\u27eb_\ud835\udd5c\u2016 \u2264 \u2016v\u2016 * \u2016f x\u2016\n\u22a2 \u2016v\u2016 * (\u2016f\u2016 * \u2016x\u2016) = \u2016f\u2016 * \u2016v\u2016 * \u2016x\u2016",["ring","linarith"]],["Algebra/Homology/HomotopyCategory/DegreewiseSplit.lean",108,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.47183, u_1} C\ninst\u271d\u00b9 : Preadditive C\nS : ShortComplex (CochainComplex C \u2124)\n\u03c3 : (n : \u2124) \u2192 (S.map (eval C (ComplexShape.up \u2124) n)).Splitting\ninst\u271d : HasBinaryBiproducts C\np : \u2124\nh : (\u03c3 (p + 1)).r \u226b S.f.f (p + 1) + S.g.f (p + 1) \u226b (\u03c3 (p + 1)).s = \ud835\udfd9 (S.X\u2082.X (p + 1))\n\u22a2 S.g.f (p + 1) \u226b (\u03c3 (p + 1)).s + (\u03c3 (p + 1)).r \u226b S.f.f (p + 1) =\n    (\u03c3 (p + 1)).r \u226b S.f.f (p + 1) + S.g.f (p + 1) \u226b (\u03c3 (p + 1)).s",["abel"]],["Analysis/SpecialFunctions/Bernstein.lean",127,"case h.e'_2.e_f.h.e_a\nn : \u2115\nh : 0 < \u2191n\nx : \u2191I\nh' : \u2191n \u2260 0\nthis :\n  \u2211 x_1 : Fin (n + 1), (\u2191n * \u2191x - \u2191\u2191x_1) ^ 2 * Polynomial.eval (\u2191x) (bernsteinPolynomial \u211d n \u2191x_1) = \u2191n * \u2191x * (1 - \u2191x)\nk : Fin (n + 1)\n\u22a2 \u2191n * \u2191n * (\u2191x * \u2191n - \u2191\u2191k) ^ 2 = (\u2191n * \u2191x - \u2191\u2191k) ^ 2 * \u2191n ^ 2",["ring","linarith"]],["Analysis/SpecialFunctions/Bernstein.lean",276,"f : C(\u2191I, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n \u21a6 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (\ud835\udcdd 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\nnpos : 0 < \u2191n\nx : \u2191I\nS : Finset (Fin (n + 1)) := bernsteinApproximation.S f \u03b5 h n x\n\u22a2 2 * \u2016f\u2016 * \u03b4 ^ (-2) * (\u2191x * (1 - \u2191x) / \u2191n) = 2 * \u2016f\u2016 * \u03b4 ^ (-2) * \u2191x * (1 - \u2191x) / \u2191n",["ring"]],["Data/Real/Pi/Bounds.lean",41,"n : \u2115\n\u22a2 (4 / 2 ^ 2 / 2 ^ n) ^ 3 / 4 = ((2 ^ n) ^ 3)\u207b\u00b9 / 4",["norm_num","ring"]],["Data/Real/Pi/Bounds.lean",44,"n : \u2115\n\u22a2 4 = 2 ^ (0 + 2)",["norm_num","ring"]],["Analysis/Calculus/FDeriv/Extend.lean",90,"E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : E \u2192 F\ns : Set E\nx : E\nf' : E \u2192L[\u211d] F\nf_diff : DifferentiableOn \u211d f s\ns_conv : Convex \u211d s\ns_open : IsOpen s\nf_cont : \u2200 y \u2208 closure s, ContinuousWithinAt f s y\nh : Tendsto (fun y \u21a6 fderiv \u211d f y) (\ud835\udcdd[s] x) (\ud835\udcdd f')\nhx : x \u2208 closure s\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4_pos : \u03b4 > 0\nh\u03b4 : \u2200 y \u2208 s, dist y x < \u03b4 \u2192 \u2016fderiv \u211d f y - f'\u2016 < \u03b5\nB : Set E := ball x \u03b4\nkey : \u2200 p \u2208 (B \u2229 s) \u00d7\u02e2 (B \u2229 s), \u2016f p.2 - f p.1 - (f' p.2 - f' p.1)\u2016 \u2264 \u03b5 * \u2016p.2 - p.1\u2016\nu v : E\nuv_in : (u, v) \u2208 closure ((B \u2229 s) \u00d7\u02e2 (B \u2229 s))\nf_cont' : \u2200 y \u2208 closure s, ContinuousWithinAt (f - \u21d1f') s y\nthis : (B \u2229 s) \u00d7\u02e2 (B \u2229 s) \u2286 s \u00d7\u02e2 s\nu_in : u \u2208 closure s\nv_in : v \u2208 closure s\nu\u271d v\u271d : E\n\u22a2 f v\u271d - f u\u271d - (f' v\u271d - f' u\u271d) = f v\u271d - f' v\u271d - (f u\u271d - f' u\u271d)",["abel"]],["NumberTheory/Harmonic/GammaDeriv.lean",228,"f : \u2102 \u2192 \u2102 := fun s \u21a6 \u2191\u03c0 ^ (-s / 2)\ng : \u2102 \u2192 \u2102 := fun s \u21a6 Gamma (s / 2)\naux : \u2191\u03c0 ^ (1 / 2) = \u2191\u221a\u03c0\naux2 : \u2191\u221a\u03c0 \u2260 0\nhf : HasDerivAt f (-log \u2191\u03c0 / 2 / \u2191\u221a\u03c0) 1\nhg : HasDerivAt g (-\u2191\u221a\u03c0 * (\u2191\u03b3 + 2 * log 2) / 2) 1\n\u22a2 -(\u2191\u03b3 + log \u2191(2 ^ 2 * \u03c0)) / 2 = -(\u2191\u03b3 + log (4 * \u2191\u03c0)) / 2",["norm_num"]],["NumberTheory/Harmonic/GammaDeriv.lean",58,"case succ\nn\u271d : \u2115\nf : \u211d \u2192 \u211d := log \u2218 Gamma\nhc : ConvexOn \u211d (Ioi 0) f\nh_rec : \u2200 (x : \u211d), 0 < x \u2192 f (x + 1) = f x + log x\nhder : \u2200 {x : \u211d}, 0 < x \u2192 DifferentiableAt \u211d f x\nhder_rec : \u2200 (x : \u211d), 0 < x \u2192 deriv f (x + 1) = deriv f x + 1 / x\nn : \u2115\nhn : deriv f (\u2191n + 1) = deriv f 1 + \u2191(harmonic n)\n\u22a2 deriv f 1 + \u2191(harmonic n) + 1 / (\u2191n + 1) = deriv f 1 + (\u2191(harmonic n) + (\u2191n + 1)\u207b\u00b9)",["ring"]],["NumberTheory/Harmonic/GammaDeriv.lean",145,"h_diff : \u2200 {s : \u211d}, 0 < s \u2192 DifferentiableAt \u211d Gamma s\nh_diff' : \u2200 {s : \u211d}, 0 < s \u2192 DifferentiableAt \u211d (fun s \u21a6 Gamma (2 * s)) s\n\u22a2 \u221a\u03c0 * (-2 * \u03b3 + -(2 * log 2) + \u03b3) = -\u221a\u03c0 * (\u03b3 + 2 * log 2)",["ring","linarith"]],["RingTheory/Polynomial/Dickson.lean",98,"R : Type u_1\ninst\u271d : CommRing R\n\u22a2 3 - \u21912 = 1",["norm_num","ring"]],["RingTheory/Polynomial/Dickson.lean",120,"R : Type u_1\ninst\u271d : CommRing R\nx y : R\nh : x * y = 1\n\u22a2 eval (x + y) (3 - \u21911) = 1 + 1",["norm_num"]],["RingTheory/Polynomial/Dickson.lean",140,"R : Type u_1\ninst\u271d : CommRing R\n\u22a2 3 - \u21911 = Chebyshev.C R \u21910",["norm_num"]],["RingTheory/Polynomial/Dickson.lean",160,"R : Type u_1\ninst\u271d : CommRing R\n\u22a2 3 - \u21912 = Chebyshev.S R \u21910",["norm_num"]],["RingTheory/Polynomial/Dickson.lean",126,"R : Type u_1\ninst\u271d : CommRing R\nx y : R\nh : x * y = 1\nn : \u2115\n\u22a2 x * x * x ^ n + x ^ n + (y ^ n + y * y * y ^ n) - (x ^ n + y ^ n) = x ^ (n + 2) + y ^ (n + 2)",["ring"]],["RingTheory/Polynomial/Dickson.lean",147,"R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\n\u22a2 X * Chebyshev.C R (\u2191n + 1) - 1 * Chebyshev.C R \u2191n = X * Chebyshev.C R (\u2191n + 1) - Chebyshev.C R \u2191n",["ring"]],["RingTheory/Polynomial/Dickson.lean",167,"R : Type u_1\ninst\u271d : CommRing R\nn : \u2115\n\u22a2 X * Chebyshev.S R (\u2191n + 1) - 1 * Chebyshev.S R \u2191n = X * Chebyshev.S R (\u2191n + 1) - Chebyshev.S R \u2191n",["ring"]],["RingTheory/Polynomial/Dickson.lean",254,"case a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nK : Type\nw\u271d\u00b9 : Field K\nw\u271d : CharP K p\nH : Set.univ.Infinite\nh : {x | \u2203 y, x = y + y\u207b\u00b9 \u2227 y \u2260 0}.Finite\nx : K\nx\u271d : x \u2208 {x | \u2203 y, x = y + y\u207b\u00b9 \u2227 y \u2260 0}\n\u03c6 : K[X] := X ^ 2 - C x * X + 1\nh\u03c6 : \u03c6 \u2260 0\ny : K\nhy : \u00acy = 0\n\u22a2 y * y + 1 - x * y = y ^ 2 - x * y + 1",["ring"]],["Analysis/InnerProductSpace/OfNorm.lean",112,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx : E\nh\u2081 : \u2016x - x\u2016 = 0\nh\u2082 : \u2016x + x\u2016 = 2 \u2022 \u2016x\u2016\n\u22a2 \u2016x\u2016 ^ 2 =\n    4 / (4 * 4 + 0 * 0) *\n        (2 \u2022 \u2016x\u2016 * 2 \u2022 \u2016x\u2016 - 0 * 0 - (0 * 0 - 0 * 0) +\n            ((0 * \u2016I \u2022 x + x\u2016 - im I * 0) * \u2016I \u2022 x + x\u2016 - (0 * 0 + im I * \u2016I \u2022 x + x\u2016) * 0) -\n          ((0 * \u2016I \u2022 x - x\u2016 - im I * 0) * \u2016I \u2022 x - x\u2016 - (0 * 0 + im I * \u2016I \u2022 x - x\u2016) * 0)) -\n      -0 / (4 * 4 + 0 * 0) *\n        (2 \u2022 \u2016x\u2016 * 0 + 0 * 2 \u2022 \u2016x\u2016 - (0 * 0 + 0 * 0) +\n            ((0 * \u2016I \u2022 x + x\u2016 - im I * 0) * 0 + (0 * 0 + im I * \u2016I \u2022 x + x\u2016) * \u2016I \u2022 x + x\u2016) -\n          ((0 * \u2016I \u2022 x - x\u2016 - im I * 0) * 0 + (0 * 0 + im I * \u2016I \u2022 x - x\u2016) * \u2016I \u2022 x - x\u2016))",["ring"]],["Analysis/InnerProductSpace/OfNorm.lean",128,"case neg\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx y : E\nhI : \u00acI = 0\nhI' : I * I = -1\nI_smul : \u2200 (v : E), \u2016I \u2022 v\u2016 = \u2016v\u2016\nh\u2081 : \u2016I \u2022 y - x\u2016 = \u2016I \u2022 x + y\u2016\nh\u2082 : \u2016I \u2022 y + x\u2016 = \u2016I \u2022 x - y\u2016\n\u22a2 4\u207b\u00b9 *\n      (\u2191\u2016x + y\u2016 * \u2191\u2016x + y\u2016 - \u2191\u2016x - y\u2016 * \u2191\u2016x - y\u2016 + -I * \u2191\u2016I \u2022 x - y\u2016 * \u2191\u2016I \u2022 x - y\u2016 - -I * \u2191\u2016I \u2022 x + y\u2016 * \u2191\u2016I \u2022 x + y\u2016) =\n    4\u207b\u00b9 *\n      (\ud835\udcda \u2016x + y\u2016 * \ud835\udcda \u2016x + y\u2016 - \ud835\udcda \u2016x - y\u2016 * \ud835\udcda \u2016x - y\u2016 + I * \ud835\udcda \u2016I \u2022 x + y\u2016 * \ud835\udcda \u2016I \u2022 x + y\u2016 -\n        I * \ud835\udcda \u2016I \u2022 x - y\u2016 * \ud835\udcda \u2016I \u2022 x - y\u2016)",["ring"]],["Analysis/InnerProductSpace/OfNorm.lean",218,"\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : InnerProductSpaceable E\nr : \ud835\udd5c\nx y : E\n\u22a2 \u2191(re r) * inner_ \ud835\udd5c x y + \u2191(im r) * (-I * inner_ \ud835\udd5c x y) = (\u2191(re r) + \u2191(im r) * -I) * inner_ \ud835\udd5c x y",["ring"]],["Data/Nat/Choose/Sum.lean",84,"case a\nR : Type u_1\ninst\u271d : CommRing R\nx y : R\nn m : \u2115\nhm : m \u2208 range (n + 1)\nthis : (-1) ^ (n - m) = (-1) ^ (n + m)\n\u22a2 x ^ m * ((-1) ^ (n + m) * y ^ (n - m)) * \u2191(n.choose m) = (-1) ^ (m + n) * x ^ m * y ^ (n - m) * \u2191(n.choose m)",["ring"]],["Analysis/SpecialFunctions/Stirling.lean",81,"case h.e'_5.h\nm : \u2115\nf : \u2115 \u2192 \u211d := fun k \u21a6 1 / (2 * \u2191k + 1) * ((1 / (2 * \u2191(m + 1) + 1)) ^ 2) ^ k\nk : \u2115\n\u22a2 (2 * \u2191k + 1) * ((2 * (\u2191m + 1) + 1) ^ (2 * k) * (2 * (\u2191m + 1) + 1)) =\n    ((\u2191m + 1) * 2 + 1) * ((2 * \u2191k + 1) * (2 * (\u2191m + 1) + 1) ^ (2 * k))",["ring","linarith"]],["Analysis/SpecialFunctions/Stirling.lean",85,"case h.e'_6\nm : \u2115\nf : \u2115 \u2192 \u211d := fun k \u21a6 1 / (2 * \u2191k + 1) * ((1 / (2 * \u2191(m + 1) + 1)) ^ 2) ^ k\nh : \u2200 (x : \u211d), x \u2260 0 \u2192 1 + x\u207b\u00b9 = (x + 1) / x\n\u22a2 Real.log (\u2191m + 1) + Real.log \u2191m ! - 1 / 2 * (Real.log 2 + Real.log (\u2191m + 1)) - (\u2191m + 1) * (Real.log (\u2191m + 1) - 1) -\n        (Real.log (\u2191m + 1 + 1) + (Real.log (\u2191m + 1) + Real.log \u2191m !) - 1 / 2 * (Real.log 2 + Real.log (\u2191m + 1 + 1)) -\n          (\u2191m + 1 + 1) * (Real.log (\u2191m + 1 + 1) - 1)) +\n      f 0 =\n    (\u2191m + 1 + 1 / 2) * (Real.log (\u2191m + 1 + 1) - Real.log (\u2191m + 1))",["ring"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",212,"case h.e'_3\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nb : P.Base\ni j k : \u03b9\nhij : i \u2260 j\nhi : i \u2208 b.support\nhj : j \u2208 b.support\nhkj : k \u2260 j\nhk' : P.root k + P.root i \u2208 range \u21d1P.root\nhm : P.pairingIn \u2124 j k \u2264 0\nl : \u03b9\nhl : P.root l = P.root k + P.root i - P.root j\nhli : l \u2260 i\nhkl : P.pairingIn \u2124 l k \u2264 0\nhki : P.pairing k i = -1\n\u22a2 1 - P.pairing j i = -1 + 2 - P.pairing j i",["ring"]],["Algebra/Symmetrized.lean",262,"case h.e_6.h.e_a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Invertible 2\na b c : \u03b1\u02e2\u02b8\u1d50\n\u22a2 unsym a * unsym b + unsym a * unsym c + (unsym b * unsym a + unsym c * unsym a) =\n    unsym a * unsym b + unsym b * unsym a + (unsym a * unsym c + unsym c * unsym a)",["abel"]],["Analysis/Normed/Order/UpperLower.lean",154,"case refine_1\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nx : \u03b9 \u2192 \u211d\n\u03b4 : \u211d\nhs : IsUpperSet s\nhx : x \u2208 closure s\nh\u03b4 : 0 < \u03b4\n\u22a2 \u03b4 / 4 + 3 / 4 * \u03b4 = \u03b4",["ring","linarith"]],["Analysis/Normed/Order/UpperLower.lean",172,"case refine_1\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nx : \u03b9 \u2192 \u211d\n\u03b4 : \u211d\nhs : IsLowerSet s\nhx : x \u2208 closure s\nh\u03b4 : 0 < \u03b4\n\u22a2 \u03b4 / 4 + 3 / 4 * \u03b4 = \u03b4",["ring","linarith"]],["Analysis/Convex/SpecificFunctions/Basic.lean",45,"x y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 rexp y - rexp y * rexp (x - y) = rexp y * (1 - rexp (x - y))",["ring","linarith"]],["Analysis/Convex/SpecificFunctions/Basic.lean",54,"x y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < z - y\n\u22a2 rexp y * (rexp (z - y) - 1) = rexp (z - y) * rexp y - rexp y",["ring","linarith"]],["Analysis/Convex/SpecificFunctions/Basic.lean",212,"case e_x\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\nhxy' : -x \u2260 -y\n\u22a2 a * -x + b * -y = -(a * x + b * y)",["ring","linarith"]],["Analysis/Convex/SpecificFunctions/Basic.lean",223,"t : \u211d\nht : -1 \u2264 t \u2227 t \u2264 1\nx : \u211d\n\u22a2 (1 + t) / 2 + (1 - t) / 2 = 1",["ring","linarith"]],["Analysis/Convex/SpecificFunctions/Basic.lean",224,"t : \u211d\nht : -1 \u2264 t \u2227 t \u2264 1\nx : \u211d\n\u22a2 (1 + t) / 2 * rexp x + (1 - t) / 2 * rexp (-x) = (rexp x + rexp (-x)) / 2 + t * ((rexp x - rexp (-x)) / 2)",["ring","linarith"]],["Algebra/Jordan/Basic.lean",164,"case h.e'_2\nA : Type u_1\ninst\u271d\u00b9 : NonUnitalNonAssocCommRing A\ninst\u271d : IsCommJordan A\na b : A\n\u22a2 \u2045L a, L (a * b)\u2046 + \u2045L a, L (a * b)\u2046 + (\u2045L b, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046) + \u2045L b, L (a * a)\u2046 + \u2045L a, L (b * b)\u2046 =\n    \u2045L b, L (a * a)\u2046 + (\u2045L a, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046) + (\u2045L a, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046 + \u2045L a, L (b * b)\u2046)",["abel"]],["Algebra/Jordan/Basic.lean",177,"A : Type u_1\ninst\u271d : NonUnitalNonAssocCommRing A\na b c : A\n\u22a2 \u2045L a, L (a * a)\u2046 + \u2045L b, L (a * a)\u2046 + \u2045L c, L (a * a)\u2046 + (\u2045L a, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046 + \u2045L c, L (a * b)\u2046) +\n          (\u2045L a, L (a * c)\u2046 + \u2045L b, L (a * c)\u2046 + \u2045L c, L (a * c)\u2046) +\n        (\u2045L a, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046 + \u2045L c, L (a * b)\u2046 +\n            (\u2045L a, L (b * b)\u2046 + \u2045L b, L (b * b)\u2046 + \u2045L c, L (b * b)\u2046) +\n          (\u2045L a, L (b * c)\u2046 + \u2045L b, L (b * c)\u2046 + \u2045L c, L (b * c)\u2046)) +\n      (\u2045L a, L (a * c)\u2046 + \u2045L b, L (a * c)\u2046 + \u2045L c, L (a * c)\u2046 + (\u2045L a, L (b * c)\u2046 + \u2045L b, L (b * c)\u2046 + \u2045L c, L (b * c)\u2046) +\n        (\u2045L a, L (c * c)\u2046 + \u2045L b, L (c * c)\u2046 + \u2045L c, L (c * c)\u2046)) =\n    \u2045L a, L (a * a)\u2046 + \u2045L b, L (a * a)\u2046 + \u2045L c, L (a * a)\u2046 + (\u2045L a, L (b * b)\u2046 + \u2045L b, L (b * b)\u2046 + \u2045L c, L (b * b)\u2046) +\n            (\u2045L a, L (c * c)\u2046 + \u2045L b, L (c * c)\u2046 + \u2045L c, L (c * c)\u2046) +\n          (\u2045L a, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046 + \u2045L c, L (a * b)\u2046 +\n            (\u2045L a, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046 + \u2045L c, L (a * b)\u2046)) +\n        (\u2045L a, L (a * c)\u2046 + \u2045L b, L (a * c)\u2046 + \u2045L c, L (a * c)\u2046 +\n          (\u2045L a, L (a * c)\u2046 + \u2045L b, L (a * c)\u2046 + \u2045L c, L (a * c)\u2046)) +\n      (\u2045L a, L (b * c)\u2046 + \u2045L b, L (b * c)\u2046 + \u2045L c, L (b * c)\u2046 + (\u2045L a, L (b * c)\u2046 + \u2045L b, L (b * c)\u2046 + \u2045L c, L (b * c)\u2046))",["abel"]],["Algebra/Jordan/Basic.lean",209,"A : Type u_1\ninst\u271d\u00b9 : NonUnitalNonAssocCommRing A\ninst\u271d : IsCommJordan A\na b c : A\n\u22a2 \u2045L a, L (b * b)\u2046 + \u2045L a, L (c * c)\u2046 + 2 \u2022 \u2045L a, L (a * b)\u2046 + 2 \u2022 \u2045L a, L (c * a)\u2046 + 2 \u2022 \u2045L a, L (b * c)\u2046 +\n        (\u2045L b, L (a * a)\u2046 + \u2045L b, L (c * c)\u2046 + 2 \u2022 \u2045L b, L (a * b)\u2046 + 2 \u2022 \u2045L b, L (c * a)\u2046 + 2 \u2022 \u2045L b, L (b * c)\u2046) +\n      (\u2045L c, L (a * a)\u2046 + \u2045L c, L (b * b)\u2046 + 2 \u2022 \u2045L c, L (a * b)\u2046 + 2 \u2022 \u2045L c, L (c * a)\u2046 + 2 \u2022 \u2045L c, L (b * c)\u2046) =\n    \u2045L a, L (b * b)\u2046 + \u2045L b, L (a * a)\u2046 + 2 \u2022 (\u2045L a, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046) +\n          (\u2045L a, L (c * c)\u2046 + \u2045L c, L (a * a)\u2046 + 2 \u2022 (\u2045L a, L (c * a)\u2046 + \u2045L c, L (c * a)\u2046)) +\n        (\u2045L b, L (c * c)\u2046 + \u2045L c, L (b * b)\u2046 + 2 \u2022 (\u2045L b, L (b * c)\u2046 + \u2045L c, L (b * c)\u2046)) +\n      (2 \u2022 \u2045L a, L (b * c)\u2046 + 2 \u2022 \u2045L b, L (c * a)\u2046 + 2 \u2022 \u2045L c, L (a * b)\u2046)",["abel"]],["Algebra/Jordan/Basic.lean",225,"A : Type u_1\ninst\u271d\u00b9 : NonUnitalNonAssocCommRing A\ninst\u271d : IsCommJordan A\na b c : A\n\u22a2 \u2045L a, L (b * b)\u2046 + \u2045L b, L (a * a)\u2046 + (-\u2045L b, L (a * a)\u2046 + -\u2045L a, L (b * b)\u2046) +\n        (\u2045L a, L (c * c)\u2046 + \u2045L c, L (a * a)\u2046 + (-\u2045L c, L (a * a)\u2046 + -\u2045L a, L (c * c)\u2046)) +\n      (\u2045L b, L (c * c)\u2046 + \u2045L c, L (b * b)\u2046 + (-\u2045L c, L (b * b)\u2046 + -\u2045L b, L (c * c)\u2046)) =\n    0",["abel"]],["NumberTheory/SumFourSquares.lean",25,"R : Type u_1\ninst\u271d : CommRing R\na b c d x y z w : R\n\u22a2 (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)",["ring"]],["NumberTheory/SumFourSquares.lean",45,"m x y : \u2124\nh : 2 * m = x ^ 2 + y ^ 2\nthis : Even (x ^ 2 + y ^ 2)\n\u22a2 2 * (x ^ 2 + y ^ 2) = (x - y) ^ 2 + (x + y) ^ 2",["ring","linarith"]],["LinearAlgebra/RootSystem/Reduced.lean",120,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R N\nP : RootPairing \u03b9 R M N\ni j : \u03b9\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : CharZero R\ninst\u271d : NoZeroSMulDivisors R M\nthis : NoZeroSMulDivisors \u2124 M\nh : \u00acLinearIndependent R ![P.root j, P.root i]\nh\u2081 : P.pairing j i \u2022 P.root i = 2 \u2022 P.root j\nh\u2082 : P.pairing i j \u2022 P.root j = 2 \u2022 P.root i\n\u22a2 (2 * 2) \u2022 P.root i = 4 \u2022 P.root i",["norm_num","ring"]],["LinearAlgebra/RootSystem/Reduced.lean",135,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R N\nP : RootPairing \u03b9 R M N\ni j : \u03b9\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : CharZero R\ninst\u271d : NoZeroSMulDivisors R M\nx\u271d : P.pairing i j = 2 \u2227 P.pairing j i = 2\nh\u2081 : P.pairing i j = 2\nh\u2082 : P.pairing j i = 2\n\u22a2 2 * 2 = 4",["norm_num","ring"]],["NumberTheory/ModularForms/EisensteinSeries/UniformConvergence.lean",62,"z : \u210d\nc d : \u211d\nhd : 1 \u2264 d ^ 2\n\u22a2 (c * z.re + d) ^ 2 + (c * z.im) ^ 2 = c ^ 2 * (z.re ^ 2 + z.im ^ 2) + d * 2 * c * z.re + d ^ 2",["ring","linarith"]],["NumberTheory/ModularForms/EisensteinSeries/UniformConvergence.lean",64,"z : \u210d\nc d : \u211d\nhd : 1 \u2264 d ^ 2\nH1 : (c * z.re + d) ^ 2 + (c * z.im) ^ 2 = c ^ 2 * (z.re ^ 2 + z.im ^ 2) + d * 2 * c * z.re + d ^ 2\n\u22a2 (c ^ 2 * (z.re ^ 2 + z.im ^ 2) + d * 2 * c * z.re + d ^ 2) * (z.re ^ 2 + z.im ^ 2) - z.im ^ 2 =\n    (c * (z.re ^ 2 + z.im ^ 2) + d * z.re) ^ 2 + (d ^ 2 - 1) * z.im ^ 2",["ring","linarith"]],["Algebra/Order/CauSeq/BigOperators.lean",78,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nha : IsCauSeq abs fun m \u21a6 \u2211 n \u2208 range m, abv (f n)\nhb : IsCauSeq abv fun m \u21a6 \u2211 n \u2208 range m, g n\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\nP : \u03b1\nhP : \u2200 (i : \u2115), |\u2211 n \u2208 range i, abv (f n)| < P\nQ : \u03b1\nhQ : \u2200 (i : \u2115), abv (\u2211 n \u2208 range i, g n) < Q\nhP0 : 0 < P\nhP\u03b50 : 0 < \u03b5 / (2 * P)\nN : \u2115\nhN : \u2200 j \u2265 N, \u2200 k \u2265 N, abv (\u2211 n \u2208 range j, g n - \u2211 n \u2208 range k, g n) < \u03b5 / (2 * P)\nhQ\u03b50 : 0 < \u03b5 / (4 * Q)\nM : \u2115\nhM : \u2200 j \u2265 M, \u2200 k \u2265 M, |\u2211 n \u2208 range j, abv (f n) - \u2211 n \u2208 range k, abv (f n)| < \u03b5 / (4 * Q)\nK : \u2115\nhK : K \u2265 2 * (N \u2294 M + 1)\nh\u2081 : \u2211 m \u2208 range K, \u2211 k \u2208 range (m + 1), f k * g (m - k) = \u2211 m \u2208 range K, \u2211 n \u2208 range (K - m), f m * g n\nh\u2082 : (fun i \u21a6 \u2211 k \u2208 range (K - i), f i * g k) = fun i \u21a6 f i * \u2211 k \u2208 range (K - i), g k\nh\u2083 :\n  \u2211 i \u2208 range K, f i * \u2211 k \u2208 range (K - i), g k =\n    \u2211 i \u2208 range K, f i * (\u2211 k \u2208 range (K - i), g k - \u2211 k \u2208 range K, g k) + \u2211 i \u2208 range K, f i * \u2211 k \u2208 range K, g k\n\u22a2 4 = 2 * 2",["norm_num","ring","linarith"]],["Data/Real/Cardinality.lean",115,"c : \u211d\nh1 : 0 < c\nh2 : c < 1 / 2\nn : \u2115\nf g : \u2115 \u2192 Bool\nhn : \u2200 k < n, f k = g k\nfn : f n = false\ngn : g n = true\n\u22a2 1 / 2 < 1",["norm_num","linarith"]],["Data/Real/Cardinality.lean",135,"case h.e'_4\nc : \u211d\nh1 : 0 < c\nh2 : c < 1 / 2\nh3 : c < 1\nf g : \u2115 \u2192 Bool\nhn : \u2200 k < 0, f k = g k\nfn : f 0 = false\ngn : g 0 = true\nf_max : \u2115 \u2192 Bool := fun n \u21a6 rec false (fun x x \u21a6 true) n\nhf_max : \u2200 (n : \u2115), f n = true \u2192 f_max n = true\ng_min : \u2115 \u2192 Bool := fun n \u21a6 rec true (fun x x \u21a6 false) n\nhg_min : \u2200 (n : \u2115), g_min n = true \u2192 g n = true\n\u22a2 1 = 1 / 2 + 1 / 2",["norm_num","ring","linarith"]],["Analysis/NormedSpace/HahnBanach/SeparatingDual.lean",129,"R : Type u_1\nV : Type u_2\ninst\u271d\u2078 : Field R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : TopologicalSpace R\ninst\u271d\u2075 : TopologicalSpace V\ninst\u271d\u2074 : IsTopologicalRing R\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : SeparatingDual R V\ninst\u271d\u00b9 : IsTopologicalAddGroup V\ninst\u271d : ContinuousSMul R V\nx y : V\nhx : x \u2260 0\nhy : y \u2260 0\nG : V \u2192L[R] R\nGx : G x = 1\nGy : G y \u2260 0\na b : V\n\u22a2 a + b + (G a \u2022 (y - x) + G b \u2022 (y - x)) = a + G a \u2022 (y - x) + (b + G b \u2022 (y - x))",["abel"]],["Analysis/NormedSpace/HahnBanach/SeparatingDual.lean",137,"R : Type u_1\nV : Type u_2\ninst\u271d\u2078 : Field R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : TopologicalSpace R\ninst\u271d\u2075 : TopologicalSpace V\ninst\u271d\u2074 : IsTopologicalRing R\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : SeparatingDual R V\ninst\u271d\u00b9 : IsTopologicalAddGroup V\ninst\u271d : ContinuousSMul R V\nx y : V\nhx : x \u2260 0\nhy : y \u2260 0\nG : V \u2192L[R] R\nGx : G x = 1\nGy : G y \u2260 0\nz : V\n\u22a2 z + (G z \u2022 y - G z \u2022 x) + (G z \u2022 x - G z \u2022 y) = z",["abel"]],["Analysis/NormedSpace/HahnBanach/SeparatingDual.lean",144,"R : Type u_1\nV : Type u_2\ninst\u271d\u2078 : Field R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : TopologicalSpace R\ninst\u271d\u2075 : TopologicalSpace V\ninst\u271d\u2074 : IsTopologicalRing R\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : SeparatingDual R V\ninst\u271d\u00b9 : IsTopologicalAddGroup V\ninst\u271d : ContinuousSMul R V\nx y : V\nhx : x \u2260 0\nhy : y \u2260 0\nG : V \u2192L[R] R\nGx : G x = 1\nGy : G y \u2260 0\nz : V\n\u22a2 z + (((G y)\u207b\u00b9 * G z) \u2022 x - ((G y)\u207b\u00b9 * G z) \u2022 y) + (((G y)\u207b\u00b9 * G z) \u2022 y - ((G y)\u207b\u00b9 * G z) \u2022 x) = z",["abel"]],["Analysis/Convex/Mul.lean",42,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2079 : LinearOrderedCommRing \ud835\udd5c\ninst\u271d\u2078 : LinearOrderedCommRing E\ninst\u271d\u2077 : LinearOrderedAddCommGroup F\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : Module \ud835\udd5c F\ninst\u271d\u2074 : Module E F\ninst\u271d\u00b3 : IsScalarTower \ud835\udd5c E F\ninst\u271d\u00b2 : SMulCommClass \ud835\udd5c E F\ninst\u271d\u00b9 : OrderedSMul \ud835\udd5c F\ninst\u271d : OrderedSMul E F\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\ng : \ud835\udd5c \u2192 F\nhf : ConvexOn \ud835\udd5c s f\nhg : ConvexOn \ud835\udd5c s g\nhf\u2080 : \u2200 \u2983x : \ud835\udd5c\u2984, x \u2208 s \u2192 0 \u2264 f x\nhg\u2080 : \u2200 \u2983x : \ud835\udd5c\u2984, x \u2208 s \u2192 0 \u2264 g x\nhfg : MonovaryOn f g s\nx : \ud835\udd5c\nhx : x \u2208 s\ny : \ud835\udd5c\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 (a * a) \u2022 f x \u2022 g x + (b * b) \u2022 f y \u2022 g y + ((a * b) \u2022 f x \u2022 g x + (a * b) \u2022 f y \u2022 g y) =\n    (a * a) \u2022 f x \u2022 g x + (a * b) \u2022 f x \u2022 g x + ((a * b) \u2022 f y \u2022 g y + (b * b) \u2022 f y \u2022 g y)",["abel"]],["Analysis/Convex/Mul.lean",60,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b9\u2070 : LinearOrderedCommRing \ud835\udd5c\ninst\u271d\u2079 : LinearOrderedCommRing E\ninst\u271d\u2078 : LinearOrderedAddCommGroup F\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c F\ninst\u271d\u2075 : Module E F\ninst\u271d\u2074 : IsScalarTower \ud835\udd5c E F\ninst\u271d\u00b3 : SMulCommClass \ud835\udd5c E F\ninst\u271d\u00b2 : OrderedSMul \ud835\udd5c F\ninst\u271d\u00b9 : OrderedSMul E F\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\ng : \ud835\udd5c \u2192 F\ninst\u271d : OrderedSMul \ud835\udd5c E\nhf : ConcaveOn \ud835\udd5c s f\nhg : ConcaveOn \ud835\udd5c s g\nhf\u2080 : \u2200 \u2983x : \ud835\udd5c\u2984, x \u2208 s \u2192 0 \u2264 f x\nhg\u2080 : \u2200 \u2983x : \ud835\udd5c\u2984, x \u2208 s \u2192 0 \u2264 g x\nhfg : AntivaryOn f g s\nx : \ud835\udd5c\nhx : x \u2208 s\ny : \ud835\udd5c\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 (a * a) \u2022 f x \u2022 g x + (a * b) \u2022 f x \u2022 g x + ((a * b) \u2022 f y \u2022 g y + (b * b) \u2022 f y \u2022 g y) =\n    (a * a) \u2022 f x \u2022 g x + (b * b) \u2022 f y \u2022 g y + ((a * b) \u2022 f x \u2022 g x + (a * b) \u2022 f y \u2022 g y)",["abel"]],["Analysis/Convex/Mul.lean",160,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedCommRing \ud835\udd5c\nn : \u2115\nx : \ud835\udd5c\nx\u271d\u00b9 : x \u2208 univ\ny : \ud835\udd5c\nx\u271d : y \u2208 univ\nb : \ud835\udd5c\nhb : 0 \u2264 b\nha : 0 \u2264 1 - b\nhab : 1 - b + b = 1\n\u22a2 (1 - b) * b * (x - y) ^ 2 = (1 - b) * x ^ 2 + b * y ^ 2 - ((1 - b) * x + b * y) ^ 2",["ring"]],["Analysis/Convex/Mul.lean",181,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\nn : \u2115\nx : \ud835\udd5c\nhx : 0 < x\ny : \ud835\udd5c\nhy : 0 < y\nb : \ud835\udd5c\nhb : 0 < b\nha : 0 < 1 - b\nhab : 1 - b + b = 1\n\u22a2 (1 - b) * b * (x - y) ^ 2 = ((1 - b) * y + b * x) * ((1 - b) * x + b * y) - 1 * (x * y)",["ring"]],["MeasureTheory/Measure/LogLikelihoodRatio.lean",168,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\ninst\u271d\u00b9 : IsProbabilityMeasure \u03bc\ninst\u271d : SigmaFinite \u03bd\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nhf : Integrable f \u03bc\nh_int : Integrable (llr \u03bc \u03bd) \u03bc\nhf\u03bc : Integrable (fun x \u21a6 rexp (f x)) \u03bc\nhf\u03bd : AEMeasurable f \u03bd\n\u22a2 \u222b (x : \u03b1), f x \u2202\u03bc - log (\u222b (x : \u03b1), rexp (f x) \u2202\u03bc) + \u222b (x : \u03b1), llr \u03bc \u03bd x \u2202\u03bc =\n    \u222b (x : \u03b1), llr \u03bc \u03bd x \u2202\u03bc + \u222b (x : \u03b1), f x \u2202\u03bc - log (\u222b (x : \u03b1), rexp (f x) \u2202\u03bc)",["abel","ring","linarith"]],["MeasureTheory/Measure/LogLikelihoodRatio.lean",205,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\ninst\u271d\u00b9 : IsProbabilityMeasure \u03bc\ninst\u271d : SigmaFinite \u03bd\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nhf\u03bc : Integrable f \u03bc\nhf\u03bd : Integrable (fun x \u21a6 rexp (f x)) \u03bd\nh_int : Integrable (llr \u03bc \u03bd) \u03bc\n\u22a2 -\u222b (x : \u03b1), f x \u2202\u03bc + log (\u222b (x : \u03b1), rexp (f x) \u2202\u03bd) + \u222b (x : \u03b1), llr \u03bc \u03bd x \u2202\u03bc =\n    \u222b (x : \u03b1), llr \u03bc \u03bd x \u2202\u03bc - \u222b (x : \u03b1), f x \u2202\u03bc + log (\u222b (x : \u03b1), rexp (f x) \u2202\u03bd)",["abel","ring","linarith"]],["MeasureTheory/Measure/LogLikelihoodRatio.lean",100,"case h\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : \u03bc.HaveLebesgueDecomposition \u03bd\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nc : \u211d\u22650\u221e\nhc : c \u2260 0\nhc_ne_top : c \u2260 \u22a4\nh : (c \u2022 \u03bc).rnDeriv \u03bd =\u1da0[ae \u03bd] c \u2022 \u03bc.rnDeriv \u03bd\nx : \u03b1\nhx_eq : (c \u2022 \u03bc).rnDeriv \u03bd x = (c \u2022 \u03bc.rnDeriv \u03bd) x\nhx_pos : 0 < \u03bc.rnDeriv \u03bd x\nhx_ne_top : \u03bc.rnDeriv \u03bd x < \u22a4\n\u22a2 log c.toReal + log (\u03bc.rnDeriv \u03bd x).toReal = log (\u03bc.rnDeriv \u03bd x).toReal + log c.toReal",["ring","linarith","abel"]],["MeasureTheory/Measure/LogLikelihoodRatio.lean",118,"case h\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : \u03bc.HaveLebesgueDecomposition \u03bd\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nc : \u211d\u22650\u221e\nhc : c \u2260 0\nhc_ne_top : c \u2260 \u22a4\nh : \u03bc.rnDeriv (c \u2022 \u03bd) =\u1da0[ae \u03bd] c\u207b\u00b9 \u2022 \u03bc.rnDeriv \u03bd\nx : \u03b1\nhx_eq : \u03bc.rnDeriv (c \u2022 \u03bd) x = (c\u207b\u00b9 \u2022 \u03bc.rnDeriv \u03bd) x\nhx_pos : 0 < \u03bc.rnDeriv \u03bd x\nhx_ne_top : \u03bc.rnDeriv \u03bd x < \u22a4\n\u22a2 -log c.toReal + log (\u03bc.rnDeriv \u03bd x).toReal = log (\u03bc.rnDeriv \u03bd x).toReal - log c.toReal",["ring","linarith","abel"]],["NumberTheory/Transcendental/Lindemann/Init/AnalyticalPart.lean",35,"case h.e'_9\np : \u2102[X]\ns : \u2102\nx : \u211d\nh\u2080 : HasDerivAt (fun y \u21a6 y \u2022 s) (1 \u2022 s) x\nh\u2081 : HasDerivAt (fun x \u21a6 cexp (-(x \u2022 s))) (cexp (-(x \u2022 s)) * -(1 \u2022 s)) x\nh\u2082 : HasDerivAt ((fun x \u21a6 eval x (sumIDeriv p)) \u2218 fun y \u21a6 y \u2022 s) (eval (x \u2022 s) (derivative (sumIDeriv p)) * 1 \u2022 s) x\n\u22a2 s * (cexp (-(x \u2022 s)) * eval (x \u2022 s) p) =\n    -(cexp (-(x \u2022 s)) * -s * (eval (x \u2022 s) p + eval (x \u2022 s) (derivative (sumIDeriv p))) +\n        cexp (-(x \u2022 s)) * (eval (x \u2022 s) (derivative (sumIDeriv p)) * s))",["ring"]],["NumberTheory/Transcendental/Lindemann/Init/AnalyticalPart.lean",189,"f : \u2124[X]\nhf : eval 0 f \u2260 0\nc' : \u2102 \u2192 \u211d\nc'0 : \u2200 (s : \u2102), c' s \u2265 0\nPp'_le : \u2200 (s : \u2102) (p : \u2115), p \u2260 0 \u2192 \u2016LindemannWeierstrass.P (map (algebraMap \u2124 \u2102) (X ^ (p - 1) * f ^ p)) s\u2016 \u2264 c' s ^ p\np : \u2115\np_gt : p > (eval 0 f).natAbs\nprime_p : Nat.Prime p\ngp' : \u2124[X]\nh' : eval 0 (sumIDeriv (X ^ (p - 1) * f ^ p)) = (p - 1)! \u2022 eval 0 (f ^ p) + p ! \u2022 eval 0 gp'\ngp : \u2124[X]\ngp'_le : gp.natDegree \u2264 (X ^ (p - 1) * f ^ p).natDegree - p\nr : \u2102\nhr : r \u2208 f.aroots \u2102\nh : (aeval r) (sumIDeriv (X ^ (p - 1) * f ^ p)) = \u2191p ! * (aeval r) gp\n\u22a2 ((\u2191(eval 0 f) ^ p + \u2191p * \u2191(eval 0 gp')) * cexp r - \u2191p * (aeval r) gp) * \u2191(p - 1)! =\n    \u2191(eval 0 f) ^ p * cexp r * \u2191(p - 1)! + \u2191p * \u2191(p - 1)! * (\u2191(eval 0 gp') * cexp r - (aeval r) gp)",["ring"]],["NumberTheory/Transcendental/Lindemann/Init/AnalyticalPart.lean",197,"f : \u2124[X]\nhf : eval 0 f \u2260 0\nc' : \u2102 \u2192 \u211d\nc'0 : \u2200 (s : \u2102), c' s \u2265 0\nPp'_le : \u2200 (s : \u2102) (p : \u2115), p \u2260 0 \u2192 \u2016LindemannWeierstrass.P (map (algebraMap \u2124 \u2102) (X ^ (p - 1) * f ^ p)) s\u2016 \u2264 c' s ^ p\np : \u2115\np_gt : p > (eval 0 f).natAbs\nprime_p : Nat.Prime p\ngp' : \u2124[X]\nh' : eval 0 (sumIDeriv (X ^ (p - 1) * f ^ p)) = (p - 1)! \u2022 eval 0 (f ^ p) + p ! \u2022 eval 0 gp'\ngp : \u2124[X]\ngp'_le : gp.natDegree \u2264 (X ^ (p - 1) * f ^ p).natDegree - p\nr : \u2102\nhr : r \u2208 f.aroots \u2102\nh : (aeval r) (sumIDeriv (X ^ (p - 1) * f ^ p)) = \u2191p ! * (aeval r) gp\nthis :\n  (\u2191(eval 0 f ^ p + \u2191p * eval 0 gp') * cexp r - \u2191p * (aeval r) gp) * \u2191(p - 1)! =\n    \u2191(eval 0 f) ^ p * cexp r * \u2191(p - 1)! + \u2191(p * (p - 1)!) * (\u2191(eval 0 gp') * cexp r - (aeval r) gp)\n\u22a2 \u2191(eval 0 f) ^ p * cexp r * \u2191(p - 1)! + (\u2191p ! * (\u2191(eval 0 gp') * cexp r) - (aeval r) (sumIDeriv (X ^ (p - 1) * f ^ p))) =\n    (\u2191(p - 1)! * \u2191(eval 0 f) ^ p + \u2191p ! * \u2191(eval 0 gp')) * cexp r - (aeval r) (sumIDeriv (X ^ (p - 1) * f ^ p))",["ring"]],["NumberTheory/Zsqrtd/GaussianInt.lean",192,"x y : \u2124[i]\n\u22a2 2\u207b\u00b9 * 2\u207b\u00b9 + 2\u207b\u00b9 * 2\u207b\u00b9 < 1",["norm_num"]],["Analysis/Fourier/Inversion.lean",84,"case h.e'_3.h.h.e'_7.h.e_a.e_z.e_a\nV : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : InnerProductSpace \u211d V\ninst\u271d\u2075 : MeasurableSpace V\ninst\u271d\u2074 : BorelSpace V\ninst\u271d\u00b3 : FiniteDimensional \u211d V\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nf : V \u2192 E\ninst\u271d : CompleteSpace E\nhf : Integrable f volume\nh'f : Integrable (\ud835\udcd5 f) volume\nv : V\nthis : Integrable (fun w \u21a6 \ud835\udc1e (inner w v) \u2022 \ud835\udcd5 f w) volume\nc : \u211d\nw : V\n\u22a2 2 * \u2191\u03c0 * I * \u2191(inner w v) = 2 * \u2191\u03c0 * \u2191(inner w v) * I",["ring"]],["Analysis/Fourier/Inversion.lean",101,"case h.e_f.h.e_a.e_a.e_z\nV : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : InnerProductSpace \u211d V\ninst\u271d\u2075 : MeasurableSpace V\ninst\u271d\u2074 : BorelSpace V\ninst\u271d\u00b3 : FiniteDimensional \u211d V\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nf : V \u2192 E\ninst\u271d : CompleteSpace E\nhf : Integrable f volume\nh'f : Integrable (\ud835\udcd5 f) volume\nv : V\nA : Tendsto (fun c \u21a6 \u222b (w : V), cexp (-\u2191c\u207b\u00b9 * \u2191\u2016w\u2016 ^ 2 + 2 * \u2191\u03c0 * I * \u2191(inner v w)) \u2022 \ud835\udcd5 f w) atTop (\ud835\udcdd (\ud835\udcd5\u207b (\ud835\udcd5 f) v))\nB :\n  Tendsto (fun c \u21a6 \u222b (w : V), \ud835\udcd5 (fun w \u21a6 cexp (-\u2191c\u207b\u00b9 * \u2191\u2016w\u2016 ^ 2 + 2 * \u2191\u03c0 * I * \u2191(inner v w))) w \u2022 f w) atTop\n    (\ud835\udcdd (\ud835\udcd5\u207b (\ud835\udcd5 f) v))\nc : \u211d\nhc : 0 < c\nw : V\n\u22a2 \u2191\u03c0 ^ 2 * \u2191\u2016v - w\u2016 ^ 2 * \u2191c = \u2191\u03c0 ^ 2 * \u2191c * \u2191\u2016v - w\u2016 ^ 2",["ring"]],["NumberTheory/Cyclotomic/Three.lean",80,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\n\u22a2 (\u03b6 - 1) ^ 2 = \u03b6 ^ 2 + \u03b6 + 1 - 3 * \u03b6",["ring"]],["NumberTheory/Cyclotomic/Three.lean",151,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\n\u22a2 -\u2191\u03b7 - 1 + \u2191\u03b7 + 1 = 0",["ring","abel"]],["NumberTheory/Cyclotomic/Three.lean",156,"K : Type u_1\ninst\u271d : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nx : \ud835\udcde K\n\u22a2 (x - 1) * (x - \u2191\u03b7) * (x - \u2191\u03b7 ^ 2) = x ^ 3 - x ^ 2 * (\u2191\u03b7 ^ 2 + \u2191\u03b7 + 1) + x * (\u2191\u03b7 ^ 2 + \u2191\u03b7 + \u2191\u03b7 ^ 3) - \u2191\u03b7 ^ 3",["ring"]],["NumberTheory/Cyclotomic/Three.lean",178,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nx y : \ud835\udcde K\nhy : x - 1 = \u03bb * y\n\u22a2 (x - 1) * (x - h\u03b6.toInteger) * (x - h\u03b6.toInteger ^ 2) = (x - 1) * (x - 1 - \u03bb) * (x - 1 - \u03bb * (h\u03b6.toInteger + 1))",["ring"]],["NumberTheory/Cyclotomic/Three.lean",179,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nx y : \ud835\udcde K\nhy : x - 1 = \u03bb * y\n\u22a2 \u03bb * y * (\u03bb * y - \u03bb) * (\u03bb * y - \u03bb * (\u2191\u03b7 + 1)) = \u03bb ^ 3 * (y * (y - 1) * (y - (\u2191\u03b7 + 1)))",["ring"]],["NumberTheory/Cyclotomic/Three.lean",190,"case h.e'_4\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nx : \ud835\udcde K\nh : \u03bb \u2223 -x - 1\n\u22a2 x ^ 3 + 1 = -((-x) ^ 3 - 1)",["ring"]],["Analysis/Complex/Polynomial/Basic.lean",183,"p : \u211d[X]\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 X ^ 2 - (C z + C ((starRingEnd \u2102) z)) * X + C z * C ((starRingEnd \u2102) z) = (X - C ((starRingEnd \u2102) z)) * (X - C z)",["ring"]],["Topology/Bornology/BoundedOperation.lean",184,"case h.e'_5\nR : Type u_1\ninst\u271d : SeminormedAddCommGroup R\n\u22a2 2 = 1 + 1",["norm_num","ring"]],["Combinatorics/Additive/Corner/Roth.lean",128,"n : \u2115\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhn : cornersTheoremBound (\u03b5 / 9) \u2264 n\nA : Finset (\u2115 \u00d7 \u2115)\nhAn : \u2191A \u2286 \u2191(range n) \u00d7\u02e2 \u2191(range n)\nhA\u03b5 : \u03b5 * \u2191n ^ 2 \u2264 \u2191(#A)\nhA : IsCornerFree (Prod.map Fin.val Fin.val '' (Prod.map Nat.cast Nat.cast '' \u2191A))\nthis\u271d\u00b9 : \u2191A = Prod.map Fin.val Fin.val '' (Prod.map Nat.cast Nat.cast '' \u2191A)\nthis\u271d : IsAddFreimanIso 2 (Set.Iio \u2191n) (Set.Iio n) Fin.val\nthis : IsCornerFree \u2191(image (Prod.map Nat.cast Nat.cast) A)\n\u22a2 \u03b5 / 9 * (2 * \u2191n + \u2191n) ^ 2 = \u03b5 * \u2191n ^ 2",["ring","linarith"]],["Combinatorics/Additive/Corner/Roth.lean",146,"G : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Fintype G\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhG : cornersTheoremBound \u03b5 \u2264 Fintype.card G\nA : Finset G\nhA\u03b5 : \u03b5 * \u2191(Fintype.card G) \u2264 \u2191(#A)\nhA : ThreeAPFree \u2191A\nB : Finset (G \u00d7 G) :=\n  filter\n    (fun x \u21a6\n      match x with\n      | (x, y) => y - x \u2208 A)\n    univ\n\u22a2 \u03b5 * \u2191(Fintype.card G) ^ 2 = \u2191(Fintype.card G) * (\u03b5 * \u2191(Fintype.card G))",["ring","linarith"]],["Combinatorics/Additive/Corner/Roth.lean",185,"n : \u2115\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhG : cornersTheoremBound (\u03b5 / 3) \u2264 n\nA : Finset \u2115\nhAn : \u2191A \u2286 Set.Iio n\nhA\u03b5 : \u03b5 * \u2191n \u2264 \u2191(#A)\nhA : ThreeAPFree (Fin.val '' (Nat.cast '' \u2191A))\nthis\u271d\u00b9 : \u2191A = Fin.val '' (Nat.cast '' \u2191A)\nthis\u271d : IsAddFreimanIso 2 (Set.Iio \u2191n) (Set.Iio n) Fin.val\nthis : ThreeAPFree \u2191(image (fun x \u21a6 \u2191x) A)\n\u22a2 \u03b5 / 3 * (2 * \u2191n + \u2191n) = \u03b5 * \u2191n",["ring","linarith"]],["RingTheory/Ideal/Maximal.lean",186,"case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\ninst\u271d : CommSemiring \u03b1\nI : Ideal \u03b1\nS : Submonoid \u03b1\ndisjoint : Disjoint \u2191I \u2191S\nmaximally_disjoint : \u2200 (J : Ideal \u03b1), I < J \u2192 \u00acDisjoint \u2191J \u2191S\nx y : \u03b1\nhxy : x * y \u2208 I\nrid : x \u2209 I \u2227 y \u2209 I\ns\u2081 : \u03b1\nhs\u2081 : s\u2081 \u2208 S\ni\u2081 : \u03b1\nhi\u2081 : i\u2081 \u2208 I\nr\u2081 : \u03b1\nhr\u2081 : i\u2081 + x * r\u2081 = s\u2081\ns\u2082 : \u03b1\nhs\u2082 : s\u2082 \u2208 S\ni\u2082 : \u03b1\nhi\u2082 : i\u2082 \u2208 I\nr\u2082 : \u03b1\nhr\u2082 : i\u2082 + y * r\u2082 = s\u2082\n\u22a2 (i\u2081 + x * r\u2081) * i\u2082 + (i\u2081 * (y * r\u2082) + x * y * (r\u2081 * r\u2082)) = (i\u2081 + x * r\u2081) * (i\u2082 + y * r\u2082)",["ring"]],["AlgebraicTopology/DoldKan/Faces.lean",133,"case a.h.mk.e_a\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn a q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhnaq : n = a + q\nhnaq_shift : \u2200 (d : \u2115), n + d = a + d + q\nsimplif : \u2200 (a b c d e f : Y \u27f6 X _\u298bn + 1\u298c), b = f \u2192 d + e = 0 \u2192 c + a = 0 \u2192 a + b + (c + d + e) = f\ni : \u2115\nhi : i < a + 1\na\u271d : \u27e8i, hi\u27e9 \u2208 Finset.univ\nhia : \u27e8i, \u22ef\u27e9 \u2264 \u27e8a, \u22ef\u27e9.castSucc\n\u22a2 (-1) ^ i * (-1) ^ (a + 1) = -((-1) ^ a * (-1) ^ i)",["ring"]],["GroupTheory/CommutingProbability.lean",136,"case e_a.e_a\nn : \u2115\nhn : Odd n\n\u22a2 2 * 2 = 4",["norm_num","ring","linarith"]],["GroupTheory/CommutingProbability.lean",198,"case neg.inl\nn : \u2115\nh0 : \u00acn = 0\nh1 : \u00acn = 1\nh2 : Even n\nthis : n / 2 < n\n\u22a2 (3 + 3) * 2 = 4 * 3",["norm_num","ring","linarith"]],["Geometry/Manifold/Algebra/LeftInvariantDerivation.lean",240,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nn : WithTop \u2115\u221e\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2074 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nG : Type u_4\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : ChartedSpace H G\ninst\u271d\u00b9 : Monoid G\ninst\u271d : ContMDiffMul I \u221e G\ng h : G\nr : \ud835\udd5c\nX\u271d Y\u271d : LeftInvariantDerivation I G\nf f' : C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef\nX Y Z : LeftInvariantDerivation I G\nf\u271d : C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef\n\u22a2 X (Z f\u271d) + Y (Z f\u271d) - (Z (X f\u271d) + Z (Y f\u271d)) = X (Z f\u271d) - Z (X f\u271d) + (Y (Z f\u271d) - Z (Y f\u271d))",["ring","abel"]],["Geometry/Manifold/Algebra/LeftInvariantDerivation.lean",244,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nn : WithTop \u2115\u221e\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2074 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nG : Type u_4\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : ChartedSpace H G\ninst\u271d\u00b9 : Monoid G\ninst\u271d : ContMDiffMul I \u221e G\ng h : G\nr : \ud835\udd5c\nX\u271d Y\u271d : LeftInvariantDerivation I G\nf f' : C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef\nX Y Z : LeftInvariantDerivation I G\nf\u271d : C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef\n\u22a2 X (Y f\u271d) + X (Z f\u271d) - (Y (X f\u271d) + Z (X f\u271d)) = X (Y f\u271d) - Y (X f\u271d) + (X (Z f\u271d) - Z (X f\u271d))",["ring","abel"]],["Geometry/Manifold/Algebra/LeftInvariantDerivation.lean",249,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nn : WithTop \u2115\u221e\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nH : Type u_3\ninst\u271d\u2074 : TopologicalSpace H\nI : ModelWithCorners \ud835\udd5c E H\nG : Type u_4\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : ChartedSpace H G\ninst\u271d\u00b9 : Monoid G\ninst\u271d : ContMDiffMul I \u221e G\ng h : G\nr : \ud835\udd5c\nX\u271d Y\u271d : LeftInvariantDerivation I G\nf f' : C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef\nX Y Z : LeftInvariantDerivation I G\nf\u271d : C^\u221e\u27eeI, G; \ud835\udcd8(\ud835\udd5c, \ud835\udd5c), \ud835\udd5c\u27ef\n\u22a2 X (Y (Z f\u271d)) - X (Z (Y f\u271d)) - (Y (Z (X f\u271d)) - Z (Y (X f\u271d))) =\n    X (Y (Z f\u271d)) - Y (X (Z f\u271d)) - (Z (X (Y f\u271d)) - Z (Y (X f\u271d))) +\n      (Y (X (Z f\u271d)) - Y (Z (X f\u271d)) - (X (Z (Y f\u271d)) - Z (X (Y f\u271d))))",["ring","abel"]],["Combinatorics/Additive/DoublingConst.lean",191,"G : Type u_1\ninst\u271d\u00b9 : CommGroup G\ninst\u271d : DecidableEq G\nA : Finset G\nhA' : A.Nonempty\n\u22a2 \u03b4\u2098[A] * \u2191(#A) * (\u03b4\u2098[A] * \u2191(#A)) = \u03b4\u2098[A] ^ 2 * (\u2191(#A) * \u2191(#A))",["ring"]],["Combinatorics/Additive/DoublingConst.lean",207,"G : Type u_1\ninst\u271d\u00b9 : CommGroup G\ninst\u271d : DecidableEq G\nA : Finset G\nhA' : A.Nonempty\n\u22a2 \u03c3\u2098[A] * \u2191(#A) * (\u03c3\u2098[A] * \u2191(#A)) = \u03c3\u2098[A] ^ 2 * (\u2191(#A) * \u2191(#A))",["ring"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",48,"\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 2\u207b\u00b9 < 1",["norm_num","linarith"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",81,"\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\nP : Finpartition univ\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhP\u2081 : P.IsEquipartition\nhP\u2083 : #P.parts \u2264 bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a\nx y z : \u03b1\ns : Finset \u03b1\nhX : s \u2208 P.parts\nY : Finset \u03b1\nhY : Y \u2208 P.parts\nxX : x \u2208 s\nyY : y \u2208 Y\nnXY : s \u2260 Y\nuXY : G.IsUniform (\u03b5 / 8) s Y\ndXY\u271d : \u03b5 / 4 \u2264 \u2191(G.edgeDensity s Y)\nZ : Finset \u03b1\nhZ : Z \u2208 P.parts\nzZ : z \u2208 Z\nhX' : s \u2208 P.parts\nxX' : x \u2208 s\nnXZ : s \u2260 Z\nuXZ : G.IsUniform (\u03b5 / 8) s Z\ndXZ\u271d : \u03b5 / 4 \u2264 \u2191(G.edgeDensity s Z)\nhY' : Y \u2208 P.parts\nyY' : y \u2208 Y\nhZ' : Z \u2208 P.parts\nzZ' : z \u2208 Z\nnYZ : Y \u2260 Z\nuYZ : G.IsUniform (\u03b5 / 8) Y Z\ndYZ\u271d : \u03b5 / 4 \u2264 \u2191(G.edgeDensity Y Z)\ndXY : Function.onFun Disjoint id s Y\ndXZ : Function.onFun Disjoint id s Z\ndYZ : Function.onFun Disjoint id Y Z\n\u22a2 2 * (\u03b5 / 8) = \u03b5 / 4",["ring","linarith"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",89,"\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\nP : Finpartition univ\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhP\u2081 : P.IsEquipartition\nhP\u2083 : #P.parts \u2264 bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a\nx y z : \u03b1\ns : Finset \u03b1\nhX : s \u2208 P.parts\nY : Finset \u03b1\nhY : Y \u2208 P.parts\nxX : x \u2208 s\nyY : y \u2208 Y\nnXY : s \u2260 Y\nuXY : G.IsUniform (\u03b5 / 8) s Y\ndXY\u271d : \u03b5 / 4 \u2264 \u2191(G.edgeDensity s Y)\nZ : Finset \u03b1\nhZ : Z \u2208 P.parts\nzZ : z \u2208 Z\nhX' : s \u2208 P.parts\nxX' : x \u2208 s\nnXZ : s \u2260 Z\nuXZ : G.IsUniform (\u03b5 / 8) s Z\ndXZ\u271d : \u03b5 / 4 \u2264 \u2191(G.edgeDensity s Z)\nhY' : Y \u2208 P.parts\nyY' : y \u2208 Y\nhZ' : Z \u2208 P.parts\nzZ' : z \u2208 Z\nnYZ : Y \u2260 Z\nuYZ : G.IsUniform (\u03b5 / 8) Y Z\ndYZ\u271d : \u03b5 / 4 \u2264 \u2191(G.edgeDensity Y Z)\ndXY : Function.onFun Disjoint id s Y\ndXZ : Function.onFun Disjoint id s Z\ndYZ : Function.onFun Disjoint id Y Z\nthat : 2 * (\u03b5 / 8) = \u03b5 / 4\nthis : 0 \u2264 1 - 2 * (\u03b5 / 8)\n\u22a2 (1 - \u03b5 / 4) * (\u03b5 / (16 * \u2191(bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a))) ^ 3 * \u2191(Fintype.card \u03b1) ^ 3 =\n    (1 - 2 * (\u03b5 / 8)) * (\u03b5 / 8) ^ 3 * (\u2191(Fintype.card \u03b1) / (2 * \u2191(bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a))) *\n        (\u2191(Fintype.card \u03b1) / (2 * \u2191(bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a))) *\n      (\u2191(Fintype.card \u03b1) / (2 * \u2191(bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a)))",["ring"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",118,"\u03b1 : Type u_1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\nP : Finpartition univ\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nh\u03b5 : 0 < \u03b5\nhP : P.IsEquipartition\nhP\u03b5 : P.IsUniform G (\u03b5 / 8)\nhP' : 4 / \u03b5 \u2264 \u2191(#P.parts)\nA : Finset (\u03b1 \u00d7 \u03b1) :=\n  (P.nonUniforms G (\u03b5 / 8)).biUnion fun x \u21a6\n    match x with\n    | (U, V) => U \u00d7\u02e2 V\nB : Finset (\u03b1 \u00d7 \u03b1) := P.parts.biUnion offDiag\nC : Finset (\u03b1 \u00d7 \u03b1) :=\n  (P.sparsePairs G (\u03b5 / 4)).biUnion fun x \u21a6\n    match x with\n    | (U, V) => G.interedges U V\n\u22a2 4 * (\u03b5 / 8) * \u2191(Fintype.card \u03b1 ^ 2) + \u03b5 / 2 * \u2191(Fintype.card \u03b1 ^ 2) + 4 * (\u03b5 / 4) * \u2191(Fintype.card \u03b1 ^ 2) =\n    2 * \u03b5 * \u2191(Fintype.card \u03b1 ^ 2)",["ring","linarith"]],["Algebra/Lie/TensorProduct.lean",53,"R : Type u\ninst\u271d\u00b9\u2078 : CommRing R\nL : Type v\nM : Type w\nN : Type w\u2081\nP : Type w\u2082\nQ : Type w\u2083\ninst\u271d\u00b9\u2077 : LieRing L\ninst\u271d\u00b9\u2076 : LieAlgebra R L\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : LieRingModule L M\ninst\u271d\u00b9\u00b2 : LieModule R L M\ninst\u271d\u00b9\u00b9 : AddCommGroup N\ninst\u271d\u00b9\u2070 : Module R N\ninst\u271d\u2079 : LieRingModule L N\ninst\u271d\u2078 : LieModule R L N\ninst\u271d\u2077 : AddCommGroup P\ninst\u271d\u2076 : Module R P\ninst\u271d\u2075 : LieRingModule L P\ninst\u271d\u2074 : LieModule R L P\ninst\u271d\u00b3 : AddCommGroup Q\ninst\u271d\u00b2 : Module R Q\ninst\u271d\u00b9 : LieRingModule L Q\ninst\u271d : LieModule R L Q\nx y : L\nt : M \u2297[R] N\n\u22a2 (LinearMap.rTensor N ((toEnd R L M) x)) t + (LinearMap.rTensor N ((toEnd R L M) y)) t +\n      ((LinearMap.lTensor M ((toEnd R L N) x)) t + (LinearMap.lTensor M ((toEnd R L N) y)) t) =\n    (LinearMap.rTensor N ((toEnd R L M) x)) t + (LinearMap.lTensor M ((toEnd R L N) x)) t +\n      ((LinearMap.rTensor N ((toEnd R L M) y)) t + (LinearMap.lTensor M ((toEnd R L N) y)) t)",["abel"]],["Algebra/Lie/TensorProduct.lean",64,"case a.h.h\nR : Type u\ninst\u271d\u00b9\u2078 : CommRing R\nL : Type v\nM : Type w\nN : Type w\u2081\nP : Type w\u2082\nQ : Type w\u2083\ninst\u271d\u00b9\u2077 : LieRing L\ninst\u271d\u00b9\u2076 : LieAlgebra R L\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : LieRingModule L M\ninst\u271d\u00b9\u00b2 : LieModule R L M\ninst\u271d\u00b9\u00b9 : AddCommGroup N\ninst\u271d\u00b9\u2070 : Module R N\ninst\u271d\u2079 : LieRingModule L N\ninst\u271d\u2078 : LieModule R L N\ninst\u271d\u2077 : AddCommGroup P\ninst\u271d\u2076 : Module R P\ninst\u271d\u2075 : LieRingModule L P\ninst\u271d\u2074 : LieModule R L P\ninst\u271d\u00b3 : AddCommGroup Q\ninst\u271d\u00b2 : Module R Q\ninst\u271d\u00b9 : LieRingModule L Q\ninst\u271d : LieModule R L Q\nx y : L\nt : M \u2297[R] N\nm : M\nn : N\n\u22a2 \u2045x, \u2045y, m\u2046\u2046 \u2297\u209c[R] n + \u2045y, m\u2046 \u2297\u209c[R] \u2045x, n\u2046 + (\u2045x, m\u2046 \u2297\u209c[R] \u2045y, n\u2046 + m \u2297\u209c[R] \u2045x, \u2045y, n\u2046\u2046) =\n    \u2045x, \u2045y, m\u2046\u2046 \u2297\u209c[R] n - \u2045y, \u2045x, m\u2046\u2046 \u2297\u209c[R] n + (m \u2297\u209c[R] \u2045x, \u2045y, n\u2046\u2046 - m \u2297\u209c[R] \u2045y, \u2045x, n\u2046\u2046) +\n      (\u2045y, \u2045x, m\u2046\u2046 \u2297\u209c[R] n + \u2045x, m\u2046 \u2297\u209c[R] \u2045y, n\u2046 + (\u2045y, m\u2046 \u2297\u209c[R] \u2045x, n\u2046 + m \u2297\u209c[R] \u2045y, \u2045x, n\u2046\u2046))",["abel"]],["Analysis/SpecialFunctions/Log/NegMulLog.lean",160,"case neg\nx y : \u211d\nhx : \u00acx = 0\nhy : \u00acy = 0\n\u22a2 -(x * y * (log x + log y)) = y * -(x * log x) + x * -(y * log y)",["ring","linarith"]],["Analysis/SpecialFunctions/Log/NegMulLog.lean",186,"x : \u211d\nhx : x \u2260 0\n\u22a2 -(log x + 1) = -log x - 1",["ring","linarith","abel"]],["Combinatorics/SimpleGraph/Regularity/Increment.lean",145,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nhP : P.IsEquipartition\nhP\u2087 : 7 \u2264 #P.parts\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhPG : \u00acP.IsUniform G \u03b5\nh\u03b5\u2080 : 0 \u2264 \u03b5\nh\u03b5\u2081 : \u03b5 \u2264 1\n\u22a2 (\u2211 i \u2208 P.parts.offDiag.attach, \u2211 i \u2208 SzemerediRegularity.distinctPairs hP G \u03b5 i, \u2191(G.edgeDensity i.1 i.2) ^ 2) /\n        16 ^ #P.parts /\n      \u2191(#P.parts) ^ 2 =\n    (\u2211 x \u2208 P.parts.offDiag.attach, \u2211 i \u2208 SzemerediRegularity.distinctPairs hP G \u03b5 x, \u2191(G.edgeDensity i.1 i.2) ^ 2) /\n        (4 ^ 2) ^ #P.parts /\n      \u2191(#P.parts) ^ 2",["norm_num","ring","linarith"]],["Combinatorics/SimpleGraph/Regularity/Increment.lean",165,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nhP : P.IsEquipartition\nhP\u2087 : 7 \u2264 #P.parts\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhPG : \u2191(#P.parts.offDiag) * \u03b5 < \u2191(#(P.nonUniforms G \u03b5))\nh\u03b5\u2080 : 0 \u2264 \u03b5\nh\u03b5\u2081 : \u03b5 \u2264 1\n\u22a2 \u2191(#P.parts) ^ 2 * (\u03b5 ^ 5 / 4) = 6 / 7 * \u2191(#P.parts) ^ 2 * \u03b5 ^ 5 * (7 / 24)",["ring","linarith"]],["Combinatorics/SimpleGraph/Regularity/Increment.lean",174,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nhP : P.IsEquipartition\nhP\u2087 : 7 \u2264 #P.parts\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhPG : \u2191(#P.parts.offDiag) * \u03b5 < \u2191(#(P.nonUniforms G \u03b5))\nh\u03b5\u2080 : 0 \u2264 \u03b5\nh\u03b5\u2081 : \u03b5 \u2264 1\n\u22a2 \u2191(#P.parts.offDiag) * \u03b5 ^ 5 * (22 / 75) = \u2191(#P.parts.offDiag) * \u03b5 * (\u03b5 ^ 4 / 3) - \u2191(#P.parts.offDiag) * (\u03b5 ^ 5 / 25)",["ring","linarith"]],["Combinatorics/Additive/SmallTripling.lean",79,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\nhA\u2080 : A.Nonempty\nthis : 0 \u2264 K\n\u22a2 2 \u2264 3",["norm_num"]],["Combinatorics/Additive/SmallTripling.lean",111,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\nhA\u2080 : A.Nonempty\nthis : 0 \u2264 K\n\u22a2 2 \u2264 3",["norm_num"]],["Combinatorics/Additive/SmallTripling.lean",63,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nk : \u211d\nm\u271d : \u2115\nh : \u2200 (\u03b5 : Fin 3 \u2192 \u2124), (\u2200 (i : Fin 3), |\u03b5 i| = 1) \u2192 \u2191(#(List.map (fun i \u21a6 A ^ \u03b5 i) (finRange 3)).prod) \u2264 k * \u2191(#A)\nm : \u2115\nhm : 3 \u2264 m + 1\nih :\n  \u2200 (\u03b5 : Fin (m + 1) \u2192 \u2124),\n    (\u2200 (i : Fin (m + 1)), |\u03b5 i| = 1) \u2192 \u2191(#(List.map (fun i \u21a6 A ^ \u03b5 i) (finRange (m + 1))).prod) \u2264 k ^ (m + 1 - 2) * \u2191(#A)\n\u03b5 : Fin (m + 1 + 1) \u2192 \u2124\nh\u03b5 : \u2200 (i : Fin (m + 1 + 1)), |\u03b5 i| = 1\nhm\u2080 : m \u2260 0\nh\u03b5\u2080 : \u2200 (i : Fin (m + 1 + 1)), \u03b5 i \u2260 0\nhA : A.Nonempty\nhk : 0 \u2264 k\n\u03c0 : {n : \u2115} \u2192 (Fin n \u2192 \u2124) \u2192 Finset G := fun {n} \u03b4 \u21a6 (List.map (fun i \u21a6 A ^ \u03b4 i) (finRange n)).prod\nV : Finset G := \u03c0 ![-\u03b5 1, -\u03b5 0]\nW : Finset G := \u03c0 (tail (tail \u03b5))\n\u22a2 k * \u2191(#A) * (k ^ (m - 1) * \u2191(#A)) = \u2191(#A) * (k ^ (m - 1) * k * \u2191(#A))",["ring"]],["Combinatorics/Additive/SmallTripling.lean",81,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\nhA\u2080 : A.Nonempty\nthis : 0 \u2264 K\n\u22a2 K * \u2191(#A) * (K * \u2191(#A)) = \u2191(#A) * (K ^ 2 * \u2191(#A))",["ring"]],["Combinatorics/Additive/SmallTripling.lean",113,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\nhA\u2080 : A.Nonempty\nthis : 0 \u2264 K\n\u22a2 K ^ 2 * \u2191(#A) * (K * \u2191(#A)) = \u2191(#A) * (K ^ 3 * \u2191(#A))",["ring"]],["Combinatorics/SimpleGraph/Triangle/Counting.lean",94,"case intro.intro\n\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\ns t u : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ndst : 2 * \u03b5 \u2264 \u2191(G.edgeDensity s t)\ndsu : 2 * \u03b5 \u2264 \u2191(G.edgeDensity s u)\ndtu : 2 * \u03b5 \u2264 \u2191(G.edgeDensity t u)\nutu : G.IsUniform \u03b5 t u\nx : \u03b1\nhxY : \u2191(#t) * (\u2191(G.edgeDensity s t) - \u03b5) \u2264 \u2191(#(filter (fun y \u21a6 G.Adj x y) t))\nhsu : \u2191(#u) * (\u2191(G.edgeDensity s u) - \u03b5) \u2264 \u2191(#(filter (fun y \u21a6 G.Adj x y) u))\nhY : \u2191(#t) * \u03b5 \u2264 \u2191(#(filter (fun y \u21a6 G.Adj x y) t))\nhZ : \u2191(#u) * \u03b5 \u2264 \u2191(#(filter (fun y \u21a6 G.Adj x y) u))\nthis\u271d : |\u2191(G.edgeDensity (filter (G.Adj x) t) (filter (G.Adj x) u)) - \u2191(G.edgeDensity t u)| < \u03b5\nthis :\n  \u03b5 \u2264\n    \u2191(#(G.interedges (filter (fun y \u21a6 G.Adj x y) t) (filter (fun y \u21a6 G.Adj x y) u))) /\n      (\u2191(#(filter (fun y \u21a6 G.Adj x y) t)) * \u2191(#(filter (fun y \u21a6 G.Adj x y) u)))\nh\u03b5 : 0 \u2264 \u03b5\n\u22a2 \u03b5 ^ 3 * \u2191(#t) * \u2191(#u) = \u03b5 * (\u2191(#t) * \u03b5 * (\u2191(#u) * \u03b5))",["ring"]],["Algebra/Homology/BifunctorHomotopy.lean",106,"C\u2081 : Type u_1\nC\u2082 : Type u_2\nD : Type u_3\nI\u2081 : Type u_4\nI\u2082 : Type u_5\nJ : Type u_6\ninst\u271d\u00b9\u00b9 : Category.{u_8, u_1} C\u2081\ninst\u271d\u00b9\u2070 : Category.{u_9, u_2} C\u2082\ninst\u271d\u2079 : Category.{u_7, u_3} D\ninst\u271d\u2078 : Preadditive C\u2081\ninst\u271d\u2077 : Preadditive C\u2082\ninst\u271d\u2076 : Preadditive D\nc\u2081 : ComplexShape I\u2081\nc\u2082 : ComplexShape I\u2082\nK\u2081 L\u2081 : HomologicalComplex C\u2081 c\u2081\nf\u2081 f\u2081' : K\u2081 \u27f6 L\u2081\nh\u2081 : Homotopy f\u2081 f\u2081'\nK\u2082 L\u2082 : HomologicalComplex C\u2082 c\u2082\nf\u2082 : K\u2082 \u27f6 L\u2082\nF : C\u2081 \u2964 C\u2082 \u2964 D\ninst\u271d\u2075 : F.Additive\ninst\u271d\u2074 : \u2200 (X\u2081 : C\u2081), (F.obj X\u2081).Additive\nc : ComplexShape J\ninst\u271d\u00b3 : DecidableEq J\ninst\u271d\u00b2 : TotalComplexShape c\u2081 c\u2082 c\ninst\u271d\u00b9 : K\u2081.HasMapBifunctor K\u2082 F c\ninst\u271d : L\u2081.HasMapBifunctor L\u2082 F c\nj : J\ni\u2081 : I\u2081\ni\u2082 : I\u2082\nh : c\u2081.\u03c0 c\u2082 c (i\u2081, i\u2082) = j\nX Y : D\na b d : X \u27f6 Y\n\u22a2 a + b = a + d + (b + -d)",["abel"]],["NumberTheory/ADEInequality.lean",144,"case inr.inl.intro\npqr : Multiset \u2115+\nn : \u2115+\nH : D' n = pqr\n\u22a2 1 < (\u2191\u21912)\u207b\u00b9 + (\u2191\u21912)\u207b\u00b9 + (\u2191\u2191n)\u207b\u00b9",["norm_num"]],["NumberTheory/ADEInequality.lean",147,"case inr.inr.inl\npqr : Multiset \u2115+\nH : E' 3 = pqr\n\u22a2 1 < (\u2191\u21912)\u207b\u00b9 + (\u2191\u21913)\u207b\u00b9 + (\u2191\u21913)\u207b\u00b9\n```\n---\n```lean\ncase inr.inr.inr.inl\npqr : Multiset \u2115+\nH : E' 4 = pqr\n\u22a2 1 < (\u2191\u21912)\u207b\u00b9 + (\u2191\u21913)\u207b\u00b9 + (\u2191\u21914)\u207b\u00b9\n```\n---\n```lean\ncase inr.inr.inr.inr\npqr : Multiset \u2115+\nH : E' 5 = pqr\n\u22a2 1 < (\u2191\u21912)\u207b\u00b9 + (\u2191\u21913)\u207b\u00b9 + (\u2191\u21915)\u207b\u00b9",["norm_num"]],["NumberTheory/ADEInequality.lean",169,"p q r : \u2115+\nhpq : p \u2264 q\nhqr : q \u2264 r\nh3 : 0 < 3\nH : 3 \u2264 p\nh3q : 3 \u2264 q\nh3r : 3 \u2264 r\nhp : (\u2191\u2191p)\u207b\u00b9 \u2264 3\u207b\u00b9\nhq : (\u2191\u2191q)\u207b\u00b9 \u2264 3\u207b\u00b9\nhr : (\u2191\u2191r)\u207b\u00b9 \u2264 3\u207b\u00b9\n\u22a2 3\u207b\u00b9 + 3\u207b\u00b9 + 3\u207b\u00b9 = 1",["norm_num"]],["NumberTheory/ADEInequality.lean",186,"q r : \u2115+\nhqr : q \u2264 r\nh4 : 0 < 4\nH : 4 \u2264 q\nh4r : 4 \u2264 r\nhq : (\u2191\u2191q)\u207b\u00b9 \u2264 4\u207b\u00b9\nhr : (\u2191\u2191r)\u207b\u00b9 \u2264 4\u207b\u00b9\n\u22a2 2\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9 = 1",["norm_num"]],["NumberTheory/ADEInequality.lean",198,"r : \u2115+\nh6 : 0 < 6\nH : 6 \u2264 r\nhr : (\u2191\u2191r)\u207b\u00b9 \u2264 6\u207b\u00b9\n\u22a2 2\u207b\u00b9 + 3\u207b\u00b9 + 6\u207b\u00b9 = 1",["norm_num"]],["NumberTheory/SiegelsLemma.lean",149,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Fintype \u03b2\nA : Matrix \u03b1 \u03b2 \u2124\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nhn : m < n\nhm : 0 < m\ni : \u03b1\nx\u271d : i \u2208 univ\n\u22a2 \u2191n * (1 \u2294 \u2016A\u2016) * \u2191B = \u2191n * ((1 \u2294 \u2016A\u2016) * \u2191B)",["ring","linarith"]],["Algebra/Group/ForwardDiff.lean",55,"case h\nM : Type u_1\nG : Type u_2\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommGroup G\nh : M\nR : Type\ninst\u271d\u00b9 : Ring R\ninst\u271d : Module R G\nf : M \u2192 R\ng : M \u2192 G\ny : M\n\u22a2 f (y + h) \u2022 g (y + h) - f y \u2022 g y =\n    f (y + h) \u2022 g y - f y \u2022 g y + (f y \u2022 g (y + h) - f y \u2022 g y) +\n      (f (y + h) \u2022 g (y + h) - f y \u2022 g (y + h) - (f (y + h) \u2022 g y - f y \u2022 g y))",["abel"]],["InformationTheory/KullbackLeibler/KLFun.lean",151,"case h\nx\u271d : \u211d\n\u22a2 x\u271d * log x\u271d + 1 - x\u271d = x\u271d * (log x\u271d - 1) + 1",["ring","linarith"]],["MeasureTheory/Decomposition/UnsignedHahn.lean",47,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nd : Set \u03b1 \u2192 \u211d := fun s \u21a6 \u2191(\u03bc s).toNNReal - \u2191(\u03bd s).toNNReal\nc : Set \u211d := d '' {s | MeasurableSet s}\n\u03b3 : \u211d := sSup c\nh\u03bc : \u2200 (s : Set \u03b1), \u03bc s \u2260 \u22a4\nh\u03bd : \u2200 (s : Set \u03b1), \u03bd s \u2260 \u22a4\nto_nnreal_\u03bc : \u2200 (s : Set \u03b1), \u2191(\u03bc s).toNNReal = \u03bc s\nto_nnreal_\u03bd : \u2200 (s : Set \u03b1), \u2191(\u03bd s).toNNReal = \u03bd s\ns t : Set \u03b1\nht : MeasurableSet t\n\u22a2 \u2191(\u03bc (s \u2229 t)).toNNReal + \u2191(\u03bc (s \\ t)).toNNReal + (-\u2191(\u03bd (s \u2229 t)).toNNReal + -\u2191(\u03bd (s \\ t)).toNNReal) =\n    \u2191(\u03bc (s \\ t)).toNNReal + -\u2191(\u03bd (s \\ t)).toNNReal + (\u2191(\u03bc (s \u2229 t)).toNNReal + -\u2191(\u03bd (s \u2229 t)).toNNReal)",["abel","ring","linarith"]],["MeasureTheory/Decomposition/UnsignedHahn.lean",100,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nd : Set \u03b1 \u2192 \u211d := fun s \u21a6 \u2191(\u03bc s).toNNReal - \u2191(\u03bd s).toNNReal\nc : Set \u211d := d '' {s | MeasurableSet s}\n\u03b3 : \u211d := sSup c\nh\u03bc : \u2200 (s : Set \u03b1), \u03bc s \u2260 \u22a4\nh\u03bd : \u2200 (s : Set \u03b1), \u03bd s \u2260 \u22a4\nto_nnreal_\u03bc : \u2200 (s : Set \u03b1), \u2191(\u03bc s).toNNReal = \u03bc s\nto_nnreal_\u03bd : \u2200 (s : Set \u03b1), \u2191(\u03bd s).toNNReal = \u03bd s\nd_split : \u2200 (s t : Set \u03b1), MeasurableSet t \u2192 d s = d (s \\ t) + d (s \u2229 t)\nd_Union : \u2200 (s : \u2115 \u2192 Set \u03b1), Monotone s \u2192 Tendsto (fun n \u21a6 d (s n)) atTop (\ud835\udcdd (d (\u22c3 n, s n)))\nd_Inter :\n  \u2200 (s : \u2115 \u2192 Set \u03b1),\n    (\u2200 (n : \u2115), MeasurableSet (s n)) \u2192\n      (\u2200 (n m : \u2115), n \u2264 m \u2192 s m \u2286 s n) \u2192 Tendsto (fun n \u21a6 d (s n)) atTop (\ud835\udcdd (d (\u22c2 n, s n)))\nbdd_c : BddAbove c\nc_nonempty : c.Nonempty\nd_le_\u03b3 : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 d s \u2264 \u03b3\nthis : \u2200 (n : \u2115), \u2203 s, MeasurableSet s \u2227 \u03b3 - (1 / 2) ^ n < d s\ne : \u2115 \u2192 Set \u03b1\nhe : \u2200 (x : \u2115), MeasurableSet (e x) \u2227 \u03b3 - (1 / 2) ^ x < d (e x)\nhe\u2081 : \u2200 (n : \u2115), MeasurableSet (e n)\nhe\u2082 : \u2200 (n : \u2115), \u03b3 - (1 / 2) ^ n < d (e n)\nf : \u2115 \u2192 \u2115 \u2192 Set \u03b1 := fun n m \u21a6 (Finset.Ico n (m + 1)).inf e\nhf : \u2200 (n m : \u2115), MeasurableSet (f n m)\nf_subset_f : \u2200 {a b c d : \u2115}, a \u2264 b \u2192 c \u2264 d \u2192 f a d \u2286 f b c\nf_succ : \u2200 (n m : \u2115), n \u2264 m \u2192 f n (m + 1) = f n m \u2229 e (m + 1)\nn\u271d m : \u2115\nh : m \u2264 n\u271d\nn : \u2115\nhmn : m \u2264 n\nih : \u03b3 - 2 * (1 / 2) ^ m + (1 / 2) ^ n \u2264 d (f m n)\n\u22a2 \u03b3 + (\u03b3 + -(2 * (1 / 2) ^ m) + ((1 / 2) ^ n + -(1 / 2) ^ (n + 1))) =\n    \u03b3 + -(1 / 2) ^ (n + 1) + (\u03b3 + -(2 * (1 / 2) ^ m) + (1 / 2) ^ n)",["abel","ring","linarith"]],["Dynamics/Ergodic/AddCircle.lean",137,"case h\nT : \u211d\nhT : Fact (0 < T)\nx : AddCircle T\nn : \u2124\nf : AddCircle T \u2192 AddCircle T := fun y \u21a6 n \u2022 y + x\ne : AddCircle T \u2243\u1d50 AddCircle T := MeasurableEquiv.addLeft (DivisibleBy.div x (n - 1))\nhe : MeasurePreserving (\u21d1e) volume volume\nh : n - 1 \u2260 0\nhnx : n \u2022 DivisibleBy.div x (n - 1) = x + DivisibleBy.div x (n - 1)\ny : AddCircle T\n\u22a2 DivisibleBy.div x (n - 1) + (-DivisibleBy.div x (n - 1) + -x + n \u2022 y + x) = n \u2022 y",["abel"]],["NumberTheory/Harmonic/EulerMascheroni.lean",64,"\u22a2 \u2191(harmonic 6) - log (\u21916 + 1) = 49 / 20 - log 7",["norm_num"]],["NumberTheory/Harmonic/EulerMascheroni.lean",68,"this : eulerMascheroniSeq 6 = 49 / 20 - log 7\n\u22a2 7 <\n    \u2211 i \u2208 Finset.range 0, (49 / 20 - 1 / 2) ^ i / \u2191i.factorial + (49 / 20 - 1 / 2) ^ 0 / \u2191(Nat.factorial 0) +\n                (49 / 20 - 1 / 2) ^ 1 / \u2191((0 + 1) * Nat.factorial 0) +\n              (49 / 20 - 1 / 2) ^ 2 / \u2191((1 + 1) * ((0 + 1) * Nat.factorial 0)) +\n            (49 / 20 - 1 / 2) ^ 3 / \u2191((2 + 1) * ((1 + 1) * ((0 + 1) * Nat.factorial 0))) +\n          (49 / 20 - 1 / 2) ^ 4 / \u2191((3 + 1) * ((2 + 1) * ((1 + 1) * ((0 + 1) * Nat.factorial 0)))) +\n        (49 / 20 - 1 / 2) ^ 5 / \u2191((4 + 1) * ((3 + 1) * ((2 + 1) * ((1 + 1) * ((0 + 1) * Nat.factorial 0))))) +\n      (49 / 20 - 1 / 2) ^ 6 / \u2191((5 + 1) * ((4 + 1) * ((3 + 1) * ((2 + 1) * ((1 + 1) * ((0 + 1) * Nat.factorial 0))))))",["norm_num"]],["NumberTheory/Harmonic/EulerMascheroni.lean",99,"\u22a2 (if 6 = 0 then 2 else \u2191(harmonic 6) - log \u21916) = 49 / 20 - log 6",["norm_num"]],["Analysis/SpecialFunctions/MulExpNegMulSq.lean",96,"\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nx : \u211d\n\u22a2 rexp (-(\u03b5 * x * x)) + x * (rexp (-(\u03b5 * x * x)) * (-2 * \u03b5 * x)) = rexp (-(\u03b5 * x * x)) * (1 - 2 * (\u03b5 * x * x))",["ring","linarith"]],["Algebra/QuaternionBasis.lean",117,"R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nc\u2081 c\u2082 c\u2083 : R\nq : Basis A c\u2081 c\u2082 c\u2083\nx y : \u210d[R,c\u2081,c\u2082,c\u2083]\n\u22a2 (algebraMap R A) x.re + (algebraMap R A) y.re + (x.imI \u2022 q.i + y.imI \u2022 q.i) + (x.imJ \u2022 q.j + y.imJ \u2022 q.j) +\n      (x.imK \u2022 q.k + y.imK \u2022 q.k) =\n    (algebraMap R A) x.re + x.imI \u2022 q.i + x.imJ \u2022 q.j + x.imK \u2022 q.k +\n      ((algebraMap R A) y.re + y.imI \u2022 q.i + y.imJ \u2022 q.j + y.imK \u2022 q.k)",["abel"]],["RingTheory/Derivation/MapCoeffs.lean",79,"case h_add\nR : Type u_1\nA : Type u_2\nM : Type u_3\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module A M\ninst\u271d\u2077 : Module R M\nd : Derivation R A M\nB : Type u_4\nM' : Type u_5\ninst\u271d\u2076 : CommRing B\ninst\u271d\u2075 : Algebra R B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module B M'\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module A M'\nd' : Derivation R B M'\nf : M \u2192\u2097[A] M'\nh : \u2200 (a : A), f (d a) = d' ((algebraMap A B) a)\nx : B\np\u271d q\u271d : A[X]\na\u271d\u00b9 :\n  d' ((aeval x) p\u271d) =\n    (PolynomialModule.eval x) ((PolynomialModule.map B f) (d.mapCoeffs p\u271d)) + (aeval x) (derivative p\u271d) \u2022 d' x\na\u271d :\n  d' ((aeval x) q\u271d) =\n    (PolynomialModule.eval x) ((PolynomialModule.map B f) (d.mapCoeffs q\u271d)) + (aeval x) (derivative q\u271d) \u2022 d' x\n\u22a2 (PolynomialModule.eval x) ((PolynomialModule.map B f) (d.mapCoeffs p\u271d)) + (aeval x) (derivative p\u271d) \u2022 d' x +\n      ((PolynomialModule.eval x) ((PolynomialModule.map B f) (d.mapCoeffs q\u271d)) + (aeval x) (derivative q\u271d) \u2022 d' x) =\n    (PolynomialModule.eval x) ((PolynomialModule.map B f) (d.mapCoeffs p\u271d)) +\n        (PolynomialModule.eval x) ((PolynomialModule.map B f) (d.mapCoeffs q\u271d)) +\n      ((aeval x) (derivative p\u271d) \u2022 d' x + (aeval x) (derivative q\u271d) \u2022 d' x)",["abel"]],["Data/Matrix/Invertible.lean",130,"m : Type u_1\nn : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Ring \u03b1\nA : Matrix n n \u03b1\nU : Matrix n m \u03b1\nC : Matrix m m \u03b1\nV : Matrix m n \u03b1\ninst\u271d\u00b2 : Invertible A\ninst\u271d\u00b9 : Invertible C\ninst\u271d : Invertible (\u215f C + V * \u215f A * U)\n\u22a2 1 - U * \u215f (\u215f C + V * \u215f A * U) * V * \u215f A + U * C * V * \u215f A - U * C * V * \u215f A * U * \u215f (\u215f C + V * \u215f A * U) * V * \u215f A =\n    1 + U * C * V * \u215f A - (U * \u215f (\u215f C + V * \u215f A * U) * V * \u215f A + U * C * V * \u215f A * U * \u215f (\u215f C + V * \u215f A * U) * V * \u215f A)",["abel"]],["Data/Matrix/Invertible.lean",138,"m : Type u_1\nn : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Ring \u03b1\nA : Matrix n n \u03b1\nU : Matrix n m \u03b1\nC : Matrix m m \u03b1\nV : Matrix m n \u03b1\ninst\u271d\u00b2 : Invertible A\ninst\u271d\u00b9 : Invertible C\ninst\u271d : Invertible (\u215f C + V * \u215f A * U)\n\u22a2 1 + U * C * V * \u215f A - U * C * V * \u215f A = 1",["abel"]],["Data/Matrix/Invertible.lean",149,"m : Type u_1\nn : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Ring \u03b1\nA : Matrix n n \u03b1\nU : Matrix n m \u03b1\nC : Matrix m m \u03b1\nV : Matrix m n \u03b1\ninst\u271d\u00b2 : Invertible A\ninst\u271d\u00b9 : Invertible C\ninst\u271d : Invertible (\u215f C + V * \u215f A * U)\n\u22a2 1 - \u215f A * U * \u215f (\u215f C + V * \u215f A * U) * V + \u215f A * U * C * V - \u215f A * U * \u215f (\u215f C + V * \u215f A * U) * V * \u215f A * U * C * V =\n    1 + \u215f A * U * C * V - (\u215f A * U * \u215f (\u215f C + V * \u215f A * U) * V + \u215f A * U * \u215f (\u215f C + V * \u215f A * U) * V * \u215f A * U * C * V)",["abel"]],["Data/Matrix/Invertible.lean",159,"m : Type u_1\nn : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u2077 : Fintype n\ninst\u271d\u2076 : DecidableEq n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Ring \u03b1\nA : Matrix n n \u03b1\nU : Matrix n m \u03b1\nC : Matrix m m \u03b1\nV : Matrix m n \u03b1\ninst\u271d\u00b2 : Invertible A\ninst\u271d\u00b9 : Invertible C\ninst\u271d : Invertible (\u215f C + V * \u215f A * U)\n\u22a2 1 + \u215f A * U * C * V - \u215f A * U * C * V = 1",["abel"]],["Analysis/Asymptotics/SpecificAsymptotics.lean",114,"\u03b1 : Type u_1\ninst\u271d : NormedAddCommGroup \u03b1\nf : \u2115 \u2192 \u03b1\ng : \u2115 \u2192 \u211d\nh : f =o[atTop] g\nhg : 0 \u2264 g\nh'g : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, g i) atTop atTop\nA : \u2200 (i : \u2115), \u2016g i\u2016 = g i\nB : \u2200 (n : \u2115), \u2016\u2211 i \u2208 range n, g i\u2016 = \u2211 i \u2208 range n, g i\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nN : \u2115\nhN : \u2200 (b : \u2115), N \u2264 b \u2192 \u2016f b\u2016 \u2264 \u03b5 / 2 * g b\nthis : (fun x \u21a6 \u2211 i \u2208 range N, f i) =o[atTop] fun n \u21a6 \u2211 i \u2208 range n, g i\nn : \u2115\nhn : \u2016\u2211 i \u2208 range N, f i\u2016 \u2264 \u03b5 / 2 * \u2016\u2211 i \u2208 range n, g i\u2016\nNn : n \u2208 Set.Ici N\n\u22a2 \u03b5 / 2 * \u2211 i \u2208 range n, g i + \u03b5 / 2 * \u2211 i \u2208 range n, g i = \u03b5 * \u2211 i \u2208 range n, g i",["ring","linarith"]],["Analysis/Convex/SpecificFunctions/Deriv.lean",140,"case h.e'_3\nx : \u211d\nhx : 0 < x\nsqx : \u211d\nh\u2080 : sqx \u2260 0\n\u22a2 -(log x * (sqx * sqx * (2 * sqx) * (2 * sqx) ^ 2)) =\n    (2 * sqx * (2 * sqx) - sqx * sqx * ((2 + log x) * 2)) * (4 * sqx ^ 3)",["ring","linarith"]],["LinearAlgebra/Matrix/Circulant.lean",131,"case a.e_a.e_a\n\u03b1 : Type u_1\nn : Type u_3\ninst\u271d\u00b3 : CommSemigroup \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : AddCommGroup n\nv w : n \u2192 \u03b1\ni j x : n\n\u22a2 x - j = i - (i - x + j)",["abel"]],["Data/Real/GoldenRatio.lean",43,"this : 1 + \u221a5 \u2260 0\n\u22a2 2 * 2 = 5 - 1",["norm_num","ring","linarith"]],["Data/Real/GoldenRatio.lean",54,"\u22a2 1 ^ 2 - \u221a5 ^ 2 = -(2 * 2)",["norm_num"]],["Data/Real/GoldenRatio.lean",102,"\u22a2 (1 + 3) / 2 = 2",["norm_num","ring","linarith"]],["Data/Real/GoldenRatio.lean",123,"this\u271d : Irrational \u221a\u21915\nthis : Irrational (\u21911 + \u221a\u21915)\n\u22a2 0.5 \u2260 0",["norm_num","linarith","positivity"]],["Data/Real/GoldenRatio.lean",131,"this\u271d : Irrational \u221a\u21915\nthis : Irrational (\u21911 - \u221a\u21915)\n\u22a2 0.5 \u2260 0",["norm_num","linarith","positivity"]],["Data/Real/GoldenRatio.lean",64,"\u22a2 (1 + \u221a5) / 2 + (1 - \u221a5) / 2 = 1",["ring","linarith"]],["Data/Real/GoldenRatio.lean",73,"\u22a2 \u03c6 - \u03c8 = \u221a5",["ring"]],["Data/Real/GoldenRatio.lean",76,"n : \u2115\n\u22a2 5 * (1 / 2 + \u221a5 * (1 / 2)) ^ n * (1 / 4) + -((1 / 2 + \u221a5 * (1 / 2)) ^ n * (1 / 4)) = (1 / 2 + \u221a5 * (1 / 2)) ^ n",["ring","linarith"]],["Data/Real/GoldenRatio.lean",196,"case h.e'_4.h\nthis : fibRec.IsSolution ((fun n \u21a6 (\u221a5)\u207b\u00b9 * \u03c6 ^ n) - fun n \u21a6 (\u221a5)\u207b\u00b9 * \u03c8 ^ n)\nx\u271d : \u2115\n\u22a2 (\u03c6 ^ x\u271d - \u03c8 ^ x\u271d) / \u221a5 = (\u221a5)\u207b\u00b9 * \u03c6 ^ x\u271d - (\u221a5)\u207b\u00b9 * \u03c8 ^ x\u271d",["ring"]],["Data/Real/GoldenRatio.lean",221,"n : \u2115\nih : \u03c6 * \u2191(Nat.fib (n + 1)) + \u2191(Nat.fib n) = \u03c6 ^ (n + 1)\n\u22a2 \u03c6 * (\u2191(Nat.fib n) + \u2191(Nat.fib n.succ)) + \u2191(Nat.fib (n + 1)) = \u03c6 * \u2191(Nat.fib n) + (\u03c6 + 1) * \u2191(Nat.fib (n + 1))",["ring","linarith"]],["Data/Real/GoldenRatio.lean",222,"n : \u2115\nih : \u03c6 * \u2191(Nat.fib (n + 1)) + \u2191(Nat.fib n) = \u03c6 ^ (n + 1)\n\u22a2 \u03c6 * \u2191(Nat.fib n) + \u03c6 ^ 2 * \u2191(Nat.fib (n + 1)) = \u03c6 * (\u2191(Nat.fib n) + \u03c6 * \u2191(Nat.fib (n + 1)))",["ring","linarith"]],["Data/Real/GoldenRatio.lean",223,"n : \u2115\nih : \u03c6 * \u2191(Nat.fib (n + 1)) + \u2191(Nat.fib n) = \u03c6 ^ (n + 1)\n\u22a2 \u03c6 * \u03c6 ^ (n + 1) = \u03c6 ^ (n + 2)",["ring"]],["AlgebraicTopology/DoldKan/Projections.lean",77,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq : \u2115\n\u22a2 \ud835\udfd9 K[X] - (P q + P q \u226b H\u03c3 q) = \ud835\udfd9 K[X] - P q - P q \u226b H\u03c3 q",["abel"]],["Analysis/NormedSpace/Extend.lean",50,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module \u211d F\ninst\u271d\u00b9 : Module \ud835\udd5c F\ninst\u271d : IsScalarTower \u211d \ud835\udd5c F\nfr : F \u2192\u2097[\u211d] \u211d\nfc : F \u2192 \ud835\udd5c := fun x \u21a6 \u2191(fr x) - I * \u2191(fr (I \u2022 x))\nx y : F\n\u22a2 \u2191(fr x) + \u2191(fr y) - (I * \u2191(fr (I \u2022 x)) + I * \u2191(fr (I \u2022 y))) =\n    \u2191(fr x) - I * \u2191(fr (I \u2022 x)) + (\u2191(fr y) - I * \u2191(fr (I \u2022 y)))",["abel","ring"]],["Analysis/NormedSpace/Extend.lean",60,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module \u211d F\ninst\u271d\u00b9 : Module \ud835\udd5c F\ninst\u271d : IsScalarTower \u211d \ud835\udd5c F\nfr : F \u2192\u2097[\u211d] \u211d\nfc : F \u2192 \ud835\udd5c := fun x \u21a6 \u2191(fr x) - I * \u2191(fr (I \u2022 x))\nadd : \u2200 (x y : F), fc (x + y) = fc x + fc y\nA : \u2200 (c : \u211d) (x : F), \u2191(fr (\u2191c \u2022 x)) = \u2191c * \u2191(fr x)\nc : \u211d\nx : F\n\u22a2 \u2191c * \u2191(fr x) - I * (\u2191c * \u2191(fr (I \u2022 x))) = \u2191c * \u2191(fr x) - \u2191c * (I * \u2191(fr (I \u2022 x)))",["ring"]],["NumberTheory/ModularForms/JacobiTheta/OneVariable.lean",59,"\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nn : \u2124\ny : \u211d := rexp (-\u03c0 * \u03c4.im)\nh : y < 1\n\u22a2 \u03c0 * \u2191n ^ 2 * -\u03c4.im = -\u03c0 * \u03c4.im * \u2191n ^ 2",["ring","linarith"]],["Algebra/Order/Round.lean",168,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\n\u22a2 x \u2208 Ico (0 - 1 / 2) (1 - 1 / 2) \u2194 x \u2208 Ico (-(1 / 2)) (1 / 2)",["norm_num"]],["Topology/MetricSpace/Kuratowski.lean",65,"\u03b1 : Type u\ninst\u271d : MetricSpace \u03b1\nx : \u2115 \u2192 \u03b1\nH : DenseRange x\na b : \u03b1\ne : \u211d\nepos : 0 < e\nn : \u2115\nhn : dist a (x n) < e / 2\nC : dist b (x n) - dist a (x n) = \u2191(embeddingOfSubset x b) n - \u2191(embeddingOfSubset x a) n\n\u22a2 dist a (x n) + dist b (x n) = 2 * dist a (x n) + (dist b (x n) - dist a (x n))",["ring","linarith"]],["Topology/MetricSpace/Kuratowski.lean",76,"\u03b1 : Type u\ninst\u271d : MetricSpace \u03b1\nx : \u2115 \u2192 \u03b1\nH : DenseRange x\na b : \u03b1\ne : \u211d\nepos : 0 < e\nn : \u2115\nhn : dist a (x n) < e / 2\nC : dist b (x n) - dist a (x n) = \u2191(embeddingOfSubset x b) n - \u2191(embeddingOfSubset x a) n\n\u22a2 2 * (e / 2) + dist (embeddingOfSubset x b) (embeddingOfSubset x a) =\n    dist (embeddingOfSubset x b) (embeddingOfSubset x a) + e",["ring","linarith"]],["Analysis/Calculus/FDeriv/Bilinear.lean",51,"case h.mk.mk.mk.mk\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nb : E \u00d7 F \u2192 G\nh : IsBoundedBilinearMap \ud835\udd5c b\nT : Type (max u_3 u_2) := (E \u00d7 F) \u00d7 E \u00d7 F\nx\u2081 : E\ny\u2081 : F\nx\u2082 : E\ny\u2082 : F\nx : E\ny : F\n\u22a2 b (x, y) + b (x\u2081, y) + (b (x, y\u2081) + b (x\u2081, y\u2081)) - (b (x, y) + b (x\u2082, y) + (b (x, y\u2082) + b (x\u2082, y\u2082))) -\n      (b (x, y) + b (x, y\u2081) + (b (x, y) + b (x\u2081, y)) - (b (x, y) + b (x, y\u2082) + (b (x, y) + b (x\u2082, y)))) =\n    b (x\u2081, y\u2081) - b (x\u2082, y\u2082)",["abel"]],["Algebra/QuadraticDiscriminant.lean",108,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NeZero 2\na b c : K\nha : a \u2260 0\nx : K\nhx : (2 * a * x + b) ^ 2 * a ^ 2 = (2 * a * (-b + -(x * a)) + b * a) ^ 2 \u2192 -b + -(x * a) = x * a\n\u22a2 (2 * a * x + b) ^ 2 * a ^ 2 = (2 * a * (-b + -(x * a)) + b * a) ^ 2",["ring"]],["Algebra/QuadraticDiscriminant.lean",143,"case h.e'_3\nK : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nh : \u2200 (x : K), 0 \u2264 a * (x * x) + b * x + c\nha : 0 < a\nha' : 0 \u2264 4 * a\n\u22a2 (b * b - 4 * a * c) * (2 * a * (2 * a) * (2 * a)) =\n    -(4 * a * (a * (b * b) * (2 * a) + -(b * b * (2 * a * (2 * a))) + c * (2 * a * (2 * a) * (2 * a))))",["ring"]],["Algebra/MvPolynomial/Derivation.lean",96,"case add\n\u03c3 : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : Module (MvPolynomial \u03c3 R) A\ninst\u271d : IsScalarTower R (MvPolynomial \u03c3 R) A\nD : MvPolynomial \u03c3 R \u2192\u2097[R] A\nh\u2081\u271d : D 1 = 0\nH : \u2200 (s : \u03c3 \u2192\u2080 \u2115) (i : \u03c3), D ((monomial s) 1 * X i) = (monomial s) 1 \u2022 D (X i) + X i \u2022 D ((monomial s) 1)\nhC : \u2200 (r : R), D (C r) = 0\nthis : \u2200 (p : MvPolynomial \u03c3 R) (i : \u03c3), D (p * X i) = p \u2022 D (X i) + X i \u2022 D p\np q\u2081 q\u2082 : MvPolynomial \u03c3 R\nh\u2081 : D (p * q\u2081) = p \u2022 D q\u2081 + q\u2081 \u2022 D p\nh\u2082 : D (p * q\u2082) = p \u2022 D q\u2082 + q\u2082 \u2022 D p\n\u22a2 p \u2022 D q\u2081 + q\u2081 \u2022 D p + (p \u2022 D q\u2082 + q\u2082 \u2022 D p) = p \u2022 D q\u2081 + p \u2022 D q\u2082 + (q\u2081 \u2022 D p + q\u2082 \u2022 D p)",["abel"]],["Analysis/Calculus/Deriv/ZPow.lean",50,"case h.e'_9.e_a.e_a\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nm : \u2124\nx : \ud835\udd5c\nh : x \u2260 0 \u2228 0 \u2264 m\nthis\u271d : \u2200 (m : \u2124), 0 < m \u2192 HasStrictDerivAt (fun x \u21a6 x ^ m) (\u2191m * x ^ (m - 1)) x\nhm : m < 0\nhx : x \u2260 0\nthis : HasStrictDerivAt (fun x \u21a6 x ^ m) (\u2191(-m) * x ^ (-m - 1) * -((x ^ m)\u207b\u00b9 ^ 2)\u207b\u00b9) x\n\u22a2 m - 1 = -m - 1 + (m + m)",["abel","ring","omega","linarith"]],["Analysis/InnerProductSpace/NormPow.lean",50,"case a.a.h.e'_12.h.e'_5\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nx : E\np : \u211d\nhp : 1 < p\nhx : \u00acx = 0\n\u22a2 p * \u2016x\u2016 ^ (-2 + p) = p * (1 / 2) * \u2016x\u2016 ^ (-2 + p) * 2",["ring","linarith"]],["Analysis/SpecialFunctions/Log/PosLog.lean",49,"case pos\nr : \u211d\nhr : 0 \u2264 log r\n\u22a2 2\u207b\u00b9 * (log r + log r) = log r",["ring","linarith"]],["Analysis/Convex/Uniform.lean",92,"E : Type u_1\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : UniformConvexSpace E\n\u03b5 : \u211d\ninst\u271d : NormedSpace \u211d E\nh\u03b5 : 0 < \u03b5\nh\u03b5' : 0 < \u03b5 / 3\n\u03b4 : \u211d\nh\u03b4 : 0 < \u03b4\nh : \u2200 \u2983x : E\u2984, \u2016x\u2016 = 1 \u2192 \u2200 \u2983y : E\u2984, \u2016y\u2016 = 1 \u2192 \u03b5 / 3 \u2264 \u2016x - y\u2016 \u2192 \u2016x + y\u2016 \u2264 2 - \u03b4\n\u03b4' : \u211d := 1 / 2 \u2293 (\u03b5 / 3 \u2293 \u03b4 / 3)\nx : E\nhx : \u2016x\u2016 \u2264 1\ny : E\nhy : \u2016y\u2016 \u2264 1\nhxy : \u03b5 \u2264 \u2016x - y\u2016\nhx' : 1 - \u03b4' < \u2016x\u2016\nhy' : 1 - \u03b4' < \u2016y\u2016\nh\u03b4' : 0 < 1 - \u03b4'\nh\u2081 : \u2200 (z : E), 1 - \u03b4' < \u2016z\u2016 \u2192 \u2016\u2016z\u2016\u207b\u00b9 \u2022 z\u2016 = 1\nh\u2082 : \u2200 (z : E), \u2016z\u2016 \u2264 1 \u2192 1 - \u03b4' \u2264 \u2016z\u2016 \u2192 \u2016\u2016z\u2016\u207b\u00b9 \u2022 z - z\u2016 \u2264 \u03b4'\nx' : E := \u2016x\u2016\u207b\u00b9 \u2022 x\ny' : E := \u2016y\u2016\u207b\u00b9 \u2022 y\nhxy' : \u03b5 / 3 \u2264 \u2016x' - y'\u2016\nx\u271d\u00b9 x\u271d : E\n\u22a2 x + y = x\u271d\u00b9 + x\u271d + (x - x\u271d\u00b9) + (y - x\u271d)",["abel"]],["Analysis/Convex/Uniform.lean",81,"E : Type u_1\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : UniformConvexSpace E\n\u03b5 : \u211d\ninst\u271d : NormedSpace \u211d E\nh\u03b5 : 0 < \u03b5\nh\u03b5' : 0 < \u03b5 / 3\n\u03b4 : \u211d\nh\u03b4 : 0 < \u03b4\nh : \u2200 \u2983x : E\u2984, \u2016x\u2016 = 1 \u2192 \u2200 \u2983y : E\u2984, \u2016y\u2016 = 1 \u2192 \u03b5 / 3 \u2264 \u2016x - y\u2016 \u2192 \u2016x + y\u2016 \u2264 2 - \u03b4\n\u03b4' : \u211d := 1 / 2 \u2293 (\u03b5 / 3 \u2293 \u03b4 / 3)\nx : E\nhx : \u2016x\u2016 \u2264 1\ny : E\nhy : \u2016y\u2016 \u2264 1\nhxy : \u03b5 \u2264 \u2016x - y\u2016\nhx' : 1 - \u03b4' < \u2016x\u2016\nhy' : 1 - \u03b4' < \u2016y\u2016\nh\u03b4' : 0 < 1 - \u03b4'\nh\u2081 : \u2200 (z : E), 1 - \u03b4' < \u2016z\u2016 \u2192 \u2016\u2016z\u2016\u207b\u00b9 \u2022 z\u2016 = 1\nh\u2082 : \u2200 (z : E), \u2016z\u2016 \u2264 1 \u2192 1 - \u03b4' \u2264 \u2016z\u2016 \u2192 \u2016\u2016z\u2016\u207b\u00b9 \u2022 z - z\u2016 \u2264 \u03b4'\nx' : E := \u2016x\u2016\u207b\u00b9 \u2022 x\ny' : E := \u2016y\u2016\u207b\u00b9 \u2022 y\n\u22a2 \u03b5 / 3 = \u03b5 - (\u03b5 / 3 + \u03b5 / 3)",["ring","linarith"]],["Data/Nat/Choose/Central.lean",67,"n : \u2115\n\u22a2 (2 * n + 1).choose n * (2 * n + 2) = 2 * ((2 * n + 1).choose n * (n + 1))",["ring","linarith"]],["Analysis/NormedSpace/RieszLemma.lean",50,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nF : Subspace \ud835\udd5c E\nhFc : IsClosed \u2191F\nr : \u211d\nhr : r < 1\nx : E\nhx : x \u2209 F\nd : \u211d := infDist x \u2191F\nhFn : (\u2191F).Nonempty\nhdp : 0 < d\nr' : \u211d := r \u2294 2\u207b\u00b9\n\u22a2 2\u207b\u00b9 < 1",["norm_num","linarith"]],["Analysis/NormedSpace/RieszLemma.lean",99,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nR : \u211d\nhR : \u2016c\u2016 < R\nF : Subspace \ud835\udd5c E\nhFc : IsClosed \u2191F\nhF : \u2203 x, x \u2209 F\nRpos : 0 < R\nthis : \u2016c\u2016 / R < 1\nx : E\nxF : x \u2209 F\nhx : \u2200 y \u2208 F, \u2016c\u2016 / R * \u2016x\u2016 \u2264 \u2016x - y\u2016\nx0 : x \u2260 0\nd : \ud835\udd5c\nd0 : d \u2260 0\ndxlt : \u2016d \u2022 x\u2016 < R\nledx : R / \u2016c\u2016 \u2264 \u2016d \u2022 x\u2016\ny : E\nhy : y \u2208 F\ny' : E := d\u207b\u00b9 \u2022 y\nyy' : y = d \u2022 y'\n\u22a2 \u2016c\u2016 / R * (\u2016d\u2016 * \u2016x\u2016) = \u2016d\u2016 * (\u2016c\u2016 / R * \u2016x\u2016)",["ring","linarith"]],["Analysis/Polynomial/CauchyBound.lean",125,"K : Type u_1\ninst\u271d : NormedDivisionRing K\np : K[X]\nhp : p \u2260 0\na : K\nh : \u2016p.leadingCoeff\u2016\u208a * \u2016a\u2016\u208a ^ p.natDegree \u2264 \u2016\u2211 i \u2208 range p.natDegree, p.coeff i * a ^ i\u2016\u208a\npld : \u2016p.leadingCoeff\u2016\u208a \u2260 0\n\u22a2 \u2016p.leadingCoeff\u2016\u208a * (p.cauchyBound - 1) * \u2211 i \u2208 range p.natDegree, \u2016a\u2016\u208a ^ i =\n    ((p.cauchyBound - 1) * \u2211 i \u2208 range p.natDegree, \u2016a\u2016\u208a ^ i) * \u2016p.leadingCoeff\u2016\u208a",["ring"]],["LinearAlgebra/QuadraticForm/Real.lean",48,"\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nw : \u03b9 \u2192 \u211d\nu : \u03b9 \u2192 \u211d\u02e3 := fun i \u21a6 if h : w i = 0 then 1 else Units.mk0 (w i) h\nhu : \u2200 (i : \u03b9), 1 / \u221a|\u2191(u i)| \u2260 0\nhwu : \u2200 (i : \u03b9), w i / |\u2191(u i)| = \u2191(sign (w i))\nv : \u03b9 \u2192 \u211d\nj : \u03b9\nx\u271d : j \u2208 univ\n\u22a2 w j / |\u2191(u j)| * v j ^ 2 = w j * (v j ^ 2 * |\u2191(u j)|\u207b\u00b9)",["ring"]],["Analysis/Convex/SpecificFunctions/Pow.lean",58,"this : \u21d1sqrt = fun x \u21a6 x ^ (1 / 2)\n\u22a2 1 / 2 < 1",["linarith","norm_num"]],["Algebra/ContinuedFractions/Determinant.lean",60,"K : Type u_1\ninst\u271d : Field K\ns : SimpContFract K\nn\u271d n : \u2115\nhyp : n + 1 = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n + 1 - 1)\ng : GenContFract K := \u2191s\nconts : Pair K := g.contsAux (n + 2)\npred_conts : Pair K := g.contsAux (n + 1)\npred_conts_eq : pred_conts = g.contsAux (n + 1)\nppred_conts : Pair K := g.contsAux n\nIH : n = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n - 1) \u2192 ppred_conts.a * pred_conts.b - ppred_conts.b * pred_conts.a = (-1) ^ n\nppred_conts_eq : ppred_conts = g.contsAux n\npA : K := pred_conts.a\npB : K := pred_conts.b\nppA : K := ppred_conts.a\nppB : K := ppred_conts.b\nnot_terminated_at_n : \u00acg.TerminatedAt n\ngp : Pair K\ns_nth_eq : g.s.get? n = some gp\nthis : pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = (-1) ^ (n + 1)\ngp_a_eq_one : gp.a = 1\n\u22a2 pA * (gp.b * (g.contsAux (n + 1)).b + 1 * (g.contsAux n).b) -\n      pB * (gp.b * (g.contsAux (n + 1)).a + 1 * (g.contsAux n).a) =\n    pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA)",["ring"]],["Algebra/ContinuedFractions/Determinant.lean",63,"K : Type u_1\ninst\u271d : Field K\ns : SimpContFract K\nn\u271d n : \u2115\nhyp : n + 1 = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n + 1 - 1)\ng : GenContFract K := \u2191s\nconts : Pair K := g.contsAux (n + 2)\npred_conts : Pair K := g.contsAux (n + 1)\npred_conts_eq : pred_conts = g.contsAux (n + 1)\nppred_conts : Pair K := g.contsAux n\nIH : n = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n - 1) \u2192 ppred_conts.a * pred_conts.b - ppred_conts.b * pred_conts.a = (-1) ^ n\nppred_conts_eq : ppred_conts = g.contsAux n\npA : K := pred_conts.a\npB : K := pred_conts.b\nppA : K := ppred_conts.a\nppB : K := ppred_conts.b\nnot_terminated_at_n : \u00acg.TerminatedAt n\ngp : Pair K\ns_nth_eq : g.s.get? n = some gp\nthis : pA * ppB - pB * ppA = (-1) ^ (n + 1)\n\u22a2 pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = pA * ppB + pA * gp.b * pB - pB * ppA - pB * gp.b * pA",["ring"]],["Algebra/ContinuedFractions/Determinant.lean",64,"K : Type u_1\ninst\u271d : Field K\ns : SimpContFract K\nn\u271d n : \u2115\nhyp : n + 1 = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n + 1 - 1)\ng : GenContFract K := \u2191s\nconts : Pair K := g.contsAux (n + 2)\npred_conts : Pair K := g.contsAux (n + 1)\npred_conts_eq : pred_conts = g.contsAux (n + 1)\nppred_conts : Pair K := g.contsAux n\nIH : n = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n - 1) \u2192 ppred_conts.a * pred_conts.b - ppred_conts.b * pred_conts.a = (-1) ^ n\nppred_conts_eq : ppred_conts = g.contsAux n\npA : K := pred_conts.a\npB : K := pred_conts.b\nppA : K := ppred_conts.a\nppB : K := ppred_conts.b\nnot_terminated_at_n : \u00acg.TerminatedAt n\ngp : Pair K\ns_nth_eq : g.s.get? n = some gp\nthis : pA * ppB - pB * ppA = (-1) ^ (n + 1)\n\u22a2 pA * ppB + pA * gp.b * pB - pB * ppA - pB * gp.b * pA = pA * ppB - pB * ppA",["ring"]],["Algebra/ContinuedFractions/Determinant.lean",69,"K : Type u_1\ninst\u271d : Field K\ns : SimpContFract K\nn\u271d n : \u2115\nhyp : n + 1 = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n + 1 - 1)\ng : GenContFract K := \u2191s\nconts : Pair K := g.contsAux (n + 2)\npred_conts : Pair K := g.contsAux (n + 1)\npred_conts_eq : pred_conts = g.contsAux (n + 1)\nppred_conts : Pair K := g.contsAux n\nIH : n = 0 \u2228 \u00ac(\u2191s).TerminatedAt (n - 1) \u2192 ppred_conts.a * pred_conts.b - ppred_conts.b * pred_conts.a = (-1) ^ n\nppred_conts_eq : ppred_conts = g.contsAux n\npA : K := pred_conts.a\npB : K := pred_conts.b\nppA : K := ppred_conts.a\nppB : K := ppred_conts.b\nnot_terminated_at_n : \u00acg.TerminatedAt n\ngp : Pair K\ns_nth_eq : g.s.get? n = some gp\nthis : ppA * pB - ppB * pA = (-1) ^ n\npow_succ_n : (-1) ^ (n + 1) = -1 * (-1) ^ n\n\u22a2 pA * ppB - pB * ppA = -1 * (ppA * pB - ppB * pA)",["ring"]],["Analysis/InnerProductSpace/ProdL2.lean",35,"\ud835\udd5c : Type u_1\n\u03b9\u2081 : Type u_2\n\u03b9\u2082 : Type u_3\nE : Type u_4\nF : Type u_5\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \ud835\udd5c F\nx y z : WithLp 2 (E \u00d7 F)\n\u22a2 inner x.1 z.1 + inner y.1 z.1 + (inner x.2 z.2 + inner y.2 z.2) =\n    inner x.1 z.1 + inner x.2 z.2 + (inner y.1 z.1 + inner y.2 z.2)",["ring","abel"]],["Analysis/InnerProductSpace/ProdL2.lean",38,"\ud835\udd5c : Type u_1\n\u03b9\u2081 : Type u_2\n\u03b9\u2082 : Type u_3\nE : Type u_4\nF : Type u_5\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \ud835\udd5c F\nx y : WithLp 2 (E \u00d7 F)\nr : \ud835\udd5c\n\u22a2 (starRingEnd \ud835\udd5c) r * inner x.1 y.1 + (starRingEnd \ud835\udd5c) r * inner x.2 y.2 =\n    (starRingEnd \ud835\udd5c) r * (inner x.1 y.1 + inner x.2 y.2)",["ring"]],["Data/Nat/Factorial/DoubleFactorial.lean",61,"n : \u2115\n\u22a2 (2 * n + 2) * (2 ^ n * n !) = 2 ^ n * 2 * ((n + 1) * n !)",["ring"]],["Analysis/SpecialFunctions/Log/Monotone.lean",47,"x : \u211d\nhex : rexp 1 \u2264 x\ny : \u211d\nhey : rexp 1 \u2264 y\nhxy : x \u2264 y\nx_pos : 0 < x\ny_pos : 0 < y\nhlogx : 1 \u2264 log x\nhyx : 0 \u2264 y / x - 1\n\u22a2 log x * (y / x - 1) = log x / x * y - log x",["ring"]],["RingTheory/Polynomial/Hermite/Gaussian.lean",47,"n : \u2115\nx : \u211d\nih : (deriv^[n] fun y \u21a6 Real.exp (-(y ^ 2 / 2))) = fun x \u21a6 (-1) ^ n * ((aeval x) (hermite n) * Real.exp (-(x ^ 2 / 2)))\n\u22a2 Real.exp (-(x ^ 2 / 2)) * x = x * Real.exp (-(x ^ 2 / 2))",["ring","linarith"]],["Algebra/BigOperators/Module.lean",41,"R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nm n : \u2115\nhmn : m < n\nh\u2081 : \u2211 i \u2208 Ico (m + 1) n, f i \u2022 \u2211 i \u2208 range i, g i = \u2211 i \u2208 Ico m (n - 1), f (i + 1) \u2022 \u2211 i \u2208 range (i + 1), g i\nh\u2082 :\n  \u2211 i \u2208 Ico (m + 1) n, f i \u2022 \u2211 i \u2208 range (i + 1), g i =\n    \u2211 i \u2208 Ico m (n - 1), f i \u2022 \u2211 i \u2208 range (i + 1), g i + f (n - 1) \u2022 \u2211 i \u2208 range n, g i - f m \u2022 \u2211 i \u2208 range (m + 1), g i\nthis :\n  \u2200 (i : \u2115),\n    f i \u2022 \u2211 i \u2208 range (i + 1), g i - f (i + 1) \u2022 \u2211 i \u2208 range (i + 1), g i =\n      -((f (i + 1) - f i) \u2022 \u2211 i \u2208 range (i + 1), g i)\n\u22a2 f m \u2022 g m +\n      (f (n - 1) \u2022 \u2211 i \u2208 range n, g i - (f m \u2022 \u2211 i \u2208 range m, g i + f m \u2022 g m) +\n        -\u2211 x \u2208 Ico m (n - 1), ((f (x + 1) - f x) \u2022 \u2211 i \u2208 range x, g i + (f (x + 1) - f x) \u2022 g x)) =\n    f (n - 1) \u2022 \u2211 i \u2208 range n, g i - f m \u2022 \u2211 i \u2208 range m, g i -\n      \u2211 x \u2208 Ico m (n - 1), ((f (x + 1) - f x) \u2022 \u2211 i \u2208 range x, g i + (f (x + 1) - f x) \u2022 g x)",["abel"]],["Data/Complex/ExponentialBounds.lean",35,"\u22a2 1 / 10 ^ 10 + 2244083 / 825552 < 2.7182818286",["norm_num","linarith"]],["Data/Complex/ExponentialBounds.lean",40,"\u22a2 1 / 10 ^ 10 + 2244083 / 825552 < 0.36787944116\u207b\u00b9",["norm_num","linarith"]],["Algebra/Module/LinearMap/Prod.lean",29,"case map_add\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx y : M \u00d7 M\n\u22a2 x.1 + y.1 + (x.2 + y.2) = x.1 + x.2 + (y.1 + y.2)",["abel"]]]},{"tactics":["linarith","positivity","omega"],"cost":20,"goals":[["Computability/AkraBazzi/AkraBazzi.lean",233,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc : \u211d := b (max_bi b) + (1 - b (max_bi b)) / 2\nh_max_bi_pos : 0 < b (max_bi b)\nthis : b (max_bi b) < 1\n\u22a2 0 < 1 - b (max_bi b)",["linarith","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",530,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nh\u2081 : \u2211 x : \u03b1, 0 = 0\ni : \u03b1\nx\u271d : i \u2208 univ\nthis : 0 < b i\n\u22a2 -1 < b i",["linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",703,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nthis : c\u2083 < 1\n\u22a2 0 < 1 - c\u2083",["linarith","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",186,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ngt_zero : 0 < b (min_bi b)\nhlo : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 c * \u2016\u2191x\u2016\nhlo' : \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 b (min_bi b) / 2 * \u2016\u2191x\u2016\nn : \u2115\nhn' : \u2200 (i : \u03b1), b i * \u2191n - \u2191n / log \u2191n ^ 2 \u2264 \u2191(r i n)\ni : \u03b1\nhn : \u2016\u2191n / log \u2191n ^ 2\u2016 \u2264 b (min_bi b) / 2 * \u2191n\n\u22a2 b (min_bi b) * \u2191n - b (min_bi b) / 2 * \u2191n \u2264 b (min_bi b) * \u2191n - \u2016\u2191n / log \u2191n ^ 2\u2016",["gcongr","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",251,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc : \u211d := b (max_bi b) + (1 - b (max_bi b)) / 2\nh_max_bi_pos : 0 < b (max_bi b)\nh_max_bi_lt_one : 0 < 1 - b (max_bi b)\nhc_pos : 0 < c\nh\u2081 : 0 < (1 - b (max_bi b)) / 2\nhc_lt_one : c < 1\nhlo : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 c * \u2016\u2191x\u2016\nhlo' : \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 (1 - b (max_bi b)) / 2 * \u2016\u2191x\u2016\nn : \u2115\nhn' : \u2200 (i : \u03b1), \u2191(r i n) \u2264 b i * \u2191n + \u2191n / log \u2191n ^ 2\ni : \u03b1\nhn : \u2191n / log \u2191n ^ 2 \u2264 (1 - b (max_bi b)) / 2 * \u2191n\n\u22a2 b i * \u2191n + \u2191n / log \u2191n ^ 2 \u2264 b i * \u2191n + (1 - b (max_bi b)) / 2 * \u2191n",["gcongr","aesop","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",190,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ngt_zero : 0 < b (min_bi b)\nhlo : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 c * \u2016\u2191x\u2016\nhlo' : \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 b (min_bi b) / 2 * \u2016\u2191x\u2016\nn : \u2115\nhn' : \u2200 (i : \u03b1), b i * \u2191n - \u2191n / log \u2191n ^ 2 \u2264 \u2191(r i n)\ni : \u03b1\nhn : \u2016\u2191n / log \u2191n ^ 2\u2016 \u2264 b (min_bi b) / 2 * \u2191n\n\u22a2 0 \u2264 \u2191n / log \u2191n ^ 2",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",234,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc : \u211d := b (max_bi b) + (1 - b (max_bi b)) / 2\nh_max_bi_pos : 0 < b (max_bi b)\nh_max_bi_lt_one : 0 < 1 - b (max_bi b)\n\u22a2 0 < c",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",235,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc : \u211d := b (max_bi b) + (1 - b (max_bi b)) / 2\nh_max_bi_pos : 0 < b (max_bi b)\nh_max_bi_lt_one : 0 < 1 - b (max_bi b)\nhc_pos : 0 < c\n\u22a2 0 < (1 - b (max_bi b)) / 2",["positivity","aesop","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",439,"case h\nh\u2081 : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u211d) in atTop, \u2016\u03b5 x\u2016 \u2264 c * \u20161\u2016\nx : \u211d\na\u271d : \u2016\u03b5 x\u2016 \u2264 1 / 2 * \u20161\u2016\nhx' : 1 < x\nthis : 0 < log x\n\u22a2 0 < 1 + 1 / log x",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",541,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nh\u2081\u271d : Tendsto (fun p \u21a6 a (max_bi b) * b (max_bi b) ^ p) atBot atTop\np : \u211d\ni : \u03b1\nx\u271d : i \u2208 univ\nh\u2081 : 0 < a i\nh\u2082 : 0 < b i\n\u22a2 0 \u2264 (fun i \u21a6 a i * b i ^ p) i",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",682,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhc\u2081_pos : 0 < c\u2081\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, g u \u2264 c\u2082 * g \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : p a b + 1 < 0\nu : \u2115\nhu : r i n \u2264 u \u2227 u < n\nthis : 0 < u\n\u22a2 0 < \u2191u",["positivity","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",728,"case h.h.hc\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nhc\u2083' : 0 < 1 - c\u2083\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nhn\u2083 : \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 \u2264 p a b + 1\nu : \u2115\nhu : r i n \u2264 u \u2227 u < n\nthis : 0 < u\n\u22a2 0 < \u2191u ^ (p a b + 1)",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",762,"case h.h.hc\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nhc\u2083' : 0 < 1 - c\u2083\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nhn\u2083 : \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 > p a b + 1\nu : \u2115\nhu : r i n \u2264 u \u2227 u < n\nthis : 0 < u\n\u22a2 0 < \u2191u ^ (p a b + 1)",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",764,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 \u2208 Set.Ioo 0 1\nhc\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhc\u2082 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nc\u2083 : \u211d\nhc\u2083_mem : c\u2083 \u2208 Set.Ioo 0 1\nhc\u2083 : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhc\u2081_pos : 0 < c\u2081\nhc\u2083' : 0 < 1 - c\u2083\nn : \u2115\nhn\u2081 : \u2200 (i : \u03b1), c\u2081 * \u2191n \u2264 \u2191(r i n)\nhn\u2082 : \u2200 u \u2208 Set.Icc (c\u2081 * \u2191n) \u2191n, c\u2082 * g \u2191n \u2264 g u\nhn\u2083 : \u2200 (i : \u03b1), \u2191(r i n) \u2264 c\u2083 * \u2191n\nhrpos : \u2200 (i : \u03b1), 0 < r i n\nhr_lt_n : \u2200 (i : \u03b1), r i n < n\nhn_pos : 0 < n\ni : \u03b1\nhrpos_i : 0 < r i n\ng_nonneg : 0 \u2264 g \u2191n\nhp : 0 > p a b + 1\nu : \u2115\nhu : r i n \u2264 u \u2227 u < n\n\u22a2 0 < \u2191(r i n)",["positivity","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",803,"p x : \u211d\nhx : 1 < x\n\u22a2 x \u2260 0",["positivity","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",820,"p x : \u211d\nhx : 1 < x\n\u22a2 x \u2260 0",["positivity","linarith"]],["Computability/AkraBazzi/AkraBazzi.lean",903,"p : \u211d\nhp : p = 0\nx : \u211d\nhx : deriv (fun x \u21a6 1 - \u03b5 x) x = x\u207b\u00b9 / log x ^ 2\nhx_pos : 1 < x\nhlog : 0 < log x\n\u22a2 0 \u2264 x\u207b\u00b9 / log x ^ 2",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",925,"p : \u211d\nhp : p = 0\nx : \u211d\nhx : deriv (fun x \u21a6 1 + \u03b5 x) x = -x\u207b\u00b9 / log x ^ 2\nhx_pos : 1 < x\nhlog : 0 < log x\n\u22a2 0 \u2264 x\u207b\u00b9 / log x ^ 2",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",945,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nq : \u211d \u2192 \u211d\nhq_diff : DifferentiableOn \u211d q (Set.Ioi 1)\nhq_poly : GrowsPolynomially fun x \u21a6 \u2016deriv q x\u2016\ni : \u03b1\nb' : \u211d := b (min_bi b) / 2\nthis : 0 < b (min_bi b)\n\u22a2 0 < b'",["positivity","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1024,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 - \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2191n \u2260 0",["positivity","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1032,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 - \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nthis : 0 < b i\n\u22a2 b i ^ p a b \u2260 0",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1058,"case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 - \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nh_main_norm : (fun n \u21a6 \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n \u21a6 \u2016b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\u2016\nn : \u2115\nhn : \u2308(b i)\u207b\u00b9\u2309\u208a < n\nhn' : 1 < n\nh\u2081 : 0 < b i\nh\u2082 : 0 \u2264 \u03b5 (b i * \u2191n) - \u03b5 \u2191n\n\u22a2 0 \u2264 b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1119,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 + \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2191n \u2260 0",["positivity","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1126,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 + \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nthis : 0 < b i\n\u22a2 b i ^ p a b \u2260 0",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1154,"case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 + \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nh_main_norm : (fun n \u21a6 \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n \u21a6 \u2016b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\u2016\nn : \u2115\nhn : \u2308(b i)\u207b\u00b9\u2309\u208a < n\nhn' : 1 < n\nh\u2081 : 0 < b i\nh\u2082 : 0 \u2264 \u03b5 (b i * \u2191n) - \u03b5 \u2191n\n\u22a2 0 \u2264 b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1175,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nn : \u2115\nhn : 0 < n\nb' : \u211d := b (min_bi b)\nhb_pos : 0 < b'\n\u22a2 0 \u2264 b' / 2 * \u2191n",["positivity","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1236,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\ni : \u03b1\n\u22a2 0 \u2264 b' * \u2191n\u2080",["positivity","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1266,"case bc.h.a0\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\ni : \u03b1\na\u271d : i \u2208 univ\nthis : 0 < a i\n\u22a2 0 \u2264 C * a i",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1291,"case bc.h.a0\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\ni : \u03b1\na\u271d : i \u2208 univ\nthis : 0 < a i\n\u22a2 0 \u2264 C * a i",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1293,"case bc.h.h.a0\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\ni : \u03b1\na\u271d : i \u2208 univ\nthis : 0 < b i\n\u22a2 0 \u2264 b i ^ p a b * (1 - \u03b5 \u2191n)",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1362,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nm : \u2115\nhm_mem : m \u2208 Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080\nhm :\n  ((Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)) =\n    T m / ((1 + \u03b5 \u2191m) * asympBound g a b m)\nH\u2081 : 0 < T m\nH\u2082 : 0 < 1 + \u03b5 \u2191m\nH\u2083 : 0 < asympBound g a b m\n\u22a2 0 < T m / ((1 + \u03b5 \u2191m) * asympBound g a b m)",["positivity","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1385,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\ni : \u03b1\n\u22a2 0 \u2264 b' * \u2191n\u2080",["positivity","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1411,"case bc.h.a0\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\ni : \u03b1\na\u271d : i \u2208 univ\nthis : 0 < a i\n\u22a2 0 \u2264 C * a i",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1436,"case bc.h.a0\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\ni : \u03b1\na\u271d : i \u2208 univ\nthis : 0 < a i\n\u22a2 0 \u2264 C * a i",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1438,"case bc.h.h.a0\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\ni : \u03b1\na\u271d : i \u2208 univ\nthis : 0 < b i\n\u22a2 0 \u2264 b i ^ p a b * (1 + \u03b5 \u2191n)",["positivity"]],["Computability/AkraBazzi/AkraBazzi.lean",1457,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\nb_mul_n\u2080_le_ri : \u2200 (i : \u03b1), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 r i n\ng_pos : 0 \u2264 g \u2191n\n\u22a2 c\u2081 \u2260 0",["positivity","linarith"]],["MeasureTheory/Integral/SetIntegral.lean",447,"X : Type u_1\nmX : MeasurableSpace X\n\u03bc : Measure X\nf : X \u2192 \u211d\nhfi : Integrable f \u03bc\nh_meas : NullMeasurableSet {x | 0 \u2264 f x} \u03bc\nx : X\nhx : \u00ac0 \u2264 f x\n\u22a2 f x \u2264 0",["linarith"]],["MeasureTheory/Integral/SetIntegral.lean",1475,"case neg\nY : Type u_2\nE : Type u_3\nF : Type u_4\nX : Type u_5\nG : Type u_6\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9\u00b9 : TopologicalSpace X\ninst\u271d\u00b9\u2070 : TopologicalSpace Y\ninst\u271d\u2079 : MeasurableSpace Y\ninst\u271d\u2078 : OpensMeasurableSpace Y\n\u03bc : Measure Y\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : NormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\ninst\u271d : NormedSpace \ud835\udd5c E\nL : F \u2192L[\ud835\udd5c] G \u2192L[\ud835\udd5c] E\nf : X \u2192 Y \u2192 G\ns : Set X\nk : Set Y\ng : Y \u2192 F\nhk : IsCompact k\nhf : ContinuousOn (uncurry f) (s \u00d7\u02e2 univ)\nhfs : \u2200 (p : X) (x : Y), p \u2208 s \u2192 x \u2209 k \u2192 f p x = 0\nhg : IntegrableOn g k \u03bc\nA : \u2200 p \u2208 s, Continuous (f p)\nq : X\nhq : q \u2208 s\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : \u222b (x : Y) in k, \u2016L\u2016 * \u2016g x\u2016 * \u03b4 \u2202\u03bc < \u03b5\nv : Set X\nv_mem : v \u2208 \ud835\udcdd[s] q\nhv : \u2200 p \u2208 v, \u2200 x \u2208 k, \u2016f p x - f q x\u2016 < \u03b4\nI : \u2200 p \u2208 s, IntegrableOn (fun y \u21a6 (L (g y)) (f p y)) k \u03bc\np : X\nhp : p \u2208 v\nh'p : p \u2208 s\ny : Y\nhy : y \u2209 k\n\u22a2 0 \u2264 \u2016L\u2016 * \u2016g y\u2016 * \u03b4",["positivity"]],["Analysis/Calculus/MeanValue.lean",921,"case h.intro.intro\nf : \u211d \u2192 \u211d\na : \u211d\nhf : Tendsto (derivWithin f (Ioi a)) (\ud835\udcdd[>] a) atTop\nhcont_at_a : ContinuousWithinAt f (Ici a) a\nhdiff : Tendsto (slope f a) (\ud835\udcdd[>] a) (\ud835\udcdd (derivWithin f (Ioi a) a))\nh\u2080 : \u2200\u1da0 (b : \u211d) in \ud835\udcdd[>] a, \u2200 x \u2208 Ioc a b, (derivWithin f (Ioi a) a + 1) \u2294 0 < derivWithin f (Ioi a) x\nh\u2081 : \u2200\u1da0 (b : \u211d) in \ud835\udcdd[>] a, slope f a b < derivWithin f (Ioi a) a + 1\nb : \u211d\nhslope : slope f a b < derivWithin f (Ioi a) a + 1\nhab : a < b\nhdiff' : DifferentiableOn \u211d f (Ioc a b)\nhcont_Ioc : \u2200 z \u2208 Ioc a b, ContinuousWithinAt f (Icc a b) z\nhcont : ContinuousOn f (Icc a b)\nx : \u211d\nhx\u2081 : x \u2208 Ioo a b\nhb : derivWithin f (Ioi a) a + 1 < slope f a b \u2227 0 < slope f a b\nhx\u2082 : derivWithin f (Ioi a) x = slope f a b\n\u22a2 False",["linarith"]],["Analysis/Calculus/MeanValue.lean",952,"f : \u211d \u2192 \u211d\na : \u211d\nf' : \u211d \u2192 \u211d := f \u2218 Neg.neg\nb : \u211d\nhb\u2081 : b < a\nhb\u2082 : \u2200 \u2983x : \u211d\u2984, x \u2208 Ioo b a \u2192 deriv f x \u2208 Iic (-1)\nx : \u211d\nhx : -a < x \u2227 x < -b\nh\u2081 : -x \u2208 Ioo b a\nh\u2082 : deriv f (-x) \u2264 -1\n\u22a2 deriv f (-x) < 0",["linarith"]],["Analysis/Analytic/Basic.lean",962,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\np : FormalMultilinearSeries \ud835\udd5c E F\ns : Set E\nx : E\nr : \u211d\u22650\u221e\ny : E\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhy : y \u2208 EMetric.ball 0 r\nh'y : x + y \u2208 insert x s\nA\u271d : Tendsto (fun z \u21a6 p.partialSum z.1 y) (atTop \u00d7\u02e2 \ud835\udcdd y) (\ud835\udcdd (f (x + y)))\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nr' : \u211d\u22650\nyr' : \u2016y\u2016\u208a < r'\nr'r : \u2191r' < r\nyr'_2 : \u2016y\u2016 < \u2191r'\nS : Summable fun n \u21a6 \u2016p n\u2016 * \u2191r' ^ n\nk : \u2115\nhk : \u2211' (n : \u2115), \u2016p (n + k)\u2016 * \u2191r' ^ (n + k) < \u03b5 / 4\nA : \u2200\u1da0 (z : \u2115 \u00d7 E) in atTop \u00d7\u02e2 \ud835\udcdd y, dist (p.partialSum k z.2) (p.partialSum k y) < \u03b5 / 4\nB : \u2200\u1da0 (z : \u2115 \u00d7 E) in atTop \u00d7\u02e2 \ud835\udcdd y, \u2016z.2\u2016\u208a < r'\nC : \u2200\u1da0 (z : \u2115 \u00d7 E) in atTop \u00d7\u02e2 \ud835\udcdd y, k \u2264 z.1\nn : \u2115\nz : E\nh'z : \u2016(n, z).2\u2016\u208a < r'\nhkn : k \u2264 (n, z).1\nhz : \u2016p.partialSum k z - p.partialSum k y\u2016 < \u03b5 / 4\nI : \u2200 (w : E), \u2016w\u2016\u208a < r' \u2192 \u2016\u2211 i \u2208 Finset.Ico k n, (p i) fun x \u21a6 w\u2016 \u2264 \u03b5 / 4\n\u22a2 \u03b5 / 4 + \u03b5 / 4 + \u03b5 / 4 < \u03b5",["linarith"]],["Analysis/Analytic/Basic.lean",942,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\np : FormalMultilinearSeries \ud835\udd5c E F\ns : Set E\nx : E\nr : \u211d\u22650\u221e\ny : E\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhy : y \u2208 EMetric.ball 0 r\nh'y : x + y \u2208 insert x s\nA\u271d : Tendsto (fun z \u21a6 p.partialSum z.1 y) (atTop \u00d7\u02e2 \ud835\udcdd y) (\ud835\udcdd (f (x + y)))\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nr' : \u211d\u22650\nyr' : \u2016y\u2016\u208a < r'\nr'r : \u2191r' < r\nyr'_2 : \u2016y\u2016 < \u2191r'\nS : Summable fun n \u21a6 \u2016p n\u2016 * \u2191r' ^ n\nk : \u2115\nhk : \u2211' (n : \u2115), \u2016p (n + k)\u2016 * \u2191r' ^ (n + k) < \u03b5 / 4\nA : \u2200\u1da0 (z : \u2115 \u00d7 E) in atTop \u00d7\u02e2 \ud835\udcdd y, dist (p.partialSum k z.2) (p.partialSum k y) < \u03b5 / 4\nB : \u2200\u1da0 (z : \u2115 \u00d7 E) in atTop \u00d7\u02e2 \ud835\udcdd y, \u2016z.2\u2016\u208a < r'\nC : \u2200\u1da0 (z : \u2115 \u00d7 E) in atTop \u00d7\u02e2 \ud835\udcdd y, k \u2264 z.1\nn : \u2115\nz : E\nh'z : \u2016(n, z).2\u2016\u208a < r'\nhkn : k \u2264 (n, z).1\nhz : \u2016p.partialSum k z - p.partialSum k y\u2016 < \u03b5 / 4\nw : E\nhw : \u2016w\u2016\u208a < r'\ni : \u2115\n_hi : i \u2209 Finset.range (n - k)\n\u22a2 0 \u2264 \u2016p (i + k)\u2016 * \u2191r' ^ (i + k)",["positivity"]],["MeasureTheory/Integral/Bochner.lean",766,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nH : Type u_7\ninst\u271d : NormedAddCommGroup H\nf : \u03b1 \u2192 H\np : \u211d\u22650\u221e\nhp1 : p \u2260 0\nhp2 : p \u2260 \u22a4\nhf : MemLp f p \u03bc\nA : \u222b\u207b (a : \u03b1), ENNReal.ofReal (\u2016f a\u2016 ^ p.toReal) \u2202\u03bc = \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 ^ p.toReal \u2202\u03bc\nx : \u03b1\n\u22a2 0 x \u2264 (fun a \u21a6 \u2016f a\u2016 ^ p.toReal) x",["positivity"]],["Data/Ordmap/Ordset.lean",722,"case H2.inr.intro.intro.inl.intro\n\u03b1 : Type u_1\nl : Ordnode \u03b1\nx : \u03b1\nr : Ordnode \u03b1\nhl : l.Balanced\nhr : r.Balanced\nsl : l.Sized\nsr : r.Sized\nl1 : 1 \u2264 l.size\na\u271d : 1 \u2264 r.size\nr' : \u2115\ne : Raised r.size r'\nH : l.size + r' \u2264 1\nleft\u271d : r.size \u2264 r'\nright\u271d : r' \u2264 r.size + 1\n\u22a2 r.size \u2264 3 * l.size",["omega","linarith"]],["Data/Ordmap/Ordset.lean",979,"a b c d : \u2115\nlr\u2082 : 3 * (b + c + 1 + d) \u2264 16 * a + 9\nmr\u2082 : b + c + 1 \u2264 3 * d\nmm\u2081 : b \u2264 3 * c\n\u22a2 b < 3 * a + 1",["omega","linarith"]],["Data/Ordmap/Ordset.lean",981,"b c d : \u2115\nmr\u2082 : b + c + 1 \u2264 3 * d\n\u22a2 c \u2264 3 * d",["omega","linarith"]],["Data/Ordmap/Ordset.lean",984,"b c d : \u2115\nmr\u2081 : 2 * d \u2264 b + c + 1\nmm\u2081 : b \u2264 3 * c\n\u22a2 d \u2264 3 * c",["omega","linarith"]],["Data/Ordmap/Ordset.lean",987,"a b c d : \u2115\nlr\u2081 : 3 * a \u2264 b + c + 1 + d\nmr\u2082 : b + c + 1 \u2264 3 * d\nmm\u2081 : b \u2264 3 * c\n\u22a2 a + b + 1 \u2264 3 * (c + d + 1)",["omega","linarith"]],["Data/Ordmap/Ordset.lean",990,"a b c d : \u2115\nlr\u2082 : 3 * (b + c + 1 + d) \u2264 16 * a + 9\nmr\u2081 : 2 * d \u2264 b + c + 1\nmm\u2082 : c \u2264 3 * b\n\u22a2 c + d + 1 \u2264 3 * (a + b + 1)",["omega","linarith"]],["Data/Ordmap/Ordset.lean",1050,"a b c : \u2115\nH2 : 3 * a \u2264 b + c\nhb\u2082 : c \u2264 3 * b\n\u22a2 a \u2264 3 * b",["omega","linarith"]],["Data/Ordmap/Ordset.lean",1053,"a b c : \u2115\nH3 : 2 * (b + c) \u2264 9 * a + 3\nh : b < 2 * c\n\u22a2 b < 3 * a + 1",["omega","linarith"]],["Data/Ordmap/Ordset.lean",1056,"a b c : \u2115\nH2 : 3 * a \u2264 b + c\nh : b < 2 * c\n\u22a2 a + b < 3 * c",["omega","linarith"]],["Data/Ordmap/Ordset.lean",1059,"a b : \u2115\nH3 : 2 * b \u2264 9 * a + 3\n\u22a2 3 * b \u2264 16 * a + 9",["omega","linarith"]],["Data/Ordmap/Ordset.lean",1075,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx : \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr : Ordnode \u03b1\nhr : Valid' (\u2191x) (Ordnode.node rs rl rx rr) o\u2082\nH1 : \u00acl.size + (Ordnode.node rs rl rx rr).size \u2264 1\nH2 : delta * l.size \u2264 rl.size + rr.size\nH3 : 2 * (rl.size + rr.size) \u2264 9 * l.size + 3 \u2228 rl.size + rr.size \u2264 2\nH3_0 : l.size = 0 \u2192 rl.size + rr.size \u2264 2\nH3p : l.size > 0 \u2192 2 * (rl.size + rr.size) \u2264 9 * l.size + 3\n\u22a2 \u2200 {a b : \u2115}, 1 \u2264 a \u2192 a + b \u2264 2 \u2192 b \u2264 1",["omega"]],["Data/Ordmap/Ordset.lean",1142,"\u03b1 : Type u_2\nl : Ordnode \u03b1\nl' : \u2115\nr : Ordnode \u03b1\nr' : \u2115\nH1 : BalancedSz l' r'\nH2 : l.size.dist l' \u2264 1 \u2227 r.size = r' \u2228 r.size.dist r' \u2264 1 \u2227 l.size = l'\nthis : r.size \u2264 3 * (l.size + 1)\n\u22a2 2 * r.size \u2264 9 * l.size + 5 \u2228 r.size \u2264 3",["omega"]],["Data/Ordmap/Ordset.lean",1176,"case inr.inr\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nl : Ordnode \u03b1\nx : \u03b1\nr : Ordnode \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nhl : Valid' o\u2081 l \u2191x\nhr : Valid' (\u2191x) r o\u2082\nH\u2081 : l.size = 0 \u2192 r.size \u2264 1\nH\u2083 : 2 * l.size \u2264 9 * r.size + 5 \u2228 l.size \u2264 3\nr0 : r.size > 0\nl0 : l.size > 0\nH\u2082 : r.size \u2264 3 * l.size\n\u22a2 2 * r.size \u2264 9 * l.size + 5",["omega","linarith"]],["Data/Ordmap/Ordset.lean",1266,"a b c : \u2115\nh\u2081 : 3 * a < b + c + 1\nh\u2082 : b \u2264 3 * c\n\u22a2 2 * (a + b) \u2264 9 * c + 5",["omega","linarith"]],["Data/Ordmap/Ordset.lean",1283,"case inr.intro\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\no\u2081 : WithBot \u03b1\no\u2082 : WithTop \u03b1\nls : \u2115\nll : Ordnode \u03b1\nlx : \u03b1\nlr : Ordnode \u03b1\nrs : \u2115\nrl : Ordnode \u03b1\nrx : \u03b1\nrr t : Ordnode \u03b1\nhl : Valid' o\u2081 (Ordnode.node ls ll lx lr) o\u2082\nhr : Valid' o\u2081 (Ordnode.node rs rl rx rr) o\u2082\nh : 3 * (ll.size + lr.size + 1) < rl.size + rr.size + 1\nv : Valid' o\u2081 t \u2191rx\ne : t.size = ll.size + lr.size + 1 + rl.size\nhr\u2081 : rl.size \u2264 delta * rr.size\nhr\u2082 : rr.size \u2264 3 * rl.size\na\u271d\u00b9 : 1 \u2264 t.size\na\u271d : 1 \u2264 rr.size\n\u22a2 rr.size \u2264 3 * (ll.size + lr.size + 1 + rl.size)",["omega"]],["Analysis/InnerProductSpace/Projection.lean",225,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nh : Convex \u211d K\nu v : F\nhv : v \u2208 K\nthis\u271d\u00b9 : Nonempty \u2191K := Nonempty.intro \u27e8v, hv\u27e9\neq : \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016\nw : F\nhw : w \u2208 K\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\np : \u211d := \u27eau - v, w - v\u27eb_\u211d\nq : \u211d := \u2016w - v\u2016 ^ 2\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nthis\u271d : \u2200 (\u03b8 : \u211d), 0 < \u03b8 \u2192 \u03b8 \u2264 1 \u2192 2 * p \u2264 \u03b8 * 0\nhq : q = 0\nthis : 2 * p \u2264 1 * 0\n\u22a2 p \u2264 0",["linarith","aesop"]],["Analysis/InnerProductSpace/Projection.lean",240,"case neg\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nh : Convex \u211d K\nu v : F\nhv : v \u2208 K\nthis\u271d\u00b9 : Nonempty \u2191K := Nonempty.intro \u27e8v, hv\u27e9\neq : \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016\nw : F\nhw : w \u2208 K\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\np : \u211d := \u27eau - v, w - v\u27eb_\u211d\nq : \u211d := \u2016w - v\u2016 ^ 2\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nthis\u271d : \u2200 (\u03b8 : \u211d), 0 < \u03b8 \u2192 \u03b8 \u2264 1 \u2192 2 * p \u2264 \u03b8 * q\nhq : \u00acq = 0\nq_pos : 0 < q\nhp : 0 < \u27eau - v, w - v\u27eb_\u211d\n\u03b8 : \u211d := 1 \u2293 p / q\neq\u2081 : \u03b8 * q \u2264 p\nthis : 2 * p \u2264 p\n\u22a2 False",["linarith","aesop"]],["Analysis/InnerProductSpace/Projection.lean",248,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nh\u271d : Convex \u211d K\nu v : F\nhv : v \u2208 K\nthis\u271d : Nonempty \u2191K := Nonempty.intro \u27e8v, hv\u27e9\nh : \u2200 w \u2208 K, \u27eau - v, w - v\u27eb_\u211d \u2264 0\nw : \u2191K\nthis : \u27eau - v, \u2191w - v\u27eb_\u211d \u2264 0\n\u22a2 \u2016u - v\u2016 * \u2016u - v\u2016 \u2264 \u2016u - v\u2016 * \u2016u - v\u2016 - 2 * \u27eau - v, \u2191w - v\u27eb_\u211d",["linarith"]],["Analysis/InnerProductSpace/Projection.lean",308,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Submodule \u211d F\nu v : F\nhv : v \u2208 K\nh\u271d : \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016\nh : \u2200 w \u2208 K, \u27eau - v, w - v\u27eb_\u211d \u2264 0\nw : F\nhw : w \u2208 K\nle : \u27eau - v, w\u27eb_\u211d \u2264 0\nw'' : F := -w + v\nthis : w'' \u2208 K\nh\u2081 : -\u27eau - v, w\u27eb_\u211d \u2264 0\nh\u2082 : w'' - v = -w\n\u22a2 \u27eau - v, w\u27eb_\u211d \u2265 0",["linarith","aesop"]],["Analysis/InnerProductSpace/Projection.lean",158,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nne : K.Nonempty\nh\u2081 : IsComplete K\nh\u2082 : Convex \u211d K\nu : F\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\nthis\u271d : Nonempty \u2191K := Set.Nonempty.to_subtype ne\nzero_le_\u03b4 : 0 \u2264 \u03b4\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nw : \u2115 \u2192 \u2191K\nhw : \u2200 (n : \u2115), \u2016u - \u2191(w n)\u2016 < \u03b4 + 1 / (\u2191n + 1)\nnorm_tendsto : Tendsto (fun n \u21a6 \u2016u - \u2191(w n)\u2016) atTop (\ud835\udcdd \u03b4)\nb\u271d : \u2115 \u2192 \u211d := fun n \u21a6 8 * \u03b4 * (1 / (\u2191n + 1)) + 4 * (1 / (\u2191n + 1)) * (1 / (\u2191n + 1))\np q N : \u2115\nhp : N \u2264 p\nhq : N \u2264 q\nwp : F := \u2191(w p)\nwq : F := \u2191(w q)\na : F := u - wq\nb : F := u - wp\nhalf : \u211d := 1 / 2\ndiv : \u211d := 1 / (\u2191N + 1)\nthis : 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016 + \u2016wp - wq\u2016 * \u2016wp - wq\u2016 = 2 * (\u2016a\u2016 * \u2016a\u2016 + \u2016b\u2016 * \u2016b\u2016)\neq : \u03b4 \u2264 \u2016u - half \u2022 (wq + wp)\u2016\neq\u2081 : 4 * \u03b4 * \u03b4 \u2264 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016\neq\u2082 : \u2016a\u2016 \u2264 \u03b4 + div\neq\u2082' : \u2016b\u2016 \u2264 \u03b4 + div\n\u22a2 2 * (\u2016a\u2016 * \u2016a\u2016 + \u2016b\u2016 * \u2016b\u2016) - 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016 \u2264\n    2 * (\u2016a\u2016 * \u2016a\u2016 + \u2016b\u2016 * \u2016b\u2016) - 4 * \u03b4 * \u03b4",["gcongr","linarith"]],["Analysis/InnerProductSpace/Projection.lean",161,"case h.right.left.h\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nne : K.Nonempty\nh\u2081 : IsComplete K\nh\u2082 : Convex \u211d K\nu : F\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\nthis\u271d : Nonempty \u2191K := Set.Nonempty.to_subtype ne\nzero_le_\u03b4 : 0 \u2264 \u03b4\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nw : \u2115 \u2192 \u2191K\nhw : \u2200 (n : \u2115), \u2016u - \u2191(w n)\u2016 < \u03b4 + 1 / (\u2191n + 1)\nnorm_tendsto : Tendsto (fun n \u21a6 \u2016u - \u2191(w n)\u2016) atTop (\ud835\udcdd \u03b4)\nb\u271d : \u2115 \u2192 \u211d := fun n \u21a6 8 * \u03b4 * (1 / (\u2191n + 1)) + 4 * (1 / (\u2191n + 1)) * (1 / (\u2191n + 1))\np q N : \u2115\nhp : N \u2264 p\nhq : N \u2264 q\nwp : F := \u2191(w p)\nwq : F := \u2191(w q)\na : F := u - wq\nb : F := u - wp\nhalf : \u211d := 1 / 2\ndiv : \u211d := 1 / (\u2191N + 1)\nthis : 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016 + \u2016wp - wq\u2016 * \u2016wp - wq\u2016 = 2 * (\u2016a\u2016 * \u2016a\u2016 + \u2016b\u2016 * \u2016b\u2016)\neq : \u03b4 \u2264 \u2016u - half \u2022 (wq + wp)\u2016\neq\u2081 : 4 * \u03b4 * \u03b4 \u2264 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016\neq\u2082 : \u2016a\u2016 \u2264 \u03b4 + div\neq\u2082' : \u2016b\u2016 \u2264 \u03b4 + div\n\u22a2 0 \u2264 b\u271d N",["positivity"]],["Analysis/InnerProductSpace/Projection.lean",1171,"F : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\nn : \u2115\nIH :\n  \u2200 (\u03c6 : F \u2243\u2097\u1d62[\u211d] F),\n    finrank \u211d\n          \u21a5(LinearMap.ker\n                (ContinuousLinearMap.id \u211d F -\n                  \u2191{ toLinearEquiv := \u03c6.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef }))\u15ee \u2264\n        n \u2192\n      \u2203 l, l.length \u2264 n \u2227 \u03c6 = (List.map (fun v \u21a6 reflection (Submodule.span \u211d {v})\u15ee) l).prod\n\u03c6 : F \u2243\u2097\u1d62[\u211d] F\nW : Submodule \u211d F :=\n  LinearMap.ker\n    (ContinuousLinearMap.id \u211d F - \u2191{ toLinearEquiv := \u03c6.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef })\nhW : \u2200 w \u2208 W, \u03c6 w = w\nhn' : \u00acfinrank \u211d \u21a5W\u15ee \u2264 n\nthis\u271d\u00b2 : Nontrivial \u21a5W\u15ee\nv : \u21a5W\u15ee\nhv : v \u2260 0\nh\u03c6v : \u03c6 \u2191v \u2208 W\u15ee\nhv' : \u2191v \u2209 W\nx : F := \u2191v - \u03c6 \u2191v\n\u03c1 : F \u2243\u2097\u1d62[\u211d] F := reflection (Submodule.span \u211d {x})\u15ee\nV : Submodule \u211d F :=\n  LinearMap.ker\n    (ContinuousLinearMap.id \u211d F -\n      \u2191{ toLinearEquiv := (\u03c6.trans \u03c1).toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef })\nhV : \u2200 (w : F), \u03c1 (\u03c6 w) = w \u2192 w \u2208 V\nH\u2082V : W \u2264 V\nH\u2081V : \u2191v \u2208 V\nhn : finrank \u211d \u21a5W\u15ee \u2264 n + 1\nthis\u271d\u00b9 : finrank \u211d \u21a5W + 1 \u2264 finrank \u211d \u21a5V\nthis\u271d : finrank \u211d \u21a5V + finrank \u211d \u21a5V\u15ee = finrank \u211d F\nthis : finrank \u211d \u21a5W + finrank \u211d \u21a5W\u15ee = finrank \u211d F\n\u22a2 finrank \u211d \u21a5V\u15ee \u2264 n",["omega","linarith"]],["Analysis/NormedSpace/Multilinear/Basic.lean",285,"\ud835\udd5c : Type u\n\u03b9 : Type v\nE : \u03b9 \u2192 Type wE\nG : Type wG\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b2 : SeminormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\ninst\u271d : Fintype \u03b9\nf : MultilinearMap \ud835\udd5c E G\nC : \u211d\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nD : \u211d := C \u2294 1\nD_pos : 0 \u2264 D\nm : (i : \u03b9) \u2192 E i\n\u22a2 0 \u2264 \u220f i : \u03b9, \u2016m i\u2016",["positivity"]],["Analysis/NormedSpace/Multilinear/Basic.lean",685,"\ud835\udd5c : Type u\n\u03b9 : Type v\nE : \u03b9 \u2192 Type wE\nG : Type wG\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b2 : SeminormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\ninst\u271d : Fintype \u03b9\nf : MultilinearMap \ud835\udd5c E G\nC : \u211d\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm : (i : \u03b9) \u2192 E i\n\u22a2 0 \u2264 \u220f i : \u03b9, \u2016m i\u2016",["positivity"]],["Analysis/NormedSpace/Multilinear/Basic.lean",987,"case hc\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u00b2 : Fintype \u03b9'\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2076 : SeminormedAddCommGroup G\ninst\u271d\u2075 : NormedSpace \ud835\udd5c G\ninst\u271d\u2074 : SeminormedAddCommGroup G'\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G'\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\nf : MultilinearMap \ud835\udd5c E (MultilinearMap \ud835\udd5c E' G)\nC : \u211d\nH : \u2200 (m\u2081 : (i : \u03b9) \u2192 E i) (m\u2082 : (i : \u03b9') \u2192 E' i), \u2016(f m\u2081) m\u2082\u2016 \u2264 (C * \u220f i : \u03b9, \u2016m\u2081 i\u2016) * \u220f i : \u03b9', \u2016m\u2082 i\u2016\nm : (i : \u03b9) \u2192 E i\n\u22a2 0 \u2264 \u220f i : \u03b9, \u2016m i\u2016",["positivity"]],["Analysis/Analytic/Composition.lean",108,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b9\u2070 : CommRing \ud835\udd5c\ninst\u271d\u2079 : AddCommGroup E\ninst\u271d\u2078 : AddCommGroup F\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c F\ninst\u271d\u2075 : TopologicalSpace E\ninst\u271d\u2074 : TopologicalSpace F\ninst\u271d\u00b3 : IsTopologicalAddGroup E\ninst\u271d\u00b2 : ContinuousConstSMul \ud835\udd5c E\ninst\u271d\u00b9 : IsTopologicalAddGroup F\ninst\u271d : ContinuousConstSMul \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nv : Fin n \u2192 E\ni : Fin (Composition.ones n).length\nj : \u2115\nhjn : j < (Composition.ones n).blocksFun i\nhj1 : j < 1\n\u22a2 j = 0",["omega","aesop","linarith"]],["Analysis/Analytic/Composition.lean",418,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nv0 : Fin 0 \u2192 E\nn : \u2115\nn_pos : n > 0\nb : Composition n\na\u271d : b \u2208 Finset.univ\nhb : b \u2260 Composition.single n n_pos\nthis\u271d : b.length \u2260 1\nthis : 0 < b.length\n\u22a2 1 < b.length",["omega"]],["Topology/ContinuousMap/Bounded/Basic.lean",1173,"F : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nR : Type u_2\ninst\u271d : NonUnitalSeminormedRing R\nf g : \u03b1 \u2192\u1d47 R\n\u22a2 0 \u2264 \u2016f\u2016 * \u2016g\u2016",["positivity"]],["Analysis/Seminorm.lean",431,"R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\n\u03b9 : Type u_11\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np\u271d q\u271d : Seminorm \ud835\udd5c E\nx\u271d : E\np q : Seminorm \ud835\udd5c E\nx i : E\n\u22a2 0 \u2264 p i + q (0 - i)",["positivity"]],["Analysis/Seminorm.lean",1188,"\ud835\udd5c : Type u_3\nE : Type u_7\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nx : E\nhx : p x \u2260 0\n\u22a2 0 < p x / \u03b5",["positivity"]],["Analysis/Seminorm.lean",1190,"\ud835\udd5c : Type u_3\nE : Type u_7\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nx : E\nhx : p x \u2260 0\nx\u03b5pos : 0 < p x / \u03b5\nn : \u2124\nhn : p x / \u03b5 \u2208 Ico (\u2016c\u2016 ^ n) (\u2016c\u2016 ^ (n + 1))\n\u22a2 0 < \u2016c\u2016",["positivity","linarith"]],["Analysis/Distribution/SchwartzSpace.lean",628,"C\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\nthis\u271d : 0 \u2264 C\u2082\nthis : 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l) = ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)\nh'x : 1 \u2264 x\n\u22a2 C\u2082 \u2264 C\u2081 + C\u2082",["linarith"]],["Analysis/Distribution/SchwartzSpace.lean",626,"C\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\nthis\u271d : 0 \u2264 C\u2082\nthis : 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l) = ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)\nh'x : 1 \u2264 x\n\u22a2 0 \u2264 ((1 + x) / 2) ^ (-\u2191l)",["positivity"]],["Analysis/Distribution/SchwartzSpace.lean",659,"D : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup D\ninst\u271d\u00b2 : MeasurableSpace D\nE : Type u_8\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\nv : D\n\u22a2 0 v \u2264 \u2016v\u2016 ^ k * \u2016f v\u2016",["positivity"]],["Analysis/Distribution/SchwartzSpace.lean",812,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u00b9\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : NormedSpace \u211d E\ninst\u271d\u00b9\u2070 : NormedAddCommGroup F\ninst\u271d\u2079 : NormedSpace \u211d F\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2077 : NormedAlgebra \u211d \ud835\udd5c\ninst\u271d\u2076 : NormedAddCommGroup D\ninst\u271d\u2075 : NormedSpace \u211d D\ninst\u271d\u2074 : NormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \u211d G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : NormedSpace \ud835\udd5c G\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\ng : D \u2192 F\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nhgrowth : \u2200 N \u2264 n, \u2200 (x : D), \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\n\u22a2 0 \u2264 \u2016B\u2016 * (\u2191n + 1) * \u2191(n.choose (n / 2)) * (C * 2 ^ (l + k))",["positivity"]],["Analysis/Distribution/SchwartzSpace.lean",870,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \u211d F\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup D\ninst\u271d\u00b2 : NormedSpace \u211d D\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : SMulCommClass \u211d \ud835\udd5c F\ng : D \u2192 E\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nhgrowth : \u2200 N \u2264 n, \u2200 (x : D), \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\nkg : \u2115\nCg : \u211d\nhg_upper' : 0 \u2264 Cg * (1 + \u2016g 0\u2016) ^ kg\n\u22a2 0 < (1 + \u2016g 0\u2016) ^ kg",["positivity"]],["Analysis/Distribution/SchwartzSpace.lean",872,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \u211d F\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup D\ninst\u271d\u00b2 : NormedSpace \u211d D\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : SMulCommClass \u211d \ud835\udd5c F\ng : D \u2192 E\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nhgrowth : \u2200 N \u2264 n, \u2200 (x : D), \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\nkg : \u2115\nCg : \u211d\nhg_upper' : \u2200 (x : D), \u2016x\u2016 \u2264 Cg * (1 + \u2016g x\u2016) ^ kg\nhCg : 1 \u2264 1 + Cg\nk' : \u2115 := kg * (k + l * n)\n\u22a2 0 \u2264 (1 + Cg) ^ (k + l * n) * ((C + 1) ^ n * \u2191n ! * 2 ^ k')",["positivity"]],["Analysis/Distribution/SchwartzSpace.lean",887,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \u211d F\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup D\ninst\u271d\u00b2 : NormedSpace \u211d D\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : SMulCommClass \u211d \ud835\udd5c F\ng : D \u2192 E\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nhgrowth : \u2200 N \u2264 n, \u2200 (x : D), \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\nkg : \u2115\nCg : \u211d\nhg_upper' : \u2200 (x : D), \u2016x\u2016 \u2264 Cg * (1 + \u2016g x\u2016) ^ kg\nhCg : 1 \u2264 1 + Cg\nk' : \u2115 := kg * (k + l * n)\nf : \ud835\udce2(E, F)\nx : D\nseminorm_f : \u211d := ((Finset.Iic (k', n)).sup (schwartzSeminormFamily \ud835\udd5c E F)) f\nhg_upper'' : (1 + \u2016x\u2016) ^ (k + l * n) \u2264 (1 + Cg) ^ (k + l * n) * (1 + \u2016g x\u2016) ^ k'\ni : \u2115\nhi : i \u2264 n\n\u22a2 0 < (1 + \u2016g x\u2016) ^ k'",["positivity"]],["Analysis/Distribution/SchwartzSpace.lean",913,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \u211d F\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup D\ninst\u271d\u00b2 : NormedSpace \u211d D\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : SMulCommClass \u211d \ud835\udd5c F\ng : D \u2192 E\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nhgrowth : \u2200 N \u2264 n, \u2200 (x : D), \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\nkg : \u2115\nCg : \u211d\nhg_upper' : \u2200 (x : D), \u2016x\u2016 \u2264 Cg * (1 + \u2016g x\u2016) ^ kg\nhCg : 1 \u2264 1 + Cg\nk' : \u2115 := kg * (k + l * n)\nf : \ud835\udce2(E, F)\nx : D\nseminorm_f : \u211d := ((Finset.Iic (k', n)).sup (schwartzSeminormFamily \ud835\udd5c E F)) f\nhg_upper'' : (1 + \u2016x\u2016) ^ (k + l * n) \u2264 (1 + Cg) ^ (k + l * n) * (1 + \u2016g x\u2016) ^ k'\nhbound : \u2200 i \u2264 n, \u2016iteratedFDeriv \u211d i (\u21d1f) (g x)\u2016 \u2264 2 ^ k' * seminorm_f / (1 + \u2016g x\u2016) ^ k'\nhgrowth' : \u2200 (N : \u2115), 1 \u2264 N \u2192 N \u2264 n \u2192 \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 ((C + 1) * (1 + \u2016x\u2016) ^ l) ^ N\nthis :\n  \u2016iteratedFDeriv \u211d n (f.toFun \u2218 g) x\u2016 \u2264 \u2191n ! * (2 ^ k' * seminorm_f / (1 + \u2016g x\u2016) ^ k') * ((C + 1) * (1 + \u2016x\u2016) ^ l) ^ n\nhxk : \u2016x\u2016 ^ k \u2264 (1 + \u2016x\u2016) ^ k\nrearrange :\n  (1 + \u2016x\u2016) ^ k * (\u2191n ! * (2 ^ k' * seminorm_f / (1 + \u2016g x\u2016) ^ k') * ((C + 1) * (1 + \u2016x\u2016) ^ l) ^ n) =\n    (1 + \u2016x\u2016) ^ (k + l * n) / (1 + \u2016g x\u2016) ^ k' * ((C + 1) ^ n * \u2191n ! * 2 ^ k' * seminorm_f)\n\u22a2 0 < (1 + \u2016g x\u2016) ^ k'",["positivity"]],["Analysis/Distribution/SchwartzSpace.lean",917,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \u211d F\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup D\ninst\u271d\u00b2 : NormedSpace \u211d D\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : SMulCommClass \u211d \ud835\udd5c F\ng : D \u2192 E\nhg : Function.HasTemperateGrowth g\nk n l : \u2115\nC : \u211d\nhC : 0 \u2264 C\nhgrowth : \u2200 N \u2264 n, \u2200 (x : D), \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 C * (1 + \u2016x\u2016) ^ l\nkg : \u2115\nCg : \u211d\nhg_upper' : \u2200 (x : D), \u2016x\u2016 \u2264 Cg * (1 + \u2016g x\u2016) ^ kg\nhCg : 1 \u2264 1 + Cg\nk' : \u2115 := kg * (k + l * n)\nf : \ud835\udce2(E, F)\nx : D\nseminorm_f : \u211d := ((Finset.Iic (k', n)).sup (schwartzSeminormFamily \ud835\udd5c E F)) f\nhg_upper'' : (1 + \u2016x\u2016) ^ (k + l * n) / (1 + \u2016g x\u2016) ^ k' \u2264 (1 + Cg) ^ (k + l * n)\nhbound : \u2200 i \u2264 n, \u2016iteratedFDeriv \u211d i (\u21d1f) (g x)\u2016 \u2264 2 ^ k' * seminorm_f / (1 + \u2016g x\u2016) ^ k'\nhgrowth' : \u2200 (N : \u2115), 1 \u2264 N \u2192 N \u2264 n \u2192 \u2016iteratedFDeriv \u211d N g x\u2016 \u2264 ((C + 1) * (1 + \u2016x\u2016) ^ l) ^ N\nthis\u271d :\n  \u2016iteratedFDeriv \u211d n (f.toFun \u2218 g) x\u2016 \u2264 \u2191n ! * (2 ^ k' * seminorm_f / (1 + \u2016g x\u2016) ^ k') * ((C + 1) * (1 + \u2016x\u2016) ^ l) ^ n\nhxk : \u2016x\u2016 ^ k \u2264 (1 + \u2016x\u2016) ^ k\nrearrange :\n  (1 + \u2016x\u2016) ^ k * (\u2191n ! * (2 ^ k' * seminorm_f / (1 + \u2016g x\u2016) ^ k') * ((C + 1) * (1 + \u2016x\u2016) ^ l) ^ n) =\n    (1 + \u2016x\u2016) ^ (k + l * n) / (1 + \u2016g x\u2016) ^ k' * ((C + 1) ^ n * \u2191n ! * 2 ^ k' * seminorm_f)\nhgxk' : 0 < (1 + \u2016g x\u2016) ^ k'\nthis : 0 \u2264 seminorm_f\n\u22a2 0 \u2264 (C + 1) ^ n * \u2191n ! * 2 ^ k' * seminorm_f",["positivity"]],["RingTheory/LaurentSeries.lean",626,"K : Type u_2\ninst\u271d : Field K\nn D : \u2124\nf : K\u2e28X\u2e29\nH : Valued.v f \u2264 \u2191(Multiplicative.ofAdd (-D))\nhnd : n < D\nh_n_ord : HahnSeries.order f \u2264 n\nF : K\u27e6X\u27e7 := f.powerSeriesPart\nhF : F = f.powerSeriesPart\nord_nonpos : HahnSeries.order f \u2264 0\ns : \u2115\nhs : HahnSeries.order f = -\u2191s\nm : \u2115\nhm : n + \u2191s = \u2191m\n\u22a2 0 \u2264 D + \u2191s",["omega","linarith"]],["RingTheory/LaurentSeries.lean",634,"K : Type u_2\ninst\u271d : Field K\nn D : \u2124\nf : K\u2e28X\u2e29\nH : Valued.v f \u2264 \u2191(Multiplicative.ofAdd (-D))\nhnd : n < D\nh_n_ord : HahnSeries.order f \u2264 n\nF : K\u27e6X\u27e7 := f.powerSeriesPart\nhF : F = f.powerSeriesPart\nord_nonpos : 0 < HahnSeries.order f\ns : \u2115\nhs : -HahnSeries.order f = -\u2191s\n\u22a2 0 \u2264 n - \u2191s",["omega","aesop","linarith"]],["RingTheory/LaurentSeries.lean",635,"K : Type u_2\ninst\u271d : Field K\nn D : \u2124\nf : K\u2e28X\u2e29\nH : Valued.v f \u2264 \u2191(Multiplicative.ofAdd (-D))\nhnd : n < D\nh_n_ord : HahnSeries.order f \u2264 n\nF : K\u27e6X\u27e7 := f.powerSeriesPart\nhF : F = f.powerSeriesPart\nord_nonpos : 0 < HahnSeries.order f\ns : \u2115\nhs : -HahnSeries.order f = -\u2191s\nm : \u2115\nhm : n - \u2191s = \u2191m\n\u22a2 0 \u2264 D - \u2191s",["omega","linarith"]],["RingTheory/LaurentSeries.lean",663,"case neg.intro.a\nK : Type u_2\ninst\u271d : Field K\nD : \u2124\nf : K\u2e28X\u2e29\nh_val_f : \u2200 n < D, f.coeff n = 0\nF : K\u27e6X\u27e7 := f.powerSeriesPart\nord_nonpos : HahnSeries.order f \u2264 0\ns : \u2115\nhs : HahnSeries.order f = -\u2191s\nhDs : \u00acD + \u2191s \u2264 0\nd : \u2115\nhd : D + \u2191s = \u2191d\nn : \u2115\nhn : n < d\n\u22a2 -\u2191s + \u2191n < D",["omega","linarith"]],["RingTheory/LaurentSeries.lean",674,"case pos\nK : Type u_2\ninst\u271d : Field K\nD : \u2124\nf : K\u2e28X\u2e29\nh_val_f : \u2200 n < D, f.coeff n = 0\nF : K\u27e6X\u27e7 := f.powerSeriesPart\nord_nonpos : \u00acHahnSeries.order f \u2264 0\ns : \u2115\nhs : HahnSeries.order f = \u2191s\nhDs : D - \u2191s \u2264 0\n\u22a2 0 \u2264 -D + \u2191s",["omega","aesop","linarith"]],["RingTheory/LaurentSeries.lean",681,"case neg.intro\nK : Type u_2\ninst\u271d : Field K\nD : \u2124\nf : K\u2e28X\u2e29\nh_val_f : \u2200 n < D, f.coeff n = 0\nF : K\u27e6X\u27e7 := f.powerSeriesPart\nord_nonpos : \u00acHahnSeries.order f \u2264 0\ns : \u2115\nhs : HahnSeries.order f = \u2191s\nhDs : \u00acD - \u2191s \u2264 0\nd : \u2115\nhd : D - \u2191s = \u2191d\nn : \u2115\nhn : n < d\n\u22a2 \u2191s + \u2191n < D",["omega","linarith"]],["Analysis/Normed/Group/Basic.lean",487,"E : Type u_5\ninst\u271d : SeminormedGroup E\nx : E\n\u22a2 0 < 1 + \u2016x\u2016 ^ 2",["positivity"]],["MeasureTheory/Decomposition/Lebesgue.lean",717,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nh : \u00ac\u03bc \u27c2\u2098 \u03bd\nf : \u2115 \u2192 Set \u03b1\nhf\u2081 : \u2200 (n : \u2115), MeasurableSet (f n)\nhf\u2082 : \u2200 (n : \u2115) (t : Set \u03b1), MeasurableSet t \u2192 ((1 / (\u2191n + 1)) \u2022 \u03bd) (t \u2229 f n) \u2264 \u03bc (t \u2229 f n)\nhf\u2083 : \u2200 (n : \u2115) (t : Set \u03b1), MeasurableSet t \u2192 \u03bc (t \u2229 (f n)\u1d9c) \u2264 ((1 / (\u2191n + 1)) \u2022 \u03bd) (t \u2229 (f n)\u1d9c)\nA : Set \u03b1 := \u22c2 n, (f n)\u1d9c\nhAmeas : MeasurableSet A\nhA\u2082 : \u2200 (n : \u2115) (t : Set \u03b1), MeasurableSet t \u2192 \u03bc (t \u2229 A) \u2264 ((1 / (\u2191n + 1)) \u2022 \u03bd) (t \u2229 A)\n\u03bcA : \u211d\u22650\nhA\u2083\u271d\u00b9 : \u2200 (n : \u2115), \u2191\u03bcA \u2264 \u2191(1 / (\u2191n + 1)) * \u03bd A\n\u03bdA : \u211d\u22650\nhA\u2083\u271d hA\u2083 : \u2200 (n : \u2115), \u2191\u03bcA \u2264 \u2191(1 / (\u2191n + 1)) * \u2191\u03bdA\nhb : 0 < \u03bdA\nc : \u211d\u22650\nhc : 0 < c\n\u22a2 0 < \u2191c * (\u2191\u03bdA)\u207b\u00b9",["positivity","aesop"]],["Topology/MetricSpace/GromovHausdorff.lean",557,"X : Type u\ninst\u271d\u2075 : MetricSpace X\ninst\u271d\u2074 : CompactSpace X\ninst\u271d\u00b3 : Nonempty X\nY : Type v\ninst\u271d\u00b2 : MetricSpace Y\ninst\u271d\u00b9 : CompactSpace Y\ninst\u271d : Nonempty Y\ns : Set X\n\u03a6 : \u2191s \u2192 Y\n\u03b5\u2081 \u03b5\u2082 \u03b5\u2083 : \u211d\nhs : \u2200 (x : X), \u2203 y \u2208 s, dist x y \u2264 \u03b5\u2081\nhs' : \u2200 (x : Y), \u2203 y, dist x (\u03a6 y) \u2264 \u03b5\u2083\nH : \u2200 (x y : \u2191s), |dist x y - dist (\u03a6 x) (\u03a6 y)| \u2264 \u03b5\u2082\n\u03b4 : \u211d\n\u03b40 : 0 < \u03b4\nxX : X\nh\u271d : xX \u2208 univ\nxs : X\nhxs : xs \u2208 s\nDxs : dist xX xs \u2264 \u03b5\u2081\nsne : s.Nonempty\nthis\u271d : Nonempty \u2191s := Nonempty.to_subtype sne\nthis : 0 \u2264 \u03b5\u2082\np q : \u2191s\n\u22a2 \u03b5\u2082 \u2264 2 * (\u03b5\u2082 / 2 + \u03b4)",["linarith"]],["Topology/MetricSpace/GromovHausdorff.lean",617,"case intro.intro.intro\nX : Type u\ninst\u271d\u2075 : MetricSpace X\ninst\u271d\u2074 : CompactSpace X\ninst\u271d\u00b3 : Nonempty X\nY : Type v\ninst\u271d\u00b2 : MetricSpace Y\ninst\u271d\u00b9 : CompactSpace Y\ninst\u271d : Nonempty Y\ns : Set X\n\u03a6 : \u2191s \u2192 Y\n\u03b5\u2081 \u03b5\u2082 \u03b5\u2083 : \u211d\nhs : \u2200 (x : X), \u2203 y \u2208 s, dist x y \u2264 \u03b5\u2081\nhs' : \u2200 (x : Y), \u2203 y, dist x (\u03a6 y) \u2264 \u03b5\u2083\nH : \u2200 (x y : \u2191s), |dist x y - dist (\u03a6 x) (\u03a6 y)| \u2264 \u03b5\u2082\n\u03b4 : \u211d\n\u03b40 : 0 < \u03b4\nxX : X\nh\u271d : xX \u2208 univ\nxs : X\nhxs : xs \u2208 s\nDxs : dist xX xs \u2264 \u03b5\u2081\nsne : s.Nonempty\nthis\u271d\u2078 : Nonempty \u2191s := Nonempty.to_subtype sne\nthis\u271d\u2077 : 0 \u2264 \u03b5\u2082\nthis\u271d\u2076 : \u2200 (p q : \u2191s), |dist p q - dist (\u03a6 p) (\u03a6 q)| \u2264 2 * (\u03b5\u2082 / 2 + \u03b4)\nthis\u271d\u2075 : MetricSpace (X \u2295 Y) := glueMetricApprox (fun x \u21a6 \u2191x) (fun x \u21a6 \u03a6 x) (\u03b5\u2082 / 2 + \u03b4) \u22ef this\u271d\u2076\nFl : X \u2192 X \u2295 Y := inl\nFr : Y \u2192 X \u2295 Y := inr\nIl : Isometry Fl\nIr : Isometry Fr\nthis\u271d\u2074 : ghDist X Y \u2264 hausdorffDist (range Fl) (range Fr)\nthis\u271d\u00b3 : hausdorffDist (range Fl) (range Fr) \u2264 hausdorffDist (range Fl) (Fl '' s) + hausdorffDist (Fl '' s) (range Fr)\nthis\u271d\u00b2 :\n  hausdorffDist (Fl '' s) (range Fr) \u2264 hausdorffDist (Fl '' s) (Fr '' range \u03a6) + hausdorffDist (Fr '' range \u03a6) (range Fr)\nthis\u271d\u00b9 : hausdorffDist (range Fl) (Fl '' s) \u2264 \u03b5\u2081\nthis\u271d : hausdorffDist (Fl '' s) (Fr '' range \u03a6) \u2264 \u03b5\u2082 / 2 + \u03b4\nthis : hausdorffDist (Fr '' range \u03a6) (range Fr) \u2264 \u03b5\u2083\n\u22a2 ghDist X Y \u2264 \u03b5\u2081 + \u03b5\u2082 / 2 + \u03b5\u2083 + \u03b4",["linarith"]],["Topology/MetricSpace/GromovHausdorff.lean",274,"X : Type u\ninst\u271d\u2075 : MetricSpace X\ninst\u271d\u2074 : CompactSpace X\ninst\u271d\u00b3 : Nonempty X\nY : Type v\ninst\u271d\u00b2 : MetricSpace Y\ninst\u271d\u00b9 : CompactSpace Y\ninst\u271d : Nonempty Y\ninhabited_h\u271d : Inhabited X\ninhabited_h : Inhabited Y\np q : NonemptyCompacts \u21a5(lp (fun n \u21a6 \u211d) \u22a4)\nhp : \u27e6p\u27e7 = toGHSpace X\nhq : \u27e6q\u27e7 = toGHSpace Y\nbound : hausdorffDist \u2191p \u2191q < diam univ + 1 + diam univ\n\u03a6 : X \u2192 \u21a5(lp (fun n \u21a6 \u211d) \u22a4)\n\u03a6isom : Isometry \u03a6\n\u03a6range : range \u03a6 = \u2191p\n\u03a8 : Y \u2192 \u21a5(lp (fun n \u21a6 \u211d) \u22a4)\n\u03a8isom : Isometry \u03a8\n\u03a8range : range \u03a8 = \u2191q\nxX : X\nh\u271d : xX \u2208 univ\ny : \u21a5(lp (fun n \u21a6 \u211d) \u22a4)\nhy : y \u2208 range \u03a8\nz : Y\ndy : dist (\u03a6 xX) (\u03a8 z) < diam univ + 1 + diam univ\nhzy : \u03a8 z = y\nD\u03a6 : diam (range \u03a6) = diam univ\nD\u03a8 : diam (range \u03a8) = diam univ\n\u22a2 diam univ + dist (\u03a6 xX) (\u03a8 z) + diam univ \u2264 diam univ + (diam univ + 1 + diam univ) + diam univ",["gcongr","linarith"]],["Topology/MetricSpace/GromovHausdorff.lean",973,"X : \u2115 \u2192 Type\ninst\u271d\u00b2 : (n : \u2115) \u2192 MetricSpace (X n)\ninst\u271d\u00b9 : \u2200 (n : \u2115), CompactSpace (X n)\ninst\u271d : \u2200 (n : \u2115), Nonempty (X n)\nd : \u2115 \u2192 \u211d := fun n \u21a6 (1 / 2) ^ n\nx\u271d : \u2115\n\u22a2 0 < d x\u271d",["positivity","aesop"]],["Data/Num/Lemmas.lean",484,"n : PosNum\nthis : 0 < \u2191n\n\u22a2 \u00ac2 * \u2191n = 0",["omega","aesop"]],["Data/Num/Lemmas.lean",488,"n : PosNum\n\u22a2 \u00ac2 * \u2191n + 1 = 0",["omega"]],["Data/Num/Lemmas.lean",824,"n : \u2115\nIH : \u2200 (m : PosNum), \u2191(m >>> n) = \u2191(pos m) >>> n\nm : PosNum\nm\u271d : \u2115\n\u22a2 (m\u271d + m\u271d) / 2 = m\u271d",["omega"]],["Topology/MetricSpace/Pseudo/Defs.lean",239,"\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u03b1\n\u22a2 0 \u2264 dist x y",["positivity"]],["Data/Set/Image.lean",337,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nS S' : Set \u03b2\n\u22a2 (\u2203 x \u2208 range f \u2229 S', x \u2209 range f \u2229 S) \u2194 \u2203 x \u2208 f \u207b\u00b9' S', x \u2209 f \u207b\u00b9' S",["aesop","omega"]],["Analysis/Convex/Deriv.lean",103,"case neg.intro.intro.intro.intro.intro.intro.intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nw : \u211d\nhw : deriv f w = 0\nhxw : x < w\nhwy : w < y\na : \u211d\nhxa : x < a\nhaw : a < w\nb : \u211d\nhwb : w < b\nhby : b < y\nha : f w - f x < deriv f a * (w - x)\nhb : f y - f w < deriv f b * (y - w)\nthis : deriv f a * (w - x) < deriv f b * (w - x)\n\u22a2 f y - f x < deriv f b * (y - x)",["linarith"]],["Analysis/Convex/Deriv.lean",147,"case neg.intro.intro.intro.intro.intro.intro.intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nw : \u211d\nhw : deriv f w = 0\nhxw : x < w\nhwy : w < y\na : \u211d\nhxa : x < a\nhaw : a < w\nb : \u211d\nhwb : w < b\nhby : b < y\nha : deriv f a * (w - x) < f w - f x\nhb : deriv f b * (y - w) < f y - f w\nthis : deriv f a * (y - w) < deriv f b * (y - w)\n\u22a2 deriv f a * (y - x) < f y - f x",["linarith"]],["RingTheory/Ideal/Operations.lean",409,"case neg\nR : Type u\ninst\u271d : CommSemiring R\nI J : Ideal R\nn m i : \u2115\nhi : i \u2208 Finset.range (n + m + 1)\nhn : \u00acn \u2264 i\n\u22a2 m \u2264 n + m - i",["omega"]],["MeasureTheory/Measure/Hausdorff.lean",211,"X : Type u_2\ninst\u271d : EMetricSpace X\n\u03bc : OuterMeasure X\nhm : \u03bc.IsMetric\nt : Set X\nht : t \u2208 {s | IsClosed s}\ns : Set X\nS : \u2115 \u2192 Set X := fun n \u21a6 {x | x \u2208 s \u2227 (\u2191n)\u207b\u00b9 \u2264 infEdist x t}\nSsep : \u2200 (n : \u2115), Metric.AreSeparated (S n) t\nSsep' : \u2200 (n : \u2115), Metric.AreSeparated (S n) (s \u2229 t)\nS_sub : \u2200 (n : \u2115), S n \u2286 s \\ t\nhSs : \u2200 (n : \u2115), \u03bc (s \u2229 t) + \u03bc (S n) \u2264 \u03bc s\niUnion_S : \u22c3 n, S n = s \\ t\nhtop : \u00ac\u03bc (s \\ t) = \u22a4\nr n i j : \u2115\nhj : i < j\n\u22a2 2 * i + 1 + r < 2 * j + r",["omega","linarith"]],["Probability/Process/Stopping.lean",265,"case h.e'_3.h\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nf : Filtration \u2115 m\n\u03c4 : \u03a9 \u2192 \u2115\nh\u03c4 : IsStoppingTime f \u03c4\ni j : \u2115\nhij : j < i\n\u03c9 : \u03a9\n\u22a2 \u00ac\u03c4 \u03c9 + i = j",["omega","aesop","linarith"]],["Algebra/Order/Floor.lean",1231,"k : Type u_4\ninst\u271d\u00b9 : LinearOrderedField k\ninst\u271d : FloorRing k\na : k\nha\u271d : 1 \u2264 a\nha : 1 < a\n\u22a2 0 < a - 1",["linarith","aesop"]],["Algebra/Order/Floor.lean",496,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorSemiring \u03b1\na b : \u03b1\nhb : 1 < b\nhba : \u2191\u2308(b - 1)\u207b\u00b9\u2309\u208a / b < a\nhab : a \u2264 (b - 1)\u207b\u00b9\n\u22a2 0 < b",["positivity"]],["Algebra/Order/Floor.lean",499,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorSemiring \u03b1\na b : \u03b1\nhb : 0 < b - 1\nhba\u271d : \u2191\u2308(b - 1)\u207b\u00b9\u2309\u208a / b < a\nhba : (b - 1)\u207b\u00b9 \u2264 a\n\u22a2 0 \u2264 (b - 1)\u207b\u00b9",["positivity"]],["Algebra/Order/Floor.lean",500,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorSemiring \u03b1\na b : \u03b1\nhb : 0 < b - 1\nhba\u271d : \u2191\u2308(b - 1)\u207b\u00b9\u2309\u208a / b < a\nhba : (b - 1)\u207b\u00b9 \u2264 a\n\u22a2 b - 1 \u2260 0",["positivity"]],["Algebra/Order/Floor.lean",501,"case bc.a0\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorSemiring \u03b1\na b : \u03b1\nhb : 0 < b - 1\nhba\u271d : \u2191\u2308(b - 1)\u207b\u00b9\u2309\u208a / b < a\nhba : (b - 1)\u207b\u00b9 \u2264 a\n\u22a2 0 \u2264 b - 1",["positivity"]],["Algebra/Order/Floor.lean",1232,"k : Type u_4\ninst\u271d\u00b9 : LinearOrderedField k\ninst\u271d : FloorRing k\na : k\nha\u271d : 1 \u2264 a\nha : 1 < a\nthis : 0 < a - 1\n\u22a2 0 < (a - 1)\u207b\u00b9",["positivity"]],["Algebra/Order/Floor.lean",1243,"k : Type u_4\ninst\u271d\u00b9 : LinearOrderedField k\ninst\u271d : FloorRing k\na b : k\nhb : 1 < b\nhba : \u2191\u2308(b - 1)\u207b\u00b9\u2309 / b < a\nhab : a \u2264 (b - 1)\u207b\u00b9\n\u22a2 0 < b",["positivity"]],["Algebra/Order/Floor.lean",1247,"k : Type u_4\ninst\u271d\u00b9 : LinearOrderedField k\ninst\u271d : FloorRing k\na b : k\nhb : 0 < b - 1\nhba\u271d : \u2191\u2308(b - 1)\u207b\u00b9\u2309 / b < a\nhba : (b - 1)\u207b\u00b9 \u2264 a\n\u22a2 b - 1 \u2260 0",["positivity"]],["Algebra/Order/Floor.lean",1248,"case bc.a0\nk : Type u_4\ninst\u271d\u00b9 : LinearOrderedField k\ninst\u271d : FloorRing k\na b : k\nhb : 0 < b - 1\nhba\u271d : \u2191\u2308(b - 1)\u207b\u00b9\u2309 / b < a\nhba : (b - 1)\u207b\u00b9 \u2264 a\n\u22a2 0 \u2264 b - 1",["positivity"]],["Algebra/Order/Floor.lean",1254,"case inl.hb\nk : Type u_4\ninst\u271d\u00b9 : LinearOrderedField k\ninst\u271d : FloorRing k\nb : k\nhb : 1 < b\nhba : \u2191\u2308(b - 1)\u207b\u00b9\u2309 / b \u2264 \u2191\u2308(b - 1)\u207b\u00b9\u2309 / b\n\u22a2 b \u2260 0",["positivity","linarith"]],["Data/Set/Card.lean",1042,"\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\nhn : autoParam (0 < s.ncard) _auto\u271d\nhe : Even s.ncard\nthis : s.ncard \u2260 1\n\u22a2 1 < s.ncard",["omega"]],["Analysis/Calculus/FDeriv/Measurable.lean",804,"\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b3 : LocallyCompactSpace E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\n\u03b1 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 E \u2192 F\nr s : \u211d\nhf : Continuous (Function.uncurry f)\nL : E \u2192L[\ud835\udd5c] F\nthis : ProperSpace E\na : \u03b1\nx : E\nr' : \u211d\nhr :\n  \u2200 (y : E), dist y (a, x).2 < r' \u2192 \u2200 (z : E), dist z (a, x).2 < r' \u2192 \u2016f (a, x).1 z - f (a, x).1 y - (L z - L y)\u2016 < s * r\nIrr' : r / 2 < r'\nIr'r : r' \u2264 r\nha : Continuous (f a)\nt : \u211d\nhrt : r / 2 < t\nhtr' : t < r'\nt' : \u211d\nhrt' : r / 2 < t'\nht't : t' < t\nB : Continuous fun p \u21a6 \u2016f a p.2 - f a p.1 - (L p.2 - L p.1)\u2016\n\u22a2 0 \u2264 t",["linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",856,"\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b3 : LocallyCompactSpace E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\n\u03b1 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 E \u2192 F\nr s : \u211d\nhf : Continuous (Function.uncurry f)\nL : E \u2192L[\ud835\udd5c] F\nthis\u271d : ProperSpace E\na : \u03b1\nx : E\nr' : \u211d\nhr :\n  \u2200 (y : E), dist y (a, x).2 < r' \u2192 \u2200 (z : E), dist z (a, x).2 < r' \u2192 \u2016f (a, x).1 z - f (a, x).1 y - (L z - L y)\u2016 < s * r\nIrr' : r / 2 < r'\nIr'r : r' \u2264 r\nha : Continuous (f a)\nt : \u211d\nhrt : r / 2 < t\nhtr' : t < r'\nt' : \u211d\nhrt' : r / 2 < t'\nht't : t' < t\nb : \u211d\nb_lt : b < s * r\nhb : \u2200 y \u2208 closedBall x t, \u2200 z \u2208 closedBall x t, \u2016f a z - f a y - (L z - L y)\u2016 \u2264 b\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nh\u03b5 : b + 2 * \u03b5 < s * r\nu : Set \u03b1\nu_open : IsOpen u\nau : a \u2208 u\nhu : \u2200 (p : \u03b1 \u00d7 E), p.1 \u2208 u \u2192 p.2 \u2208 closedBall x t \u2192 dist (Function.uncurry f p) (Function.uncurry f (a, p.2)) < \u03b5\nthis : u \u00d7\u02e2 ball x (t - t') \u2208 \ud835\udcdd (a, x)\na' : \u03b1\nx' : E\nha'x' : a' \u2208 u \u2227 dist x' x < t - t'\ny : E\nhy : dist y (a', x').2 < t'\nz : E\nhz : dist z (a', x').2 < t'\ndyx : dist y x \u2264 t\ndzx : dist z x \u2264 t\n\u22a2 \u03b5 + \u03b5 + b < s * r",["linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",262,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\ne p q e' p' q' : \u2115\nhp : n e \u2264 p\nhq : n e \u2264 q\nhp' : n e' \u2264 p'\nhq' : n e' \u2264 q'\nhe' : e \u2264 e'\nr : \u2115 := n e \u2294 n e'\nI : (1 / 2) ^ e' \u2264 (1 / 2) ^ e\nJ1 : \u2016L e p q - L e p r\u2016 \u2264 4 * \u2016c\u2016 * (1 / 2) ^ e\nJ2 : \u2016L e p r - L e' p' r\u2016 \u2264 4 * \u2016c\u2016 * (1 / 2) ^ e\nJ3 : \u2016L e' p' r - L e' p' q'\u2016 \u2264 4 * \u2016c\u2016 * (1 / 2) ^ e\n\u22a2 \u2016L e p q - L e p r\u2016 + \u2016L e p r - L e' p' r\u2016 + \u2016L e' p' r - L e' p' q'\u2016 \u2264\n    4 * \u2016c\u2016 * (1 / 2) ^ e + 4 * \u2016c\u2016 * (1 / 2) ^ e + 4 * \u2016c\u2016 * (1 / 2) ^ e",["gcongr","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",593,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\ne p q e' p' q' : \u2115\nhp : n e \u2264 p\nhq : n e \u2264 q\nhp' : n e' \u2264 p'\nhq' : n e' \u2264 q'\nhe' : e \u2264 e'\nr : \u2115 := n e \u2294 n e'\nI : (1 / 2) ^ e' \u2264 (1 / 2) ^ e\nJ1 : \u2016L e p q - L e p r\u2016 \u2264 4 * (1 / 2) ^ e\nJ2 : \u2016L e p r - L e' p' r\u2016 \u2264 4 * (1 / 2) ^ e\nJ3 : \u2016L e' p' r - L e' p' q'\u2016 \u2264 4 * (1 / 2) ^ e\n\u22a2 \u2016L e p q - L e p r\u2016 + \u2016L e p r - L e' p' r\u2016 + \u2016L e' p' r - L e' p' q'\u2016 \u2264\n    4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e",["gcongr","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",156,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nx : E\nhx : DifferentiableAt \ud835\udd5c f x\n\u03b4 : \u211d := \u03b5 / 2 / 2\n\u22a2 0 < \u03b4",["positivity","aesop"]],["Analysis/Calculus/FDeriv/Measurable.lean",294,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : E \u2192L[\ud835\udd5c] F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u22a2 0 < 4 + 12 * \u2016c\u2016",["positivity","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",324,"case hy\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : E \u2192L[\ud835\udd5c] F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\npos : 0 < 4 + 12 * \u2016c\u2016\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / (4 + 12 * \u2016c\u2016)\ny : E\nhy : y \u2208 ball 0 ((1 / 2) ^ (n e + 1))\ny_pos : \u00acy = 0\nyzero : 0 < \u2016y\u2016\ny_lt : \u2016y\u2016 < (1 / 2) ^ (n e + 1)\nyone : \u2016y\u2016 \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : \u2016y\u2016 \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < \u2016y\u2016\nm_ge : n e \u2264 m\nkm : k = m + 1\n\u22a2 0 \u2264 (1 / 2) ^ m / 2",["positivity"]],["Analysis/Calculus/FDeriv/Measurable.lean",657,"case hy\nF : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / 16\ny : \u211d\nhy : y \u2208 Icc x (x + (1 / 2) ^ (n e + 1))\nxy : x < y\nyzero : 0 < y - x\ny_le : y - x \u2264 (1 / 2) ^ (n e + 1)\nyone : y - x \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : y - x \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < y - x\nm_ge : n e \u2264 m\nkm : k = m + 1\n\u22a2 0 \u2264 (2 ^ m)\u207b\u00b9 / 2",["positivity"]],["Analysis/Calculus/FDeriv/Measurable.lean",314,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\nthis\u271d : CauchySeq L0\nf' : E \u2192L[\ud835\udd5c] F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\npos : 0 < 4 + 12 * \u2016c\u2016\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / (4 + 12 * \u2016c\u2016)\ny : E\nhy : y \u2208 ball 0 ((1 / 2) ^ (n e + 1))\ny_pos : \u00acy = 0\nyzero : 0 < \u2016y\u2016\ny_lt : \u2016y\u2016 < (1 / 2) ^ (n e + 1)\nyone : \u2016y\u2016 \u2264 1\nk : \u2115\nhk : (1 / 2) ^ (k + 1) < \u2016y\u2016\nh'k : \u2016y\u2016 \u2264 (1 / 2) ^ k\nthis : n e + 1 < k + 1\n\u22a2 n e < k",["omega","aesop","linarith"]],["Analysis/Calculus/FDeriv/Measurable.lean",645,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\nthis\u271d : CauchySeq L0\nf' : F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / 16\ny : \u211d\nhy : y \u2208 Icc x (x + (1 / 2) ^ (n e + 1))\nxy : x < y\nyzero : 0 < y - x\ny_le : y - x \u2264 (1 / 2) ^ (n e + 1)\nyone : y - x \u2264 1\nk : \u2115\nhk : (1 / 2) ^ (k + 1) < y - x\nh'k : y - x \u2264 (1 / 2) ^ k\nthis : n e + 1 < k + 1\n\u22a2 n e < k",["omega","aesop","linarith"]],["NumberTheory/ArithmeticFunction.lean",987,"n : \u2115\nthis : \u03bc n = 0 \u2228 \u03bc n = 1 \u2228 \u03bc n = -1\n\u22a2 \u03bc n \u2260 0 \u2194 \u03bc n = 1 \u2228 \u03bc n = -1",["aesop","omega"]],["Combinatorics/SimpleGraph/Path.lean",252,"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : G.Adj v u\nhc : (cons h p).IsCycle\nthis : 3 \u2264 p.length + 1\n\u22a2 0 < p.length",["omega"]],["Combinatorics/SimpleGraph/Path.lean",316,"case neg\nV : Type u\nG : SimpleGraph V\nu\u271d v\u271d v w u : V\nh : G.Adj v w\np : G.Walk w u\nihp :\n  p.IsPath \u2192 \u2200 \u2983n : \u2115\u2984, n \u2208 {i | i \u2264 p.length} \u2192 \u2200 \u2983m : \u2115\u2984, m \u2208 {i | i \u2264 p.length} \u2192 p.getVert n = p.getVert m \u2192 n = m\nhp : (cons h p).IsPath\nn : \u2115\nhn : n \u2264 p.length + 1\nm : \u2115\nhm : m \u2264 p.length + 1\nhn0 : \u00acn = 0\nhm0 : \u00acm = 0\nhnm : p.getVert (n - 1) = p.getVert (m - 1)\nthis : n - 1 = m - 1\n\u22a2 n = m",["omega"]],["Combinatorics/SimpleGraph/Path.lean",333,"V : Type u\nG : SimpleGraph V\nu w : V\ni : \u2115\np : G.Walk u w\nhp : p.IsPath\nhi : i \u2264 p.length\nthis : p.getVert i = w \u2194 p.length - i = 0\n\u22a2 p.length - i = 0 \u2194 i = p.length",["omega"]],["Combinatorics/SimpleGraph/Path.lean",369,"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc\u271d : p.IsCycle\nhpc : (cons \u22ef p.tail).IsCycle\nn : \u2115\nhn : 1 \u2264 n \u2227 n \u2264 p.tail.length + 1\nm : \u2115\nhm : 1 \u2264 m \u2227 m \u2264 p.tail.length + 1\nhnm : p.getVert n = p.getVert m\nthis : n - 1 = m - 1\n\u22a2 n = m",["omega"]],["Combinatorics/SimpleGraph/Path.lean",377,"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\nn : \u2115\nhn : n \u2264 p.length - 1\nm : \u2115\nhm : m \u2264 p.length - 1\nhnm : p.getVert n = p.getVert m\nthis : 3 \u2264 p.length\n\u22a2 1 \u2264 p.length - n \u2227 p.length - n \u2264 p.length",["omega"]],["Combinatorics/SimpleGraph/Path.lean",378,"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\nn : \u2115\nhn : n \u2264 p.length - 1\nm : \u2115\nhm : m \u2264 p.length - 1\nhnm : p.getVert n = p.getVert m\nthis : 3 \u2264 p.length\n\u22a2 1 \u2264 p.length - m \u2227 p.length - m \u2264 p.length",["omega"]],["Combinatorics/SimpleGraph/Path.lean",381,"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\nn : \u2115\nhn : n \u2264 p.length - 1\nm : \u2115\nhm : m \u2264 p.length - 1\nhnm : p.getVert n = p.getVert m\nthis\u271d : 3 \u2264 p.length\nthis : p.length - n = p.length - m\n\u22a2 n = m",["omega"]],["Combinatorics/SimpleGraph/Path.lean",387,"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhp : p.IsCycle\nthis : 3 \u2264 p.length\nh : 1 = p.length - 1\n\u22a2 False",["omega"]],["Combinatorics/SimpleGraph/Path.lean",394,"V : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nhl : i \u2264 p.length\nh : p.getVert i = u\nhi : \u00aci = 0\n\u22a2 1 \u2264 i \u2227 i \u2264 p.length",["omega"]],["Combinatorics/SimpleGraph/Path.lean",404,"case pos\nV : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nh : i \u2264 p.length\nhl : 3 \u2264 p.length\nhi' : i \u2265 p.length - 1\nh' : i - 1 = 0 \u2228 i - 1 = p.length\n\u22a2 False",["omega"]],["Combinatorics/SimpleGraph/Path.lean",406,"V : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nh : i \u2264 p.length\nhl : 3 \u2264 p.length\nhi' : \u00aci \u2265 p.length - 1\nh' : p.getVert (i - 1) = p.getVert (i + 1)\n\u22a2 i \u2264 p.length - 1 + 1",["omega"]],["Combinatorics/SimpleGraph/Path.lean",408,"case neg\nV : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nh : i \u2264 p.length\nhl : 3 \u2264 p.length\nhi' : \u00aci \u2265 p.length - 1\nh' : p.getVert (i - 1) = p.getVert (i + 1)\nthis : i - 1 = i + 1\n\u22a2 False",["omega"]],["Combinatorics/SimpleGraph/Path.lean",472,"case intro.intro\nV : Type u\nG : SimpleGraph V\nu v w : V\ninst\u271d : DecidableEq V\np : G.Walk u v\nhp : p.IsPath\nhw : w \u2208 p.support\nh : v \u2260 w\nn : \u2115\nhn : p.getVert n = v\nhnl : n \u2264 (p.takeUntil w hw).length\nthis\u271d : (p.takeUntil w hw).length < p.length\nthis : n = p.length\n\u22a2 False",["omega"]],["Analysis/MeanInequalities.lean",159,"\u03b9 : Type u_1\ns : Finset \u03b9\nw z : \u03b9 \u2192 \u211d\nhw : \u2200 i \u2208 s, 0 \u2264 w i\nhw' : 0 < \u2211 i \u2208 s, w i\nhz : \u2200 i \u2208 s, 0 \u2264 z i\n\u22a2 \u2211 i \u2208 s, w i \u2260 0",["linarith","aesop","positivity"]],["Analysis/MeanInequalities.lean",518,"\u03b9 : Type u\ns : Finset \u03b9\np : \u211d\nhp\u271d : 1 \u2264 p\nw f : \u03b9 \u2192 \u211d\u22650\nhp : 1 < p\n\u22a2 p \u2260 0",["positivity","linarith"]],["Analysis/MeanInequalities.lean",751,"\u03b9 : Type u\ns : Finset \u03b9\np : \u211d\nhp : 1 \u2264 p\nw f : \u03b9 \u2192 \u211d\nhw : \u2200 (i : \u03b9), 0 \u2264 w i\nhf : \u2200 (i : \u03b9), 0 \u2264 f i\ni : \u03b9\nx\u271d : i \u2208 s\nthis\u271d : 0 \u2264 w i\nthis : 0 \u2264 f i\n\u22a2 0 \u2264 w i * f i ^ p",["positivity"]],["Analysis/MeanInequalities.lean",900,"\u03b9 : Type u\ns : Finset \u03b9\np : \u211d\nhp\u271d : 1 \u2264 p\nw f : \u03b9 \u2192 \u211d\u22650\u221e\nhp : 1 < p\n\u22a2 0 < p",["positivity","linarith"]],["Data/Nat/Init.lean",135,"m n : \u2115\n\u22a2 min m n = 0 \u2194 m = 0 \u2228 n = 0",["omega"]],["Data/Nat/Init.lean",136,"m n : \u2115\n\u22a2 max m n = 0 \u2194 m = 0 \u2227 n = 0",["omega"]],["Data/Nat/Init.lean",188,"m n : \u2115\nh : m < n - 1\n\u22a2 m < n",["omega"]],["Data/Nat/Init.lean",190,"b a : \u2115\nhb : b \u2260 0\n\u22a2 a \u2264 b + (a - 1)",["omega"]],["Data/Nat/Init.lean",209,"m n : \u2115\n\u22a2 m + n = max m n \u2194 m = 0 \u2228 n = 0",["omega"]],["Data/Nat/Init.lean",210,"m n : \u2115\n\u22a2 m + n = min m n \u2194 m = 0 \u2227 n = 0",["omega"]],["Data/Nat/Init.lean",215,"m n : \u2115\n\u22a2 0 < m + n \u2194 0 < m \u2228 0 < n",["omega"]],["Data/Nat/Init.lean",217,"m n : \u2115\n\u22a2 m + n = 1 \u2194 m = 0 \u2227 n = 1 \u2228 m = 1 \u2227 n = 0",["omega"]],["Data/Nat/Init.lean",220,"m n : \u2115\n\u22a2 m + n = 2 \u2194 m = 0 \u2227 n = 2 \u2228 m = 1 \u2227 n = 1 \u2228 m = 2 \u2227 n = 0",["omega"]],["Data/Nat/Init.lean",224,"m n : \u2115\n\u22a2 m + n = 3 \u2194 m = 0 \u2227 n = 3 \u2228 m = 1 \u2227 n = 2 \u2228 m = 2 \u2227 n = 1 \u2228 m = 3 \u2227 n = 0",["omega"]],["Data/Nat/Init.lean",226,"m n : \u2115\n\u22a2 m \u2264 n + 1 \u2194 m \u2264 n \u2228 m = n + 1",["omega"]],["Data/Nat/Init.lean",228,"m n : \u2115\n\u22a2 n \u2264 m \u2227 m \u2264 n + 1 \u2194 m = n \u2228 m = n + 1",["omega"]],["Data/Nat/Init.lean",230,"a b c d : \u2115\nhab : a < b\nhcd : c < d\n\u22a2 a + c + 1 < b + d",["omega"]],["Data/Nat/Init.lean",232,"a b c d : \u2115\nh : a + c = b + d - 1\n\u22a2 b \u2264 a \u2228 d \u2264 c",["omega"]],["Data/Nat/Init.lean",242,"a b c : \u2115\nh : a = b + c\n\u22a2 a - b = c",["omega"]],["Data/Nat/Init.lean",243,"a b c : \u2115\nh : c + b = a\n\u22a2 c = a - b",["omega"]],["Data/Nat/Init.lean",244,"a b c : \u2115\nh : b + c = a\n\u22a2 c = a - b",["omega"]],["Data/Nat/Init.lean",247,"a b c : \u2115\n\u22a2 a < c - b \u2194 b + a < c",["omega"]],["Data/Nat/Init.lean",248,"a b c : \u2115\nhba : b \u2264 a\n\u22a2 a - b < c \u2194 a < b + c",["omega"]],["Data/Nat/Init.lean",249,"a b c : \u2115\nhba : b \u2264 a\n\u22a2 a - b < c \u2194 a < c + b",["omega"]],["Data/Nat/Init.lean",251,"a b c : \u2115\nh : c \u2264 b\n\u22a2 a - c - (b - c) = a - b",["omega"]],["Data/Nat/Init.lean",252,"a b c : \u2115\nh : c \u2264 a\n\u22a2 a + b - (a - c) = b + c",["omega"]],["Data/Nat/Init.lean",253,"a b c : \u2115\nhab : b \u2264 a\nhcb : c \u2264 b\n\u22a2 a - b + (b - c) = a - c",["omega"]],["Data/Nat/Init.lean",257,"a b c : \u2115\nh : c \u2264 a\n\u22a2 a - c < b - c \u2194 a < b",["omega"]],["Data/Nat/Init.lean",323,"n : \u2115\nh : 2 * n \u2264 n\n\u22a2 n = 0",["omega"]],["Data/Nat/Init.lean",333,"a b c d : \u2115\nhac : a < c\nhbd : b < d\n\u22a2 0 < d",["omega"]],["Data/Nat/Init.lean",362,"a : \u2115\nha : 2 \u2264 a\nx\u271d : 2 \u2264 2\n\u22a2 a + 2 \u2264 a * 2",["omega"]],["Data/Nat/Init.lean",363,"a : \u2115\nha : 2 \u2264 a\nb : \u2115\nx\u271d : 2 \u2264 b + 3\nthis : a + (b + 2) \u2264 a * (b + 2)\n\u22a2 a + (b + 3) \u2264 a * (b + 2) + a",["omega"]],["Data/Nat/Init.lean",464,"a b : \u2115\nh : a / 2 < a - b\n\u22a2 b \u2264 a / 2",["omega"]],["Data/Nat/Init.lean",467,"a b : \u2115\nh : a - b \u2264 a / 2\n\u22a2 a / 2 \u2264 b",["omega"]],["Data/Nat/Init.lean",553,"a n : \u2115\n\u22a2 a = 0 \u2227 n \u2260 0 \u2228 a = 0 \u2194 a = 0 \u2227 n + 1 \u2260 0",["omega"]],["Data/Nat/Init.lean",850,"P : \u2115 \u2192 \u2115 \u2192 Prop\nha : \u2200 (a : \u2115), P (a + 1) (a + 1)\nhb : \u2200 (b : \u2115), P 0 (b + 1)\nhd : \u2200 (a b : \u2115), a < b \u2192 P (a + 1) b \u2192 P a (b + 1) \u2192 P (a + 1) (b + 1)\na b : \u2115\nh : a + 1 < b + 1\n\u22a2 a + 1 = b \u2228 a + 1 < b",["omega"]],["Data/Nat/Init.lean",996,"case intro\nn k d : \u2115\nh1 : n * k < n * d\nh2 : n * d < n * (k + 1)\nthis\u271d : k < d\nthis : d < k + 1\n\u22a2 False",["omega"]],["Data/Nat/Init.lean",1051,"n : \u2115\n\u22a2 \u00ac2 \u2223 2 * n + 1",["omega"]],["Analysis/Normed/Lp/lpSpace.lean",179,"\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nq : \u211d\u22650\u221e\nf : (i : \u03b1) \u2192 E i\nhfq : Mem\u2113p f q\nhq : 0 < q.toReal\nhpq : q \u2264 \u22a4\nA : \u211d\nhA : A \u2208 upperBounds (Set.range fun i \u21a6 \u2016f i\u2016 ^ q.toReal)\ni : \u03b1\n\u22a2 0 \u2264 \u2016f i\u2016 ^ q.toReal",["positivity"]],["Analysis/Normed/Lp/lpSpace.lean",212,"case inr.inr.hf.refine_1\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : \u211d\u22650\u221e\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nf g : (i : \u03b1) \u2192 E i\nhf : Mem\u2113p f p\nhg : Mem\u2113p g p\nhp : 0 < p.toReal\nC : \u211d := if p.toReal < 1 then 1 else 2 ^ (p.toReal - 1)\nb\u271d : \u03b1\n\u22a2 0 \u2264 \u2016(f + g) b\u271d\u2016 ^ p.toReal",["positivity"]],["Analysis/Calculus/ContDiff/FaaDiBruno.lean",523,"case h.e'_3.inl.e_self.e_a.e_val\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\ns : Set E\nt : Set F\nq : F \u2192 FormalMultilinearSeries \ud835\udd5c F G\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nc\u271d : OrderedFinpartition n\nc : OrderedFinpartition (n + 1)\nhc : range (c.emb 0) \u2260 {0}\nj : Fin c.length\nhij : c.index 0 < j\nA : 1 < c.partSize (c.index 0)\n\u22a2 c.partSize (c.index 0) - 1 - 1 + 1 = c.partSize (c.index 0) - 1",["omega"]],["Analysis/Calculus/ContDiff/FaaDiBruno.lean",534,"case h.e'_3.inr.h\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\ns : Set E\nt : Set F\nq : F \u2192 FormalMultilinearSeries \ud835\udd5c F G\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nc\u271d : OrderedFinpartition n\nc : OrderedFinpartition (n + 1)\nhc : range (c.emb 0) \u2260 {0}\ni j : Fin c.length\nhij : i < j\nhi : i \u2260 c.index 0\nthis : \u00ac\u2191(c.emb i \u27e8c.partSize i - 1, \u22ef\u27e9) = 0\n\u22a2 1 \u2264 \u2191(c.emb i \u27e8c.partSize i - 1, \u22ef\u27e9)",["omega"]],["Analysis/Calculus/ContDiff/FaaDiBruno.lean",539,"case h.e'_4.inl.e_self.e_a.e_val\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\ns : Set E\nt : Set F\nq : F \u2192 FormalMultilinearSeries \ud835\udd5c F G\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nc\u271d : OrderedFinpartition n\nc : OrderedFinpartition (n + 1)\nhc : range (c.emb 0) \u2260 {0}\ni : Fin c.length\nhij : i < c.index 0\nA : 1 < c.partSize (c.index 0)\n\u22a2 c.partSize (c.index 0) - 1 - 1 + 1 = c.partSize (c.index 0) - 1",["omega"]],["Analysis/Calculus/ContDiff/FaaDiBruno.lean",550,"case h.e'_4.inr.h\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\ns : Set E\nt : Set F\nq : F \u2192 FormalMultilinearSeries \ud835\udd5c F G\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nc\u271d : OrderedFinpartition n\nc : OrderedFinpartition (n + 1)\nhc : range (c.emb 0) \u2260 {0}\ni j : Fin c.length\nhij : i < j\nhj : j \u2260 c.index 0\nthis : \u00ac\u2191(c.emb j \u27e8c.partSize j - 1, \u22ef\u27e9) = 0\n\u22a2 1 \u2264 \u2191(c.emb j \u27e8c.partSize j - 1, \u22ef\u27e9)",["omega"]],["Analysis/Calculus/ContDiff/FaaDiBruno.lean",592,"case intro.intro.inl.refine_2.e_a\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\ns : Set E\nt : Set F\nq : F \u2192 FormalMultilinearSeries \ud835\udd5c F G\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nc\u271d : OrderedFinpartition n\nc : OrderedFinpartition (n + 1)\nhc : range (c.emb 0) \u2260 {0}\nx : Fin n\nj : Fin (c.partSize (c.index 0))\nhij : c.emb (c.index 0) j = x.succ\nj_ne : j \u2260 0\nje_ne' : \u2191j \u2260 0\nA : c.partSize (c.index 0) - 1 + 1 = c.partSize (c.index 0)\nB : update c.partSize (c.index 0) (c.partSize (c.index 0) - 1) (c.index 0) = c.partSize (c.index 0) - 1\nthis : x = x.succ.pred \u22ef\n\u22a2 \u2191j - 1 + 1 = \u2191j",["omega"]],["NumberTheory/NumberField/Embeddings.lean",1102,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u03b6 : K\nk : \u2115\nhk : 2 < k\nh\u03b6 : IsPrimitiveRoot \u03b6 k\nx\u271d : { w // w.IsReal }\nw : NumberField.InfinitePlace K\nhwreal : NumberField.ComplexEmbedding.IsReal w.embedding\nf : K \u2192+* \u2102 := w.embedding\nh\u03b6' : IsPrimitiveRoot (f \u03b6) k\nhim : |(f \u03b6).re| = \u2016f \u03b6\u2016\n\u22a2 k \u2260 0",["omega","aesop","linarith","positivity"]],["NumberTheory/NumberField/Embeddings.lean",1111,"case inr\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u03b6 : K\nk : \u2115\nhk : 2 < k\nh\u03b6 : IsPrimitiveRoot \u03b6 k\nx\u271d : { w // w.IsReal }\nw : NumberField.InfinitePlace K\nhwreal : NumberField.ComplexEmbedding.IsReal w.embedding\nf : K \u2192+* \u2102 := w.embedding\nhim : (f \u03b6).im = 0\nhnegone : (f \u03b6).re = -1\nh\u03b6' : k = 2\n\u22a2 False",["omega","aesop","linarith"]],["MeasureTheory/Function/UniformIntegrable.lean",520,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup \u03b2\np : \u211d\u22650\u221e\ninst\u271d : IsFiniteMeasure \u03bc\nhp : 1 \u2264 p\nhp' : p \u2260 \u22a4\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\nhf : \u2200 (n : \u2115), StronglyMeasurable (f n)\nhg : StronglyMeasurable g\nhg' : MemLp g p \u03bc\nhui : UnifIntegrable f p \u03bc\nhfg : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n \u21a6 f n x) atTop (\ud835\udcdd (g x))\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 > 0\nh : \u03b5 < \u22a4\nh\u03bc : \u00ac\u03bc = 0\nh\u03b5' : 0 < \u03b5.toReal / 3\nhdivp : 0 \u2264 1 / p.toReal\nhpow : 0 < measureUnivNNReal \u03bc ^ (1 / p.toReal)\n\u03b4\u2081 : \u211d\nh\u03b4\u2081 : 0 < \u03b4\u2081\nheLpNorm\u2081 :\n  \u2200 (i : \u2115) (s : Set \u03b1),\n    MeasurableSet s \u2192 \u03bc s \u2264 ENNReal.ofReal \u03b4\u2081 \u2192 eLpNorm (s.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal (\u03b5.toReal / 3)\n\u03b4\u2082 : \u211d\nh\u03b4\u2082 : 0 < \u03b4\u2082\nheLpNorm\u2082 :\n  \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s \u2264 ENNReal.ofReal \u03b4\u2082 \u2192 eLpNorm (s.indicator g) p \u03bc \u2264 ENNReal.ofReal (\u03b5.toReal / 3)\nt : Set \u03b1\nhtm : MeasurableSet t\nht\u2081 : \u03bc t \u2264 ENNReal.ofReal (\u03b4\u2081 \u2293 \u03b4\u2082)\nN n : \u2115\nhn : n \u2265 N\nhnf : eLpNorm (t.indicator (f n)) p \u03bc \u2264 ENNReal.ofReal (\u03b5.toReal / 3)\nhng : eLpNorm (t.indicator g) p \u03bc \u2264 ENNReal.ofReal (\u03b5.toReal / 3)\nhN : \u2200 x \u2208 t\u1d9c, dist (g x) (f n x) < \u03b5.toReal / (3 * \u2191(measureUnivNNReal \u03bc) ^ (1 / p.toReal))\n\u22a2 0 \u2264 \u03b5.toReal / (3 * \u2191(measureUnivNNReal \u03bc) ^ (1 / p.toReal))",["positivity"]],["Analysis/SpecialFunctions/Pow/Real.lean",763,"x y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhz : z \u2260 0\n\u22a2 0 \u2264 x ^ z\u207b\u00b9",["positivity"]],["Analysis/SpecialFunctions/Pow/Real.lean",766,"x y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhz : z \u2260 0\n\u22a2 0 \u2264 y ^ z\u207b\u00b9",["positivity"]],["Analysis/SpecialFunctions/Pow/Real.lean",1028,"n : \u2115\nhn : n \u2260 0\nx : \u211d\n\u22a2 0 < \u2191(\u2191n ^ x)",["positivity"]],["Data/List/Basic.lean",679,"case e_i\n\u03b1 : Type u\nl : List \u03b1\nh : l.length = 1\nn : \u2115\nh\u2081 : n < l.length\nh\u2082 : n < [l.get \u27e80, \u22ef\u27e9].length\n\u22a2 n = 0",["omega","aesop"]],["Data/List/Basic.lean",1007,"case cons.tail\n\u03b1 : Type u\ninst\u271d : SizeOf \u03b1\nx h : \u03b1\nt : List \u03b1\na\u271d : Mem x t\nih : sizeOf x < sizeOf t\n\u22a2 sizeOf x < 1 + sizeOf h + sizeOf t",["omega"]],["Analysis/Calculus/ContDiff/FTaylorSeries.lean",190,"\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ns : Set E\nf : E \u2192 F\nN : WithTop \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhN : \u221e \u2264 N\nk : \u2115\nH : \u2200 (n : \u2115), HasFTaylorSeriesUpToOn (\u2191(n + k)) f p s\nm : \u2115\na\u271d : \u2191m < N\n\u22a2 m < m.succ + k",["omega","linarith"]],["Analysis/Fourier/FourierTransformDeriv.lean",592,"case h.hf\nE : Type u_1\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : NormedSpace \u211d V\ninst\u271d\u2075 : NormedAddCommGroup W\ninst\u271d\u2074 : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\ninst\u271d\u00b3 : MeasurableSpace V\ninst\u271d\u00b2 : BorelSpace V\ninst\u271d\u00b9 : FiniteDimensional \u211d V\n\u03bc : Measure V\ninst\u271d : \u03bc.IsAddHaarMeasure\nK N : \u2115\u221e\nhf : ContDiff \u211d (\u2191N) f\nh'f : \u2200 (k n : \u2115), \u2191k \u2264 K \u2192 \u2191n \u2264 N \u2192 Integrable (fun v \u21a6 \u2016v\u2016 ^ k * \u2016iteratedFDeriv \u211d n f v\u2016) \u03bc\nk n : \u2115\nhk : \u2191k \u2264 K\nhn : \u2191n \u2264 N\nw : W\nm : \u2115\nhm : \u2191m \u2264 N\nI : Integrable (fun v \u21a6 \u2211 p \u2208 Finset.range (k + 1) \u00d7\u02e2 Finset.range (m + 1), \u2016v\u2016 ^ p.1 * \u2016iteratedFDeriv \u211d p.2 f v\u2016) \u03bc\nv : V\ni\u271d : \u2115\nhi : i\u271d \u2264 m\nj : \u2115\nhj : j \u2264 k\ni : \u2115 \u00d7 \u2115\n_hi : i \u2208 Finset.range (k + 1) \u00d7\u02e2 Finset.range (m + 1)\n\u22a2 0 \u2264 (fun p \u21a6 \u2016v\u2016 ^ p.1 * \u2016iteratedFDeriv \u211d p.2 f v\u2016) i",["positivity"]],["Analysis/Fourier/FourierTransformDeriv.lean",624,"case hf\nE : Type u_1\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : NormedSpace \u211d V\ninst\u271d\u2075 : NormedAddCommGroup W\ninst\u271d\u2074 : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\ninst\u271d\u00b3 : MeasurableSpace V\ninst\u271d\u00b2 : BorelSpace V\ninst\u271d\u00b9 : FiniteDimensional \u211d V\n\u03bc : Measure V\ninst\u271d : \u03bc.IsAddHaarMeasure\nK N : \u2115\u221e\nhf : ContDiff \u211d (\u2191N) f\nh'f : \u2200 (k n : \u2115), \u2191k \u2264 K \u2192 \u2191n \u2264 N \u2192 Integrable (fun v \u21a6 \u2016v\u2016 ^ k * \u2016iteratedFDeriv \u211d n f v\u2016) \u03bc\nk n : \u2115\nhk : \u2191k \u2264 K\nhn : \u2191n \u2264 N\nw : W\nI : \u2200 p \u2208 Finset.range (k + 1) \u00d7\u02e2 Finset.range (n + 1), Integrable (fun v \u21a6 \u2016v\u2016 ^ p.1 * \u2016iteratedFDeriv \u211d p.2 f v\u2016) \u03bc\nv : V\ni\u271d : \u2115\nhi : i\u271d \u2264 n\nj : \u2115\nhj : j \u2264 k\ni : \u2115 \u00d7 \u2115\n_hi : i \u2208 Finset.range (k + 1) \u00d7\u02e2 Finset.range (n + 1)\n\u22a2 0 \u2264 (fun p \u21a6 \u2016v\u2016 ^ p.1 * \u2016iteratedFDeriv \u211d p.2 f v\u2016) i",["positivity"]],["Analysis/Fourier/FourierTransformDeriv.lean",642,"E : Type u_1\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : NormedSpace \u211d V\ninst\u271d\u2075 : NormedAddCommGroup W\ninst\u271d\u2074 : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\ninst\u271d\u00b3 : MeasurableSpace V\ninst\u271d\u00b2 : BorelSpace V\ninst\u271d\u00b9 : FiniteDimensional \u211d V\n\u03bc : Measure V\ninst\u271d : \u03bc.IsAddHaarMeasure\nK N : \u2115\u221e\nhf : ContDiff \u211d (\u2191N) f\nh'f : \u2200 (k n : \u2115), \u2191k \u2264 K \u2192 \u2191n \u2264 N \u2192 Integrable (fun v \u21a6 \u2016v\u2016 ^ k * \u2016iteratedFDeriv \u211d n f v\u2016) \u03bc\nk n : \u2115\nhk : \u2191k \u2264 K\nhn : \u2191n \u2264 N\nv : V\nw : W\n\u22a2 0 \u2264 |(L v) w| ^ n * \u2016iteratedFDeriv \u211d k (fourierIntegral \ud835\udc1e \u03bc L.toLinearMap\u2082 f) w\u2016",["positivity"]],["Analysis/Fourier/FourierTransformDeriv.lean",748,"case inr.inl\nE : Type u_1\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u2102 E\nV : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : FiniteDimensional \u211d V\ninst\u271d\u00b9 : MeasurableSpace V\ninst\u271d : BorelSpace V\nf : V \u2192 E\nK N : \u2115\u221e\nhf : ContDiff \u211d (\u2191N) f\nh'f : \u2200 (k n : \u2115), \u2191k \u2264 K \u2192 \u2191n \u2264 N \u2192 Integrable (fun v \u21a6 \u2016v\u2016 ^ k * \u2016iteratedFDeriv \u211d n f v\u2016) volume\nk n : \u2115\nhk : \u2191k \u2264 K\nhn\u271d : \u2191n \u2264 N\nhn : n \u2260 0\nZ :\n  \u20160\u2016 ^ n * (\u20160\u2016 ^ n * \u2016iteratedFDeriv \u211d k (\ud835\udcd5 f) 0\u2016) \u2264\n    \u20160\u2016 ^ n *\n      ((2 * (\u03c0 * \u2016innerSL \u211d\u2016)) ^ k *\n        ((2 * \u2191k + 2) ^ n *\n          \u2211 p \u2208 Finset.range (k + 1) \u00d7\u02e2 Finset.range (n + 1), \u222b (v : V), \u2016v\u2016 ^ p.1 * \u2016iteratedFDeriv \u211d p.2 f v\u2016))\n\u22a2 0 \u2264\n    (2 * \u03c0) ^ k * (2 * \u2191k + 2) ^ n *\n      \u2211 p \u2208 Finset.range (k + 1) \u00d7\u02e2 Finset.range (n + 1), \u222b (v : V), \u2016v\u2016 ^ p.1 * \u2016iteratedFDeriv \u211d p.2 f v\u2016",["positivity"]],["Probability/StrongLaw.lean",162,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf : AEStronglyMeasurable f \u03bc\nA : \u211d\nn : \u2115\nhn : n \u2260 0\nh'f : 0 \u2264 f\nM : MeasurableSet (Set.Ioc 0 A)\nM' : MeasurableSet (Set.Ioc A 0)\nhA : A < 0\nthis : \u2200\u1d50 (x : \u211d) \u2202Measure.map f \u03bc, 0 \u2264 x\nx : \u211d\nhx : 0 \u2264 x\na\u271d : A < x\nh''x : x \u2264 0\n\u22a2 x = 0",["linarith"]],["Analysis/Complex/PhragmenLindelof.lean",377,"case inr.intro.intro.refine_1.intro.intro.intro.refine_1\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nC : \u211d\nf : \u2102 \u2192 E\nhd : DiffContOnCl \u2102 f (Ioi 0 \u00d7\u2102 Ioi 0)\nhre : \u2200 (x : \u211d), 0 \u2264 x \u2192 \u2016f \u2191x\u2016 \u2264 C\nhim : \u2200 (x : \u211d), 0 \u2264 x \u2192 \u2016f (\u2191x * I)\u2016 \u2264 C\n\u03b6 : \u2102\nh\u03b6 : \u03b6.im \u2208 Icc 0 (\u03c0 / 2)\nhz_re : 0 \u2264 (cexp \u03b6).re\nhz_im : 0 \u2264 (cexp \u03b6).im\nhzne : cexp \u03b6 \u2260 0\nH : MapsTo cexp (im \u207b\u00b9' Ioo 0 (\u03c0 / 2)) (Ioi 0 \u00d7\u2102 Ioi 0)\nc : \u211d\nhc\u271d : c < 2\nB : \u211d\nhO : f =O[cobounded \u2102 \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Ioi 0)] fun z \u21a6 expR (B * \u2016z\u2016 ^ c)\nhc : ContinuousWithinAt f (Ioi 0 \u00d7\u2102 Ioi 0) 0\nw : \u2102\n\u22a2 0 \u2264 (B \u2294 0) * expR (c * |w.re|)",["positivity"]],["MeasureTheory/VectorMeasure/Basic.lean",185,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : SignedMeasure \u03b1\nA B : Set \u03b1\nh : Disjoint A B\nhA\u2081 : MeasurableSet A\nhB\u2081 : MeasurableSet B\nhA\u2082 : 0 \u2264 \u2191s A\nhB\u2082 : 0 \u2264 \u2191s B\nhAB : \u2191s A + \u2191s B = 0\n\u22a2 \u2191s A = 0",["linarith"]],["MeasureTheory/VectorMeasure/Basic.lean",191,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : SignedMeasure \u03b1\nA B : Set \u03b1\nh : Disjoint A B\nhA\u2081 : MeasurableSet A\nhB\u2081 : MeasurableSet B\nhA\u2082 : \u2191s A \u2264 0\nhB\u2082 : \u2191s B \u2264 0\nhAB : \u2191s A + \u2191s B = 0\n\u22a2 \u2191s A = 0",["linarith"]],["Data/ZMod/Basic.lean",1195,"n : \u2115\nG : Type u_2\ninst\u271d\u00b3 : AddCommGroup G\ninst\u271d\u00b2 : Module (ZMod n) G\ninst\u271d\u00b9 : NeZero n\ninst\u271d : Nontrivial G\nthis\u271d : n \u2260 0\nthis : n \u2260 1\n\u22a2 2 \u2264 n",["omega"]],["Computability/PartrecCode.lean",201,"cf : Code\n\u22a2 cf.encodeCode < 2 * (2 * cf.encodeCode + 1) + 1 + 4",["omega"]],["LinearAlgebra/Eigenspace/Basic.lean",247,"R : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : End R M\n\u03bc : R\nk : \u2115\nx : M\ni : \u2115\nhi : i \u2264 k\n\u22a2 k = i + (k - i)",["omega","aesop"]],["LinearAlgebra/Eigenspace/Basic.lean",873,"R : Type v\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf\u2081 f\u2082 : End R M\n\u03bc\u2081 \u03bc\u2082 : R\nk\u2081 k\u2082 : \u2115\u221e\nm : M\nl\u2081 : \u2115\nhlk\u2081 : \u2191l\u2081 \u2264 k\u2081\nhl\u2081 : ((f\u2081 - \u03bc\u2081 \u2022 1) ^ l\u2081) m = 0\nl\u2082 : \u2115\nhlk\u2082 : \u2191l\u2082 \u2264 k\u2082\nhl\u2082 : ((f\u2082 - \u03bc\u2082 \u2022 1) ^ l\u2082) m = 0\nthis : f\u2081 + f\u2082 - (\u03bc\u2081 + \u03bc\u2082) \u2022 1 = f\u2081 - \u03bc\u2081 \u2022 1 + (f\u2082 - \u03bc\u2082 \u2022 1)\nh : Commute (f\u2081 - \u03bc\u2081 \u2022 1) (f\u2082 - \u03bc\u2082 \u2022 1)\nx\u271d : \u2115 \u00d7 \u2115\ni j : \u2115\nhij : (i, j).1 + (i, j).2 = l\u2081 + l\u2082\n\u22a2 l\u2081 \u2264 i \u2228 l\u2082 \u2264 j",["omega"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",538,"x y : \u211d\nhx\u2081 : -(\u03c0 / 2) \u2264 x\nhy\u2082 : y \u2264 \u03c0 / 2\nhxy : x < y\nthis\u271d : 0 < sin ((y - x) / 2)\nthis : 0 < cos ((y + x) / 2)\n\u22a2 0 < 2 * sin ((y - x) / 2) * cos ((y + x) / 2)",["positivity","aesop"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",661,"n : \u2115\nA : 1 < 2 ^ (n + 1)\nB : \u03c0 / 2 ^ (n + 1) < \u03c0\n\u22a2 0 < \u03c0 / 2 ^ (n + 1)",["positivity"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",530,"n : \u2124\nh : cos (\u2191n * (2 * \u03c0)) = 1\nhx\u2081 : -n < 1\nhx\u2082 : n < 1\n\u22a2 0 \u2264 n",["omega","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",805,"\u03b8 : \u211d := \u03c0 / 5\nh\u03b8 : \u03b8 = \u03c0 / 5\nc : \u211d := cos \u03b8\ns : \u211d := sin \u03b8\nn : \u2124\nhn : n * 5 = 1\n\u22a2 False",["omega"]],["Analysis/SpecialFunctions/Pow/NNReal.lean",364,"z : \u211d\nh_one_le : 1 \u2264 z\nhx : \u22a5 \u2264 1\n\u22a2 z \u2260 0",["linarith","positivity"]],["Analysis/SpecialFunctions/Pow/NNReal.lean",775,"case top.inr.inl.inl\ny z : \u211d\nhyz : y \u2264 z\nhx : 1 \u2264 \u22a4\nHy : y = 0\nHz : z < 0\n\u22a2 False\n```\n---\n```lean\ncase top.inr.inr.inl\ny z : \u211d\nhyz : y \u2264 z\nhx : 1 \u2264 \u22a4\nHy : 0 < y\nHz : z < 0\n\u22a2 False\n```\n---\n```lean\ncase top.inr.inr.inr.inl\ny z : \u211d\nhyz : y \u2264 z\nhx : 1 \u2264 \u22a4\nHy : 0 < y\nHz : z = 0\n\u22a2 False",["linarith"]],["Analysis/SpecialFunctions/Pow/NNReal.lean",793,"case pos.inl.inr.inl\ny z : \u211d\nhyz : z \u2264 y\nx : \u211d\u22650\nhx1 : \u2191x \u2264 1\nh : x = 0\nHy : y < 0\nHz : z = 0\n\u22a2 False\n```\n---\n```lean\ncase pos.inl.inr.inr\ny z : \u211d\nhyz : z \u2264 y\nx : \u211d\u22650\nhx1 : \u2191x \u2264 1\nh : x = 0\nHy : y < 0\nHz : 0 < z\n\u22a2 False\n```\n---\n```lean\ncase pos.inr.inl.inr.inr\ny z : \u211d\nhyz : z \u2264 y\nx : \u211d\u22650\nhx1 : \u2191x \u2264 1\nh : x = 0\nHy : y = 0\nHz : 0 < z\n\u22a2 False",["linarith"]],["Data/Seq/Seq.lean",687,"\u03b1 : Type u\nx : \u03b1\nk : \u2115\nih : \u2200 {s : Seq \u03b1} {n : \u2115}, k < n \u2192 s.get? k = some x \u2192 x \u2208 take n s\ns : Seq \u03b1\nh_get : s.get? (k + 1) = some x\nl : \u2115\nh_mn : k + 1 < k + 1 + l + 1\ny : \u03b1\nhy : s.get? 0 = some y\n\u22a2 k < k + 1 + l",["omega","aesop"]],["Data/Seq/Seq.lean",1022,"case h.e'_3.h.e'_3\n\u03b1 : Type u\ns : Seq \u03b1\nk : \u2115\nih : \u2200 {m : \u2115}, (s.drop k).get? m = s.get? (k + m)\nm : \u2115\n\u22a2 k + 1 + m = k + (m + 1)",["omega"]],["Analysis/LocallyConvex/WithSeminorms.lean",755,"\ud835\udd5c : Type u_1\nF : Type u_6\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nq : Seminorm \ud835\udd5c F\nhq : Continuous \u21d1q\nhq' : Tendsto (\u21d1q) (\ud835\udcdd 0) (\ud835\udcdd 0)\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\nh\u03b5 : {y | \u2016y\u2016 < \u03b5} \u2286 \u21d1q \u207b\u00b9' Iio 1\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\n\u22a2 0 < \u2016c\u2016 / \u03b5",["positivity"]],["Analysis/Normed/Lp/PiLp.lean",527,"p : \u211d\u22650\u221e\n\ud835\udd5c : Type u_1\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\n\u03b2 : \u03b9 \u2192 Type u_4\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nx y : PiLp p \u03b2\nh : 1 \u2264 0\nhp : p = \u22a4\n\u22a2 False",["linarith"]],["Analysis/InnerProductSpace/Basic.lean",551,"case mp\nF : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx y : F\nh : \u27eay, x\u27eb_\u211d + \u27eax, x\u27eb_\u211d = \u27eay, x\u27eb_\u211d + \u27eay, y\u27eb_\u211d\n\u22a2 \u27eax, x\u27eb_\u211d = \u27eay, y\u27eb_\u211d",["linarith","aesop"]],["Analysis/InnerProductSpace/Basic.lean",553,"case mpr\nF : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx y : F\nh : \u27eax, x\u27eb_\u211d = \u27eay, y\u27eb_\u211d\n\u22a2 \u27eax, x\u27eb_\u211d + \u27eay, x\u27eb_\u211d = \u27eay, x\u27eb_\u211d + \u27eay, y\u27eb_\u211d",["linarith"]],["Analysis/InnerProductSpace/Basic.lean",566,"F : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx y : F\n\u22a2 0 \u2264 \u2016x\u2016 * \u2016y\u2016",["positivity"]],["ModelTheory/Semantics.lean",377,"case pos\nL : Language\nM : Type w\ninst\u271d : L.Structure M\n\u03b1 : Type u'\nn n' m : \u2115\nv : \u03b1 \u2192 M\nk : \u2115\nf\u271d : L.BoundedFormula \u03b1 (k + 1)\nih3 :\n  \u2200 {xs : Fin (k + 1 + n') \u2192 M},\n    m + n' \u2264 k + 1 + 1 \u2192\n      ((mapTermRel (fun x t \u21a6 Term.liftAt n' m t) (fun x \u21a6 id) (fun x \u21a6 castLE \u22ef) f\u271d).Realize v xs \u2194\n        f\u271d.Realize v (xs \u2218 fun i \u21a6 if \u2191i < m then castAdd n' i else i.addNat n'))\nxs : Fin (k + n') \u2192 M\nhmn : m + n' \u2264 k + 1\nh : k + 1 + n' = k + n' + 1\nx : M\nh\u271d : k < m\n\u22a2 k = k + n'",["omega"]],["Analysis/SpecificLimits/Normed.lean",235,"case pos\nR : Type u_2\ninst\u271d : NormedRing R\nx : R\nh : \u2016x\u2016 < 1\nhx : Summable fun n \u21a6 x ^ n\nthis : \u2016\u2211' (b : \u2115), (fun n \u21a6 x ^ (n + 1)) b\u2016 \u2264 (1 - \u2016x\u2016)\u207b\u00b9 - 1\n\u22a2 \u20161\u2016 + \u2016\u2211' (b : \u2115), x ^ (b + 1)\u2016 \u2264 \u20161\u2016 - 1 + (1 - \u2016x\u2016)\u207b\u00b9",["linarith"]],["Analysis/SpecificLimits/Normed.lean",239,"R : Type u_2\ninst\u271d : NormedRing R\nx : R\nh : \u2016x\u2016 < 1\nhx : \u00acSummable fun n \u21a6 x ^ n\na\u271d : Nontrivial R\nthis : 1 \u2264 \u20161\u2016\n\u22a2 0 \u2264 1 - \u2016x\u2016",["linarith"]],["Analysis/SpecificLimits/Normed.lean",240,"R : Type u_2\ninst\u271d : NormedRing R\nx : R\nh : \u2016x\u2016 < 1\nhx : \u00acSummable fun n \u21a6 x ^ n\na\u271d : Nontrivial R\nthis\u271d : 1 \u2264 \u20161\u2016\nthis : 0 \u2264 (1 - \u2016x\u2016)\u207b\u00b9\n\u22a2 0 \u2264 \u20161\u2016 - 1 + (1 - \u2016x\u2016)\u207b\u00b9",["linarith"]],["Analysis/SpecificLimits/Normed.lean",626,"case h\n\u03b1 : Type u_2\ninst\u271d : SeminormedAddCommGroup \u03b1\nf : \u2115 \u2192 \u03b1\nl : \u211d\nhl : 1 < l\nh : Tendsto (fun n \u21a6 \u2016f (n + 1)\u2016 / \u2016f n\u2016) atTop (\ud835\udcdd l)\na\u271d : \u2115\nhn : 1 \u2264 0\nhc : \u2016f a\u271d\u2016 = 0\n\u22a2 False",["linarith"]],["Analysis/SpecificLimits/Normed.lean",390,"R : Type u_2\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nr : R\nhr : \u2016r\u2016 < 1\nk : \u2115\nih : HasSum (fun n \u21a6 \u2191((n + k).choose k) * r ^ n) (Ring.inverse (1 - r) ^ (k + 1))\nn : \u2115\nhn : k < n\n\u22a2 n + k \u2264 2 * n",["omega","linarith"]],["Algebra/Lie/Nilpotent.lean",340,"R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : LieAlgebra R L\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieModule R L M\ninst\u271d : IsNilpotent L M\nx y : L\nk : \u2115\nhM : lowerCentralSeries R L M k = \u22a5\n\u22a2 k \u2264 2 * k",["omega","linarith"]],["Analysis/SpecialFunctions/Trigonometric/Deriv.lean",1053,"x : \u211d\nhx : 0 < x\n\u22a2 0 < Real.sinh x",["positivity","aesop"]],["Analysis/SpecialFunctions/Trigonometric/Deriv.lean",1054,"x : \u211d\nhx : 0 \u2264 x\n\u22a2 0 \u2264 Real.sinh x",["positivity","aesop"]],["Analysis/SpecialFunctions/Trigonometric/Deriv.lean",1055,"x : \u211d\nhx : x \u2260 0\n\u22a2 Real.sinh x \u2260 0",["positivity","aesop"]],["Order/KrullDimension.lean",200,"case h.e'_3.e_a.e_val\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\np : LTSeries \u03b1\nx : \u03b1\nhlast : RelSeries.last p \u2264 x\nhlen0 : p.length \u2260 0\n\u22a2 p.length - 1 + 1 = p.length",["omega"]],["Order/KrullDimension.lean",205,"case h.e'_3\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\np : LTSeries \u03b1\nx : \u03b1\nhlast : RelSeries.last p \u2264 x\nhlen0 : p.length \u2260 0\np' : RelSeries fun x1 x2 \u21a6 x1 < x2 := (RelSeries.eraseLast p).snoc x \u22ef\nthis : \u2191p.length - 1 + 1 \u2264 height x\n\u22a2 p.length = p.length - 1 + 1",["omega"]],["Order/KrullDimension.lean",249,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\np : LTSeries \u03b1\ni : Fin (p.length + 1)\np' : LTSeries \u03b1\nhp' : RelSeries.last p' = p.toFun i\nhp'' : p'.length + (p.length - \u2191i) \u2264 p.length\n\u22a2 p'.length \u2264 \u2191i",["omega"]],["Order/KrullDimension.lean",355,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nn m : \u2115\np : LTSeries \u03b1\nhne : Nonempty { p_1 // RelSeries.last p_1 = RelSeries.last p }\nha : \u2200 (p_1 : LTSeries \u03b1), RelSeries.last p_1 = RelSeries.last p \u2192 p_1.length \u2260 n\nhp : p.length = m\nhnm : n < m\n\u22a2 p.length - (m - n) = n",["omega"]],["Order/KrullDimension.lean",364,"case h.right\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na : \u03b1\nn : \u2115\nhne : Nonempty { p // RelSeries.last p = a }\nm : \u2115\nh : n \u2264 m\nha : \u2a06 x, \u2191(\u2191x).length = \u2191m\np : LTSeries \u03b1\nhlast : RelSeries.last p = a\nhlen : p.length = m\n\u22a2 m - (m - n) = n",["omega"]],["Order/KrullDimension.lean",464,"case h.left.a\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nx : \u03b1\nn : \u2115\nhfin : height x < \u22a4\nm : \u2115\nhx : height x = \u2191m\nh : n < m\np : LTSeries \u03b1\nhp : RelSeries.last p = x\nhlen : p.length = m\n\u22a2 n < p.length",["omega","aesop"]],["Order/KrullDimension.lean",505,"case a.h.e'_2.h.h'.a.coe\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nx : \u03b1\nhfin : height x < \u22a4\nn : \u2115\ny : \u03b1\na\u271d\u00b9 : y < x\na\u271d : \u2115\n\u22a2 a\u271d \u2264 n \u2194 a\u271d < n + 1",["omega"]],["Order/KrullDimension.lean",524,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nn : \u2115\np : LTSeries \u03b1\nhp : p.length = n + 1\nhfin : \u2200 (n : \u2115), \u2203 p_1, RelSeries.last p_1 = RelSeries.last p \u2227 p_1.length = n\n\u22a2 p.length \u2260 0",["omega","aesop"]],["Order/KrullDimension.lean",923,"case e_a.e_val\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nx : \u03b1\np : LTSeries (WithBot \u03b1)\nhlast : RelSeries.last p = \u2191x\nhlenpos : p.length \u2260 0\np' : LTSeries \u03b1 :=\n  { length := p.length - 1,\n    toFun := fun x \u21a6\n      match x with\n      | \u27e8i, hi\u27e9 => (p.toFun \u27e8i + 1, \u22ef\u27e9).unbot \u22ef,\n    step := \u22ef }\n\u22a2 p.length - 1 + 1 = p.length",["omega"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",234,"\u03b9 : Type u_1\nA : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 MeasurableSpace (A i)\n\u03bc : (i : \u03b9) \u2192 Measure (A i)\ninst\u271d\u00b2 : DecidableEq \u03b9\np : \u211d\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : \u2200 (i : \u03b9), SigmaFinite (\u03bc i)\nhp\u2080 : 0 \u2264 p\nhp : (\u2191#\u03b9 - 1) * p \u2264 1\nf : ((i : \u03b9) \u2192 A i) \u2192 \u211d\u22650\u221e\nhf : Measurable f\ns : Finset \u03b9\ni : \u03b9\nhi : i \u2209 s\nthis : \u2191(#s) + 1 \u2264 \u2191#\u03b9\n\u22a2 \u2191(#s) \u2264 \u2191#\u03b9 - 1",["linarith"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",277,"\u03b9 : Type u_1\nA : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 MeasurableSpace (A i)\n\u03bc : (i : \u03b9) \u2192 Measure (A i)\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : \u2200 (i : \u03b9), SigmaFinite (\u03bc i)\np : \u211d\nhp : (\u2191#\u03b9).IsConjExponent p\nf : ((a : \u03b9) \u2192 A a) \u2192 \u211d\u22650\u221e\nhf : Measurable f\nthis : Nontrivial \u03b9\nh0 : 1 < \u2191#\u03b9\n\u22a2 0 < \u2191#\u03b9 - 1",["linarith","aesop"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",312,"\u03b9 : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : Fintype \u03b9\np : \u211d\nhp : (\u2191#\u03b9).IsConjExponent p\nu : (\u03b9 \u2192 \u211d) \u2192 F\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\nh\u03b9 : 2 \u2264 \u2191#\u03b9\n\u22a2 1 \u2264 \u2191#\u03b9 - 1",["linarith"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",278,"\u03b9 : Type u_1\nA : \u03b9 \u2192 Type u_2\ninst\u271d\u00b3 : (i : \u03b9) \u2192 MeasurableSpace (A i)\n\u03bc : (i : \u03b9) \u2192 Measure (A i)\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : \u2200 (i : \u03b9), SigmaFinite (\u03bc i)\np : \u211d\nhp : (\u2191#\u03b9).IsConjExponent p\nf : ((a : \u03b9) \u2192 A a) \u2192 \u211d\u22650\u221e\nhf : Measurable f\nthis : Nontrivial \u03b9\nh0 : 1 < \u2191#\u03b9\nh1 : 0 < \u2191#\u03b9 - 1\n\u22a2 0 \u2264 1 / (\u2191#\u03b9 - 1)",["positivity"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",587,"case h\nE : Type u_4\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : MeasurableSpace E\ninst\u271d\u2075 : BorelSpace E\ninst\u271d\u2074 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b3 : \u03bc.IsAddHaarMeasure\nF' : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup F'\ninst\u271d\u00b9 : InnerProductSpace \u211d F'\ninst\u271d : CompleteSpace F'\nu : E \u2192 F'\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\np p' : \u211d\u22650\nhp\u271d : 1 \u2264 p\nhp'0 : \u00acp' = 0\nn : \u2115 := finrank \u211d E\nhn\u271d : 0 < n\nhp' : (\u2191p')\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191n)\u207b\u00b9\nn' : \u211d\u22650 := (\u2191n).conjExponent\nh2p : \u2191p < \u2191n\nh0n : 2 \u2264 n\nhn : (\u2191n).IsConjExponent n'\nh1n : 1 \u2264 \u2191n\nh2n : 0 < \u2191n - 1\nhnp : 0 < \u2191n - \u2191p\nhp : 1 < p\nq : \u211d := (\u2191p).conjExponent\nhq : (\u2191p).IsConjExponent q\nh0p : p \u2260 0\nh1p : \u2191p \u2260 1\nh3p : \u2191p - 1 \u2260 0\nh0p' : p' \u2260 0\nh2q : 1 / \u2191n' - 1 / q = 1 / \u2191p'\n\u03b3 : \u211d\u22650 := \u27e8\u2191p * (\u2191n - 1) / (\u2191n - \u2191p), \u22ef\u27e9\nh0\u03b3 : \u2191\u03b3 = \u2191p * (\u2191n - 1) / (\u2191n - \u2191p)\nh1\u03b3 : 1 < \u2191\u03b3\nh2\u03b3 : \u03b3 * n' = p'\nh3\u03b3 : (\u2191\u03b3 - 1) * q = \u2191p'\nh4\u03b3 : \u2191\u03b3 \u2260 0\nh3u : \u00ac\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc = 0\nh4u : \u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc \u2260 \u22a4\nh5u : (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q) \u2260 0\nh6u : (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q) \u2260 \u22a4\nh7u : Continuous u\nh8u : Continuous (fderiv \u211d u)\nv : E \u2192 \u211d := fun x \u21a6 \u2016u x\u2016 ^ \u2191\u03b3\nhv : ContDiff \u211d 1 v\nh2v : HasCompactSupport v\nC : \u211d\u22650 := eLpNormLESNormFDerivOneConst \u03bc \u2191n'\nthis :\n  (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / \u2191n') \u2264\n    \u2191C * \u2191\u03b3 * (\u222b\u207b (x : E), \u2016fderiv \u211d u x\u2016\u2091 ^ \u2191p \u2202\u03bc) ^ (1 / \u2191p) * (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q)\n\u22a2 0 \u2264 \u2191p * (\u2191n - 1) / (\u2191n - \u2191p)",["positivity","linarith"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",688,"case ha\nF : Type u_3\ninst\u271d\u2078 : NormedAddCommGroup F\ninst\u271d\u2077 : NormedSpace \u211d F\nE : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\ninst\u271d\u2074 : MeasurableSpace E\ninst\u271d\u00b3 : BorelSpace E\ninst\u271d\u00b2 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : FiniteDimensional \u211d F\nu : E \u2192 F\ns : Set E\nhu : ContDiff \u211d 1 u\nh2u : support u \u2286 s\np q : \u211d\u22650\nhp : 1 \u2264 p\nh2p : p < \u2191(finrank \u211d E)\nhpq : \u2191p\u207b\u00b9 - (\u2191(finrank \u211d E))\u207b\u00b9 \u2264 (\u2191q)\u207b\u00b9\nhs : Bornology.IsBounded s\nhq0 : \u00acq = 0\np' : \u211d\u22650 := (p\u207b\u00b9 - (\u2191(finrank \u211d E))\u207b\u00b9)\u207b\u00b9\nhp' : \u2191p'\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191(finrank \u211d E))\u207b\u00b9\nH : p'\u207b\u00b9 \u2264 q\u207b\u00b9\nthis : 0 < p\u207b\u00b9 - (\u2191(finrank \u211d E))\u207b\u00b9\n\u22a2 0 < p'",["positivity","aesop"]],["NumberTheory/PellMatiyasevic.lean",704,"a : \u2115\na1 : 1 < a\ni j n : \u2115\nipos : 0 < i\nhin : i \u2264 n\nj4n : j \u2264 4 * n\nh : xn a1 j \u2261 xn a1 i [MOD xn a1 n]\ni2n : i \u2264 2 * n\nj2n : 2 * n < j\n\u22a2 4 * n - j \u2264 2 * n",["omega"]],["NumberTheory/PellMatiyasevic.lean",709,"a : \u2115\na1 : 1 < a\ni j n : \u2115\nipos : 0 < i\nhin : i \u2264 n\nj4n : j \u2264 4 * n\nh : xn a1 j \u2261 xn a1 i [MOD xn a1 n]\ni2n : i \u2264 2 * n\nj2n : 2 * n < j\nj42n : 4 * n - j \u2264 2 * n\n\u22a2 a = 2 \u2192 n = 1 \u2192 (i = 0 \u2192 4 * n - j \u2260 2) \u2227 (i = 2 \u2192 4 * n - j \u2260 0)",["omega"]],["NumberTheory/PellMatiyasevic.lean",887,"n k : \u2115\nhk : 0 < k\nhn : 0 < n\nw : \u2115 := n \u2294 k\nnw : n \u2264 w\nkw : k \u2264 w\nwpos : 0 < w\nw1 : 1 < w + 1\na : \u2115 := xn w1 w\na1 : 1 < a\nna : n \u2264 a\nx : \u2115 := xn a1 k\ny : \u2115 := yn a1 k\nz : \u2115\nze : yn w1 w = w * z\nt : \u2115\nte : \u2191t = 2 * \u2191a * \u2191n - \u2191n * \u2191n - 1\nnt\u271d nt : \u2191(n ^ k) < \u2191t\ntm : x \u2261 y * (a - n) + n ^ k [MOD t]\n\u22a2 2 * \u2191a * \u2191n = \u2191t + (\u2191n * \u2191n + 1)",["omega","aesop","linarith"]],["MeasureTheory/Measure/LevyProkhorovMetric.lean",447,"\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : PseudoMetricSpace \u03a9\ninst\u271d : OpensMeasurableSpace \u03a9\n\u03bcs : \u2115 \u2192 LevyProkhorov (ProbabilityMeasure \u03a9)\n\u03bd : LevyProkhorov (ProbabilityMeasure \u03a9)\nh\u03bcs : Tendsto \u03bcs atTop (\ud835\udcdd \u03bd)\nP : ProbabilityMeasure \u03a9 := (equiv (ProbabilityMeasure \u03a9)) \u03bd\nPs : \u2115 \u2192 ProbabilityMeasure \u03a9 := fun n \u21a6 (equiv (ProbabilityMeasure \u03a9)) (\u03bcs n)\nf\u271d f : \u03a9 \u2192\u1d47 \u211d\nf_nn : 0 \u2264 f\nf_zero : \u00ac\u2016f\u2016 = 0\nnorm_f_pos : 0 < \u2016f\u2016\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\n\u03b5s : \u2115 \u2192 \u211d\nleft\u271d : StrictAnti \u03b5s\n\u03b5s_pos : \u2200 (n : \u2115), 0 < \u03b5s n\n\u03b5s_lim : Tendsto \u03b5s atTop (\ud835\udcdd 0)\n\u03b5_of_room : Tendsto (fun x \u21a6 dist (\u03bcs x) \u03bd + \u03b5s x) atTop (\ud835\udcdd 0)\n\u03b5_of_room' : Tendsto (fun n \u21a6 dist (\u03bcs n) \u03bd + \u03b5s n) atTop (\ud835\udcdd[>] 0)\nkey :\n  Tendsto ((fun \u03b5 \u21a6 \u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P (thickening \u03b5 {a | t \u2264 f a}))).toReal) \u2218 fun n \u21a6 dist (\u03bcs n) \u03bd + \u03b5s n)\n    atTop (\ud835\udcdd (\u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P {a | t \u2264 f a})).toReal))\nz : \u211d\n\u22a2 z < z + \u03b4 / 2",["linarith"]],["MeasureTheory/Measure/LevyProkhorovMetric.lean",558,"\u03a9 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03a9\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : OpensMeasurableSpace \u03a9\ninst\u271d : SeparableSpace \u03a9\nP : ProbabilityMeasure \u03a9\n\u03b5 : \u211d\n\u03b5_pos : \u03b5 > 0\n\u22a2 0 < \u03b5 / 3",["linarith","aesop","positivity"]],["MeasureTheory/Measure/LevyProkhorovMetric.lean",596,"\u03a9 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03a9\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : OpensMeasurableSpace \u03a9\ninst\u271d : SeparableSpace \u03a9\nP : ProbabilityMeasure \u03a9\n\u03b5 : \u211d\n\u03b5_pos : \u03b5 > 0\nthird_\u03b5_pos : 0 < \u03b5 / 3\nthird_\u03b5_pos' : 0 < ENNReal.ofReal (\u03b5 / 3)\nEs : \u2115 \u2192 Set \u03a9\nEs_mble : \u2200 (n : \u2115), MeasurableSet (Es n)\nEs_bdd : \u2200 (n : \u2115), Bornology.IsBounded (Es n)\nEs_diam : \u2200 (n : \u2115), diam (Es n) \u2264 \u03b5 / 3\nEs_cover : \u22c3 n, Es n = univ\nEs_disjoint : Pairwise fun n m \u21a6 Disjoint (Es n) (Es m)\nN : \u2115\nhN : \u2191P (\u22c3 j \u2208 Iio N, Es j)\u1d9c < ENNReal.ofReal (\u03b5 / 3)\nJs_finite : {J | J \u2286 Iio N}.Finite\nGs : Set (Set \u03a9) := (fun J \u21a6 thickening (\u03b5 / 3) (\u22c3 j \u2208 J, Es j)) '' {J | J \u2286 Iio N}\nGs_open : \u2200 (J : Set \u2115), IsOpen (thickening (\u03b5 / 3) (\u22c3 j \u2208 J, Es j))\nmem_nhds_P : \u2200 (G : Set \u03a9), IsOpen G \u2192 {Q | \u2191P G < \u2191Q G + ENNReal.ofReal (\u03b5 / 3)} \u2208 \ud835\udcdd P\nQ : ProbabilityMeasure \u03a9\nhQ :\n  \u2200 i \u2286 Iio N,\n    \u2191P (\u22c3 i_2 \u2208 i, thickening (\u03b5 / 3) (Es i_2)) < \u2191Q (\u22c3 i_2 \u2208 i, thickening (\u03b5 / 3) (Es i_2)) + ENNReal.ofReal (\u03b5 / 3)\n\u22a2 2 * (\u03b5 / 3) < \u03b5",["linarith"]],["MeasureTheory/Measure/LevyProkhorovMetric.lean",635,"case intro.intro.intro.intro.intro.intro.intro\n\u03a9 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03a9\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : OpensMeasurableSpace \u03a9\ninst\u271d : SeparableSpace \u03a9\nP : ProbabilityMeasure \u03a9\n\u03b5 : \u211d\n\u03b5_pos : \u03b5 > 0\nthird_\u03b5_pos : 0 < \u03b5 / 3\nthird_\u03b5_pos' : 0 < ENNReal.ofReal (\u03b5 / 3)\nEs : \u2115 \u2192 Set \u03a9\nEs_mble : \u2200 (n : \u2115), MeasurableSet (Es n)\nEs_bdd : \u2200 (n : \u2115), Bornology.IsBounded (Es n)\nEs_diam : \u2200 (n : \u2115), diam (Es n) \u2264 \u03b5 / 3\nEs_cover : \u22c3 n, Es n = univ\nEs_disjoint : Pairwise fun n m \u21a6 Disjoint (Es n) (Es m)\nN : \u2115\nhN : \u2191P (\u22c3 j \u2208 Iio N, Es j)\u1d9c < ENNReal.ofReal (\u03b5 / 3)\nJs_finite : {J | J \u2286 Iio N}.Finite\nGs : Set (Set \u03a9) := (fun J \u21a6 thickening (\u03b5 / 3) (\u22c3 j \u2208 J, Es j)) '' {J | J \u2286 Iio N}\nGs_open : \u2200 (J : Set \u2115), IsOpen (thickening (\u03b5 / 3) (\u22c3 j \u2208 J, Es j))\nmem_nhds_P : \u2200 (G : Set \u03a9), IsOpen G \u2192 {Q | \u2191P G < \u2191Q G + ENNReal.ofReal (\u03b5 / 3)} \u2208 \ud835\udcdd P\nQ : ProbabilityMeasure \u03a9\nhQ :\n  \u2200 i \u2286 Iio N,\n    \u2191P (\u22c3 i_2 \u2208 i, thickening (\u03b5 / 3) (Es i_2)) < \u2191Q (\u22c3 i_2 \u2208 i, thickening (\u03b5 / 3) (Es i_2)) + ENNReal.ofReal (\u03b5 / 3)\n\u03b4 : \u211d\nB : Set \u03a9\n\u03b4_gt : 2 * (\u03b5 / 3) < \u03b4\nx\u271d : MeasurableSet B\nJB : Set \u2115 := {i | B \u2229 Es i \u2260 \u2205 \u2227 i \u2208 Iio N}\nB_subset : B \u2286 (\u22c3 i \u2208 JB, thickening (\u03b5 / 3) (Es i)) \u222a (\u22c3 j \u2208 Iio N, Es j)\u1d9c\n\u03c9 : \u03a9\nk : \u2115\nB_intersects : B \u2229 Es k \u2260 \u2205\nright\u271d : k \u2208 Iio N\nw : \u03a9\nw_in_Ek : w \u2208 Es k\nw_near : dist \u03c9 w < \u03b5 / 3\nz : \u03a9\nz_in_B : z \u2208 B\nz_in_Ek : z \u2208 Es k\n\u22a2 \u03b5 / 3 + \u03b5 / 3 < \u03b4",["linarith"]],["MeasureTheory/Measure/FiniteMeasure.lean",416,"\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : TopologicalSpace \u03a9\ninst\u271d : OpensMeasurableSpace \u03a9\n\u03bc : FiniteMeasure \u03a9\nf\u2081 f\u2082 : \u03a9 \u2192\u1d47 \u211d\u22650\nkey : \u03bc.testAgainstNN f\u2082 \u2264 \u03bc.testAgainstNN f\u2081 + \u03bc.mass * nndist f\u2082 f\u2081\nthis : \u2191(\u03bc.testAgainstNN f\u2082) \u2264 \u2191(\u03bc.testAgainstNN f\u2081) + \u2191\u03bc.mass * dist f\u2081 f\u2082\n\u22a2 -(\u2191\u03bc.mass * dist f\u2081 f\u2082) \u2264 \u2191(\u03bc.testAgainstNN f\u2081) - \u2191(\u03bc.testAgainstNN f\u2082)",["linarith","aesop"]],["MeasureTheory/Measure/FiniteMeasure.lean",420,"\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : TopologicalSpace \u03a9\ninst\u271d : OpensMeasurableSpace \u03a9\n\u03bc : FiniteMeasure \u03a9\nf\u2081 f\u2082 : \u03a9 \u2192\u1d47 \u211d\u22650\nkey : \u03bc.testAgainstNN f\u2081 \u2264 \u03bc.testAgainstNN f\u2082 + \u03bc.mass * nndist f\u2081 f\u2082\nthis : \u2191(\u03bc.testAgainstNN f\u2081) \u2264 \u2191(\u03bc.testAgainstNN f\u2082) + \u2191\u03bc.mass * dist f\u2081 f\u2082\n\u22a2 \u2191(\u03bc.testAgainstNN f\u2081) - \u2191(\u03bc.testAgainstNN f\u2082) \u2264 \u2191\u03bc.mass * dist f\u2081 f\u2082",["linarith"]],["NumberTheory/FLT/Three.lean",295,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nhm : FiniteMultiplicity \u03bb S'.c\nthis : 4 \u2264 3 * multiplicity \u03bb S'.c\n\u22a2 2 \u2264 multiplicity \u03bb S'.c",["omega","linarith"]],["NumberTheory/FLT/Three.lean",348,"case intro.intro\nK : Type u_1\ninst\u271d\u00b3 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS' : Solution' h\u03b6\ninst\u271d\u00b2 : NumberField K\ninst\u271d\u00b9 : IsCyclotomicExtension {3} \u211a K\ninst\u271d : DecidableRel fun a b \u21a6 a \u2223 b\nh1 : multiplicity \u03bb (S'.a + S'.b) < 2\nh2 : multiplicity \u03bb (S'.a + \u2191\u03b7 * S'.b) < 2\nh3 : multiplicity \u03bb (S'.a + \u2191\u03b7 ^ 2 * S'.b) < 2\nh1' : FiniteMultiplicity \u03bb (S'.a + S'.b)\nh2' : FiniteMultiplicity \u03bb (S'.a + \u2191\u03b7 * S'.b)\nh3' : FiniteMultiplicity \u03bb (S'.a + \u2191\u03b7 ^ 2 * S'.b)\nthis : 2 * 3 \u2264 multiplicity \u03bb (S'.a + S'.b) + multiplicity \u03bb (S'.a + \u2191\u03b7 * S'.b) + multiplicity \u03bb (S'.a + \u2191\u03b7 ^ 2 * S'.b)\n\u22a2 False",["omega","linarith"]],["NumberTheory/FLT/Three.lean",658,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : 2 \u2264 S.multiplicity\n\u22a2 (S.multiplicity - 1) * 3 + 1 = 3 * S.multiplicity - 2",["omega"]],["NumberTheory/FLT/Three.lean",667,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : 2 \u2264 S.multiplicity\n\u22a2 3 * (S.multiplicity - 1) = 2 + (3 * S.multiplicity - 5)",["omega"]],["NumberTheory/FLT/Three.lean",736,"K : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nS : Solution h\u03b6\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nthis : 2 \u2264 S.multiplicity\n\u22a2 S.multiplicity \u2260 0",["omega","aesop","linarith","positivity"]],["Analysis/SpecialFunctions/Integrals.lean",80,"case h\na b r : \u211d\nh : -1 < r\nc : \u211d\nhc : 0 \u2264 c\nhderiv : \u2200 x \u2208 Set.Ioo 0 c, HasDerivAt (fun x \u21a6 x ^ (r + 1) / (r + 1)) (x ^ r) x\nx : \u211d\na\u271d : x \u2208 Set.Icc 0 c\n\u22a2 0 \u2264 r + 1",["linarith"]],["Geometry/Euclidean/MongePoint.lean",468,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nt : Triangle \u211d P\ni\u2081 i\u2082 : Fin 3\np : P\nh\u2081\u2082 : i\u2081 \u2260 i\u2082\ni\u2083 : Fin 3\nh\u2082 : p \u2208 mongePlane t i\u2083 i\u2081\nh\u2081 : p \u2208 mongePlane t i\u2083 i\u2082\nh\u2082\u2083 : i\u2082 \u2260 i\u2083\nh\u2081\u2083 : i\u2081 \u2260 i\u2083\ni : Fin 3\nhi : i\u2083 \u2260 i\n\u22a2 i\u2081 = i \u2228 i\u2082 = i",["omega"]],["Probability/Kernel/IonescuTulcea/Traj.lean",325,"case neg\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nf : \u2115 \u2192 ((n : \u2115) \u2192 X n) \u2192 \u211d\u22650\u221e\na : \u2115 \u2192 \u2115\nhcte : \u2200 (n : \u2115), DependsOn (f n) \u2191(Iic (a n))\nmf : \u2200 (n : \u2115), Measurable (f n)\nbound : \u211d\u22650\u221e\nfin_bound : bound \u2260 \u22a4\nle_bound : \u2200 (n : \u2115) (x : (n : \u2115) \u2192 X n), f n x \u2264 bound\nk : \u2115\nanti : \u2200 (x : (n : \u2115) \u2192 X n), Antitone fun n \u21a6 lmarginalPartialTraj \u03ba (k + 1) (a n) (f n) x\nl : ((n : \u2115) \u2192 X n) \u2192 \u211d\u22650\u221e\nhtendsto : \u2200 (x : (n : \u2115) \u2192 X n), Tendsto (fun n \u21a6 lmarginalPartialTraj \u03ba (k + 1) (a n) (f n) x) atTop (\ud835\udcdd (l x))\n\u03b5 : \u211d\u22650\u221e\ny : (i : { x // x \u2208 Iic k }) \u2192 X \u2191i\nhpos : \u2200 (x : (i : \u2115) \u2192 X i) (n : \u2115), \u03b5 \u2264 lmarginalPartialTraj \u03ba k (a n) (f n) (updateFinset x (Iic k) y)\nx\u271d : \u2200 (n : \u2115), Nonempty (X n)\nF : \u2115 \u2192 ((n : \u2115) \u2192 X n) \u2192 \u211d\u22650\u221e := fun n \u21a6 lmarginalPartialTraj \u03ba (k + 1) (a n) (f n)\ntendstoF : \u2200 (x : (n : \u2115) \u2192 X n), Tendsto (fun x_1 \u21a6 F x_1 x) atTop (\ud835\udcdd (l x))\nf_eq : \u2200 (x : (n : \u2115) \u2192 X n) (n : \u2115), lmarginalPartialTraj \u03ba k (a n) (f n) x = lmarginalPartialTraj \u03ba k (k + 1) (F n) x\nF_le : \u2200 (n : \u2115) (x : (n : \u2115) \u2192 X n), F n x \u2264 bound\ntendsto_int :\n  \u2200 (x : (n : \u2115) \u2192 X n),\n    Tendsto (fun n \u21a6 lmarginalPartialTraj \u03ba k (a n) (f n) x) atTop (\ud835\udcdd (lmarginalPartialTraj \u03ba k (k + 1) l x))\n\u03b5_le_lint : \u2200 (x : (i : \u2115) \u2192 X i), \u03b5 \u2264 lmarginalPartialTraj \u03ba k (k + 1) l (updateFinset x (Iic k) y)\nx_ : (n : \u2115) \u2192 X n := Classical.ofNonempty\nx : X (k + 1)\nhx : \u03b5 \u2264 l (update (updateFinset x_ (Iic k) y) (k + 1) x)\nx' : (i : \u2115) \u2192 X i\nn : \u2115\nthis : \u03b5 \u2264 lmarginalPartialTraj \u03ba (k + 1) (a n) (f n) (update (updateFinset x_ (Iic k) y) (k + 1) x)\ni : \u2115\nhi : i \u2264 k + 1\nh1 : \u00aci = k + 1\nh2 : \u00aci \u2264 k\n\u22a2 x' i = x_ i",["omega"]],["Data/Nat/Digits.lean",404,"b hd : \u2115\ntl : List \u2115\nIH : (\u2200 x \u2208 tl, x < b + 2) \u2192 ofDigits (b + 2) tl < (b + 2) ^ tl.length\nhl : \u2200 x \u2208 hd :: tl, x < b + 2\nthis\u271d : (ofDigits (b + 2) tl + 1) * (b + 2) \u2264 (b + 2) ^ tl.length * (b + 2)\nthis : hd < b + 2\n\u22a2 \u2191hd + (b + 2) * ofDigits (b + 2) tl < (b + 2) ^ tl.length * (b + 2)",["linarith"]],["Data/Nat/Digits.lean",825,"b n m r : \u2115\nl : List \u2115\ne : r + b * m = n\nhr : r < b\nh : b.digits m = l\nb2 : 1 < b\nm0 : 0 < m\n\u22a2 0 < b",["omega","linarith","positivity","infer_instance"]],["MeasureTheory/Integral/DominatedConvergence.lean",618,"E : Type u_1\nX : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : TopologicalSpace X\n\u03bc : Measure \u211d\ninst\u271d\u00b9 : NoAtoms \u03bc\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : X \u2192 \u211d \u2192 E\na\u2080 : \u211d\nhf : Continuous (Function.uncurry f)\nq : X\nb\u2080 \u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\na : \u211d\na_lt : a < a\u2080 \u2227 a < b\u2080\nb : \u211d\nlt_b : a\u2080 < b \u2227 b\u2080 < b\nthis\u271d : IsCompact ({q} \u00d7\u02e2 Icc a b)\nM : \u211d\nhM : M \u2208 upperBounds ((fun x \u21a6 \u2016Function.uncurry f x\u2016) '' {q} \u00d7\u02e2 Icc a b)\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : \u03b4 < 1\nh'\u03b4 : Icc (b\u2080 - \u03b4) (b\u2080 + \u03b4) \u2286 Icc a b\nh''\u03b4 : (M + 1) * (\u03bc (Icc (b\u2080 - \u03b4) (b\u2080 + \u03b4))).toReal + \u03b4 * (\u03bc (Icc a b)).toReal < \u03b5\nv : Set X\nv_mem : v \u2208 \ud835\udcdd[univ] q\nthis : v \u00d7\u02e2 Ioo (b\u2080 - \u03b4) (b\u2080 + \u03b4) \u2208 \ud835\udcdd (q, b\u2080)\np : X\ns : \u211d\nhp : p \u2208 v\nhs : s \u2208 Ioo (b\u2080 - \u03b4) (b\u2080 + \u03b4)\nhv : \u2200 p \u2208 v, \u2200 x \u2208 Icc a b, \u2016f p x - f q x\u2016 < \u03b4\nJ : \u2200 (r : X) (u v : \u211d), IntervalIntegrable (f r) \u03bc u v\nx : \u211d\nhx : x \u2208 Icc (b\u2080 - \u03b4) (b\u2080 + \u03b4)\n\u22a2 M + \u03b4 \u2264 M + 1",["linarith","gcongr"]],["AlgebraicTopology/SimplexCategory/Basic.lean",762,"case neg\nn : \u2115\n\u0394' : SimplexCategory\n\u03b8 : \u298bn + 1\u298c \u27f6 \u0394'\ni : Fin (n + 1)\nhi : (Hom.toOrderHom \u03b8) i.castSucc = (Hom.toOrderHom \u03b8) i.succ\nx : Fin (\u298bn + 1\u298c.len + 1)\nh'\u271d : i.castSucc < x\ny : Fin \u298bn + 1\u298c.len := x.pred \u22ef\nhy : x = y.succ\nh' : \u2191i \u2264 \u2191y\nh'' : \u00ac\u2191y = \u2191i\n\u22a2 \u2191i + 1 \u2264 \u2191y",["omega"]],["Analysis/Analytic/Inverse.lean",528,"case bc.h.hac\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nhp : 0 < p.radius\nC r : \u211d\nCpos : 0 < C\nrpos : 0 < r\nple : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\na : \u211d\napos : 0 < a\nha1 : 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a \u2264 1\nha2 : r * (I + 1) * a \u2264 1 / 2\nS : \u2115 \u2192 \u211d := fun n \u21a6 \u2211 k \u2208 Ico 1 n, a ^ k * \u2016p.rightInv i x k\u2016\nn : \u2115\none_le_n : 1 \u2264 n\nhn : S n \u2264 (I + 1) * a\nIn : 2 \u2264 n + 1\nrSn : r * S n \u2264 1 / 2\n\u22a2 0 \u2264 (r * S n) ^ (n + 1)",["positivity"]],["Analysis/Analytic/Inverse.lean",545,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nhp : 0 < p.radius\nC r : \u211d\nCpos : 0 < C\nrpos : 0 < r\nple : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\na : \u211d\napos : 0 < a\nha1 : 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a \u2264 1\nha2 : r * (I + 1) * a \u2264 1 / 2\nS : \u2115 \u2192 \u211d := fun n \u21a6 \u2211 k \u2208 Ico 1 n, a ^ k * \u2016p.rightInv i x k\u2016\nIRec : \u2200 (n : \u2115), 1 \u2264 n \u2192 S n \u2264 (I + 1) * a\na' : NNReal := \u27e8a, \u22ef\u27e9\nn : \u2115\nhn : 1 \u2264 n\nk : \u2115\nx\u271d : k \u2208 Ico 1 (n + 1)\n\u22a2 0 \u2264 a ^ k * \u2016p.rightInv i x k\u2016",["positivity","aesop"]],["Analysis/Analytic/Inverse.lean",515,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nhp : 0 < p.radius\nC r : \u211d\nCpos : 0 < C\nrpos : 0 < r\nple : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\na : \u211d\napos : 0 < a\nha1 : 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a \u2264 1\nha2 : r * (I + 1) * a \u2264 1 / 2\nS : \u2115 \u2192 \u211d := fun n \u21a6 \u2211 k \u2208 Ico 1 n, a ^ k * \u2016p.rightInv i x k\u2016\nn : \u2115\none_le_n : 1 \u2264 n\nhn : S n \u2264 (I + 1) * a\n\u22a2 2 \u2264 n + 1",["omega","aesop","linarith"]],["Analysis/Calculus/ContDiff/Bounds.lean",71,"\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nDu : Type u\ninst\u271d\u2077 : NormedAddCommGroup Du\ninst\u271d\u2076 : NormedSpace \ud835\udd5c Du\ns : Set Du\nx : Du\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nn : \u2115\nIH :\n  \u2200 {Eu Fu Gu : Type u} [inst : NormedAddCommGroup Eu] [inst_1 : NormedSpace \ud835\udd5c Eu] [inst_2 : NormedAddCommGroup Fu]\n    [inst_3 : NormedSpace \ud835\udd5c Fu] [inst_4 : NormedAddCommGroup Gu] [inst_5 : NormedSpace \ud835\udd5c Gu] (B : Eu \u2192L[\ud835\udd5c] Fu \u2192L[\ud835\udd5c] Gu)\n    {f : Du \u2192 Eu} {g : Du \u2192 Fu},\n    ContDiffOn \ud835\udd5c (\u2191n) f s \u2192\n      ContDiffOn \ud835\udd5c (\u2191n) g s \u2192\n        \u2016iteratedFDerivWithin \ud835\udd5c n (fun y \u21a6 (B (f y)) (g y)) s x\u2016 \u2264\n          \u2016B\u2016 *\n            \u2211 i \u2208 Finset.range (n + 1),\n              \u2191(n.choose i) * \u2016iteratedFDerivWithin \ud835\udd5c i f s x\u2016 * \u2016iteratedFDerivWithin \ud835\udd5c (n - i) g s x\u2016\nEu Fu Gu : Type u\ninst\u271d\u2075 : NormedAddCommGroup Eu\ninst\u271d\u2074 : NormedSpace \ud835\udd5c Eu\ninst\u271d\u00b3 : NormedAddCommGroup Fu\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c Fu\ninst\u271d\u00b9 : NormedAddCommGroup Gu\ninst\u271d : NormedSpace \ud835\udd5c Gu\nB : Eu \u2192L[\ud835\udd5c] Fu \u2192L[\ud835\udd5c] Gu\nf : Du \u2192 Eu\ng : Du \u2192 Fu\nhf : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nhg : ContDiffOn \ud835\udd5c (\u2191(n + 1)) g s\nIn : \u2191n + 1 \u2264 \u2191n.succ\nnorm : Norm (Eu \u2192L[\ud835\udd5c] (Du \u2192L[\ud835\udd5c] Fu) \u2192L[\ud835\udd5c] Du \u2192L[\ud835\udd5c] Gu) := hasOpNorm\n\u22a2 0 \u2264\n    \u2211 i \u2208 Finset.range (n + 1),\n      \u2191(n.choose i) * \u2016iteratedFDerivWithin \ud835\udd5c i f s x\u2016 * \u2016iteratedFDerivWithin \ud835\udd5c (n - i) (fderivWithin \ud835\udd5c g s) s x\u2016",["positivity"]],["Analysis/Calculus/ContDiff/Bounds.lean",93,"\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nDu : Type u\ninst\u271d\u2077 : NormedAddCommGroup Du\ninst\u271d\u2076 : NormedSpace \ud835\udd5c Du\ns : Set Du\nx : Du\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nn : \u2115\nIH :\n  \u2200 {Eu Fu Gu : Type u} [inst : NormedAddCommGroup Eu] [inst_1 : NormedSpace \ud835\udd5c Eu] [inst_2 : NormedAddCommGroup Fu]\n    [inst_3 : NormedSpace \ud835\udd5c Fu] [inst_4 : NormedAddCommGroup Gu] [inst_5 : NormedSpace \ud835\udd5c Gu] (B : Eu \u2192L[\ud835\udd5c] Fu \u2192L[\ud835\udd5c] Gu)\n    {f : Du \u2192 Eu} {g : Du \u2192 Fu},\n    ContDiffOn \ud835\udd5c (\u2191n) f s \u2192\n      ContDiffOn \ud835\udd5c (\u2191n) g s \u2192\n        \u2016iteratedFDerivWithin \ud835\udd5c n (fun y \u21a6 (B (f y)) (g y)) s x\u2016 \u2264\n          \u2016B\u2016 *\n            \u2211 i \u2208 Finset.range (n + 1),\n              \u2191(n.choose i) * \u2016iteratedFDerivWithin \ud835\udd5c i f s x\u2016 * \u2016iteratedFDerivWithin \ud835\udd5c (n - i) g s x\u2016\nEu Fu Gu : Type u\ninst\u271d\u2075 : NormedAddCommGroup Eu\ninst\u271d\u2074 : NormedSpace \ud835\udd5c Eu\ninst\u271d\u00b3 : NormedAddCommGroup Fu\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c Fu\ninst\u271d\u00b9 : NormedAddCommGroup Gu\ninst\u271d : NormedSpace \ud835\udd5c Gu\nB : Eu \u2192L[\ud835\udd5c] Fu \u2192L[\ud835\udd5c] Gu\nf : Du \u2192 Eu\ng : Du \u2192 Fu\nhf : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nhg : ContDiffOn \ud835\udd5c (\u2191(n + 1)) g s\nIn : \u2191n + 1 \u2264 \u2191n.succ\nnorm\u271d : Norm (Eu \u2192L[\ud835\udd5c] (Du \u2192L[\ud835\udd5c] Fu) \u2192L[\ud835\udd5c] Du \u2192L[\ud835\udd5c] Gu) := hasOpNorm\nI1 :\n  \u2016iteratedFDerivWithin \ud835\udd5c n (fun y \u21a6 ((precompR Du B) (f y)) (fderivWithin \ud835\udd5c g s y)) s x\u2016 \u2264\n    \u2016B\u2016 *\n      \u2211 i \u2208 Finset.range (n + 1),\n        \u2191(n.choose i) * \u2016iteratedFDerivWithin \ud835\udd5c i f s x\u2016 * \u2016iteratedFDerivWithin \ud835\udd5c (n + 1 - i) g s x\u2016\nnorm : Norm ((Du \u2192L[\ud835\udd5c] Eu) \u2192L[\ud835\udd5c] Fu \u2192L[\ud835\udd5c] Du \u2192L[\ud835\udd5c] Gu) := hasOpNorm\n\u22a2 0 \u2264\n    \u2211 i \u2208 Finset.range (n + 1),\n      \u2191(n.choose i) * \u2016iteratedFDerivWithin \ud835\udd5c i (fderivWithin \ud835\udd5c f s) s x\u2016 * \u2016iteratedFDerivWithin \ud835\udd5c (n - i) g s x\u2016",["positivity"]],["Analysis/SpecificLimits/Basic.lean",675,"case hgf\nR : Type u_4\ninst\u271d\u00b3 : TopologicalSpace R\ninst\u271d\u00b2 : LinearOrderedField R\ninst\u271d\u00b9 : OrderTopology R\ninst\u271d : FloorRing R\na : R\nha : 0 \u2264 a\nA : Tendsto (fun x \u21a6 a - x\u207b\u00b9) atTop (\ud835\udcdd a)\nx : R\nhx : x \u2265 1\nthis : a * x < \u2191\u230aa * x\u230b\u208a + 1\n\u22a2 a * x - 1 \u2264 \u2191\u230aa * x\u230b\u208a",["linarith"]],["Data/Complex/Trigonometric.lean",875,"x : \u211d\nhx0 : 0 < x\nhx : x \u2264 1\n\u22a2 x * (5 / 96) + x / 6 < x",["linarith"]],["Analysis/Normed/Lp/ProdLp.lean",409,"p : \u211d\u22650\u221e\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : WithLp p (\u03b1 \u00d7 \u03b2)\nh : 1 \u2264 p.toReal\n\u22a2 0 < p.toReal",["positivity","linarith"]],["Order/RelSeries.lean",589,"case h.e'_3.e_a\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np q : RelSeries r\nh : p.last = q.head\nH : p.length = 0\n\u22a2 0 = Fin.last p.length",["aesop","omega"]],["Order/RelSeries.lean",244,"\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\n\u03b2 : Type u_2\ns : Rel \u03b2 \u03b2\np q : RelSeries r\nconnect : r p.last q.head\n\u22a2 p.length + q.length + 1 + 1 = p.length + 1 + (q.length + 1)",["omega"]],["Order/RelSeries.lean",288,"case h.e'_2.h.e'_6.h.h\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np q : RelSeries r\nconnect : r p.last q.head\ni : Fin (q.length + 1)\n\u22a2 p.length + \u2191i + 1 < (p.length + q.length + 1).succ",["omega"]],["Order/RelSeries.lean",374,"case h.e'_2.h\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\n\u03b2 : Type u_2\ns : Rel \u03b2 \u03b2\np : RelSeries r\ni : Fin p.length\na : \u03b1\nprev_connect : r (p.toFun i.castSucc) a\nconnect_next : r a (p.toFun i.succ)\nm : Fin (p.length + 1)\nx : \u03b1 := i.succ.castSucc.insertNth a p.toFun m.castSucc\ny : \u03b1 := i.succ.castSucc.insertNth a p.toFun m.succ\nhm : \u2191i + 1 = \u2191m\n\u22a2 \u2191i + 1 < \u2191m + 1",["omega"]],["Order/RelSeries.lean",388,"\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\n\u03b2 : Type u_2\ns : Rel \u03b2 \u03b2\np : RelSeries r\ni : Fin p.length\n\u22a2 \u2191i + 1 \u2264 p.length",["omega"]],["Order/RelSeries.lean",393,"case h.e'_2.h.e'_4.h\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\n\u03b2 : Type u_2\ns : Rel \u03b2 \u03b2\np : RelSeries r\ni : Fin p.length\nhi : \u2191i + 1 \u2264 p.length\n\u22a2 p.length + 1 - (\u2191i + 1) = p.length - (\u2191i + 1) + 1",["omega"]],["Order/RelSeries.lean",507,"case h.e'_2.h.e'_4.h.e'_2\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np : RelSeries r\nh : p.length \u2260 0\n\u22a2 p.length = p.length - 1 + 1",["omega"]],["Order/RelSeries.lean",532,"\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\n\u03b2 : Type u_2\ns : Rel \u03b2 \u03b2\np q : RelSeries r\nconnect : p.last = q.head\ni : Fin (p.length + q.length)\nh\u2082 : \u00ac\u2191i + 1 < p.length\nh\u2081 : \u2191i < p.length\n\u22a2 p.length = \u2191i + 1",["omega"]],["Order/RelSeries.lean",562,"case h.e'_2.e_a.e_val\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np q : RelSeries r\nh : p.last = q.head\ni : Fin p.length\nH : \u00ac\u2191i + 1 < p.length\n\u22a2 \u2191i + 1 \u2264 p.length",["omega"]],["Order/RelSeries.lean",566,"case h.e'_3.e_a.h\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np q : RelSeries r\nh : p.last = q.head\ni : Fin p.length\nH : \u00ac\u2191i + 1 < p.length\n\u22a2 \u2191i + 1 = p.length",["omega"]],["Order/RelSeries.lean",617,"case h.e'_2.h.e'_4.h.h.h.e'_2\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\n\u03b2 : Type u_2\ns : Rel \u03b2 \u03b2\np : RelSeries r\ni : Fin (p.length + 1)\nx\u271d : Fin (p.length - \u2191i)\nj : \u2115\nh : j < p.length - \u2191i\n\u22a2 j + 1 + \u2191i = j + \u2191i + 1",["omega"]],["Order/RelSeries.lean",627,"case e_a.e_val\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np : RelSeries r\ni : Fin (p.length + 1)\n\u22a2 p.length - \u2191i + \u2191i = p.length",["omega"]],["Order/RelSeries.lean",806,"case succ\np : LTSeries \u2115\ni\u271d j\u271d\u00b9 : Fin (p.length + 1)\ni : \u2115\nhi : i < p.length + 1\nj\u271d j : \u2115\n_hij : i \u2264 j\nhj : j + 1 < p.length + 1\nih : p.toFun \u27e8i, hi\u27e9 + j \u2264 p.toFun \u27e8j, \u22ef\u27e9 + i\nstep : p.toFun \u27e8j, \u22ef\u27e9 < p.toFun \u27e8j + 1, \u22ef\u27e9\n\u22a2 p.toFun \u27e8i, hi\u27e9 + (j + 1) \u2264 p.toFun \u27e8j + 1, hj\u27e9 + i",["omega"]],["Order/RelSeries.lean",825,"case succ\np : LTSeries \u2124\ni\u271d j\u271d\u00b9 : Fin (p.length + 1)\ni : \u2115\nhi : i < p.length + 1\nj\u271d j : \u2115\n_hij : i \u2264 j\nhj : j + 1 < p.length + 1\nih : p.toFun \u27e8i, hi\u27e9 + \u2191j \u2264 p.toFun \u27e8j, \u22ef\u27e9 + \u2191i\nstep : p.toFun \u27e8j, \u22ef\u27e9 < p.toFun \u27e8j + 1, \u22ef\u27e9\n\u22a2 p.toFun \u27e8i, hi\u27e9 + \u2191(j + 1) \u2264 p.toFun \u27e8j + 1, hj\u27e9 + \u2191i",["omega"]],["Order/RelSeries.lean",841,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Fintype \u03b1\ns : LTSeries \u03b1\nh : Fintype.card \u03b1 \u2264 s.length\n\u22a2 Fintype.card \u03b1 < s.length + 1",["omega"]],["Order/RelSeries.lean",843,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Fintype \u03b1\ns : LTSeries \u03b1\nh : Fintype.card \u03b1 \u2264 s.length\ni j : Fin (s.length + 1)\nhn : i \u2260 j\nhe : s.toFun i = s.toFun j\nthis : \u2200 (i j : Fin (s.length + 1)), i \u2260 j \u2192 s.toFun i = s.toFun j \u2192 i < j \u2192 False\nhl : \u00aci < j\n\u22a2 j < i",["omega"]],["GroupTheory/FreeGroup/Basic.lean",339,"case nil\n\u03b1 : Type u\nL2 : List (\u03b1 \u00d7 Bool)\nx : \u03b1\nb : Bool\n\u22a2 sizeOf L2 < 1 + (1 + sizeOf b) + (1 + (1 + sizeOf !b) + sizeOf L2)",["omega"]],["Analysis/SpecialFunctions/Pow/Deriv.lean",660,"t : \u211d\nh\u2081 : 1 / 2 < 1\nh\u2082 : Tendsto (fun x \u21a6 1 + t / x) atTop (\ud835\udcdd 1)\nx : \u211d\nhx : 1 / 2 \u2264 1 + t / x\n\u22a2 0 < 1 + t / x",["linarith","positivity"]],["Data/List/Cycle.lean",361,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nh : l.Nodup\nk : \u2115\nhk : k < l.length\nhx : l[k] \u2208 l\nlpos : 0 < l.length\n\u22a2 l.length - 1 - k < l.length",["omega"]],["Topology/MetricSpace/Thickening.lean",370,"case neg.inr\n\u03b5 : \u211d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nh\u03b5\u271d : 0 \u2264 \u03b5\nhs : \u00acBornology.IsBounded s\nh\u03b5 : 0 < \u03b5\n\u22a2 0 \u2264 diam s + 2 * \u03b5",["positivity"]],["Data/Finset/Card.lean",455,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Set.MapsTo f \u2191s \u2191t\nhsurj : Set.SurjOn f \u2191s \u2191t\nhst : #s \u2264 #t\nthis\u271d\u00b9 : image f s = t\nthis\u271d : #(image f s) = #t\nthis : #(image f s) \u2264 #s\n\u22a2 #(image f s) = #s",["omega"]],["Data/Finset/Card.lean",557,"\u03b1 : Type u_1\ns t : Finset \u03b1\nn : \u2115\nhst : s \u2286 t\nhsn : #s \u2264 n\nhnt : n \u2264 #t\nk : \u2115\na\u271d : k < #t\nhnk : n \u2264 k\nu : Finset \u03b1\nhu\u2081 : s \u2286 u\nhu\u2082 : u \u2286 t\nhu\u2083 : #u = k + 1\n\u22a2 0 < #u - #s",["omega"]],["Data/Finset/Card.lean",575,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nh\u2081 : #(X \u2229 (Y \\ X)) = 0\nh\u2082 : #(X \u222a Y) = #X + #(Y \\ X)\nhXY : #X \u2264 n \u2227 #(Y \\ X) \u2264 n\n\u22a2 #X + #(Y \\ X) \u2264 n + n",["omega"]],["Data/Finset/Card.lean",783,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns\u271d t\u271d u : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\np : Finset \u03b1 \u2192 Sort u_4\nn : \u2115\nH : (t\u2081 : Finset \u03b1) \u2192 ({t\u2082 : Finset \u03b1} \u2192 #t\u2082 \u2264 n \u2192 t\u2081 \u2282 t\u2082 \u2192 p t\u2082) \u2192 #t\u2081 \u2264 n \u2192 p t\u2081\nx\u271d : Finset \u03b1\ns : Finset \u03b1 := x\u271d\nt : Finset \u03b1\nht : #t \u2264 n\nh : s \u2282 t\nthis : #s < #t\n\u22a2 n - #t < n - #s",["omega"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",276,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G K L : CochainComplex C \u2124\nn\u2082 n\u2083 n\u2082\u2083 : \u2124\nz\u2081 : Cochain F G 0\nz\u2082 : Cochain G K n\u2082\nz\u2083 : Cochain K L n\u2083\nh\u2082\u2083 : n\u2082 + n\u2083 = n\u2082\u2083\n\u22a2 0 + n\u2082 + n\u2083 = n\u2082\u2083",["omega","aesop","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",282,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G K L : CochainComplex C \u2124\nn\u2081 n\u2083 n\u2081\u2083 : \u2124\nz\u2081 : Cochain F G n\u2081\nz\u2082 : Cochain G K 0\nz\u2083 : Cochain K L n\u2083\nh\u2081\u2083 : n\u2081 + n\u2083 = n\u2081\u2083\n\u22a2 n\u2081 + 0 + n\u2083 = n\u2081\u2083",["omega","aesop","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",288,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G K L : CochainComplex C \u2124\nn\u2081 n\u2082 n\u2081\u2082 : \u2124\nz\u2081 : Cochain F G n\u2081\nz\u2082 : Cochain G K n\u2082\nz\u2083 : Cochain K L 0\nh\u2081\u2082 : n\u2081 + n\u2082 = n\u2081\u2082\n\u22a2 n\u2081 + n\u2082 + 0 = n\u2081\u2082",["omega","aesop","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",417,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\nn m : \u2124\nhnm : n + 1 = m\nz : Cochain F G n\np q : \u2124\nhpq : p + m = q\nq\u2081 q\u2082 : \u2124\nhq\u2081 : q\u2081 = q - 1\nhq\u2082 : p + 1 = q\u2082\n\u22a2 q\u2081 = p + n",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",418,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\nn m : \u2124\nhnm : n + 1 = m\nz : Cochain F G n\np q : \u2124\nhpq : p + m = q\nq\u2082 : \u2124\nhq\u2082 : p + 1 = q\u2082\nhq\u2081 : p + n = q - 1\n\u22a2 q\u2082 = p + m - n",["omega"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",427,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\nn m : \u2124\nhnm : \u00acn + 1 = m\nz : Cochain F G n\np q : \u2124\nhpq : p + m = q\nx\u271d : p + n + 1 = q\n\u22a2 n + 1 = m\n```\n---\n```lean\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\nn m : \u2124\nhnm : \u00acn + 1 = m\nz : Cochain F G n\np q : \u2124\nhpq : p + m = q\nx\u271d : p + 1 = p + m - n\n\u22a2 n + 1 = m",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",533,"case neg.hnm\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nF G : CochainComplex C \u2124\np : \u2124\n\u03c6 : F \u27f6 G\nh : \u00acp = 1\n\u22a2 \u00ac0 + 1 = p",["omega"]],["Computability/AkraBazzi/GrowsPolynomially.lean",165,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nh : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhlt : c\u2081 < c\u2082\nx : \u211d\nhx : \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhx_nonneg : 0 \u2264 x\nh' : 3 / 4 * x \u2208 Set.Icc (1 / 2 * x) x\nhu\u271d : f (3 / 4 * x) \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhu : c\u2081 * f x \u2264 c\u2082 * f x\n\u22a2 0 \u2264 (c\u2082 - c\u2081) * f x",["linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",166,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nh : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhlt : c\u2081 < c\u2082\nx : \u211d\nhx : \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhx_nonneg : 0 \u2264 x\nh' : 3 / 4 * x \u2208 Set.Icc (1 / 2 * x) x\nhu\u271d : f (3 / 4 * x) \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhu : c\u2081 * f x \u2264 c\u2082 * f x\nhu' : 0 \u2264 (c\u2082 - c\u2081) * f x\n\u22a2 0 < c\u2082 - c\u2081",["linarith","aesop"]],["Computability/AkraBazzi/GrowsPolynomially.lean",176,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nh : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhgt : c\u2082 < c\u2081\nx : \u211d\nhx : \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhx_nonneg : 0 \u2264 x\nh' : 3 / 4 * x \u2208 Set.Icc (1 / 2 * x) x\nhu\u271d : f (3 / 4 * x) \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhu : c\u2081 * f x \u2264 c\u2082 * f x\n\u22a2 (c\u2081 - c\u2082) * f x \u2264 0",["linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",177,"f : \u211d \u2192 \u211d\nhf : GrowsPolynomially f\nc\u2081 : \u211d\nleft\u271d\u00b9 : c\u2081 > 0\nc\u2082 : \u211d\nleft\u271d : c\u2082 > 0\nh : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhgt : c\u2082 < c\u2081\nx : \u211d\nhx : \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhx_nonneg : 0 \u2264 x\nh' : 3 / 4 * x \u2208 Set.Icc (1 / 2 * x) x\nhu\u271d : f (3 / 4 * x) \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhu : c\u2081 * f x \u2264 c\u2082 * f x\nhu' : (c\u2081 - c\u2082) * f x \u2264 0\n\u22a2 0 < c\u2081 - c\u2082",["linarith","aesop"]],["Computability/AkraBazzi/GrowsPolynomially.lean",610,"case h\nf : \u211d \u2192 \u211d\np : \u211d\nhf : GrowsPolynomially f\nhf_nonneg : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhfnew : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhc\u2081p : 0 < c\u2081 ^ p\nhc\u2082p : 0 < c\u2082 ^ p\nhp : p < 0\nhneg : \u2200\u1da0 (x : \u211d) in atTop, f x < 0\nx : \u211d\nhx : 0 \u2264 f x\nhx' : f x < 0\n\u22a2 False",["linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",421,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\n\u22a2 f x + \u2016g x\u2016 \u2264 f x + 1 / 2 * f x",["gcongr","aesop","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",426,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\n\u22a2 f x - \u2016g x\u2016 \u2265 f x - 1 / 2 * f x",["gcongr","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",437,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\nhx_lb : 1 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonneg : 0 \u2264 f u\nhfg\u2083 : \u2016g u\u2016 \u2264 1 / 2 * f u\n\u22a2 f u - \u2016g u\u2016 \u2265 f u - 1 / 2 * f u",["gcongr","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",444,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\nhx_lb : 1 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonneg : 0 \u2264 f u\nhfg\u2083 : \u2016g u\u2016 \u2264 1 / 2 * f u\n\u22a2 f u + \u2016g u\u2016 \u2264 f u + 1 / 2 * f u",["gcongr","aesop","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",465,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\n\u22a2 f x + \u2016g x\u2016 \u2264 f x + -1 / 2 * f x",["gcongr","aesop","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",141,"f : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nhf' : \u2200 (a : \u211d), \u2203 b \u2265 a, f b = 0\nc\u2081 : \u211d\nhc\u2081_mem : c\u2081 > 0\nc\u2082 : \u211d\nhc\u2082_mem : c\u2082 > 0\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (1 / 2 * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nx : \u211d\nhx : \u2200 (y : \u211d), x \u2264 y \u2192 \u2200 u \u2208 Set.Icc (1 / 2 * y) y, f u \u2208 Set.Icc (c\u2081 * f y) (c\u2082 * f y)\nhx_pos : 0 < x\nx\u2080 : \u211d\nhx\u2080_ge : x\u2080 \u2265 x \u2294 1\nhx\u2080 : f x\u2080 = 0\nx\u2080_pos : 0 < x\u2080\nhmain : \u2200 (m : \u2115) (z : \u211d), x \u2264 z \u2192 z \u2208 Set.Icc (2 ^ (-\u2191m - 1) * x\u2080) (2 ^ (-\u2191m) * x\u2080) \u2192 f z = 0\n\u22a2 0 < x / x\u2080",["positivity","aesop"]],["Computability/AkraBazzi/GrowsPolynomially.lean",658,"b : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb\u2080 : 0 < b\nh_tendsto : Tendsto (fun x \u21a6 1 / 2 * log x) atTop atTop\nx : \u211d\nhx_pos : 1 < x\nhx : \u2200 (y : \u211d), b * id x \u2264 y \u2192 -log b < 1 / 2 * log y\nu : \u211d\nhu : u \u2208 Set.Icc (b * x) x\n\u22a2 0 < b * x",["positivity"]],["Computability/AkraBazzi/GrowsPolynomially.lean",673,"f g : \u211d \u2192 \u211d\nhg\u271d : GrowsPolynomially g\nhf : f =\u0398[atTop] g\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_pos : 0 < b\nc\u2081 : \u211d\nhc\u2081_pos : 0 < c\u2081\nhf_lb : \u2200\u1da0 (x : \u211d) in atTop, c\u2081 * \u2016g x\u2016 \u2264 \u2016f x\u2016\nc\u2082 : \u211d\nhc\u2082_pos : 0 < c\u2082\nhf_ub : \u2200\u1da0 (x : \u211d) in atTop, \u2016f x\u2016 \u2264 c\u2082 * \u2016g x\u2016\nc\u2083 : \u211d\nhc\u2083_pos : 0 < c\u2083\nc\u2084 : \u211d\nhc\u2084_pos : 0 < c\u2084\nhg :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 \u2016g x\u2016) u \u2208 Set.Icc (c\u2083 * (fun x \u21a6 \u2016g x\u2016) x) (c\u2084 * (fun x \u21a6 \u2016g x\u2016) x)\n\u22a2 0 < c\u2081 * c\u2082\u207b\u00b9 * c\u2083",["positivity","aesop"]],["Computability/AkraBazzi/GrowsPolynomially.lean",674,"f g : \u211d \u2192 \u211d\nhg\u271d : GrowsPolynomially g\nhf : f =\u0398[atTop] g\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_pos : 0 < b\nc\u2081 : \u211d\nhc\u2081_pos : 0 < c\u2081\nhf_lb : \u2200\u1da0 (x : \u211d) in atTop, c\u2081 * \u2016g x\u2016 \u2264 \u2016f x\u2016\nc\u2082 : \u211d\nhc\u2082_pos : 0 < c\u2082\nhf_ub : \u2200\u1da0 (x : \u211d) in atTop, \u2016f x\u2016 \u2264 c\u2082 * \u2016g x\u2016\nc\u2083 : \u211d\nhc\u2083_pos : 0 < c\u2083\nc\u2084 : \u211d\nhc\u2084_pos : 0 < c\u2084\nhg :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 \u2016g x\u2016) u \u2208 Set.Icc (c\u2083 * (fun x \u21a6 \u2016g x\u2016) x) (c\u2084 * (fun x \u21a6 \u2016g x\u2016) x)\nh_lb_pos : 0 < c\u2081 * c\u2082\u207b\u00b9 * c\u2083\n\u22a2 0 < c\u2082 * c\u2084 * c\u2081\u207b\u00b9",["positivity","aesop"]],["Computability/AkraBazzi/GrowsPolynomially.lean",677,"f g : \u211d \u2192 \u211d\nhg\u271d : GrowsPolynomially g\nhf : f =\u0398[atTop] g\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_pos : 0 < b\nc\u2081 : \u211d\nhc\u2081_pos : 0 < c\u2081\nhf_lb : \u2200\u1da0 (x : \u211d) in atTop, c\u2081 * \u2016g x\u2016 \u2264 \u2016f x\u2016\nc\u2082 : \u211d\nhc\u2082_pos : 0 < c\u2082\nhf_ub : \u2200\u1da0 (x : \u211d) in atTop, \u2016f x\u2016 \u2264 c\u2082 * \u2016g x\u2016\nc\u2083 : \u211d\nhc\u2083_pos : 0 < c\u2083\nc\u2084 : \u211d\nhc\u2084_pos : 0 < c\u2084\nhg :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 \u2016g x\u2016) u \u2208 Set.Icc (c\u2083 * (fun x \u21a6 \u2016g x\u2016) x) (c\u2084 * (fun x \u21a6 \u2016g x\u2016) x)\nh_lb_pos : 0 < c\u2081 * c\u2082\u207b\u00b9 * c\u2083\nh_ub_pos : 0 < c\u2082 * c\u2084 * c\u2081\u207b\u00b9\n\u22a2 c\u2082 \u2260 0",["positivity","aesop","linarith"]],["Computability/AkraBazzi/GrowsPolynomially.lean",678,"f g : \u211d \u2192 \u211d\nhg\u271d : GrowsPolynomially g\nhf : f =\u0398[atTop] g\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_pos : 0 < b\nc\u2081 : \u211d\nhc\u2081_pos : 0 < c\u2081\nhf_lb : \u2200\u1da0 (x : \u211d) in atTop, c\u2081 * \u2016g x\u2016 \u2264 \u2016f x\u2016\nc\u2082 : \u211d\nhc\u2082_pos : 0 < c\u2082\nhf_ub : \u2200\u1da0 (x : \u211d) in atTop, \u2016f x\u2016 \u2264 c\u2082 * \u2016g x\u2016\nc\u2083 : \u211d\nhc\u2083_pos : 0 < c\u2083\nc\u2084 : \u211d\nhc\u2084_pos : 0 < c\u2084\nhg :\n  \u2200\u1da0 (x : \u211d) in atTop,\n    \u2200 u \u2208 Set.Icc (b * x) x, (fun x \u21a6 \u2016g x\u2016) u \u2208 Set.Icc (c\u2083 * (fun x \u21a6 \u2016g x\u2016) x) (c\u2084 * (fun x \u21a6 \u2016g x\u2016) x)\nh_lb_pos : 0 < c\u2081 * c\u2082\u207b\u00b9 * c\u2083\nh_ub_pos : 0 < c\u2082 * c\u2084 * c\u2081\u207b\u00b9\nc\u2082_cancel : c\u2082\u207b\u00b9 * c\u2082 = 1\n\u22a2 c\u2081 \u2260 0",["positivity","aesop","linarith"]],["GroupTheory/Perm/Centralizer.lean",703,"case pos.a.H1\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nm : Multiset \u2115\nhm : m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a\nthis : 0 < m.prod\n\u22a2 0 < (Fintype.card \u03b1 - m.sum)! * m.prod * \u220f n \u2208 m.toFinset, (Multiset.count n m)!",["positivity"]],["GroupTheory/Perm/Centralizer.lean",713,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nn : \u2115\nhn' : 2 \u2264 n\nh\u03b1 : n \u2264 card \u03b1\n\u22a2 n \u2260 0",["omega","aesop","positivity"]],["GroupTheory/Perm/Cycle/Type.lean",608,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Perm \u03b1\nh0 : \u00ac\u03c3.cycleType = 0\nn : \u2115\nhn : n \u2208 \u03c3.cycleType\nh1 : \u00ac\u03c3.cycleType.erase n = 0\nm : \u2115\nh : n + (m + ((\u03c3.cycleType.erase n).erase m).sum) = 3\nhm : m \u2208 \u03c3.cycleType.erase n\n\u22a2 \u2200 {k : \u2115}, 2 \u2264 m \u2192 2 \u2264 n \u2192 n + (m + k) = 3 \u2192 False",["omega"]],["RingTheory/PowerSeries/Basic.lean",621,"R : Type u_2\ninst\u271d : CommSemiring R\n\u03c6 : R\u27e6X\u27e7\nn' : \u2115\nih : n' > 0 \u2192 (coeff R 1) (\u03c6 ^ n') = \u2191n' * (coeff R 1) \u03c6 * (constantCoeff R) \u03c6 ^ (n' - 1)\nhn : n' + 1 > 0\nh\u2081 : \u2200 (m : \u2115), \u03c6 ^ (m + 1) = \u03c6 ^ m * \u03c6\nh\u2082 : antidiagonal 1 = {(0, 1), (1, 0)}\n\u22a2 n' = 0 \u2228 1 \u2264 n'",["omega"]],["Algebra/Polynomial/FieldDivision.lean",189,"case intro\nR : Type u\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : CharZero R\nf g : R[X]\nhf0 : f \u2260 0\na : R\nhaf : f.IsRoot a\nr : R[X]\nhr : derivative f * g = f * r\nhdf0 : derivative f \u2260 0\nhg : \u00acg.IsRoot a\nhdfg0 : derivative f * g \u2260 0\nhr' : rootMultiplicity a f = rootMultiplicity a r + rootMultiplicity a f + Nat.succ 0\n\u22a2 False",["omega","linarith"]],["Algebra/Lie/Weights/Killing.lean",540,"K : Type u_2\nL : Type u_3\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : LieAlgebra K L\ninst\u271d\u2074 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b3 : H.IsCartanSubalgebra\ninst\u271d\u00b2 : IsKilling K L\ninst\u271d\u00b9 : IsTriangularizable K (\u21a5H) L\ninst\u271d : CharZero K\n\u03b1 : Weight K (\u21a5H) L\nh\u03b1 : \u03b1.IsNonZero\nthis : \u00ac1 < finrank K \u21a5(rootSpace H \u21d1\u03b1)\nh\u2080 : finrank K \u21a5(rootSpace H \u21d1\u03b1) \u2260 0\n\u22a2 finrank K \u21a5(rootSpace H \u21d1\u03b1) = 1",["omega"]],["Analysis/SpecialFunctions/Complex/Arg.lean",102,"r : \u211d\nhr : 0 < r\n\u03b8 : \u211d\nh\u2081 : \u03c0 / 2 < \u03b8\nh\u03b8 : \u03b8 \u2264 \u03c0\n\u22a2 \u03b8 < \u03c0 + \u03c0 / 2",["linarith"]],["NumberTheory/Padics/PadicVal/Basic.lean",348,"p : \u2115\nhp : Fact (Nat.Prime p)\nq r : \u211a\nhqr : q + r \u2260 0\nhq : q \u2260 0\nhr : r \u2260 0\nhval : padicValRat p q \u2260 padicValRat p r\nh1 : padicValRat p q \u2293 padicValRat p r \u2264 padicValRat p (q + r)\nh2 : padicValRat p (q + r) \u2293 padicValRat p r \u2264 padicValRat p q\nh3 : padicValRat p (q + r) \u2293 padicValRat p q \u2264 padicValRat p r\n\u22a2 padicValRat p (q + r) = padicValRat p q \u2293 padicValRat p r",["omega"]],["Topology/TietzeExtension.lean",203,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : NormalSpace Y\nf : X \u2192\u1d47 \u211d\ne : C(X, Y)\nhe : IsClosedEmbedding \u21d1e\nh3 : 0 < 3\nh23 : 0 < 2 / 3\nhf : 0 < \u2016f\u2016\nhf3 : -\u2016f\u2016 / 3 < \u2016f\u2016 / 3\nhc\u2081 : IsClosed (\u21d1e '' (\u21d1f \u207b\u00b9' Iic (-\u2016f\u2016 / 3)))\nhc\u2082 : IsClosed (\u21d1e '' (\u21d1f \u207b\u00b9' Ici (\u2016f\u2016 / 3)))\nhd : Disjoint (\u21d1e '' (\u21d1f \u207b\u00b9' Iic (-\u2016f\u2016 / 3))) (\u21d1e '' (\u21d1f \u207b\u00b9' Ici (\u2016f\u2016 / 3)))\ng : Y \u2192\u1d47 \u211d\nhg\u2081 : EqOn (\u21d1g) (Function.const Y (-\u2016f\u2016 / 3)) (\u21d1e '' (\u21d1f \u207b\u00b9' Iic (-\u2016f\u2016 / 3)))\nhg\u2082 : EqOn (\u21d1g) (Function.const Y (\u2016f\u2016 / 3)) (\u21d1e '' (\u21d1f \u207b\u00b9' Ici (\u2016f\u2016 / 3)))\nhgf : \u2200 (x : Y), g x \u2208 Icc (-\u2016f\u2016 / 3) (\u2016f\u2016 / 3)\nx : X\nhfx : -\u2016f\u2016 \u2264 f x \u2227 f x \u2264 \u2016f\u2016\nhle\u2081 : f x \u2264 -\u2016f\u2016 / 3\n\u22a2 -\u2016f\u2016 / 3 - f x \u2264 2 / 3 * \u2016f\u2016",["linarith"]],["Topology/TietzeExtension.lean",214,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : NormalSpace Y\nf : X \u2192\u1d47 \u211d\ne : C(X, Y)\nhe : IsClosedEmbedding \u21d1e\nh3 : 0 < 3\nh23 : 0 < 2 / 3\nhf : 0 < \u2016f\u2016\nhf3 : -\u2016f\u2016 / 3 < \u2016f\u2016 / 3\nhc\u2081 : IsClosed (\u21d1e '' (\u21d1f \u207b\u00b9' Iic (-\u2016f\u2016 / 3)))\nhc\u2082 : IsClosed (\u21d1e '' (\u21d1f \u207b\u00b9' Ici (\u2016f\u2016 / 3)))\nhd : Disjoint (\u21d1e '' (\u21d1f \u207b\u00b9' Iic (-\u2016f\u2016 / 3))) (\u21d1e '' (\u21d1f \u207b\u00b9' Ici (\u2016f\u2016 / 3)))\ng : Y \u2192\u1d47 \u211d\nhg\u2081 : EqOn (\u21d1g) (Function.const Y (-\u2016f\u2016 / 3)) (\u21d1e '' (\u21d1f \u207b\u00b9' Iic (-\u2016f\u2016 / 3)))\nhg\u2082 : EqOn (\u21d1g) (Function.const Y (\u2016f\u2016 / 3)) (\u21d1e '' (\u21d1f \u207b\u00b9' Ici (\u2016f\u2016 / 3)))\nhgf : \u2200 (x : Y), g x \u2208 Icc (-\u2016f\u2016 / 3) (\u2016f\u2016 / 3)\nx : X\nhfx : -\u2016f\u2016 \u2264 f x \u2227 f x \u2264 \u2016f\u2016\nhle\u2081 : -\u2016f\u2016 / 3 \u2264 f x\nhle\u2082 : \u2016f\u2016 / 3 \u2264 f x\n\u22a2 f x - \u2016f\u2016 / 3 \u2264 2 / 3 * \u2016f\u2016",["linarith"]],["Analysis/Calculus/UniformLimitsDeriv.lean",248,"case h\n\u03b9 : Type u_1\nl : Filter \u03b9\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\n\ud835\udd5c : Type u_3\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : IsRCLikeNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nf : \u03b9 \u2192 E \u2192 G\nf' : \u03b9 \u2192 E \u2192 E \u2192L[\ud835\udd5c] G\ns : Set E\nhs : IsOpen s\nh's : IsPreconnected s\nhf' : UniformCauchySeqOn f' l s\nhf : \u2200 (n : \u03b9), \u2200 y \u2208 s, HasFDerivAt (f n) (f' n y) y\nx\u2080 x\u271d : E\nhx\u2080 : x\u2080 \u2208 s\nhx : x\u271d \u2208 s\nhfg : Cauchy (map (fun n \u21a6 f n x\u2080) l)\nthis : l.NeBot\nt : Set E := {y | y \u2208 s \u2227 Cauchy (map (fun n \u21a6 f n y) l)}\nA : \u2200 (x : E) (\u03b5 : \u211d), x \u2208 t \u2192 Metric.ball x \u03b5 \u2286 s \u2192 Metric.ball x \u03b5 \u2286 t\nopen_t : IsOpen t\nst_nonempty : (s \u2229 t).Nonempty\nx : E\nxt : x \u2208 closure t\nxs : x \u2208 s\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nh\u03b5 : Metric.ball x \u03b5 \u2286 s\ny : E\nyt : y \u2208 t\nhxy : dist x y < \u03b5 / 2\n\u22a2 \u03b5 / 2 + dist x y \u2264 \u03b5",["linarith"]],["NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean",96,"S T : \u211d\nhT : 0 < T\nz \u03c4 : \u2102\nhz : |z.im| \u2264 S\nh\u03c4 : T \u2264 \u03c4.im\nn : \u2124\n\u22a2 0 \u2264 2 * \u03c0 * \u2191|n|",["positivity"]],["NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean",237,"z \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nn : \u2124\n\u22a2 0 \u2264 2 * \u03c0 * \u2191|n|",["positivity"]],["NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean",310,"z \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nhVmem : (z, \u03c4) \u2208 V\nhVp : IsPreconnected V\nf : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p \u21a6 jacobiTheta\u2082_term n p.1 p.2\nf' : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102 \u2192L[\u2102] \u2102 := fun n p \u21a6 jacobiTheta\u2082_term_fderiv n p.1 p.2\nhf : \u2200 (n : \u2124), \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p\nu : \u2124 \u2192 \u211d := fun n \u21a6 3 * \u03c0 * \u2191|n| ^ 2 * rexp (-\u03c0 * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))\nn : \u2124\np : \u2102 \u00d7 \u2102\nhp : p \u2208 V\n\u22a2 0 \u2264 3 * \u03c0 * \u2191|n| ^ 2",["positivity"]],["NumberTheory/Pell.lean",244,"d : \u2124\na b : Solution\u2081 d\nhax : 0 < a.x\nhay : 0 < a.y\nhbx : 0 < b.x\nhby : 0 < b.y\n\u22a2 0 < a.x * b.y + a.y * b.x",["positivity"]],["NumberTheory/Pell.lean",213,"case intro\nb : \u2124\na : Solution\u2081 (b * b)\nha : 1 < a.x\nhp : a.x + b * a.y = 1 \u2227 a.x - b * a.y = 1 \u2228 a.x + b * a.y = -1 \u2227 a.x - b * a.y = -1\n\u22a2 False",["omega"]],["NumberTheory/Pell.lean",502,"d : \u2124\na : Solution\u2081 d\nh : IsFundamental a\nH : \u2200 (n : \u2124), 0 \u2264 n \u2192 (a ^ n).y < (a ^ (n + 1)).y\nn : \u2124\nhn : n < 0\nm : \u2124 := -n - 1\nhm : n = -m - 1\n\u22a2 0 \u2264 m",["omega","linarith"]],["Probability/Moments/IntegrableExpMul.lean",163,"case refine_2.inl\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt v : \u211d\nht_int_pos : Integrable (fun \u03c9 \u21a6 rexp ((v + t) * X \u03c9)) \u03bc\nht_int_neg : Integrable (fun \u03c9 \u21a6 rexp ((v - t) * X \u03c9)) \u03bc\nh_int_add : Integrable (fun a \u21a6 rexp ((v + t) * X a) + rexp ((v - t) * X a)) \u03bc\n\u03c9 : \u03a9\nh_nonneg : 0 \u2264 X \u03c9\n\u22a2 0 \u2264 rexp ((v - t) * X \u03c9)",["positivity"]],["Probability/Moments/IntegrableExpMul.lean",166,"case refine_2.inr\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt v : \u211d\nht_int_pos : Integrable (fun \u03c9 \u21a6 rexp ((v + t) * X \u03c9)) \u03bc\nht_int_neg : Integrable (fun \u03c9 \u21a6 rexp ((v - t) * X \u03c9)) \u03bc\nh_int_add : Integrable (fun a \u21a6 rexp ((v + t) * X a) + rexp ((v - t) * X a)) \u03bc\n\u03c9 : \u03a9\nh_nonpos : X \u03c9 \u2264 0\n\u22a2 0 \u2264 rexp ((v + t) * X \u03c9)",["positivity"]],["Probability/Moments/IntegrableExpMul.lean",248,"case refine_2.e_a.inl\nx t p : \u211d\nhp : 0 \u2264 p\nht : t \u2260 0\nhx : 0 \u2264 x\n\u22a2 0 \u2264 |t| * x",["positivity","aesop"]],["Probability/Moments/IntegrableExpMul.lean",413,"l u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < (v - l) \u2293 (u - v)\n\u22a2 0 \u2264 ((v - l) \u2293 (u - v)) / 2",["positivity","linarith"]],["Probability/Moments/IntegrableExpMul.lean",429,"l u v : \u211d\nhv : v \u2208 Set.Ioo l u\nh_pos : 0 < (v - l) \u2293 (u - v)\n\u22a2 0 \u2264 ((v - l) \u2293 (u - v)) / 2",["positivity","linarith"]],["Analysis/NormedSpace/Multilinear/Curry.lean",62,"\ud835\udd5c : Type u\nn : \u2115\nEi : Fin n.succ \u2192 Type wEi\nG : Type wG\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : (i : Fin n.succ) \u2192 NormedAddCommGroup (Ei i)\ninst\u271d\u00b2 : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nf : Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i \u21a6 Ei i.succ) G\nm : (i : Fin n.succ) \u2192 Ei i\n\u22a2 0 \u2264 \u220f i : Fin n, \u2016tail m i\u2016",["positivity"]],["NumberTheory/LSeries/HurwitzZetaOdd.lean",480,"a : \u211d\ns : \u2102\nhs : 1 < s.re\nn : \u2124\n\u22a2 0 < s.re + 1",["positivity","linarith"]],["NumberTheory/LSeries/HurwitzZetaOdd.lean",513,"a : \u211d\ns : \u2102\nhs : 1 < s.re\nn : \u2124\n\u22a2 0 < s.re + 1",["positivity","linarith"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",150,"u v : \u2102\nhu : 0 < u.re\nhv : 0 < v.re\nF : \u211d \u2192 \u2102 := fun x \u21a6 \u2191x ^ u * (1 - \u2191x) ^ v\n\u22a2 0 < u.re + 1",["positivity","linarith"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",151,"u v : \u2102\nhu : 0 < u.re\nhv : 0 < v.re\nF : \u211d \u2192 \u2102 := fun x \u21a6 \u2191x ^ u * (1 - \u2191x) ^ v\nhu' : 0 < (u + 1).re\n\u22a2 0 < v.re + 1",["positivity","linarith"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",208,"case succ.refine_1\nn : \u2115\nIH : \u2200 {u : \u2102}, 0 < u.re \u2192 u.betaIntegral (\u2191n + 1) = \u2191n ! / \u220f j \u2208 Finset.range (n + 1), (u + \u2191j)\nu : \u2102\nhu : 0 < u.re\n\u22a2 0 < \u2191n.succ",["positivity"]],["Analysis/SpecialFunctions/Gamma/Beta.lean",212,"case succ.refine_2\nn : \u2115\nIH : \u2200 {u : \u2102}, 0 < u.re \u2192 u.betaIntegral (\u2191n + 1) = \u2191n ! / \u220f j \u2208 Finset.range (n + 1), (u + \u2191j)\nu : \u2102\nhu : 0 < u.re\nthis : u.betaIntegral (\u2191n.succ + 1) = \u2191n.succ * (u + 1).betaIntegral \u2191n.succ / u\n\u22a2 0 < u.re + 1",["positivity","linarith"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",132,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nd e f : \u2124\n\u03b3 : Cochain G K d\nhe : 0 + d = e\nhf : -1 + e = f\n\u22a2 e = d",["omega","aesop","linarith"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",139,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nd e f : \u2124\n\u03b3 : Cochain F K d\nhe : 1 + d = e\nhf : 0 + e = f\n\u22a2 e = f",["omega","aesop","linarith"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",145,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nd e : \u2124\n\u03b3 : Cochain G K d\nhe : 0 + d = e\n\u22a2 d = e",["omega","aesop","linarith"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",199,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\ni j : \u2124\nhij : i + 1 = j\nK : CochainComplex C \u2124\n\u03b3\u2081 \u03b3\u2082 : Cochain K (mappingCone \u03c6) i\nh\u2081 : \u03b3\u2081.comp (\u2191(fst \u03c6)) hij = \u03b3\u2082.comp (\u2191(fst \u03c6)) hij\nh\u2082 : \u03b3\u2081.comp (snd \u03c6) \u22ef = \u03b3\u2082.comp (snd \u03c6) \u22ef\np q : \u2124\nhpq : p + i = q\n\u22a2 p + j = q + 1",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",217,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\ni j : \u2124\nhij : i + 1 = j\nK : CochainComplex C \u2124\n\u03b3\u2081 \u03b3\u2082 : Cochain (mappingCone \u03c6) K j\nh\u2081 : (inl \u03c6).comp \u03b3\u2081 \u22ef = (inl \u03c6).comp \u03b3\u2082 \u22ef\nh\u2082 : (Cochain.ofHom (inr \u03c6)).comp \u03b3\u2081 \u22ef = (Cochain.ofHom (inr \u03c6)).comp \u03b3\u2082 \u22ef\np q : \u2124\nhpq : p + j = q\n\u22a2 p + 1 + i = q",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",218,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\ni j : \u2124\nhij : i + 1 = j\nK : CochainComplex C \u2124\n\u03b3\u2081 \u03b3\u2082 : Cochain (mappingCone \u03c6) K j\nh\u2082 : (Cochain.ofHom (inr \u03c6)).comp \u03b3\u2081 \u22ef = (Cochain.ofHom (inr \u03c6)).comp \u03b3\u2082 \u22ef\np q : \u2124\nhpq : p + j = q\nh\u2081 : ((inl \u03c6).comp \u03b3\u2081 \u22ef).v (p + 1) q \u22ef = ((inl \u03c6).comp \u03b3\u2082 \u22ef).v (p + 1) q \u22ef\n\u22a2 p + j = q",["omega"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",316,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : Cochain F K m\n\u03b2 : Cochain G K n\nh : m + 1 = n\np\u2081 p\u2082 p\u2083 : \u2124\nh\u2081\u2082 : p\u2081 + -1 = p\u2082\nh\u2082\u2083 : p\u2082 + n = p\u2083\n\u22a2 p\u2081 + m = p\u2083",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",431,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : Cochain K F m\n\u03b2 : Cochain K G n\nh : n + 1 = m\np\u2081 p\u2082 p\u2083 : \u2124\nh\u2081\u2082 : p\u2081 + n = p\u2082\nh\u2082\u2083 : p\u2082 + 1 = p\u2083\n\u22a2 p\u2081 + m = p\u2083",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",493,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK : CochainComplex C \u2124\n\u03b1 : Cocycle K F 1\n\u03b2 : Cochain K G 0\neq : \u03b4 0 1 \u03b2 + (\u2191\u03b1).comp (Cochain.ofHom \u03c6) \u22ef = 0\np q : \u2124\nhpq : p + 0 = q\n\u22a2 q = p",["omega","aesop","linarith"]],["Algebra/Homology/HomotopyCategory/MappingCone.lean",535,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nF G : CochainComplex C \u2124\n\u03c6 : F \u27f6 G\ninst\u271d : HasHomotopyCofiber \u03c6\nK L : CochainComplex C \u2124\nn m : \u2124\n\u03b1 : Cochain K F m\n\u03b2 : Cochain K G n\nn' m' : \u2124\n\u03b1' : Cochain F L m'\n\u03b2' : Cochain G L n'\nh : n + 1 = m\nh' : m' + 1 = n'\np : \u2124\nhp : n + n' = p\np\u2081 p\u2082 p\u2083 : \u2124\nh\u2081\u2082 : p\u2081 + n = p\u2082\nh\u2082\u2083 : p\u2082 + n' = p\u2083\nq : \u2124\nhq : p\u2081 + m = q\n\u22a2 p\u2081 + p = p\u2083",["omega","linarith"]],["NumberTheory/LSeries/ZMod.lean",436,"N : \u2115\ninst\u271d : NeZero N\n\u03a6 : ZMod N \u2192 \u2102\nh\u03a6 : Function.Odd \u03a6\ns : \u2102\nhs : 1 < s.re\nthis : \u2211 x : ZMod N, \u03a6 x * sinZeta (toAddCircle x) s = I * LFunction (\ud835\udcd5 \u03a6) s\n\u22a2 0 < s.re + 1",["linarith","positivity"]],["Data/Complex/Exponential.lean",629,"x : \u211d\nhx\u271d : x \u2260 0\nhx : x < 0\nh' : -x < 1\n\u22a2 0 < x + 1",["linarith"]],["Data/Complex/Exponential.lean",236,"x : \u211d\nhx : 0 \u2264 x\nn j : \u2115\nhj : j \u2265 n\nx\u271d\u00b2 : \u2115\nx\u271d\u00b9 : x\u271d\u00b2 \u2208 range j\nx\u271d : x\u271d\u00b2 \u2209 range n\n\u22a2 0 \u2264 x ^ x\u271d\u00b2 / \u2191x\u271d\u00b2!",["positivity"]],["Data/Complex/Exponential.lean",352,"\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\nn j : \u2115\nhn : 0 < n\nh\u2081 : \u2191n.succ \u2260 1\n\u22a2 \u2191n.succ \u2260 0",["positivity"]],["Data/Complex/Exponential.lean",353,"\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\nn j : \u2115\nhn : 0 < n\nh\u2081 : \u2191n.succ \u2260 1\nh\u2082 : \u2191n.succ \u2260 0\n\u22a2 \u2191n.factorial * \u2191n \u2260 0",["positivity"]],["Data/Complex/Exponential.lean",358,"case hab.a\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\nn j : \u2115\nhn : 0 < n\n\u22a2 0 \u2264 \u2191n.succ * (\u2191n.succ)\u207b\u00b9 ^ (j - n)",["positivity"]],["Data/Complex/Exponential.lean",421,"x : \u2102\nn : \u2115\nhx : \u2016x\u2016 / \u2191n.succ \u2264 1 / 2\nj : \u2115\nhj\u271d : j \u2265 n\nk : \u2115 := j - n\nhj : j = n + k\n\u22a2 0 \u2264 \u2016x\u2016 ^ k / (\u2191n + 1) ^ k",["positivity"]],["Data/Complex/Exponential.lean",604,"x : \u211d\nh1 : 0 < x\nh2 : x < 1\n\u22a2 0 < x ^ 3",["positivity","aesop"]],["Data/Complex/Exponential.lean",653,"case h\nn : \u2115\nt : \u211d\nht' : t \u2264 \u2191n\nhn : n \u2260 0\n\u22a2 \u2191n \u2260 0",["positivity","aesop"]],["MeasureTheory/Integral/PeakFunction.lean",126,"\u03b1 : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\nhm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : BorelSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u03b1 \u2192 E\nl : Filter \u03b9\nx\u2080 : \u03b1\ns t : Set \u03b1\n\u03c6 : \u03b9 \u2192 \u03b1 \u2192 \u211d\nhs : MeasurableSet s\nht : MeasurableSet t\nhts : t \u2286 s\nh'ts : t \u2208 \ud835\udcdd[s] x\u2080\nhn\u03c6 : \u2200\u1da0 (i : \u03b9) in l, \u2200 x \u2208 s, 0 \u2264 \u03c6 i x\nhl\u03c6 : \u2200 (u : Set \u03b1), IsOpen u \u2192 x\u2080 \u2208 u \u2192 TendstoUniformlyOn \u03c6 0 l (s \\ u)\nhi\u03c6 : Tendsto (fun i \u21a6 \u222b (x : \u03b1) in t, \u03c6 i x \u2202\u03bc) l (\ud835\udcdd 1)\nh'i\u03c6 : \u2200\u1da0 (i : \u03b9) in l, AEStronglyMeasurable (\u03c6 i) (\u03bc.restrict s)\nhmg : IntegrableOn g s \u03bc\nhcg : Tendsto g (\ud835\udcdd[s] x\u2080) (\ud835\udcdd 0)\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u03b4 : \u211d\nh\u03b4 : \u03b4 * \u222b (x : \u03b1) in s, \u2016g x\u2016 \u2202\u03bc + 2 * \u03b4 < \u03b5\n\u03b4pos : 0 < \u03b4\n\u03b4one : \u03b4 < 1\nu : Set \u03b1\nu_open : IsOpen u\nx\u2080u : x\u2080 \u2208 u\nut : s \u2229 u \u2286 t\nhu : \u2200 x \u2208 u \u2229 s, g x \u2208 ball 0 \u03b4\ni : \u03b9\nhi : \u2200 x \u2208 s \\ u, dist (0 x) (\u03c6 i x) < \u03b4\nh\u03c6pos : \u2200 x \u2208 s, 0 \u2264 \u03c6 i x\nh''i : IntegrableOn (fun x \u21a6 \u03c6 i x \u2022 g x) s \u03bc\nh : \u222b (a : \u03b1) in t, \u03c6 i a \u2202\u03bc = 0\nh'i : 1 < \u03b4\n\u22a2 False",["linarith"]],["Geometry/Manifold/Instances/Sphere.lean",219,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nv : E\nhv : \u2016v\u2016 = 1\nx : \u2191(sphere 0 1)\nhx : \u2191x \u2260 v\na : \u211d := ((innerSL \u211d) v) \u2191x\ny : \u21a5(Submodule.span \u211d {v})\u15ee := (orthogonalProjection (Submodule.span \u211d {v})\u15ee) \u2191x\nsplit : \u2191x = a \u2022 v + \u2191y\nhvy : \u27eav, \u2191y\u27eb_\u211d = 0\npythag : 1 = a ^ 2 + \u2016y\u2016 ^ 2\nthis : a < 1\n\u22a2 0 < 1 - a",["linarith"]],["Geometry/Manifold/Instances/Sphere.lean",124,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nv : E\nhv : \u2016v\u2016 = 1\nw : E\nhw : w \u2208 (Submodule.span \u211d {v})\u15ee\n\u22a2 0 < \u2016w\u2016 ^ 2 + 4",["positivity"]],["Geometry/Manifold/Instances/Sphere.lean",188,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nv : E\nhv : \u2016v\u2016 = 1\nw : \u21a5(Submodule.span \u211d {v})\u15ee\nhw : \u27eav, \u2191w\u27eb_\u211d = 0\n\u22a2 0 < \u2016\u2191w\u2016 ^ 2 + 4",["positivity"]],["Analysis/CStarAlgebra/CStarMatrix.lean",461,"case inl\nm : Type u_1\nn : Type u_2\nA : Type u_3\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : NonUnitalCStarAlgebra A\ninst\u271d\u00b2 : PartialOrder A\ninst\u271d\u00b9 : StarOrderedRing A\ninst\u271d : Fintype m\nM : CStarMatrix m n A\nC : \u211d\u22650\nh : \u2200 (v : C\u22c6\u1d50\u1d52\u1d48 (n \u2192 A)) (w : C\u22c6\u1d50\u1d52\u1d48 (m \u2192 A)), \u2016\u27eaw, (toCLM M) v\u27eb_A\u2016 \u2264 \u2191C * \u2016v\u2016 * \u2016w\u2016\nv : C\u22c6\u1d50\u1d52\u1d48 (n \u2192 A)\nh\u2080 : 0 = \u2016(toCLM M) v\u2016\n\u22a2 0 \u2264 \u2191C * \u2016v\u2016",["positivity"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",405,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhUV : U \u2260 V\nhunif : \u00acG.IsUniform \u03b5 U V\nhm\u271d : 0 \u2264 1 - (\u2191m)\u207b\u00b9\nh\u03b5 : 0 \u2264 1 - \u03b5 / 10\nh\u03b5\u2080 : 0 < \u03b5\nhm : 0 < \u2191m\n\u22a2 (\u2191m + 1) * (\u2191m - 1) \u2264 \u2191m * \u2191m",["linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",451,"case inl.h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhUVne : U \u2260 V\nhUV : \u00acG.IsUniform \u03b5 U V\np : \u211d :=\n  (\u2211 ab \u2208 (star hP G \u03b5 hU V).product (star hP G \u03b5 hV U), \u2191(G.edgeDensity ab.1 ab.2)) /\n    (\u2191(#(star hP G \u03b5 hU V)) * \u2191(#(star hP G \u03b5 hV U)))\nq : \u211d :=\n  (\u2211 ab \u2208 (chunk hP G \u03b5 hU).parts.product (chunk hP G \u03b5 hV).parts, \u2191(G.edgeDensity ab.1 ab.2)) /\n    (4 ^ #P.parts * 4 ^ #P.parts)\nr : \u211d := \u2191(G.edgeDensity ((star hP G \u03b5 hU V).biUnion id) ((star hP G \u03b5 hV U).biUnion id))\ns : \u211d := \u2191(G.edgeDensity (G.nonuniformWitness \u03b5 U V) (G.nonuniformWitness \u03b5 V U))\nt : \u211d := \u2191(G.edgeDensity U V)\nhrs : r - s \u2264 \u03b5 / 5 \u2227 s - r \u2264 \u03b5 / 5\nhpr : p - r \u2264 \u03b5 ^ 5 / 49 \u2227 r - p \u2264 \u03b5 ^ 5 / 49\nhqt : q - t \u2264 \u03b5 ^ 5 / 49 \u2227 t - q \u2264 \u03b5 ^ 5 / 49\nh\u03b5' : \u03b5 ^ 5 \u2264 \u03b5\nh\u271d : \u03b5 \u2264 s - t\n\u22a2 3 / 4 * \u03b5 \u2264 p - q",["linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",452,"case inr.h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhUVne : U \u2260 V\nhUV : \u00acG.IsUniform \u03b5 U V\np : \u211d :=\n  (\u2211 ab \u2208 (star hP G \u03b5 hU V).product (star hP G \u03b5 hV U), \u2191(G.edgeDensity ab.1 ab.2)) /\n    (\u2191(#(star hP G \u03b5 hU V)) * \u2191(#(star hP G \u03b5 hV U)))\nq : \u211d :=\n  (\u2211 ab \u2208 (chunk hP G \u03b5 hU).parts.product (chunk hP G \u03b5 hV).parts, \u2191(G.edgeDensity ab.1 ab.2)) /\n    (4 ^ #P.parts * 4 ^ #P.parts)\nr : \u211d := \u2191(G.edgeDensity ((star hP G \u03b5 hU V).biUnion id) ((star hP G \u03b5 hV U).biUnion id))\ns : \u211d := \u2191(G.edgeDensity (G.nonuniformWitness \u03b5 U V) (G.nonuniformWitness \u03b5 V U))\nt : \u211d := \u2191(G.edgeDensity U V)\nhrs : r - s \u2264 \u03b5 / 5 \u2227 s - r \u2264 \u03b5 / 5\nhpr : p - r \u2264 \u03b5 ^ 5 / 49 \u2227 r - p \u2264 \u03b5 ^ 5 / 49\nhqt : q - t \u2264 \u03b5 ^ 5 / 49 \u2227 t - q \u2264 \u03b5 ^ 5 / 49\nh\u03b5' : \u03b5 ^ 5 \u2264 \u03b5\nh\u271d : \u03b5 \u2264 -(s - t)\n\u22a2 3 / 4 * \u03b5 \u2264 -(p - q)",["linarith"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",207,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nU : Finset \u03b1\nhU : U \u2208 P.parts\n\ud835\udc9c : Finset (Finset \u03b1)\ns : Finset \u03b1\nm_pos : 0 < \u2191m\nh\ud835\udc9c : \ud835\udc9c \u2286 (chunk hP G \u03b5 hU).parts\nhs : s \u2208 \ud835\udc9c\n\u22a2 0 \u2264 \u2191(#\ud835\udc9c) * (\u2191m + 1)",["positivity"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",269,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nA B : Finset (Finset \u03b1)\nhA : A \u2286 (chunk hP G \u03b5 hU).parts\nhB : B \u2286 (chunk hP G \u03b5 hV).parts\nthis :\n  \u2191(G.edgeDensity (A.biUnion id) (B.biUnion id)) - \u03b5 ^ 5 / 50 \u2264\n    (1 - \u03b5 ^ 5 / 50) * \u2191(G.edgeDensity (A.biUnion id) (B.biUnion id))\nx y : Finset \u03b1\nhx : x \u2208 A\nhy : y \u2208 B\n\u22a2 0 \u2264 \u2191(#(A.sup id)) * \u2191(#(B.sup id))",["positivity"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",309,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nA B : Finset (Finset \u03b1)\nhA : A \u2286 (chunk hP G \u03b5 hU).parts\nhB : B \u2286 (chunk hP G \u03b5 hV).parts\nthis :\n  (1 + \u03b5 ^ 5 / 49) * \u2191(G.edgeDensity (A.biUnion id) (B.biUnion id)) \u2264\n    \u2191(G.edgeDensity (A.biUnion id) (B.biUnion id)) + \u03b5 ^ 5 / 49\nx y : Finset \u03b1\nhx : x \u2208 A\nhy : y \u2208 B\n\u22a2 0 \u2264 \u2191(#A) * \u2191(#x) * ((\u2191m + 1) / \u2191m)",["positivity"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",483,"case bc.refine_2.refine_2\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nhP : P.IsEquipartition\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\nU V : Finset \u03b1\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nhU : U \u2208 P.parts\nhV : V \u2208 P.parts\nhUVne : U \u2260 V\nhUV : \u00acG.IsUniform \u03b5 U V\nUl : 4 / 5 * \u03b5 \u2264 \u2191(#(star hP G \u03b5 hU V)) / 4 ^ #P.parts\nVl : 4 / 5 * \u03b5 \u2264 \u2191(#(star hP G \u03b5 hV U)) / 4 ^ #P.parts\nthis : 0 < \u03b5\nUVl : 4 / 5 * \u03b5 * (4 / 5 * \u03b5) \u2264 \u2191(#(star hP G \u03b5 hU V)) / 4 ^ #P.parts * (\u2191(#(star hP G \u03b5 hV U)) / 4 ^ #P.parts)\n\u22a2 0 \u2264 \u03b5 ^ 2",["positivity"]],["Analysis/InnerProductSpace/TwoDim.lean",414,"E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\nx y : E\nhx : \u00acx = 0\na : \u211d := ((o.basisRightAngleRotation x hx).repr y) 0\nb : \u211d := ((o.basisRightAngleRotation x hx).repr y) 1\nha : 0 \u2264 a * \u2016x\u2016 ^ 2\nhb : b * \u2016x\u2016 ^ 2 = 0\nhx' : 0 < \u2016x\u2016\n\u22a2 0 < \u2016x\u2016 ^ 2",["positivity","aesop"]],["Analysis/InnerProductSpace/TwoDim.lean",421,"case neg.mpr.intro.intro\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\nx : E\nhx : \u00acx = 0\nr : \u211d\nhr : 0 \u2264 r\nh : SameRay \u211d x (r \u2022 x)\n\u22a2 0 \u2264 r * \u2016x\u2016 ^ 2",["positivity","aesop"]],["Analysis/InnerProductSpace/TwoDim.lean",208,"E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\nx : E\nK : Submodule \u211d E := Submodule.span \u211d {x}\nthis\u271d\u00b2 : finrank \u211d \u21a5K \u2264 {x}.card\nthis\u271d\u00b9 : {x}.card = 1\nthis\u271d : finrank \u211d \u21a5K + finrank \u211d \u21a5K\u15ee = finrank \u211d E\nthis : finrank \u211d E = 2\n\u22a2 0 < finrank \u211d \u21a5K\u15ee",["omega","linarith"]],["MeasureTheory/Constructions/BorelSpace/Real.lean",574,"\u03bc : Measure \u211d\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nb r s : \u211d\n_rpos : 0 < r\nhrs : r \u2264 s\n\u22a2 b + r \u2264 b + s",["linarith","aesop","gcongr"]],["Analysis/Calculus/LineDeriv/Basic.lean",397,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nv : E\nf : E \u2192 F\nf' : F\nx\u2080 : E\nhf : HasLineDerivAt \ud835\udd5c f f' x\u2080 v\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u22a2 0 \u2264 C * \u2016v\u2016",["positivity"]],["Analysis/Calculus/LineDeriv/Basic.lean",432,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nv : E\nf : E \u2192 F\nx\u2080 : E\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u22a2 0 \u2264 C * \u2016v\u2016",["positivity"]],["NumberTheory/Divisors.lean",115,"case mk.mp.intro.intro.intro\nn a : \u2115\nhan : a \u2223 n\nha : a \u2260 0\nhan' : a \u2264 n\n\u22a2 \u00acn = 0",["omega","aesop"]],["Algebra/Polynomial/Derivative.lean",394,"case succ.e_a.refine_1.e_a.e_a.e_a\nR : Type u\ninst\u271d : Semiring R\np q : R[X]\nn : \u2115\nIH : (\u21d1derivative)^[n] (p * q) = \u2211 k \u2208 range n.succ, n.choose k \u2022 ((\u21d1derivative)^[n - k] p * (\u21d1derivative)^[k] q)\nk : \u2115\nhk : k < n\n\u22a2 n - (k + 1) + 1 = n - k",["omega"]],["Analysis/Convex/Gauge.lean",189,"E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nhs : Convex \u211d s\nabsorbs : Absorbent \u211d s\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\na : \u211d\nha : 0 < a\nx : E\nhx : x \u2208 s\nha' : a < gauge s ((fun x \u21a6 a \u2022 x) x) + \u03b5 / 2\nb : \u211d\nhb : 0 < b\ny : E\nhy : y \u2208 s\nhb' : b < gauge s ((fun x \u21a6 b \u2022 x) y) + \u03b5 / 2\n\u22a2 a + b < gauge s (a \u2022 x) + gauge s (b \u2022 y) + \u03b5",["linarith"]],["Analysis/Convex/Gauge.lean",508,"E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\np : Seminorm \u211d E\nx : E\nhp : {r | 0 < r \u2227 x \u2208 r \u2022 p.ball 0 1}.Nonempty\nr : \u211d\nhr : r \u2208 lowerBounds {r | 0 < r \u2227 x \u2208 r \u2022 p.ball 0 1}\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 0 < p x + \u03b5",["positivity"]],["NumberTheory/PythagoreanTriples.lean",467,"x y z : \u2124\nh : PythagoreanTriple x y z\nhc : x.gcd y = 1\nhyo : y % 2 = 1\nhzpos : 0 < z\nh0 : \u00acx = 0\nv : \u211a := \u2191x / \u2191z\nw : \u211a := \u2191y / \u2191z\nhq : v ^ 2 + w ^ 2 = 1\nhvz : v \u2260 0\nhw1 : w \u2260 -1\nhQ : \u2200 (x : \u211a), 1 + x ^ 2 \u2260 0\nhp : (v, w) \u2208 {p | p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1}\nq : \u211a := (circleEquivGen hQ).symm \u27e8(v, w), hp\u27e9\nht4 : v = 2 * q / (1 + q ^ 2) \u2227 w = (1 - q ^ 2) / (1 + q ^ 2)\nm : \u2124 := \u2191q.den\nn : \u2124 := q.num\nhm0 : m \u2260 0\nhq2 : q = \u2191n / \u2191m\n\u22a2 0 < m ^ 2 + n ^ 2",["positivity"]],["NumberTheory/PythagoreanTriples.lean",468,"x y z : \u2124\nh : PythagoreanTriple x y z\nhc : x.gcd y = 1\nhyo : y % 2 = 1\nhzpos : 0 < z\nh0 : \u00acx = 0\nv : \u211a := \u2191x / \u2191z\nw : \u211a := \u2191y / \u2191z\nhq : v ^ 2 + w ^ 2 = 1\nhvz : v \u2260 0\nhw1 : w \u2260 -1\nhQ : \u2200 (x : \u211a), 1 + x ^ 2 \u2260 0\nhp : (v, w) \u2208 {p | p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1}\nq : \u211a := (circleEquivGen hQ).symm \u27e8(v, w), hp\u27e9\nht4 : v = 2 * q / (1 + q ^ 2) \u2227 w = (1 - q ^ 2) / (1 + q ^ 2)\nm : \u2124 := \u2191q.den\nn : \u2124 := q.num\nhm0 : m \u2260 0\nhq2 : q = \u2191n / \u2191m\nhm2n2 : 0 < m ^ 2 + n ^ 2\n\u22a2 \u2191m ^ 2 + \u2191n ^ 2 \u2260 0",["positivity"]],["NumberTheory/PythagoreanTriples.lean",194,"case h\nx y z : \u2124\nh : PythagoreanTriple x y z\nm n : \u2124\nH :\n  (x = m ^ 2 - n ^ 2 \u2227 y = 2 * m * n \u2228 x = 2 * m * n \u2227 y = m ^ 2 - n ^ 2) \u2227\n    m.gcd n = 1 \u2227 (m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0)\n\u22a2 (x = 1 * (m ^ 2 - n ^ 2) \u2227 y = 1 * (2 * m * n) \u2228 x = 1 * (2 * m * n) \u2227 y = 1 * (m ^ 2 - n ^ 2)) \u2227 m.gcd n = 1",["omega","aesop"]],["NumberTheory/PythagoreanTriples.lean",626,"case h.inl.right.inl.right\nx y z : \u2124\nh : PythagoreanTriple x y z\nh_coprime : x.gcd y = 1\nh_parity : x % 2 = 1\nh_pos\u271d : 0 < z\nm n : \u2124\nht3 : m.gcd n = 1\nht4 : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0\nhm : m < 0\nh_odd : x = m ^ 2 - n ^ 2 \u2227 y = 2 * m * n\nh_pos : z = m ^ 2 + n ^ 2\n\u22a2 0 \u2264 -m",["omega"]],["NumberTheory/LSeries/PrimesInAP.lean",202,"hp\u2080 : \u2200 (p : Nat.Primes), 0 < (\u2191\u2191p)\u207b\u00b9\nhp\u2081 : \u2200 (p : Nat.Primes), (\u2191\u2191p)\u207b\u00b9 < 1\nthis\u271d : Summable fun pk \u21a6 (\u2191\u2191pk.1)\u207b\u00b9 ^ (\u2191pk.2 + 3 / 2)\npk : Nat.Primes \u00d7 \u2115\nthis : 0 \u2264 \u039b (\u2191pk.1 ^ (pk.2 + 2))\n\u22a2 0 \u2264 (if Nat.Prime (\u2191pk.1 ^ (pk.2 + 1 + 1)) then 0 else \u039b (\u2191pk.1 ^ (pk.2 + 1 + 1))) / \u2191\u2191pk.1 ^ (pk.2 + 1 + 1)",["positivity"]],["NumberTheory/LSeries/PrimesInAP.lean",212,"case refine_2.refine_1\nhp\u2080 : \u2200 (p : Nat.Primes), 0 < (\u2191\u2191p)\u207b\u00b9\nhp\u2081 : \u2200 (p : Nat.Primes), (\u2191\u2191p)\u207b\u00b9 < 1\np : Nat.Primes\nthis : 0 < 1 - (\u2191\u2191p)\u207b\u00b9\n\u22a2 0 \u2264 (1 - (\u2191\u2191p)\u207b\u00b9)\u207b\u00b9 * (\u2191\u2191p)\u207b\u00b9 ^ (3 / 2)",["positivity"]],["NumberTheory/LSeries/PrimesInAP.lean",226,"q : \u2115\na : ZMod q\nn : \u2115\nthis : 0 \u2264 residueClass a n\n\u22a2 0 \u2264 (if Nat.Prime n then 0 else residueClass a n) / \u2191n",["positivity"]],["MeasureTheory/Integral/MeanInequalities.lean",180,"\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 \u211d\u22650\u221e\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\np q : \u211d\nhp\u271d : 0 \u2264 p\nhq\u271d : 0 \u2264 q\nhpq : p + q = 1\nhp : 0 < p\nhq : 0 < q\n\u22a2 p < 1",["linarith"]],["MeasureTheory/Covering/Vitali.lean",188,"case intro.intro.intro.h\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nt : Set \u03b9\nx : \u03b9 \u2192 \u03b1\nr : \u03b9 \u2192 \u211d\nR : \u211d\nhr : \u2200 a \u2208 t, r a \u2264 R\n\u03c4 : \u211d\nh\u03c4 : 3 < \u03c4\nh\u271d : t.Nonempty\nht : \u2203 a \u2208 t, 0 \u2264 r a\nt' : Set \u03b9 := {a | a \u2208 t \u2227 0 \u2264 r a}\nu : Set \u03b9\nut' : u \u2286 t'\nu_disj : u.PairwiseDisjoint fun a \u21a6 closedBall (x a) (r a)\nhu : \u2200 a \u2208 t', \u2203 b \u2208 u, (closedBall (x a) (r a) \u2229 closedBall (x b) (r b)).Nonempty \u2227 r a \u2264 (\u03c4 - 1) / 2 * r b\na : \u03b9\nha : a \u2208 t'\nb : \u03b9\nbu : b \u2208 u\nhb : (closedBall (x a) (r a) \u2229 closedBall (x b) (r b)).Nonempty\nrb : r a \u2264 (\u03c4 - 1) / 2 * r b\nthis : dist (x a) (x b) \u2264 r a + r b\n\u22a2 r a + dist (x a) (x b) \u2264 \u03c4 * r b",["linarith"]],["Data/Nat/Squarefree.lean",79,"case pos\nn m : \u2115\nhn : Squarefree n\nhm : Squarefree m\nh : \u2200 (p : \u2115), Prime p \u2192 (p \u2223 n \u2194 p \u2223 m)\np : \u2115\nhp : Prime p\nh\u2081 : n.factorization p = 0 \u2194 m.factorization p = 0\nh\u2082 : n.factorization p \u2264 1\nh\u2083 : m.factorization p \u2264 1\n\u22a2 n.factorization p = m.factorization p",["omega"]],["Data/Nat/Squarefree.lean",154,"n k : \u2115\nn0 : 0 < n\ni : \u2115\ne : k = 2 * i + 3\nih : \u2200 (m : \u2115), Prime m \u2192 m \u2223 n \u2192 k \u2264 m\nh : \u00acn < k * k\n\u22a2 2 \u2264 k",["omega","aesop","linarith"]],["Data/Nat/Squarefree.lean",173,"n k : \u2115\nn0 : 0 < n\ni : \u2115\ne : k = 2 * i + 3\nih : \u2200 (m : \u2115), Prime m \u2192 m \u2223 n \u2192 k \u2264 m\nh : \u00acn < k * k\nk2 : 2 \u2264 k\nk0 : 0 < k\nn' : \u2115\nnd' : n' \u2223 n\nnk : \u00ack \u2223 n'\nhn' : n' \u2264 n\nthis\u271d : n'.sqrt - k < n.sqrt + 2 - k\nm : \u2115\nm2 : Prime m\nml : k < m\nme : k.succ = m\nd : 2 * (i + 2) \u2223 n'\nthis : 2 * i + 3 \u2264 2\n\u22a2 \u00ac2 * i + 3 \u2264 2",["omega"]],["Topology/Homotopy/Basic.lean",239,"X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf\u2080 f\u2081 f\u2082 : C(X, Y)\nF : f\u2080.Homotopy f\u2081\nG : f\u2081.Homotopy f\u2082\nt : \u2191I\nsnd\u271d : X\nh\u2081 : 1 - \u2191t \u2264 1 / 2\nh\u2082 : \u2191t \u2264 1 / 2\n\u22a2 \u2191t = 1 / 2",["linarith"]],["Topology/Homotopy/Basic.lean",250,"case neg\nX : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf\u2080 f\u2081 f\u2082 : C(X, Y)\nF : f\u2080.Homotopy f\u2081\nG : f\u2081.Homotopy f\u2082\nt : \u2191I\nsnd\u271d : X\nh\u2081 : \u00ac1 - \u2191t \u2264 1 / 2\nh\u2082 : \u00ac\u2191t \u2264 1 / 2\n\u22a2 False",["linarith"]],["Topology/Instances/EReal/Lemmas.lean",485,"a : \u211d\nh : 0 < a\nx : \u211d\np : EReal \u00d7 EReal\np1_gt : \u2191(2 * ((x + 1) \u2294 0) / a) < p.1\np2_gt : \u2191(a / 2) < p.2\np1_pos : 0 < p.1\n\u22a2 0 < a / 2",["linarith","aesop","positivity"]],["Algebra/Polynomial/AlgebraMap.lean",660,"R : Type u\ninst\u271d : CommSemiring R\nP : R[X]\nh : \u2200 (r : R), r \u2022 P = 0 \u2192 r = 0\nQ : R[X]\nhQ : P * Q = 0\nl : \u2115\nIH : \u2200 m > l, P.coeff m \u2022 Q = 0\nhl : (P.coeff l \u2022 Q).natDegree = Q.natDegree\nm : \u2115 := Q.natDegree\ni j : \u2115\nhij : i + j = l + m\nH : i = l \u2192 \u00acj = m\nhi : i < l\n\u22a2 m < j",["omega"]],["MeasureTheory/Measure/Lebesgue/VolumeOfBalls.lean",170,"\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\np : \u211d\nhp : 1 \u2264 p\n\u22a2 0 < p",["linarith","positivity"]],["MeasureTheory/Measure/Lebesgue/VolumeOfBalls.lean",222,"\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : Nonempty \u03b9\np : \u211d\nhp : 1 \u2264 p\nr : \u211d\n\u22a2 0 < p",["linarith","positivity"]],["MeasureTheory/Measure/Lebesgue/VolumeOfBalls.lean",242,"\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\np : \u211d\nhp : 1 \u2264 p\n\u22a2 0 < p",["linarith","positivity"]],["MeasureTheory/Measure/Lebesgue/VolumeOfBalls.lean",297,"\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : Nonempty \u03b9\np : \u211d\nhp : 1 \u2264 p\nr : \u211d\n\u22a2 0 < p",["linarith","positivity"]],["MeasureTheory/Measure/Lebesgue/VolumeOfBalls.lean",202,"\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : Nonempty \u03b9\np : \u211d\nhp : 1 \u2264 p\nr : \u211d\nx : \u03b9 \u2192 \u211d\n\u22a2 0 \u2264 \u2211 i : \u03b9, |x i| ^ p",["positivity"]],["MeasureTheory/Measure/Lebesgue/VolumeOfBalls.lean",275,"\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : Nonempty \u03b9\np : \u211d\nhp : 1 \u2264 p\nr : \u211d\nx : \u03b9 \u2192 \u2102\n\u22a2 0 \u2264 \u2211 i : \u03b9, \u2016x i\u2016 ^ p",["positivity"]],["Topology/UrysohnsLemma.lean",297,"X : Type u_1\ninst\u271d : TopologicalSpace X\nP : Set X \u2192 Prop\nh0 : 0 < 2\u207b\u00b9\nh1234 : 2\u207b\u00b9 < 3 / 4\nh1 : 3 / 4 < 1\nx : X\nx\u271d : True\nn : \u2115\nc : CU P\ny : X\nhxl : x \u2209 c.left.left.U\nhyl : y \u2209 c.left.left.U\nr : \u211d := (3 / 4) ^ n\nihn : \u2200 (c : CU P), \u2200\u1da0 (x_1 : X) in \ud835\udcdd x, dist (c.lim x_1) (c.lim x) \u2264 r\nhydl : dist (c.left.right.lim y) (c.left.right.lim x) \u2264 r\nhydr : dist (c.right.lim y) (c.right.lim x) \u2264 r\n\u22a2 (dist (c.left.right.lim y) (c.left.right.lim x) / 2 + dist (c.right.lim y) (c.right.lim x)) / 2 \u2264 (r / 2 + r) / 2",["gcongr","linarith"]],["Analysis/MellinTransform.lean",233,"b : \u211d\nf : \u211d \u2192 \u211d\nhfc : AEStronglyMeasurable f (volume.restrict (Ioi 0))\nhf : f =O[\ud835\udcdd[>] 0] fun x \u21a6 x ^ (-b)\ns : \u211d\nhs : b < s\nd : \u211d\nleft\u271d : d > 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b5' : \u2200 \u2983y : \u211d\u2984, dist y 0 < \u03b5 \u2192 y \u2208 Ioi 0 \u2192 \u2016f y\u2016 \u2264 d * \u2016y ^ (-b)\u2016\n\u22a2 -1 < s - b - 1",["linarith","aesop"]],["Analysis/Normed/Operator/Banach.lean",125,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomIsometric \u03c3\ninst\u271d\u00b9 : RingHomIsometric \u03c3'\ninst\u271d : CompleteSpace F\nsurj : Surjective \u21d1f\nA : \u22c3 n, closure (\u21d1f '' ball 0 \u2191n) = Set.univ\nn : \u2115\na : F\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nH : ball a \u03b5 \u2286 closure (\u21d1f '' ball 0 \u2191n)\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\ny : F\nhy : y \u2260 0\nhc' : 1 < \u2016\u03c3 c\u2016\nd : \ud835\udd5c'\nhd : d \u2260 0\nydlt : \u2016d \u2022 y\u2016 < \u03b5 / 2\ndinv : \u2016d\u2016\u207b\u00b9 \u2264 (\u03b5 / 2)\u207b\u00b9 * \u2016\u03c3 c\u2016 * \u2016y\u2016\n\u03b4 : \u211d := \u2016d\u2016 * \u2016y\u2016 / 4\n\u03b4pos : 0 < \u03b4\nthis\u271d : a + d \u2022 y \u2208 ball a \u03b5\nz\u2081 : F\nz\u2081im : z\u2081 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2081 : E\nh\u2081 : \u2016f x\u2081 - (a + d \u2022 y)\u2016 < \u03b4\nhx\u2081 : \u2016x\u2081\u2016 < \u2191n\nxz\u2081 : f x\u2081 = z\u2081\nthis : a \u2208 ball a \u03b5\nz\u2082 : F\nz\u2082im : z\u2082 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2082 : E\nh\u2082 : \u2016f x\u2082 - a\u2016 < \u03b4\nhx\u2082 : \u2016x\u2082\u2016 < \u2191n\nxz\u2082 : f x\u2082 = z\u2082\nx : E := x\u2081 - x\u2082\n\u22a2 \u2016f x\u2081 - (a + d \u2022 y)\u2016 + \u2016f x\u2082 - a\u2016 \u2264 \u03b4 + \u03b4",["gcongr","linarith"]],["Analysis/Normed/Operator/Banach.lean",149,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomIsometric \u03c3\ninst\u271d\u00b9 : RingHomIsometric \u03c3'\ninst\u271d : CompleteSpace F\nsurj : Surjective \u21d1f\nA : \u22c3 n, closure (\u21d1f '' ball 0 \u2191n) = Set.univ\nn : \u2115\na : F\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nH : ball a \u03b5 \u2286 closure (\u21d1f '' ball 0 \u2191n)\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\ny : F\nhy : y \u2260 0\nhc' : 1 < \u2016\u03c3 c\u2016\nd : \ud835\udd5c'\nhd : d \u2260 0\nydlt : \u2016d \u2022 y\u2016 < \u03b5 / 2\ndinv : \u2016d\u2016\u207b\u00b9 \u2264 (\u03b5 / 2)\u207b\u00b9 * \u2016\u03c3 c\u2016 * \u2016y\u2016\n\u03b4 : \u211d := \u2016d\u2016 * \u2016y\u2016 / 4\n\u03b4pos : 0 < \u03b4\nthis\u271d : a + d \u2022 y \u2208 ball a \u03b5\nz\u2081 : F\nz\u2081im : z\u2081 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2081 : E\nh\u2081 : dist (a + d \u2022 y) (f x\u2081) < \u03b4\nhx\u2081 : \u2016x\u2081\u2016 < \u2191n\nxz\u2081 : f x\u2081 = z\u2081\nthis : a \u2208 ball a \u03b5\nz\u2082 : F\nz\u2082im : z\u2082 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2082 : E\nh\u2082 : dist a (f x\u2082) < \u03b4\nhx\u2082 : \u2016x\u2082\u2016 < \u2191n\nxz\u2082 : f x\u2082 = z\u2082\nx : E := x\u2081 - x\u2082\nI : \u2016f x - d \u2022 y\u2016 \u2264 2 * \u03b4\nJ : dist (f (\u03c3' d\u207b\u00b9 \u2022 x)) y \u2264 1 / 2 * \u2016y\u2016\n\u22a2 \u2016x\u2081\u2016 + \u2016x\u2082\u2016 \u2264 \u2191n + \u2191n",["gcongr","linarith"]],["Analysis/Normed/Operator/Banach.lean",184,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u2074 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b3 : RingHomIsometric \u03c3\ninst\u271d\u00b2 : RingHomIsometric \u03c3'\ninst\u271d\u00b9 : CompleteSpace F\ninst\u271d : CompleteSpace E\nsurj : Surjective \u21d1f\nC : \u211d\nC0 : C \u2265 0\ng : F \u2192 E\nhg : \u2200 (y : F), dist (f (g y)) y \u2264 1 / 2 * \u2016y\u2016 \u2227 \u2016g y\u2016 \u2264 C * \u2016y\u2016\nh : F \u2192 F := fun y \u21a6 y - f (g y)\nhle : \u2200 (y : F), \u2016h y\u2016 \u2264 1 / 2 * \u2016y\u2016\ny : F\nn : \u2115\nIH : \u2016h^[n] y\u2016 \u2264 (1 / 2) ^ n * \u2016y\u2016\n\u22a2 1 / 2 * \u2016h^[n] y\u2016 \u2264 1 / 2 * ((1 / 2) ^ n * \u2016y\u2016)",["gcongr","aesop","linarith"]],["RingTheory/Smooth/StandardSmooth.lean",267,"R : Type u\nS : Type v\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : Algebra R S\nT : Type u_3\ninst\u271d\u2075 : CommRing T\ninst\u271d\u2074 : Algebra R T\ninst\u271d\u00b3 : Algebra S T\ninst\u271d\u00b2 : IsScalarTower R S T\nQ : PreSubmersivePresentation S T\nP : PreSubmersivePresentation R S\ninst\u271d\u00b9 : Q.IsFinite\ninst\u271d : P.IsFinite\nthis\u271d : Nat.card P.rels \u2264 Nat.card P.vars\nthis : Nat.card Q.rels \u2264 Nat.card Q.vars\n\u22a2 Nat.card Q.vars + Nat.card P.vars - (Nat.card Q.rels + Nat.card P.rels) =\n    Nat.card Q.vars - Nat.card Q.rels + (Nat.card P.vars - Nat.card P.rels)",["omega"]],["Topology/MetricSpace/GromovHausdorffRealized.lean",125,"X : Type u\nY : Type v\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : MetricSpace Y\nf : GromovHausdorff.ProdSpaceFun X Y\nx y : X \u2295 Y\nfA : f \u2208 candidates X Y\nthis : 0 \u2264 2 * f (x, y)\n\u22a2 0 \u2264 f (x, y)",["linarith","aesop"]],["NumberTheory/Modular.lean",394,"z : \u210d\nhz : z \u2208 \ud835\udc9f\u1d52\nn : \u2124\nhz\u2081 : 1 < z.re * z.re + z.im * z.im\nhzn : 0 \u2264 \u2191n * (2 * z.re) + \u2191n * \u2191n\n\u22a2 1 < (z.re + \u2191n) * (z.re + \u2191n) + z.im * z.im",["linarith"]],["NumberTheory/Modular.lean",457,"case inr\ng : SL(2, \u2124)\nz : \u210d\nhz : z \u2208 \ud835\udc9f\u1d52\nhg : g \u2022 z \u2208 \ud835\udc9f\u1d52\nc' : \u2124 := \u2191g 1 0\nc : \u211d := \u2191c'\nhc : c \u2260 0\nthis : 9 * c ^ 4 < 16\n\u22a2 (3 * c ^ 2) ^ 2 < 4 ^ 2",["linarith"]],["NumberTheory/Modular.lean",467,"g : SL(2, \u2124)\nz : \u210d\nhz : z \u2208 \ud835\udc9f\u1d52\nhg : g \u2022 z \u2208 \ud835\udc9f\u1d52\nc' : \u2124 := \u2191g 1 0\nc : \u211d := \u2191c'\nhc : c \u2260 0\nh\u2081 : 3 * 3 * c ^ 4 < 4 * (g \u2022 z).im ^ 2 * (4 * z.im ^ 2) * c ^ 4\nh\u2082 : (c * z.im) ^ 4 / normSq (denom (\u2191g) z) ^ 2 \u2264 1\nnsq : \u211d := normSq (denom (\u2191g) z)\n\u22a2 9 * c ^ 4 < c ^ 4 * z.im ^ 2 * (g \u2022 z).im ^ 2 * 16",["linarith"]],["NumberTheory/Modular.lean",471,"g : SL(2, \u2124)\nz : \u210d\nhz : z \u2208 \ud835\udc9f\u1d52\nhg : g \u2022 z \u2208 \ud835\udc9f\u1d52\nc' : \u2124 := \u2191g 1 0\nc : \u211d := \u2191c'\nhc : c \u2260 0\nh\u2081 : 3 * 3 * c ^ 4 < 4 * (g \u2022 z).im ^ 2 * (4 * z.im ^ 2) * c ^ 4\nh\u2082 : (c * z.im) ^ 4 / normSq (denom (\u2191g) z) ^ 2 \u2264 1\nnsq : \u211d := normSq (denom (\u2191g) z)\n\u22a2 (c * z.im) ^ 4 / nsq ^ 2 * 16 \u2264 16",["linarith","aesop"]],["NumberTheory/Modular.lean",488,"g : SL(2, \u2124)\nz : \u210d\nhz : z \u2208 \ud835\udc9f\u1d52\nhg : g \u2022 z \u2208 \ud835\udc9f\u1d52\ng' : SL(2, \u2124)\nhg' : g' \u2022 z \u2208 \ud835\udc9f\u1d52\nhc : \u2191g' 1 0 = 1\na : \u2124 := \u2191g' 0 0\nd : \u2124 := \u2191g' 1 1\nhad : T ^ (-a) * g' = S * T ^ d\nw : \u210d := T ^ (-a) \u2022 g' \u2022 z\nh\u2081 : normSq \u2191w < 1\nh\u2082 : 1 < normSq \u2191w\n\u22a2 False",["linarith"]],["NumberTheory/Modular.lean",326,"g : SL(2, \u2124)\nhc : \u2191g 1 0 = 0\nhad : \u2191g 0 0 * \u2191g 1 1 - \u2191g 0 1 * 0 = 1\n\u22a2 \u2191g 0 0 * \u2191g 1 1 = 1",["omega","aesop","linarith"]],["NumberTheory/Modular.lean",340,"g : SL(2, \u2124)\nhc : \u2191g 1 0 = 1\nhg : 1 = \u2191g 0 0 * \u2191g 1 1 - \u2191g 0 1 * 1\n\u22a2 \u2191g 0 1 = \u2191g 0 0 * \u2191g 1 1 - 1",["omega","linarith"]],["NumberTheory/Modular.lean",450,"g : SL(2, \u2124)\nz : \u210d\nhz : z \u2208 \ud835\udc9f\u1d52\nhg : g \u2022 z \u2208 \ud835\udc9f\u1d52\nc' : \u2124 := \u2191g 1 0\nc : \u211d := \u2191c'\nthis : 3 * c' ^ 2 < 4\n\u22a2 c' ^ 2 \u2264 1 ^ 2",["omega","linarith"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",65,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\ni : Fin N.succ\n\u22a2 0 < (fun i \u21a6 (a.r (last N))\u207b\u00b9 * a.r i) i",["positivity"]],["MeasureTheory/Decomposition/Jordan.lean",251,"\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\ns : SignedMeasure \u03b1\nu v w : Set \u03b1\nhu : MeasurableSet u\nhv : MeasurableSet v\nhw : MeasurableSet w\nhsu : 0 \u2264[u] s\nhw\u2081 : \u2191s w = 0\nhw\u2082 : w \u2286 u\nhwt : v \u2286 w\nthis : \u2191s v + \u2191s (w \\ v) = 0\nh\u2081 : 0 \u2264 \u2191s v\nh\u2082 : 0 \u2264 \u2191s (w \\ v)\n\u22a2 \u2191s v = 0",["linarith"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Basic.lean",284,"case intro.intro\nA : Type u_2\ninst\u271d : CStarAlgebra A\nb : A\na : A := star b * b\na_def : a = star b * b\nha : IsSelfAdjoint a\nc : A := b * a\u207b\nh_eq_negPart_a : -(star c * c) = a\u207b ^ 3\nx : \u211d\n\u22a2 0 \u2264 (fun x \u21a6 x\u207b ^ 3) x",["positivity"]],["Topology/Path.lean",272,"X : Type u_1\ninst\u271d : TopologicalSpace X\nx y z : X\n\u03b3 : Path x y\n\u03b3' : Path y z\nt : \u2191I\nh\u271d : \u2191(\u03c3 t) \u2264 1 / 2\nh : 1 - \u2191t \u2264 1 / 2\nh\u2081 : \u2191t \u2264 1 / 2\n\u22a2 \u2191t = 1 / 2",["linarith"]],["Topology/Path.lean",280,"case neg\nX : Type u_1\ninst\u271d : TopologicalSpace X\nx y z : X\n\u03b3 : Path x y\n\u03b3' : Path y z\nt : \u2191I\nh\u271d : \u00ac\u2191(\u03c3 t) \u2264 1 / 2\nh : \u00ac1 - \u2191t \u2264 1 / 2\nh\u2082 : \u00ac\u2191t \u2264 1 / 2\n\u22a2 False",["linarith"]],["Topology/Path.lean",320,"X : Type u_1\ninst\u271d : TopologicalSpace X\na b c : X\n\u03b3\u2081 : Path a b\n\u03b3\u2082 : Path b c\nx : X\nt : \u211d\nht0\u271d : 0 \u2264 t\nht1 : t \u2264 1\nhxt : \u03b3\u2082 \u27e8t, \u22ef\u27e9 = x\nh : t \u2260 0\nht0 : 0 < t\n\u22a2 1 / 2 < (t + 1) / 2",["linarith"]],["Topology/Path.lean",521,"case neg.e_a\nX\u271d : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\u271d\ninst\u271d\u00b9 : TopologicalSpace Y\nx y z : X\u271d\n\u03b9 : Type u_3\n\u03b3\u271d : Path x y\nX : Type u_4\ninst\u271d : TopologicalSpace X\na b : X\n\u03b3 : Path a b\nt\u2080 t\u2081 : \u211d\nh\u2081 : t\u2080 \u2264 \u21910\nh\u2082 : \u21910 \u2264 t\u2081\nh\u2083 : \u00act\u2080 \u2264 t\u2081\n\u22a2 \u21910 = t\u2081",["linarith"]],["Geometry/Euclidean/Angle/Unoriented/Affine.lean",185,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\np\u2081 p\u2082 p\u2083 : P\nh : \u03c0 / 2 = \u03c0\nheq : p\u2081 = p\u2082\n\u22a2 \u03c0 = 0",["linarith"]],["Algebra/ContinuedFractions/Computation/Approximations.lean",385,"K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nifp : IntFractPair K\nstream_nth_eq : IntFractPair.stream v n = some ifp\ng : GenContFract K := of v\nconts : Pair K := g.contsAux (n + 1)\npred_conts : Pair K := g.contsAux n\nifp_fr_ne_zero : ifp.fr \u2260 0\nA : K := conts.a\nB : K := conts.b\npA : K := pred_conts.a\npB : K := pred_conts.b\ng_finite_correctness : v = (pA + ifp.fr\u207b\u00b9 * A) / (pB + ifp.fr\u207b\u00b9 * B)\nn_eq_zero_or_not_terminatedAt_pred_n : n = 0 \u2228 \u00acg.TerminatedAt (n - 1)\ndeterminant_eq : pA * B - pB * A = (-1) ^ n\npB_ineq : \u2191(fib n) \u2264 pB\nB_ineq : \u2191(fib (n + 1)) \u2264 B\nzero_lt_B : 0 < B\nthis\u271d : 0 \u2264 pB\nthis : 0 < ifp.fr\n\u22a2 pB + ifp.fr\u207b\u00b9 * B \u2260 0",["positivity"]],["Algebra/ContinuedFractions/Computation/Approximations.lean",457,"K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nnot_terminatedAt_n : \u00ac(of v).TerminatedAt n\ng : GenContFract K := of v\nnextConts : Pair K := g.contsAux (n + 2)\nconts : Pair K := g.contsAux (n + 1)\nconts_eq : conts = g.contsAux (n + 1)\npred_conts : Pair K := g.contsAux n\npred_conts_eq : pred_conts = g.contsAux n\ngp : Pair K\ns_nth_eq : g.s.get? n = some gp\ngp_a_eq_one : gp.a = 1\nnextConts_b_eq : nextConts.b = pred_conts.b + gp.b * conts.b\nden : K := conts.b * (pred_conts.b + gp.b * conts.b)\nifp_succ_n : IntFractPair K\nsucc_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n\nifp_succ_n_b_eq_gp_b : \u2191ifp_succ_n.b = gp.b\nifp_n : IntFractPair K\nstream_nth_eq : IntFractPair.stream v n = some ifp_n\nstream_nth_fr_ne_zero : ifp_n.fr \u2260 0\nif_of_eq_ifp_succ_n : IntFractPair.of ifp_n.fr\u207b\u00b9 = ifp_succ_n\nden' : K := conts.b * (pred_conts.b + ifp_n.fr\u207b\u00b9 * conts.b)\nnextConts_b_ineq : \u2191(fib (n + 2)) \u2264 pred_conts.b + gp.b * conts.b\nconts_b_ineq : \u2191(fib (n + 1)) \u2264 conts.b\nzero_lt_conts_b : 0 < conts.b\nthis\u271d\u00b9 : 1 / den' \u2264 1 / den\nthis\u271d : 0 \u2264 pred_conts.b\nthis : 0 < ifp_n.fr\u207b\u00b9\n\u22a2 0 < den'",["positivity"]],["Algebra/Polynomial/Laurent.lean",311,"R : Type u_1\ninst\u271d : Semiring R\nn : \u2124\nr : R\nn0 : \u00ac0 \u2264 n\na : \u2115\n\u22a2 n \u2260 \u2191a",["omega","linarith"]],["Analysis/Calculus/BumpFunction/FiniteDimension.lean",394,"E : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : FiniteDimensional \u211d E\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : BorelSpace E\nD : \u211d\nx : E\nDpos : 0 < D\nD_lt_one : D < 1\nhx : \u2016x\u2016 < 1 + D\nz : E := (D / (1 + D)) \u2022 x\nhz : z = (D / (1 + D)) \u2022 x\n\u22a2 0 < 1 + D",["linarith","positivity"]],["Analysis/Calculus/BumpFunction/FiniteDimension.lean",494,"case hf.hf.mk.intro.h\nE\u271d : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\ninst\u271d\u2074 : NormedSpace \u211d E\u271d\ninst\u271d\u00b3 : FiniteDimensional \u211d E\u271d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\nIR : \u2200 (R : \u211d), 1 < R \u2192 0 < (R - 1) / (R + 1)\nR : \u211d\nx : E\nhR : 1 < R\nright\u271d : (R, x).2 \u2208 univ\n\u22a2 0 < R + 1",["linarith","aesop","positivity"]],["Analysis/Calculus/BumpFunction/FiniteDimension.lean",500,"case mk.intro.h\nE\u271d : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\ninst\u271d\u2074 : NormedSpace \u211d E\u271d\ninst\u271d\u00b3 : FiniteDimensional \u211d E\u271d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\nIR : \u2200 (R : \u211d), 1 < R \u2192 0 < (R - 1) / (R + 1)\nR : \u211d\nx : E\nhR : 1 < R\nright\u271d : (R, x).2 \u2208 univ\n\u22a2 0 < (R + 1) / 2",["linarith","aesop","positivity"]],["Analysis/Calculus/BumpFunction/FiniteDimension.lean",506,"E\u271d : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\ninst\u271d\u2074 : NormedSpace \u211d E\u271d\ninst\u271d\u00b3 : FiniteDimensional \u211d E\u271d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\nIR : \u2200 (R : \u211d), 1 < R \u2192 0 < (R - 1) / (R + 1)\nR : \u211d\nhR : 1 < R\nx : E\nhx : \u2016x\u2016 \u2264 1\n\u22a2 0 < R + 1",["linarith","aesop","positivity"]],["Analysis/Calculus/BumpFunction/FiniteDimension.lean",515,"E\u271d : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\ninst\u271d\u2074 : NormedSpace \u211d E\u271d\ninst\u271d\u00b3 : FiniteDimensional \u211d E\u271d\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nthis\u271d\u00b9 : MeasurableSpace E := borel E\nthis\u271d : BorelSpace E\nIR : \u2200 (R : \u211d), 1 < R \u2192 0 < (R - 1) / (R + 1)\nR : \u211d\nhR : 1 < R\n\u22a2 0 < (R + 1) / 2",["linarith","aesop","positivity"]],["Analysis/Calculus/BumpFunction/FiniteDimension.lean",152,"E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Set E\nhs : IsOpen s\nh's : s.Nonempty\n\u03b9 : Type (max 0 u_1) := { f // support f \u2286 s \u2227 HasCompactSupport f \u2227 ContDiff \u211d \u221e f \u2227 range f \u2286 Icc 0 1 }\nT : Set \u03b9\nT_count : T.Countable\nhT : \u22c3 f \u2208 T, support \u2191f = s\ng0 : \u2115 \u2192 \u03b9\nhg : T = range g0\ng : \u2115 \u2192 E \u2192 \u211d := fun n \u21a6 \u2191(g0 n)\ng_s : \u2200 (n : \u2115), support (g n) \u2286 s\ns_g : \u2200 x \u2208 s, \u2203 n, x \u2208 support (g n)\ng_smooth : \u2200 (n : \u2115), ContDiff \u211d \u221e (g n)\ng_comp_supp : \u2200 (n : \u2115), HasCompactSupport (g n)\ng_nonneg : \u2200 (n : \u2115) (x : E), 0 \u2264 g n x\n\u03b4 : \u2115 \u2192 \u211d\u22650\n\u03b4pos : \u2200 (i : \u2115), 0 < \u03b4 i\nc : \u211d\u22650\n\u03b4c : HasSum \u03b4 c\nc_lt : c < 1\nn : \u2115\nR : \u2115 \u2192 \u211d\nhR : \u2200 (i : \u2115) (x : E), \u2016iteratedFDeriv \u211d i (fun x \u21a6 g n x) x\u2016 \u2264 R i\nM : \u211d := (Finset.image R (Finset.range (n + 1))).max' \u22ef \u2294 1\n\u03b4npos : 0 < \u03b4 n\nIR : \u2200 i \u2264 n, R i \u2264 M\ni : \u2115\nhi : i \u2264 n\nx : E\n\u22a2 0 \u2264 M\u207b\u00b9 * \u2191(\u03b4 n)",["positivity","aesop"]],["Analysis/Calculus/BumpFunction/FiniteDimension.lean",145,"case H2.h\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Set E\nhs : IsOpen s\nh's : s.Nonempty\n\u03b9 : Type (max 0 u_1) := { f // support f \u2286 s \u2227 HasCompactSupport f \u2227 ContDiff \u211d \u221e f \u2227 range f \u2286 Icc 0 1 }\nT : Set \u03b9\nT_count : T.Countable\nhT : \u22c3 f \u2208 T, support \u2191f = s\ng0 : \u2115 \u2192 \u03b9\nhg : T = range g0\ng : \u2115 \u2192 E \u2192 \u211d := fun n \u21a6 \u2191(g0 n)\ng_s : \u2200 (n : \u2115), support (g n) \u2286 s\ns_g : \u2200 x \u2208 s, \u2203 n, x \u2208 support (g n)\ng_smooth : \u2200 (n : \u2115), ContDiff \u211d \u221e (g n)\ng_comp_supp : \u2200 (n : \u2115), HasCompactSupport (g n)\ng_nonneg : \u2200 (n : \u2115) (x : E), 0 \u2264 g n x\n\u03b4 : \u2115 \u2192 \u211d\u22650\n\u03b4pos : \u2200 (i : \u2115), 0 < \u03b4 i\nc : \u211d\u22650\n\u03b4c : HasSum \u03b4 c\nc_lt : c < 1\nn : \u2115\nR : \u2115 \u2192 \u211d\nhR : \u2200 (i : \u2115) (x : E), \u2016iteratedFDeriv \u211d i (fun x \u21a6 g n x) x\u2016 \u2264 R i\nM : \u211d := (Finset.image R (Finset.range (n + 1))).max' \u22ef \u2294 1\n\u03b4npos : 0 < \u03b4 n\ni : \u2115\nhi : i \u2264 n\n\u22a2 i < n + 1",["omega","linarith"]],["Analysis/InnerProductSpace/Defs.lean",352,"\ud835\udd5c : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\nthis : 2 * \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * (2 * \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016) - 4 * re \u27eax, x\u27eb_\ud835\udd5c * re \u27eay, y\u27eb_\ud835\udd5c \u2264 0\n\u22a2 \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 \u2264 re \u27eax, x\u27eb_\ud835\udd5c * re \u27eay, y\u27eb_\ud835\udd5c",["linarith","infer_instance"]],["Analysis/InnerProductSpace/Defs.lean",404,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\nh\u2081 : \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 \u2264 \u2016x\u2016 * \u2016y\u2016\nh\u2082 : re \u27eax, y\u27eb_\ud835\udd5c \u2264 \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016\nh\u2083 : re \u27eax, y\u27eb_\ud835\udd5c \u2264 \u2016x\u2016 * \u2016y\u2016\nh\u2084 : re \u27eay, x\u27eb_\ud835\udd5c \u2264 \u2016x\u2016 * \u2016y\u2016\n\u22a2 re \u27eax, x\u27eb_\ud835\udd5c + re \u27eax, y\u27eb_\ud835\udd5c + re \u27eay, x\u27eb_\ud835\udd5c + re \u27eay, y\u27eb_\ud835\udd5c \u2264 re \u27eax, x\u27eb_\ud835\udd5c + \u2016x\u2016 * \u2016y\u2016 + (\u2016x\u2016 * \u2016y\u2016 + re \u27eay, y\u27eb_\ud835\udd5c)",["linarith"]],["Analysis/InnerProductSpace/Defs.lean",467,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\ncd : Core \ud835\udd5c F\nx y : F\nh\u2081 : \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 \u2264 \u2016x\u2016 * \u2016y\u2016\nh\u2082 : re \u27eax, y\u27eb_\ud835\udd5c \u2264 \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016\nh\u2083 : re \u27eax, y\u27eb_\ud835\udd5c \u2264 \u2016x\u2016 * \u2016y\u2016\nh\u2084 : re \u27eay, x\u27eb_\ud835\udd5c \u2264 \u2016x\u2016 * \u2016y\u2016\n\u22a2 re \u27eax, x\u27eb_\ud835\udd5c + re \u27eax, y\u27eb_\ud835\udd5c + re \u27eay, x\u27eb_\ud835\udd5c + re \u27eay, y\u27eb_\ud835\udd5c \u2264 re \u27eax, x\u27eb_\ud835\udd5c + \u2016x\u2016 * \u2016y\u2016 + (\u2016x\u2016 * \u2016y\u2016 + re \u27eay, y\u27eb_\ud835\udd5c)",["linarith"]],["Analysis/InnerProductSpace/Defs.lean",357,"case pos.intro\n\ud835\udd5c : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : PreInnerProductSpace.Core \ud835\udd5c F\nx y : F\nt : \u211d\nhzero : \u27eax, y\u27eb_\ud835\udd5c = 0\nhx : 0 \u2264 normSq x\nhy : 0 \u2264 normSq y\n\u22a2 0 \u2264 normSq x * t ^ 2 + normSq y",["positivity"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",70,"s : \u211d\nh : 0 < s\n\u22a2 -1 < s - 1",["linarith","aesop"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",162,"s : \u2102\nhs : 0 < s.re\nX : \u211d\nhX : 0 \u2264 X\n\u22a2 0 < s.re + 1",["linarith","positivity"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",223,"case hs\ns : \u2102\nhs : 0 < s.re\nthis : Tendsto (s + 1).partialGamma atTop (\ud835\udcdd (s * s.GammaIntegral))\n\u22a2 0 < s.re + 1",["linarith","positivity"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",264,"n : \u2115\nhn : \u2200 (s : \u2102), -s.re < \u2191n \u2192 GammaAux n s = GammaAux n (s + 1) / s\ns : \u2102\nh1 : -s.re < \u2191n + 1\n\u22a2 -(s.re + 1) < \u2191n",["linarith"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",280,"s : \u2102\nn : \u2115\nh1 : -s.re < \u2191n + 1\n\u22a2 -(s.re + 1) < \u2191n",["linarith"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",312,"s : \u2102\nh2 : s \u2260 0\nn : \u2115 := \u230a1 - s.re\u230b\u208a\nt1 : -s.re < \u2191n\n\u22a2 -(s.re + 1) < \u2191n",["linarith"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",317,"s : \u2102\nhs : 0 < s.re\n\u22a2 -s.re < 0",["linarith","aesop"]],["Analysis/SpecialFunctions/Gamma/Basic.lean",524,"case a\nn\u271d : \u2115\nn_ih : \u2200 {s : \u211d}, (\u2200 (m : \u2115), s \u2260 -\u2191m) \u2192 -\u2191n\u271d < s \u2192 Gamma s \u2260 0\ns : \u211d\nhs : \u2200 (m : \u2115), s \u2260 -\u2191m\nhs' : -\u2191n\u271d + -1 < s\n\u22a2 -\u2191n\u271d < s + 1",["linarith","aesop"]],["NumberTheory/NumberField/Discriminant/Basic.lean",167,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nh : 1 < finrank \u211a K\nx : \ud835\udcde K\nh_nz : x \u2260 0\nh_nm : 1 \u2264 \u2191|(Algebra.norm \u211a) \u2191x|\nh_bd : \u2191(finrank \u211a K) ^ finrank \u211a K / ((4 / \u03c0) ^ nrComplexPlaces K * \u2191(finrank \u211a K).factorial) \u2264 \u221a|\u2191(discr K)|\n\u22a2 0 \u2264 \u2191(finrank \u211a K) ^ finrank \u211a K / ((4 / \u03c0) ^ nrComplexPlaces K * \u2191(finrank \u211a K).factorial)",["positivity"]],["MeasureTheory/Function/AEEqOfIntegral.lean",91,"\u03b1 : Type u_1\nE : Type u_2\n\ud835\udd5c : Type u_3\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nt : Set E\nf : \u03b1 \u2192 E\nhf : \u2200 (c : Dual \ud835\udd5c E), (fun x \u21a6 c (f x)) =\u1da0[ae \u03bc] 0\nh't : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, f x \u2208 t\nd : Set E\nd_count : d.Countable\nhd : t \u2286 closure d\nthis\u271d\u00b9 : Encodable \u2191d\ns : \u2191d \u2192 E \u2192L[\ud835\udd5c] \ud835\udd5c\nhs : \u2200 (x : \u2191d), \u2016s x\u2016 \u2264 1 \u2227 (s x) \u2191x = \u2191\u2016\u2191x\u2016\na : E\nhat : a \u2208 t\nha : a \u2260 0\na_pos : 0 < \u2016a\u2016\na_mem : a \u2208 closure d\nx : \u2191d\nhx : dist a \u2191x < \u2016a\u2016 / 2\nthis\u271d : \u2016a\u2016 \u2264 \u2016\u2191x\u2016 + \u2016a - \u2191x\u2016\nthis : \u2016a - \u2191x\u2016 < \u2016a\u2016 / 2\n\u22a2 \u2016a\u2016 / 2 < \u2016\u2191x\u2016",["linarith"]],["Analysis/SpecialFunctions/Log/Basic.lean",171,"x : \u211d\nhx : x < -1\n\u22a2 1 < -x",["linarith"]],["Analysis/SpecialFunctions/Log/Basic.lean",184,"x : \u211d\nh0 : x < 0\nh1 : -1 < x\n\u22a2 0 < -x",["linarith","aesop"]],["Analysis/SpecialFunctions/Log/Basic.lean",185,"x : \u211d\nh0 : x < 0\nh1 : -1 < x\nh0' : 0 < -x\n\u22a2 -x < 1",["linarith"]],["Analysis/SpecialFunctions/Log/Basic.lean",309,"x : \u211d\nh1 : 0 < x\nh2 : x \u2264 1\nthis : log (1 / x) \u2264 1 / x - 1\n\u22a2 log (1 / x) < 1 / x",["linarith"]],["Algebra/Homology/HomotopyCategory/HomComplexShift.lean",441,"case pos.h.e_a.e_a.e_n\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nK L : CochainComplex C \u2124\nn : \u2124\n\u03b3 : Cochain K L n\na n' m' : \u2124\nhn' : n + a = n'\nm : \u2124\nhm' : m + a = m'\nhnm : n + 1 = m\nhnm' : n' + 1 = m'\np q : \u2124\nhpq : p + m' = q\n\u22a2 n + 1 + a + (a * (n + a) + a * (a - 1) / 2 + a) = a + (a * (n + 1 + a) + a * (a - 1) / 2 + (n + 1))",["linarith"]],["Algebra/Homology/HomotopyCategory/HomComplexShift.lean",67,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nK L : CochainComplex C \u2124\nn : \u2124\n\u03b3 : Cochain K L n\na n' : \u2124\nhn' : n + a = n'\np q : \u2124\nhpq : p + n' = q\np' : \u2124\nhp' : p' + n = q\n\u22a2 p' = p + a",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplexShift.lean",95,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nK L : CochainComplex C \u2124\nn' a : \u2124\n\u03b3 : Cochain ((CategoryTheory.shiftFunctor (CochainComplex C \u2124) a).obj K) L n'\nn : \u2124\nhn : n + a = n'\np q : \u2124\nhpq : p + n = q\np' : \u2124\nhp' : p' + n' = q\n\u22a2 p' = p - a",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplexShift.lean",377,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nK L M : CochainComplex C \u2124\nn : \u2124\n\u03b3 : Cochain K L n\na n' : \u2124\nhn' : n + a = n'\nm t t' : \u2124\n\u03b3' : Cochain L M m\nh : n + m = t\nht' : t + a = t'\np q : \u2124\nhpq : p + t' = q\n\u22a2 n' + m = t'",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplexShift.lean",396,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nK L : CochainComplex C \u2124\nn : \u2124\n\u03b3 : Cochain K L n\na n' m' : \u2124\nhn' : n' + a = n\nm : \u2124\nhm' : m' + a = m\nhnm : n + 1 = m\n\u22a2 n' + 1 = m'",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplexShift.lean",411,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nK L : CochainComplex C \u2124\nn : \u2124\n\u03b3 : Cochain K L n\na n' m' : \u2124\nhn' : n' + a = n\nm : \u2124\nhm' : m' + a = m\nhnm : \u00acn + 1 = m\nx\u271d : n' + 1 = m'\n\u22a2 n + 1 = m",["omega"]],["Algebra/Homology/HomotopyCategory/HomComplexShift.lean",425,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nK L : CochainComplex C \u2124\nn : \u2124\n\u03b3 : Cochain K L n\na n' m' : \u2124\nhn' : n + a = n'\nm : \u2124\nhm' : m + a = m'\nhnm : n + 1 = m\n\u22a2 n' + 1 = m'",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/HomComplexShift.lean",442,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Preadditive C\nK L : CochainComplex C \u2124\nn : \u2124\n\u03b3 : Cochain K L n\na n' m' : \u2124\nhn' : n + a = n'\nm : \u2124\nhm' : m + a = m'\nhnm : \u00acn + 1 = m\nx\u271d : n' + 1 = m'\n\u22a2 n + 1 = m",["omega"]],["Tactic/Positivity/Basic.lean",463,"\u03b1 : Type u_1\nq : \u211a\u22650\nhq : 0 < q\n\u22a2 0 < q.num",["positivity","aesop"]],["Tactic/Positivity/Basic.lean",464,"\u03b1 : Type u_1\nq : \u211a\u22650\nhq : q \u2260 0\n\u22a2 q.num \u2260 0",["positivity","aesop"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",287,"V : Type u\nG : SimpleGraph V\nu v\u271d : V\np : G.Walk u v\u271d\nhp : p.IsPath\nhnp : \u00acp.Nil\nv : V\nhadj1 : \u2203 i, (p.getVert i = u \u2227 p.getVert (i + 1) = p.snd \u2228 p.getVert i = p.snd \u2227 p.getVert (i + 1) = u) \u2227 i < p.length\ni : \u2115\nright\u271d : i < p.length\nhr : p.getVert i = v \u2227 p.getVert (i + 1) = u\n\u22a2 0 \u2264 p.length",["omega"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",308,"V : Type u\nG : SimpleGraph V\nv\u271d u : V\ni : \u2115\np : G.Walk u v\u271d\nhp : p.IsPath\nv : V\nh : \u00aci = 0\nh' : i < p.length\nhadj1 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i - 1) \u2228\n        p.getVert i_1 = p.getVert (i - 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\ni' : \u2115\nright\u271d\u00b9 : i' < p.length\nhl : p.getVert i' = p.getVert i\nright\u271d : p.getVert (i' + 1) = v\n\u22a2 i' \u2264 p.length\n```\n---\n```lean\nV : Type u\nG : SimpleGraph V\nv\u271d u : V\ni : \u2115\np : G.Walk u v\u271d\nhp : p.IsPath\nv : V\nh : \u00aci = 0\nh' : i < p.length\nhadj1 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i - 1) \u2228\n        p.getVert i_1 = p.getVert (i - 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\ni' : \u2115\nright\u271d : i' < p.length\nleft\u271d : p.getVert i' = v\nhl : p.getVert (i' + 1) = p.getVert i\n\u22a2 i' + 1 \u2264 p.length",["omega"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",318,"V : Type u\nG : SimpleGraph V\nv u : V\ni : \u2115\np : G.Walk u v\nhp : p.IsPath\nh\u271d : i \u2260 0\nh' : i < p.length\nh : p.getVert (i - 1) = p.getVert (i + 1)\nthis : i - 1 = i + 1\n\u22a2 False",["omega","aesop"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",331,"V : Type u\nG : SimpleGraph V\nu v v' : V\np : G.Walk u v\nhp : p.IsPath\nhadj : p.toSubgraph.Adj u v'\ni : \u2115\nhi : (p.getVert i = u \u2227 p.getVert (i + 1) = v' \u2228 p.getVert i = v' \u2227 p.getVert (i + 1) = u) \u2227 i < p.length\nhr1 : p.getVert i = v'\nhr2 : p.getVert (i + 1) = u\n\u22a2 0 \u2264 p.length",["omega"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",367,"V : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nv : V\nh : \u00aci = 0\nh' : i < p.length\nhadj1 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i - 1) \u2228\n        p.getVert i_1 = p.getVert (i - 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\nhadj2 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i + 1) \u2228\n        p.getVert i_1 = p.getVert (i + 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\ni' : \u2115\nright\u271d : i' < p.length\nhl1 : p.getVert i' = p.getVert i\nhl2 : p.getVert (i' + 1) = v\n\u22a2 i' \u2264 p.length - 1",["omega"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",370,"V : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nv : V\nh : \u00aci = 0\nh' : i < p.length\nhadj1 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i - 1) \u2228\n        p.getVert i_1 = p.getVert (i - 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\nhadj2 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i + 1) \u2228\n        p.getVert i_1 = p.getVert (i + 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\ni' : \u2115\nright\u271d : i' < p.length\nhr1 : p.getVert i' = v\nhr2 : p.getVert (i' + 1) = p.getVert i\n\u22a2 1 \u2264 i' + 1 \u2227 i' + 1 \u2264 p.length",["omega"]],["Analysis/PSeries.lean",272,"case inl.h_nonneg\np : \u211d\nhp : 0 \u2264 p\nn : \u2115\n\u22a2 0 \u2264 (\u2191n ^ p)\u207b\u00b9",["positivity"]],["Analysis/PSeries.lean",343,"i : \u2115\n\u22a2 0 \u2264 1 / (\u2191i + 1)",["positivity"]],["Analysis/PSeries.lean",443,"case h\na s b c : \u211d\nh : Summable fun n \u21a6 1 / |\u2191n + b| ^ s\nn : \u2115\nhn : \u2308|b|\u2309\u208a < n\nhna : 0 < \u2191n + b\n\u22a2 1 / |\u2191n + b| ^ s = 0 \u2192 False",["positivity"]],["Combinatorics/Additive/AP/Three/Behrend.lean",311,"x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\n\u22a2 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a",["linarith"]],["Combinatorics/Additive/AP/Three/Behrend.lean",423,"case h\u2081\nN : \u2115\nhN : 4096 \u2264 N\n\u22a2 0 < \u2191N ^ (\u2191(nValue N))\u207b\u00b9",["positivity"]],["Analysis/Complex/Basic.lean",590,"z : \u2102\nhz : z \u2208 Metric.ball 1 1\nthis : -1 < z.re - 1\n\u22a2 0 < z.re",["linarith","aesop"]],["NumberTheory/Ostrowski.lean",160,"f : AbsoluteValue \u211a \u211d\na b : \u2115\nhp0 : 0 < f \u2191(a * b)\nhp1 : f \u2191(a * b) < 1\nhmin : \u2200 (m : \u2115), 0 < f \u2191m \u2227 f \u2191m < 1 \u2192 a * b \u2264 m\nha\u2081 : a \u2260 1\nhb\u2081 : b \u2260 1\nha\u2080 : a \u2260 0\nhb\u2080 : b \u2260 0\n\u22a2 1 < b",["omega"]],["NumberTheory/Ostrowski.lean",161,"f : AbsoluteValue \u211a \u211d\na b : \u2115\nhp0 : 0 < f \u2191(a * b)\nhp1 : f \u2191(a * b) < 1\nhmin : \u2200 (m : \u2115), 0 < f \u2191m \u2227 f \u2191m < 1 \u2192 a * b \u2264 m\nha\u2081 : a \u2260 1\nhb\u2081 : b \u2260 1\nha\u2080 : a \u2260 0\nhb\u2080 : b \u2260 0\nhap : a < a * b\n\u22a2 1 < a",["omega"]],["NumberTheory/Ostrowski.lean",354,"f : AbsoluteValue \u211a \u211d\nn\u2080 : \u2115\nhn\u2080 : 1 < n\u2080\nh : f \u2191n\u2080 \u2264 1\nn : \u2115\nh_ineq1 : \u2200 {m : \u2115}, 1 \u2264 m \u2192 f \u2191m \u2264 \u2191n\u2080 * (logb \u2191n\u2080 \u2191m + 1)\nh\u2080 : n \u2260 0\nh_ineq2 : \u2200 (k : \u2115), 0 < k \u2192 f \u2191n \u2264 (\u2191n\u2080 * (logb \u2191n\u2080 \u2191n + 1)) ^ (\u2191k)\u207b\u00b9 * \u2191k ^ (\u2191k)\u207b\u00b9\nh\u2081 : n \u2260 1\n\u22a2 1 < n",["omega"]],["NumberTheory/Ostrowski.lean",438,"f : AbsoluteValue \u211a \u211d\nnotbdd : \u00ac\u2200 (n : \u2115), f \u2191n \u2264 1\nm : \u2115\nhm : \u00acf \u2191m \u2264 1\noneltm : 1 < m\ns : \u211d := logb (\u2191m) (f \u2191m)\nhs : s = logb (\u2191m) (f \u2191m)\nn : \u2115\nh : n < 1\n\u22a2 n = 0",["omega","aesop","linarith"]],["NumberTheory/LucasLehmer.lean",503,"p k : \u2115\nhp : 2 \u2264 p\nh1 : 4 \u2264 2 ^ p\n\u22a2 1 \u2264 2 ^ p",["omega"]],["RingTheory/MvPolynomial/Homogeneous.lean",362,"R : Type u_5\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nN : \u2115\nIH : \u2200 {F : MvPolynomial (Fin N) R} {n : \u2115}, F.IsHomogeneous n \u2192 F \u2260 0 \u2192 \u2191n \u2264 #R \u2192 \u2203 r, (eval r) F \u2260 0\nF : MvPolynomial (Fin (N + 1)) R\nn : \u2115\nhF : F.IsHomogeneous n\nhF\u2080 : F \u2260 0\nhnR : \u2191n \u2264 #R\nhdeg : ((finSuccEquiv R N) F).natDegree < n + 1\ni : \u2115\nhi : ((finSuccEquiv R N) F).coeff i \u2260 0\nhin\u271d : i \u2264 n\nhFn : ((finSuccEquiv R N) F).coeff n = 0\nhin : i < n\n\u22a2 \u2200 (a : \u2115), n = i + a + 1 \u2192 i + (a + 1) = n",["omega"]],["RingTheory/MvPolynomial/Homogeneous.lean",372,"R : Type u_5\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nN : \u2115\nIH : \u2200 {F : MvPolynomial (Fin N) R} {n : \u2115}, F.IsHomogeneous n \u2192 F \u2260 0 \u2192 \u2191n \u2264 #R \u2192 \u2203 r, (eval r) F \u2260 0\nF : MvPolynomial (Fin (N + 1)) R\nn : \u2115\nhF : F.IsHomogeneous n\nhF\u2080 : F \u2260 0\nhnR : \u2191n \u2264 #R\nhdeg : ((finSuccEquiv R N) F).natDegree < n + 1\ni : \u2115\nhi : ((finSuccEquiv R N) F).coeff i \u2260 0\nhin\u271d : i \u2264 n\nhFn : ((finSuccEquiv R N) F).coeff n = 0\nhin : i < n\nj : \u2115\nhj : i + (j + 1) = n\nr : Fin N \u2192 R\nhr : (eval r) (((finSuccEquiv R N) F).coeff i) \u2260 0\n\u03c6 : R[X] := Polynomial.map (eval r) ((finSuccEquiv R N) F)\nh\u03c6 : \u03c6 = Polynomial.map (eval r) ((finSuccEquiv R N) F)\nh\u03c6\u2080 : \u03c6 \u2260 0\nthis : ((finSuccEquiv R N) F).natDegree \u2260 n\n\u22a2 ((finSuccEquiv R N) F).natDegree < n",["omega"]],["Algebra/Lie/Weights/RootSystem.lean",122,"K : Type u_1\nL : Type u_2\ninst\u271d\u2077 : Field K\ninst\u271d\u2076 : CharZero K\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : IsKilling K L\ninst\u271d\u00b2 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsTriangularizable K (\u21a5H) L\n\u03b1 \u03b2 : Weight K (\u21a5H) L\nh\u03b1 : \u03b1.IsNonZero\nn : \u2115\nhn : chainLength \u03b1 \u03b2 < n\ne : \u00acrootSpace H (-(n \u2022 \u21d1\u03b1) + \u21d1(chainTop (\u21d1\u03b1) \u03b2)) = \u22a5\nW : Weight K (\u21a5H) L := { toFun := -(n \u2022 \u21d1\u03b1) + \u21d1(chainTop (\u21d1\u03b1) \u03b2), genWeightSpace_ne_bot' := e }\nhW : \u21d1W = -(n \u2022 \u21d1\u03b1) + \u21d1(chainTop (\u21d1\u03b1) \u03b2)\nthis : chainTopCoeff (\u21d1(-\u03b1)) W + chainTopCoeff (\u21d1(-\u03b1)) W + (n + n) = chainLength (-\u03b1) W + chainLength \u03b1 \u03b2\n\u22a2 1 + n + chainTopCoeff (\u21d1(-\u03b1)) W \u2264 chainLength (-\u03b1) W",["omega","linarith"]],["Algebra/Lie/Weights/RootSystem.lean",187,"case e_a\nK : Type u_1\nL : Type u_2\ninst\u271d\u2077 : Field K\ninst\u271d\u2076 : CharZero K\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : IsKilling K L\ninst\u271d\u00b2 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsTriangularizable K (\u21a5H) L\n\u03b1 \u03b2 : Weight K (\u21a5H) L\n\u22a2 \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2 + chainBotCoeff (\u21d1\u03b1) \u03b2) - 2 * \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2) =\n    \u2191(chainBotCoeff (\u21d1\u03b1) \u03b2) - \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2)",["omega"]],["Algebra/Lie/Weights/RootSystem.lean",338,"case inr.inr.intro.refine_1\nK : Type u_1\nL : Type u_2\ninst\u271d\u2077 : Field K\ninst\u271d\u2076 : CharZero K\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : IsKilling K L\ninst\u271d\u00b2 : FiniteDimensional K L\nH\u271d : LieSubalgebra K L\ninst\u271d\u00b9 : H\u271d.IsCartanSubalgebra\ninst\u271d : IsTriangularizable K (\u21a5H\u271d) L\n\u03b1 \u03b2 : Weight K (\u21a5H\u271d) L\nh\u03b1 : \u03b1.IsNonZero\nk : K\nh : \u21d1\u03b2 = k \u2022 \u21d1\u03b1\nh\u271d : Nontrivial L\nn : \u2115\nhn : chainLength \u03b1 \u03b2 = 2 * n + 1\nH : k * 2 / 2 = \u2191(\u2191(2 * n + 1) - 2 * \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2)) / 2\nhk : k = \u2191n + 2\u207b\u00b9 - \u2191(chainTopCoeff (\u21d1\u03b1) \u03b2)\n\u22a2 \u2191n \u2264 \u2191(2 * n + 1)",["omega"]],["Geometry/Manifold/Instances/Real.lean",268,"case h\nx y : \u211d\nh : Fact (x < y)\nz : EuclideanHalfSpace 1\nhz : \u2191z 0 < y - x\n\u22a2 \u2191z 0 + x < y",["linarith"]],["Geometry/Manifold/Instances/Real.lean",278,"x y : \u211d\nh : Fact (x < y)\nz : EuclideanSpace \u211d (Fin 1)\nhz : 0 \u2264 z 0\nh'z : z 0 < y - x\ni : Fin 1\n\u22a2 x + z 0 \u2264 y",["linarith"]],["Geometry/Manifold/Instances/Real.lean",343,"case h\nx\u271d y\u271d : \u211d\nhxy : Fact (x\u271d < y\u271d)\nx y : \u211d\nh : Fact (x < y)\nz : EuclideanHalfSpace 1\nhz : \u2191z 0 < y - x\n\u22a2 x < y - \u2191z 0",["linarith"]],["Geometry/Manifold/Instances/Real.lean",353,"x\u271d y\u271d : \u211d\nhxy : Fact (x\u271d < y\u271d)\nx y : \u211d\nh : Fact (x < y)\nz : EuclideanSpace \u211d (Fin 1)\nhz : 0 \u2264 z 0\nh'z : z 0 < y - x\ni : Fin 1\n\u22a2 x \u2264 y - z 0",["linarith"]],["Geometry/Manifold/Instances/Real.lean",97,"n : \u2115\ninst\u271d : NeZero n\nx\u271d\u2076 : EuclideanSpace \u211d (Fin n)\nhx : 0 \u2264 x\u271d\u2076 0\nx\u271d\u2075 : EuclideanSpace \u211d (Fin n)\nhy : 0 \u2264 x\u271d\u2075 0\nx\u271d\u2074 x\u271d\u00b3 : \u211d\nx\u271d\u00b2 : 0 \u2264 x\u271d\u2074\nx\u271d\u00b9 : 0 \u2264 x\u271d\u00b3\nx\u271d : x\u271d\u2074 + x\u271d\u00b3 = 1\n\u22a2 0 \u2264 x\u271d\u2074 * x\u271d\u2076 0 + x\u271d\u00b3 * x\u271d\u2075 0",["positivity"]],["Geometry/Manifold/Instances/Real.lean",101,"n : \u2115\nx\u271d\u2076 x\u271d\u2075 : EuclideanSpace \u211d (Fin n)\nx\u271d\u2074 x\u271d\u00b3 : \u211d\nx\u271d\u00b2 : 0 \u2264 x\u271d\u2074\nx\u271d\u00b9 : 0 \u2264 x\u271d\u00b3\nx\u271d : x\u271d\u2074 + x\u271d\u00b3 = 1\ni : Fin n\nhx : 0 \u2264 x\u271d\u2076 i\nhy : 0 \u2264 x\u271d\u2075 i\n\u22a2 0 \u2264 x\u271d\u2074 * x\u271d\u2076 i + x\u271d\u00b3 * x\u271d\u2075 i",["positivity"]],["GroupTheory/ArchimedeanDensely.lean",209,"case intro\nG : Type u_2\ninst\u271d\u00b9 : LinearOrderedAddCommGroup G\ninst\u271d : Archimedean G\ne : G \u2243+o \u2124\nH : DenselyOrdered \u2124\nw\u271d : \u2124\nh\u271d : 0 < w\u271d \u2227 w\u271d < 1\n\u22a2 False",["omega","linarith"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",146,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : \u211d\u22650\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\n\u03b5 : \u211d\nb : E\n\u03b50 : 0 \u2264 \u03b5\nh\u03b5 : closedBall b \u03b5 \u2286 s\ny : F\nhy : y \u2208 closedBall (f b) (((\u2191f'symm.nnnorm)\u207b\u00b9 - \u2191c) * \u03b5)\nhc : \u2191c < (\u2191f'symm.nnnorm)\u207b\u00b9\nIf' : 0 < \u2191f'symm.nnnorm\nIcf' : \u2191c * \u2191f'symm.nnnorm < 1\nJf' : \u2191f'symm.nnnorm \u2260 0\n\u22a2 0 < 1 - \u2191c * \u2191f'symm.nnnorm",["linarith","aesop"]],["Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean",201,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : \u211d\u22650\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\n\u03b5 : \u211d\nb : E\n\u03b50 : 0 \u2264 \u03b5\nh\u03b5 : closedBall b \u03b5 \u2286 s\ny : F\nhy : y \u2208 closedBall (f b) (((\u2191f'symm.nnnorm)\u207b\u00b9 - \u2191c) * \u03b5)\nhc : \u2191c < (\u2191f'symm.nnnorm)\u207b\u00b9\nIf' : 0 < \u2191f'symm.nnnorm\nIcf' : \u2191c * \u2191f'symm.nnnorm < 1\nJf' : \u2191f'symm.nnnorm \u2260 0\nJcf' : 1 - \u2191c * \u2191f'symm.nnnorm \u2260 0\ng : E \u2192 E := fun x \u21a6 x + f'symm.toFun (y - f x)\nhg : g = fun x \u21a6 x + f'symm.toFun (y - f x)\nu : \u2115 \u2192 E := fun n \u21a6 g^[n] b\nhu : u = fun n \u21a6 g^[n] b\nusucc : \u2200 (n : \u2115), u (n + 1) = g (u n)\nA : \u2200 (z : E), dist (g z) z \u2264 \u2191f'symm.nnnorm * dist (f z) y\nB : \u2200 z \u2208 closedBall b \u03b5, g z \u2208 closedBall b \u03b5 \u2192 dist (f (g z)) y \u2264 \u2191c * \u2191f'symm.nnnorm * dist (f z) y\nn : \u2115\nw : E\nhw : dist w b \u2264 \u2191f'symm.nnnorm * (1 - (\u2191c * \u2191f'symm.nnnorm) ^ n) / (1 - \u2191c * \u2191f'symm.nnnorm) * dist (f b) y\n\u22a2 0 \u2264 (\u2191c * \u2191f'symm.nnnorm) ^ n",["positivity","aesop"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",58,"s t a b : \u211d\nhs : 0 < s\nht : 0 < t\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nf : \u211d \u2192 \u211d \u2192 \u211d \u2192 \u211d := fun c u x \u21a6 rexp (-c * x) * x ^ (c * (u - 1))\ne : (1 / a).IsConjExponent (1 / b)\n\u22a2 b = 1 - a",["linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",110,"x : \u211d\nhx : x \u2208 Ioi 0\ny : \u211d\nhy : y \u2208 Ioi 0\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 b = 1 - a",["linarith"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",181,"f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y\nhn : 2 \u2264 n\nhx : 0 < x\nnpos : 0 < \u2191n - 1\n\u22a2 \u2191n < \u2191n + x",["linarith","aesop"]],["Analysis/SpecialFunctions/Gamma/BohrMollerup.lean",59,"s t a b : \u211d\nhs : 0 < s\nht : 0 < t\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nf : \u211d \u2192 \u211d \u2192 \u211d \u2192 \u211d := fun c u x \u21a6 rexp (-c * x) * x ^ (c * (u - 1))\ne : (1 / a).IsConjExponent (1 / b)\nhab' : b = 1 - a\n\u22a2 0 < a * s + b * t",["positivity"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",96,"p : \u211d\nhp : p < 0\nthis : -p * log p < (1 - p) * log (1 - p)\n\u22a2 p * -log p + (1 - p) * -log (1 - p) < 0",["linarith","aesop"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",320,"q : \u2115\ntendstoTop : Tendsto (fun p \u21a6 log (\u2191q - 1) + log (1 - p) - log p) (\ud835\udcdd[>] 0) atTop\na\u271d\u00b9 : \u211d\na\u271d : 0 < a\u271d\u00b9 \u2227 a\u271d\u00b9 < 2\u207b\u00b9\n\u22a2 \u00aca\u271d\u00b9 = 0",["linarith","aesop"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",375,"q : \u2115\nqLe2 : 2 \u2264 q\np1 : \u211d\nhp1 : p1 \u2208 Icc 0 (1 - 1 / \u2191q)\np2 : \u211d\nhp2 : p2 \u2208 Icc 0 (1 - 1 / \u2191q)\np1le2 : p1 < p2\np : \u211d\nhp : p \u2208 interior (Icc 0 (1 - 1 / \u2191q))\nthis : 2 \u2264 \u2191q\nzero_le_qinv : 0 < (\u2191q)\u207b\u00b9\np_lt_1_minus_qinv : p < 1 - (\u2191q)\u207b\u00b9\n\u22a2 p < 1",["linarith"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",387,"case a\nq : \u2115\nqLe2 : 2 \u2264 q\np1 : \u211d\nhp1 : p1 \u2208 Icc 0 (1 - 1 / \u2191q)\np2 : \u211d\nhp2 : p2 \u2208 Icc 0 (1 - 1 / \u2191q)\np1le2 : p1 < p2\np : \u211d\nthis\u271d\u00b9 : 2 \u2264 \u2191q\nzero_le_qinv : 0 < (\u2191q)\u207b\u00b9\nthis\u271d : 0 < 1 - p\nhp : 0 < p \u2227 p < 1 - (\u2191q)\u207b\u00b9\nqpos : 0 < \u2191q\nthis : \u2191q * p < \u2191q - 1\n\u22a2 p < (\u2191q - 1) * (1 - p)",["linarith"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",398,"q : \u2115\nqLe2 : 2 \u2264 q\np1 : \u211d\nhp1 : p1 \u2208 Icc (1 - 1 / \u2191q) 1\np2 : \u211d\nhp2 : p2 \u2208 Icc (1 - 1 / \u2191q) 1\np1le2 : p1 < p2\np : \u211d\nhp : p \u2208 interior (Icc (1 - 1 / \u2191q) 1)\nthis : 2 \u2264 \u2191q\n\u22a2 1 < \u2191q",["linarith","aesop"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",406,"case x\nq : \u2115\nqLe2 : 2 \u2264 q\np1 : \u211d\nhp1 : p1 \u2208 Icc (1 - 1 / \u2191q) 1\np2 : \u211d\nhp2 : p2 \u2208 Icc (1 - 1 / \u2191q) 1\np1le2 : p1 < p2\np : \u211d\nthis : 2 \u2264 \u2191q\nqinv_lt_1 : (\u2191q)\u207b\u00b9 < 1\nzero_lt_1_sub_p : 0 < 1 - p\nhp : 1 - (\u2191q)\u207b\u00b9 < p \u2227 p < 1\n\u22a2 0 < p",["linarith"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",84,"p : \u211d\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\nthis\u271d\u00b9 : 0 < 1 - p\nthis\u271d : 0 < log p\u207b\u00b9\nthis : 0 < log (1 - p)\u207b\u00b9\n\u22a2 0 < p * log p\u207b\u00b9 + (1 - p) * log (1 - p)\u207b\u00b9",["positivity"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",216,"q : \u2115\np : \u211d\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\nthis : 0 < binEntropy p\n\u22a2 0 < p * log \u2191(\u2191q - 1) + binEntropy p",["positivity"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",370,"q : \u2115\nqLe2 : 2 \u2264 q\np1 : \u211d\nhp1 : p1 \u2208 Icc 0 (1 - 1 / \u2191q)\np2 : \u211d\nhp2 : p2 \u2208 Icc 0 (1 - 1 / \u2191q)\np1le2 : p1 < p2\np : \u211d\nhp : p \u2208 interior (Icc 0 (1 - 1 / \u2191q))\nthis : 2 \u2264 \u2191q\n\u22a2 0 < (\u2191q)\u207b\u00b9",["positivity"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",382,"q : \u2115\nqLe2 : 2 \u2264 q\np1 : \u211d\nhp1 : p1 \u2208 Icc 0 (1 - 1 / \u2191q)\np2 : \u211d\nhp2 : p2 \u2208 Icc 0 (1 - 1 / \u2191q)\np1le2 : p1 < p2\np : \u211d\nthis\u271d : 2 \u2264 \u2191q\nzero_le_qinv : 0 < (\u2191q)\u207b\u00b9\nthis : 0 < 1 - p\nhp : 0 < p \u2227 p < 1 - (\u2191q)\u207b\u00b9\n\u22a2 0 < \u2191q",["positivity","aesop","linarith"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",407,"q : \u2115\nqLe2 : 2 \u2264 q\np1 : \u211d\nhp1 : p1 \u2208 Icc (1 - 1 / \u2191q) 1\np2 : \u211d\nhp2 : p2 \u2208 Icc (1 - 1 / \u2191q) 1\np1le2 : p1 < p2\np : \u211d\nthis : 2 \u2264 \u2191q\nqinv_lt_1 : (\u2191q)\u207b\u00b9 < 1\nzero_lt_1_sub_p : 0 < 1 - p\nhp : 1 - (\u2191q)\u207b\u00b9 < p \u2227 p < 1\n\u22a2 0 < \u2191q",["positivity","linarith"]],["MeasureTheory/Decomposition/SignedHahn.lean",401,"\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\ns : SignedMeasure \u03b1\nf : \u2115 \u2192 \u211d\nleft\u271d : Antitone f\nhf\u2082 : Tendsto f atTop (nhds (sInf s.measureOfNegatives))\nB : \u2115 \u2192 Set \u03b1\nhB : \u2200 (n : \u2115), B n \u2208 {B | MeasurableSet B \u2227 s \u2264[B] 0} \u2227 \u2191s (B n) = f n\nhB\u2081 : \u2200 (n : \u2115), MeasurableSet (B n)\nhB\u2082 : \u2200 (n : \u2115), s \u2264[B n] 0\nA : Set \u03b1 := \u22c3 n, B n\nhA : A = \u22c3 n, B n\nhA\u2081 : MeasurableSet A\nhA\u2082 : s \u2264[A] 0\nhA\u2083 : \u2191s A = sInf s.measureOfNegatives\nC : Set \u03b1\na\u271d : MeasurableSet C\nhC\u2081 : C \u2286 A\u1d9c\nhC\u2082 : \u2191s C < \u21910 C\nD : Set \u03b1\nhD\u2081 : MeasurableSet D\nhD : D \u2286 C\nhD\u2082 : s \u2264[D] 0\nhD\u2083 : \u2191s D < 0\n\u22a2 \u2191s A + \u2191s D < \u2191s A",["linarith","aesop"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",224,"case pos\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsSFiniteKernel (\u03ba n)\na b k : \u2115\nh : a \u2264 k\nhk : partialTraj \u03ba a k = (Kernel.id \u00d7\u2096 (partialTraj \u03ba a k).map (restrict\u2082 \u22ef)).map (_root_.IicProdIoc a k)\nx :\n  (((i : { x // x \u2208 Iic a }) \u2192 X \u2191i) \u00d7 ((i : { x // x \u2208 Ioc a k }) \u2192 X \u2191i)) \u00d7 ((i : { x // x \u2208 Ioc k (k + 1) }) \u2192 X \u2191i)\ni : { x // x \u2208 Iic (k + 1) }\nh\u271d\u00b9 : \u00ac\u2191i \u2264 k\nh\u271d : \u2191i \u2264 a\n\u22a2 x.2 \u27e8\u2191i, \u22ef\u27e9 = (prodAssoc x).1 \u27e8\u2191i, \u22ef\u27e9",["omega","linarith"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",385,"case h.refine_2\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nc : \u2115\nf : ((n : \u2115) \u2192 X n) \u2192 \u211d\u22650\u221e\nmf : Measurable f\nx : (n : \u2115) \u2192 X n\ny : (i : { x // x \u2208 Ioc b c }) \u2192 X \u2191i\ni : \u2115\nhf : DependsOn f (Set.Iic a)\nhab : a \u2264 b\nhi : i \u2264 a\n\u22a2 \u2200 (h : b < i \u2227 i \u2264 c), y \u27e8i, \u22ef\u27e9 = x i",["omega"]],["LinearAlgebra/Reflection.lean",185,"R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nf g : Dual R M\nhf : f x = 2\nhg : g y = 2\nz : M\nt : optParam R (f y * g x - 2)\nht : autoParam (t = f y * g x - 2) _auto\u271d\nm : \u2115\nS_eval_t_sub_two :\n  \u2200 (k : \u2124), Polynomial.eval t (S R (k - 2)) = t * Polynomial.eval t (S R (k - 1)) - Polynomial.eval t (S R k)\nS_eval_t_sq_add_S_eval_t_sq :\n  \u2200 (k : \u2124),\n    Polynomial.eval t (S R k) ^ 2 + Polynomial.eval t (S R (k + 1)) ^ 2 -\n        t * Polynomial.eval t (S R k) * Polynomial.eval t (S R (k + 1)) =\n      1\nk : \u2124 := \u2191m / 2\nih :\n  ((reflection hf * reflection hg) ^ m) z =\n    z +\n        (Polynomial.eval t (S R ((\u2191m - 2) / 2)) *\n            (Polynomial.eval t (S R ((\u2191m - 1) / 2)) + Polynomial.eval t (S R ((\u2191m - 3) / 2)))) \u2022\n          ((g x * f z - g z) \u2022 y - f z \u2022 x) +\n      (Polynomial.eval t (S R ((\u2191m - 1) / 2)) * (Polynomial.eval t (S R k) + Polynomial.eval t (S R ((\u2191m - 2) / 2)))) \u2022\n        ((f y * g z - f z) \u2022 x - g z \u2022 y)\ne : \u2124 := \u2191m % 2\n\u22a2 e = 0 \u2228 e = 1",["omega"]],["LinearAlgebra/Reflection.lean",229,"R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\nf g : Dual R M\nhf : f x = 2\nhg : g y = 2\nz : M\nt : optParam R (f y * g x - 2)\nht : autoParam (t = f y * g x - 2) _auto\u271d\na\u271d :\n  \u2200 (n : \u2115),\n    ((reflection hf * reflection hg) ^ \u2191n) z =\n      z +\n          (Polynomial.eval t (S R ((\u2191n - 2) / 2)) *\n              (Polynomial.eval t (S R ((\u2191n - 1) / 2)) + Polynomial.eval t (S R ((\u2191n - 3) / 2)))) \u2022\n            ((g x * f z - g z) \u2022 y - f z \u2022 x) +\n        (Polynomial.eval t (S R ((\u2191n - 1) / 2)) *\n            (Polynomial.eval t (S R (\u2191n / 2)) + Polynomial.eval t (S R ((\u2191n - 2) / 2)))) \u2022\n          ((f y * g z - f z) \u2022 x - g z \u2022 y)\nm : \u2115\nht' : t = g x * f y - 2\na b : \u2124\nhab : autoParam (a + b = -3) _auto\u271d\n\u22a2 a / 2 = -(b / 2) - 2",["omega"]],["MeasureTheory/Function/ContinuousMapDense.lean",209,"\u03b1 : Type u_1\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : NormalSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : BorelSpace \u03b1\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : R1Space \u03b1\ninst\u271d\u00b9 : WeaklyLocallyCompactSpace \u03b1\ninst\u271d : \u03bc.Regular\np : \u211d\nhp : 0 < p\nf : \u03b1 \u2192 E\nhf : MemLp f (ENNReal.ofReal p) \u03bc\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nI : 0 < \u03b5 ^ (1 / p)\nA : ENNReal.ofReal (\u03b5 ^ (1 / p)) \u2260 0\nB : ENNReal.ofReal p \u2260 0\ng : \u03b1 \u2192 E\ng_support : HasCompactSupport g\ng_cont : Continuous g\ng_mem : MemLp g (\u2191p.toNNReal) \u03bc\nhg : (\u222b (a : \u03b1), \u2016(f - g) a\u2016 ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2264 \u03b5 ^ p\u207b\u00b9\n\u22a2 0 \u2264 \u222b (a : \u03b1), \u2016(f - g) a\u2016 ^ p \u2202\u03bc",["positivity"]],["MeasureTheory/Function/ContinuousMapDense.lean",306,"\u03b1 : Type u_1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : NormalSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : \u03bc.WeaklyRegular\np : \u211d\nhp : 0 < p\nf : \u03b1 \u2192 E\nhf : MemLp f (ENNReal.ofReal p) \u03bc\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nI : 0 < \u03b5 ^ (1 / p)\nA : ENNReal.ofReal (\u03b5 ^ (1 / p)) \u2260 0\nB : ENNReal.ofReal p \u2260 0\ng : \u03b1 \u2192\u1d47 E\ng_mem : MemLp (\u21d1g) (\u2191p.toNNReal) \u03bc\nhg : (\u222b (a : \u03b1), \u2016(f - \u21d1g) a\u2016 ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2264 \u03b5 ^ p\u207b\u00b9\n\u22a2 0 \u2264 \u222b (a : \u03b1), \u2016(f - \u21d1g) a\u2016 ^ p \u2202\u03bc",["positivity"]],["Analysis/SpecialFunctions/Exp.lean",126,"a \u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nthis : \u2200 (a : \u2102) (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2200\u1da0 (x : \u2102) in \ud835\udcdd a, dist (cexp x) (cexp a) < \u03b5\n\u22a2 0 < \u03b5 / (2 * Real.exp a)",["positivity"]],["MeasureTheory/Function/ConditionalExpectation/Real.lean",96,"case neg\n\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhm : \u00acm \u2264 m0\n\u22a2 0 \u2264 \u222b (x : \u03b1), |f x| \u2202\u03bc",["positivity"]],["MeasureTheory/Function/ConditionalExpectation/Real.lean",101,"case neg\n\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhm : m \u2264 m0\nhfint : \u00acIntegrable f \u03bc\n\u22a2 0 \u2264 \u222b (x : \u03b1), |f x| \u2202\u03bc",["positivity"]],["MeasureTheory/Function/ConditionalExpectation/Real.lean",121,"case neg\n\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\nf : \u03b1 \u2192 \u211d\nhnm : \u00acm \u2264 m0\n\u22a2 0 \u2264 \u222b (x : \u03b1) in s, |f x| \u2202\u03bc",["positivity"]],["MeasureTheory/Function/ConditionalExpectation/Real.lean",126,"case neg\n\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\nf : \u03b1 \u2192 \u211d\nhnm : m \u2264 m0\nhfint : \u00acIntegrable f \u03bc\n\u22a2 0 \u2264 \u222b (x : \u03b1) in s, |f x| \u2202\u03bc",["positivity"]],["NumberTheory/Harmonic/ZetaAsymp.lean",62,"n : \u2115\nhn : 0 < n\ns : \u211d\nhs : 0 < s\nx : \u211d\nhx : x \u2208 Icc (\u2191n) (\u2191n + 1)\n\u22a2 0 \u2264 s + 1",["linarith","positivity"]],["NumberTheory/Harmonic/ZetaAsymp.lean",216,"s : \u211d\nhs : 1 < s\n\u22a2 0 \u2264 s - 1",["linarith"]],["NumberTheory/Harmonic/ZetaAsymp.lean",262,"n : \u2115\ns : \u211d\nhs : 1 \u2264 s\nx : \u211d\nhx : x \u2208 Ioc (\u2191(n + 1)) (\u2191(n + 1) + 1)\nthis : 0 < x\n\u22a2 2 \u2264 s + 1",["linarith"]],["NumberTheory/Harmonic/ZetaAsymp.lean",219,"case hgf\ns : \u211d\nhs : 1 < s\nn : \u2115\n\u22a2 (fun x \u21a6 0) n \u2264 (fun k \u21a6 \u2191k / (\u2191k + 1) ^ s) n",["positivity"]],["GroupTheory/Perm/Cycle/Concrete.lean",60,"case mp\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\nhl : l.Nodup\nhl' : l'.Nodup\nhn : 2 \u2264 l.length\nhn' : 2 \u2264 l'.length\nx : \u03b1\nhx : x \u2208 l\nhx' : x \u2208 l'\nh : l.length \u2264 1 \u2228 l'.length \u2264 1\n\u22a2 False",["omega"]],["Data/Int/Init.lean",39,"a b : \u2124\n\u22a2 a \u2264 b \u2194 a = b \u2228 a < b",["omega"]],["Data/Int/Init.lean",94,"n : \u2115\n\u22a2 \u2191n = 0 \u2194 n = 0",["omega"]],["Data/Int/Init.lean",98,"n : \u2115\n\u22a2 \u2191n \u2260 0 \u2194 0 < n",["omega"]],["Data/Int/Init.lean",159,"a : \u2124\n\u22a2 a < a + 1",["omega"]],["Data/Int/Init.lean",161,"a : \u2124\n\u22a2 a - 1 < a",["omega"]],["Data/Int/Init.lean",163,"m n : \u2124\n\u22a2 m \u2264 n + 1 \u2194 m \u2264 n \u2228 m = n + 1",["omega"]],["Data/Int/Init.lean",165,"m n : \u2124\n\u22a2 m - 1 < n \u2194 m \u2264 n",["omega"]],["Data/Int/Init.lean",167,"m n : \u2124\n\u22a2 m \u2264 n - 1 \u2194 m < n",["omega"]],["Data/Int/Init.lean",229,"a b\u271d c d m n\u271d : \u2124\nC : \u2124 \u2192 Sort u_1\nz b : \u2124\nH0 : C b\nHs : (k : \u2124) \u2192 b \u2264 k \u2192 C k \u2192 C (k + 1)\nHp : (k : \u2124) \u2192 k \u2264 b \u2192 C k \u2192 C (k - 1)\nn : \u2115\n\u22a2 b + -[n+1] < b",["omega"]],["Data/Int/Init.lean",239,"C : \u2124 \u2192 Sort u_1\nz b : \u2124\nH0 : C b\nHs : (k : \u2124) \u2192 b \u2264 k \u2192 C k \u2192 C (k + 1)\nHp : (k : \u2124) \u2192 k \u2264 b \u2192 C k \u2192 C (k - 1)\nhz : z \u2264 b\n\u22a2 z - 1 - b < 0",["omega"]],["Data/Int/Init.lean",243,"C : \u2124 \u2192 Sort u_1\nz b : \u2124\nH0 : C b\nHs : (k : \u2124) \u2192 b \u2264 k \u2192 C k \u2192 C (k + 1)\nHp : (k : \u2124) \u2192 k \u2264 b \u2192 C k \u2192 C (k - 1)\nhz : z \u2264 b\nhn : z - 1 - b = -1\n\u22a2 z = b",["omega"]],["Data/Int/Init.lean",245,"C : \u2124 \u2192 Sort u_1\nz b : \u2124\nH0 : C b\nHs : (k : \u2124) \u2192 b \u2264 k \u2192 C k \u2192 C (k + 1)\nHp : (k : \u2124) \u2192 k \u2264 b \u2192 C k \u2192 C (k - 1)\nhz : z \u2264 b\nn : \u2115\nhn : z - 1 - b = -(\u2191(n + 1) + 1)\n\u22a2 z = b + -(\u2191n + 1)",["omega"]],["Data/Int/Init.lean",269,"case refine_3\nP : \u2124 \u2192 Prop\nm : \u2124\nh0 : P m\nh1 : \u2200 (n : \u2124), m \u2264 n \u2192 P n \u2192 P (n + 1)\nn k : \u2124\nhle : k \u2264 m\na\u271d : m \u2264 k \u2192 P k\nhle' : m \u2264 k - 1\n\u22a2 P (k - 1)",["omega"]],["Data/Int/Init.lean",274,"P : \u2124 \u2192 Prop\nm : \u2124\nh0 : P m\nh1 : \u2200 (n : \u2124), n \u2264 m \u2192 P n \u2192 P (n - 1)\nn k : \u2124\nhle : m \u2264 k\nx\u271d : k \u2264 m \u2192 P k\nhle' : k + 1 \u2264 m\n\u22a2 P (k + 1)",["omega"]],["Data/Int/Init.lean",286,"a b c d m n\u271d : \u2124\nP : \u2124 \u2192 Sort u_1\nlt : (n : \u2124) \u2192 n < m \u2192 P n\nge : (n : \u2124) \u2192 n \u2265 m \u2192 ((k : \u2124) \u2192 k < n \u2192 P k) \u2192 P n\nn : \u2124\nhnm : \u00acn < m\n_n : \u2124\na\u271d\u00b9 : m \u2264 _n\nih : (k : \u2124) \u2192 k < _n \u2192 P k\nl : \u2124\na\u271d : l < _n + 1\nhlm : \u00acl < m\nk : \u2124\nx\u271d : k < l\n\u22a2 k < _n",["omega"]],["Data/Int/Init.lean",287,"a b c d m n\u271d\u00b9 : \u2124\nP : \u2124 \u2192 Sort u_1\nlt : (n : \u2124) \u2192 n < m \u2192 P n\nge : (n : \u2124) \u2192 n \u2265 m \u2192 ((k : \u2124) \u2192 k < n \u2192 P k) \u2192 P n\nn\u271d : \u2124\nhnm : \u00acn\u271d < m\nn : \u2124\nx\u271d\u00b9 : n \u2264 m\nhn : (k : \u2124) \u2192 k < n \u2192 P k\nl : \u2124\nx\u271d : l < n - 1\n\u22a2 l < n",["omega"]],["Data/Int/Init.lean",304,"a b : \u2124\nha : a \u2264 0\nhb : b \u2264 0\n\u22a2 (a + b).natAbs = a.natAbs + b.natAbs",["omega"]],["Data/Int/Init.lean",339,"i : \u2124\n\u22a2 -i % 2 = i % 2",["omega"]],["Data/Int/Init.lean",343,"n : \u2124\n\u22a2 n % 2 = 0 \u2228 n % 2 = 1",["omega"]],["Data/Int/Init.lean",394,"n : \u2124\nhn : 0 < n\nk l : \u2124\nh1k : n * k < n * l\nh2k : n * l < n * (k + 1)\n\u22a2 0 \u2264 n",["omega"]],["Data/Int/Init.lean",395,"n : \u2124\nhn : 0 < n\nk l : \u2124\nh2k : n * l < n * (k + 1)\nh1k : k < l\n\u22a2 0 \u2264 n",["omega"]],["Data/Int/Init.lean",402,"case refine_2.refine_1\nn m : \u2124\nhn : 0 < n\nh : m % n \u2260 0\nthis : 0 \u2264 m % n\n\u22a2 0 < m % n",["omega"]],["Data/Int/Init.lean",463,"case ofNat.succ.ofNat.succ\nthis : 1 \u2260 -1\nm n : \u2115\n\u22a2 0 < \u2191m + 1 + (\u2191n + 1)",["omega"]],["Data/Int/Init.lean",494,"m : \u2124\nn : \u2115\nhn : n \u2260 0\n\u22a2 0 < \u2191n",["omega"]],["Data/Int/Init.lean",500,"m : \u2124\nn : \u2115\nhn : n \u2260 0\n\u22a2 0 < \u2191n",["omega"]],["Probability/Moments/Basic.lean",161,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt : \u211d\n\u22a2 0 \u2264 \u222b (x : \u03a9), (fun \u03c9 \u21a6 rexp (t * X \u03c9)) x \u2202\u03bc",["positivity"]],["Analysis/SpecialFunctions/Log/Base.lean",118,"b : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\n\u22a2 b \u2260 0",["linarith","aesop","positivity"]],["Analysis/SpecialFunctions/Log/Base.lean",119,"b : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nb_ne_zero : b \u2260 0\n\u22a2 b \u2260 -1",["linarith"]],["Analysis/SpecialFunctions/Log/Base.lean",173,"b : \u211d\nhb : 1 < b\n\u22a2 0 < b",["linarith","positivity"]],["Analysis/SpecialFunctions/Log/Base.lean",176,"b : \u211d\nhb : 1 < b\n\u22a2 b \u2260 1",["linarith","aesop"]],["Analysis/SpecialFunctions/Log/Base.lean",268,"b : \u211d\nb_lt_one : b < 1\n\u22a2 b \u2260 1",["linarith","aesop"]],["Probability/Variance.lean",383,"\u03a9 : Type u_1\nm\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsProbabilityMeasure \u03bc\na b : \u211d\nX : \u03a9 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b\nhX : AEMeasurable X \u03bc\nha : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, a \u2264 X \u03c9\nhb : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, X \u03c9 \u2264 b\nhX_int\u2082 : Integrable (fun \u03c9 \u21a6 -X \u03c9 ^ 2) \u03bc\nhX_int\u2081 : Integrable (fun \u03c9 \u21a6 (a + b) * X \u03c9) \u03bc\nh0 : 0 \u2264 -\u222b (x : \u03a9), (X ^ 2) x \u2202\u03bc + (a + b) * \u222b (x : \u03a9), X x \u2202\u03bc - a * b\n\u22a2 \u222b (x : \u03a9), (X ^ 2) x \u2202\u03bc - (\u222b (x : \u03a9), X x \u2202\u03bc) ^ 2 \u2264 (a + b) * \u222b (x : \u03a9), X x \u2202\u03bc - a * b - (\u222b (x : \u03a9), X x \u2202\u03bc) ^ 2",["linarith"]],["Combinatorics/SetFamily/AhlswedeZhang.lean",358,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nh\ud835\udc9c : IsAntichain (fun x1 x2 \u21a6 x1 \u2286 x2) \u2191\ud835\udc9c\nh\ud835\udc9c\u2080 : \u2205 \u2209 \ud835\udc9c\ns : Finset \u03b1\n\u22a2 0 \u2264 \u2191(#(\ud835\udc9c.truncatedInf s)) / (\u2191(#s) * \u2191((card \u03b1).choose #s))",["positivity"]],["Combinatorics/SetFamily/AhlswedeZhang.lean",362,"case ha\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nh\ud835\udc9c : IsAntichain (fun x1 x2 \u21a6 x1 \u2286 x2) \u2191\ud835\udc9c\nh\ud835\udc9c\u2080 : \u2205 \u2209 \ud835\udc9c\ns : Finset \u03b1\nhs : s \u2208 \ud835\udc9c\nthis : 0 < #s\n\u22a2 \u2191(#s) \u2260 0",["positivity"]],["Combinatorics/SetFamily/KruskalKatona.lean",379,"n : \u2115\n\ud835\udc9c : Finset (Finset (Fin n))\nr : \u2115\nh\ud835\udc9c : (\u2191\ud835\udc9c).Intersecting\nh\u2082 : Set.Sized r \u2191\ud835\udc9c\nh\u2083 : r \u2264 n / 2\nh1r : r > 0\nsize : (n - 1).choose (r - 1) < #\ud835\udc9c\nthis\u271d\u00b2 : Disjoint \ud835\udc9c (\u2202 ^[n - 2 * r] \ud835\udc9c\u1d9c\u02e2)\nthis\u271d\u00b9 : r \u2264 n\nthis\u271d : 1 \u2264 n\nz : (n - 1).choose (n - r) < #\ud835\udc9c\u1d9c\u02e2\nh\ud835\udc9cbar : Set.Sized (n - r) \u2191\ud835\udc9c\u1d9c\u02e2\nthis : n - 2 * r \u2264 n - r\nkk : (n - 1).choose (n - r - (n - 2 * r)) \u2264 #(\u2202 ^[n - 2 * r] \ud835\udc9c\u1d9c\u02e2)\n\u22a2 n - r - (n - 2 * r) = r",["omega"]],["Combinatorics/SetFamily/KruskalKatona.lean",393,"case h.e'_2\nn : \u2115\n\ud835\udc9c : Finset (Finset (Fin n))\nr : \u2115\nh\ud835\udc9c : (\u2191\ud835\udc9c).Intersecting\nh\u2082 : Set.Sized r \u2191\ud835\udc9c\nh\u2083 : r \u2264 n / 2\nh1r : r > 0\nsize : (n - 1).choose (r - 1) < #\ud835\udc9c\nthis\u271d\u2074 : Disjoint \ud835\udc9c (\u2202 ^[n - 2 * r] \ud835\udc9c\u1d9c\u02e2)\nthis\u271d\u00b3 : r \u2264 n\nthis\u271d\u00b2 : 1 \u2264 n\nz : (n - 1).choose (n - r) < #\ud835\udc9c\u1d9c\u02e2\nh\ud835\udc9cbar : Set.Sized (n - r) \u2191\ud835\udc9c\u1d9c\u02e2\nthis\u271d\u00b9 : n - 2 * r \u2264 n - r\nkk : (n - 1).choose r \u2264 #(\u2202 ^[n - 2 * r] \ud835\udc9c\u1d9c\u02e2)\nthis\u271d : n - r - (n - 2 * r) = r\nthis : n.choose r < #(\ud835\udc9c \u222a \u2202 ^[n - 2 * r] \ud835\udc9c\u1d9c\u02e2)\n\u22a2 r = n - r - (n - 2 * r)",["omega"]],["RingTheory/Polynomial/Eisenstein/IsIntegral.lean",320,"case h.e'_4.h.e'_6.h.e'_6.h\nR : Type u\nK : Type v\nL : Type z\np : R\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : Field K\ninst\u271d\u2078 : Field L\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra R L\ninst\u271d\u2075 : Algebra R K\ninst\u271d\u2074 : IsScalarTower R K L\ninst\u271d\u00b3 : Algebra.IsSeparable K L\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsFractionRing R K\ninst\u271d : IsIntegrallyClosed R\nB : PowerBasis K L\nhp : _root_.Prime p\nhBint : IsIntegral R B.gen\nz : L\nhzint : IsIntegral R z\nthis\u271d\u00b9 : Module.Finite K L\nP : R[X] := minpoly R B.gen\nhei : P.IsEisensteinAt (Submodule.span R {p})\nhndiv : \u00acp ^ 2 \u2223 P.coeff 0\nhP : P = minpoly R B.gen\nn : \u2115\nhn : B.dim = n.succ\nthis\u271d : NoZeroSMulDivisors R L\nx\u271d : L[X] := Polynomial.map (algebraMap R L) P\nQ\u2081 : R[X]\nQ : R[X] := Q\u2081 %\u2098 P\nhQ\u2081 : Q = Q\u2081 %\u2098 P\nhQ : (aeval B.gen) Q = p \u2022 z\nhQzero : \u00acQ = 0\nj : \u2115\nhj : j + 1 \u2208 range (Q.natDegree + 1)\nH : j + 1 + 1 \u2264 P.natDegree\nHj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j)\ng : \u2115 \u2192 R\nhg : \u2200 k \u2208 range (j + 1), Q.coeff k \u2022 B.gen ^ k = (algebraMap R L) p * g k \u2022 B.gen ^ k\nf : \u2115 \u2192 L\nhf :\n  \u2200 (i : \u2115),\n    (Polynomial.map (algebraMap R L) (minpoly R B.gen)).natDegree \u2264 i \u2192\n      f i \u2208 adjoin R {B.gen} \u2227 (algebraMap R L) p * f i = B.gen ^ i\nhf\u2081 :\n  \u2200 k \u2208 (range (Q.natDegree - j)).erase 0,\n    Q.coeff (j + 1 + k) \u2022 B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =\n      (algebraMap R L) p * Q.coeff (j + 1 + k) \u2022 f (k + P.natDegree - 1)\nthis : p ^ n.succ \u2223 Q.coeff j.succ ^ n.succ * (minpoly R B.gen).coeff 0 ^ (j.succ + (P.natDegree - (j + 2)))\n\u22a2 j + 1 \u2264 P.natDegree",["omega","linarith"]],["Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",214,"b : \u2102\nhb : 0 < b.re\n\u22a2 0 \u2264 \u03c0 + \u03c0",["positivity"]],["RingTheory/Polynomial/Pochhammer.lean",450,"case inl\nS : Type u_1\ninst\u271d : StrictOrderedRing S\nn : \u2115\ns : S\nh : \u2191n - 1 \u2264 s\nheq : \u2191n - 1 = s\n\u22a2 0 \u2264 if n = 0 then 1 else 0",["positivity","aesop"]],["NumberTheory/Padics/MahlerBasis.lean",182,"p : \u2115\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211a_[p] E\ninst\u271d : IsUltrametricDist E\nf : C(\u2124_[p], E)\ns t : \u2115\nhst : \u2200 (x y : \u2124_[p]), \u2016x - y\u2016 \u2264 \u2191p ^ (-\u2191t) \u2192 \u2016f x - f y\u2016 \u2264 \u2016f\u2016 / \u2191p ^ s\nn i : \u2115\nhi : i < p ^ t - 1\n\u22a2 i + 1 \u2264 p ^ t",["omega"]],["NumberTheory/Padics/MahlerBasis.lean",187,"p : \u2115\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211a_[p] E\ninst\u271d : IsUltrametricDist E\nf : C(\u2124_[p], E)\ns t : \u2115\nhst : \u2200 (x y : \u2124_[p]), \u2016x - y\u2016 \u2264 \u2191p ^ (-\u2191t) \u2192 \u2016f x - f y\u2016 \u2264 \u2016f\u2016 / \u2191p ^ s\nn i : \u2115\nhi : i < p ^ t - 1\nthis : 0 < (p ^ t).choose (i + 1)\n\u22a2 i + 1 \u2260 p ^ t",["omega"]],["NumberTheory/Padics/MahlerBasis.lean",218,"p : \u2115\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211a_[p] E\ninst\u271d : IsUltrametricDist E\nf : C(\u2124_[p], E)\ns t : \u2115\nhst : \u2200 (x y : \u2124_[p]), \u2016x - y\u2016 \u2264 \u2191p ^ (-\u2191t) \u2192 \u2016f x - f y\u2016 \u2264 \u2016f\u2016 / \u2191p ^ s\nk : \u2115\nIH : \u2200 (n : \u2115), k \u2264 s \u2192 \u2016\u0394_[1]^[n + k * p ^ t] (\u21d1f) 0\u2016 \u2264 \u2016f\u2016 / \u2191p ^ k\nn : \u2115\nhk : k + 1 \u2264 s\nj : \u2115\nx\u271d : j \u2208 range (p ^ t - 1)\n\u22a2 k \u2264 s",["omega","linarith"]],["NumberTheory/Padics/MahlerBasis.lean",287,"p : \u2115\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211a_[p] E\ninst\u271d\u00b9 : IsUltrametricDist E\ninst\u271d : CompleteSpace E\na : \u2115 \u2192 E\nha : Tendsto a atTop (\ud835\udcdd 0)\nm n : \u2115\nhmn : m \u2264 n\ni : \u2115\n\u22a2 m < i + (n + 1)",["omega","linarith"]],["Combinatorics/SimpleGraph/Regularity/Uniform.lean",270,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \ud835\udd5c\nhP : P.IsEquipartition\nh\u03b5 : 0 \u2264 \u03b5\ni : Finset \u03b1 \u00d7 Finset \u03b1\nx\u271d\u00b9 : i \u2208 P.parts.offDiag\nx\u271d : i \u2209 P.sparsePairs G \u03b5\n\u22a2 0 \u2264 \u03b5 * (\u2191(#i.1) * \u2191(#i.2))",["positivity"]],["Combinatorics/SimpleGraph/Regularity/Uniform.lean",338,"case inr\n\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \ud835\udd5c\ninst\u271d : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\n\u03b5 : \ud835\udd5c\nh\u03b5 : 0 < \u03b5\nhP : P.IsEquipartition\nhP' : 4 / \u03b5 \u2264 \u2191(#P.parts)\nhA : A.Nonempty\nthis : \u2191(#A) + \u2191(#P.parts) \u2264 2 * \u2191(#A)\n\u22a2 0 < \u03b5 / 4",["positivity","aesop"]],["Combinatorics/SimpleGraph/Regularity/Uniform.lean",347,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \ud835\udd5c\nhA : A.Nonempty\nh\u03b5 : 0 < \u03b5\nhP : P.IsEquipartition\nhG : P.IsUniform G \u03b5\n\u22a2 0 \u2264 \u2191(#A / #P.parts + 1) ^ 2",["positivity"]],["Analysis/ODE/PicardLindelof.lean",379,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : E \u2192 E\nt\u2080 : \u211d\nx\u2080 : E\nhv : ContDiffAt \u211d 1 v x\u2080\nL : \u211d\u22650\ns : Set E\nhs : s \u2208 \ud835\udcdd x\u2080\nhlip : LipschitzOnWith L v s\nR\u2081 : \u211d\nhR\u2081 : 0 < R\u2081\nhball : ball x\u2080 R\u2081 \u2286 s\nR\u2082 : \u211d\nhR\u2082 : 0 < R\u2082\nhbdd : \u2200 \u2983x : E\u2984, dist x x\u2080 < R\u2082 \u2192 dist \u2016v x\u2016 \u2016v x\u2080\u2016 < 1\nhbdd' : \u2200 x \u2208 ball x\u2080 R\u2082, \u2016v x\u2016 \u2264 1 + \u2016v x\u2080\u2016\n\u03b5 : \u211d := (R\u2081 \u2293 R\u2082) / 2 / (1 + \u2016v x\u2080\u2016)\nh\u03b5 : \u03b5 = (R\u2081 \u2293 R\u2082) / 2 / (1 + \u2016v x\u2080\u2016)\nh\u03b50 : 0 < \u03b5\n\u22a2 0 \u2264 (R\u2081 \u2293 R\u2082) / 2",["positivity"]],["MeasureTheory/Function/LpSeminorm/CompareExp.lean",258,"\u03b1 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedAddCommGroup G\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\np q r : \u211d\u22650\u221e\nhf : AEStronglyMeasurable f \u03bc\nhg : AEStronglyMeasurable g \u03bc\nb : E \u2192 F \u2192 G\nc : \u211d\u22650\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016b (f x) (g x)\u2016\u208a \u2264 c * \u2016f x\u2016\u208a * \u2016g x\u2016\u208a\nhpqr\u271d : p.HolderTriple q r\nhpqr : 1 / r = 1 / p + 1 / q\nhp : 0 < p.toReal\nhq : 0 < q.toReal\nhp\u2081 : 0 < p\nhp\u2082 : p < \u22a4\nhq\u2081 : 0 < q\nhq\u2082 : q < \u22a4\nhpqr' : 1 / r.toReal = 1 / p.toReal + 1 / q.toReal\n\u22a2 0 < 1 / p.toReal + 1 / q.toReal",["positivity"]],["MeasureTheory/Function/LpSeminorm/CompareExp.lean",261,"\u03b1 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedAddCommGroup G\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\np q r : \u211d\u22650\u221e\nhf : AEStronglyMeasurable f \u03bc\nhg : AEStronglyMeasurable g \u03bc\nb : E \u2192 F \u2192 G\nc : \u211d\u22650\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016b (f x) (g x)\u2016\u208a \u2264 c * \u2016f x\u2016\u208a * \u2016g x\u2016\u208a\nhpqr\u271d : p.HolderTriple q r\nhpqr : 1 / r = 1 / p + 1 / q\nhp : 0 < p.toReal\nhq : 0 < q.toReal\nhp\u2081 : 0 < p\nhp\u2082 : p < \u22a4\nhq\u2081 : 0 < q\nhq\u2082 : q < \u22a4\nhpqr' : 1 / r.toReal = 1 / p.toReal + 1 / q.toReal\nhr : 0 < r.toReal\nhr\u2081 : 0 < r\nhr\u2082 : r < \u22a4\n\u22a2 0 < 1 / q.toReal",["positivity","aesop"]],["Data/Nat/ModEq.lean",210,"m a b : \u2115\nh1 : a \u2261 b [MOD m]\nh2 : a < b\n\u22a2 a + m < b + m",["omega","aesop"]],["Data/Nat/Factorial/Basic.lean",129,"n : \u2115\nhi : 3 \u2264 n\n\u22a2 0 < n",["omega"]],["Analysis/SpecialFunctions/Trigonometric/Inverse.lean",384,"case mp\nx : \u211d\na\u271d : \u03c0 / 2 - arcsin x \u2264 \u03c0 / 4\n\u22a2 \u03c0 / 4 \u2264 arcsin x\n```\n---\n```lean\ncase mpr\nx : \u211d\na\u271d : \u03c0 / 4 \u2264 arcsin x\n\u22a2 \u03c0 / 2 - arcsin x \u2264 \u03c0 / 4",["linarith"]],["Analysis/Normed/Unbundled/SeminormFromBounded.lean",100,"case inr\nR : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\nx : R\nhx : 0 < f x\nhc : 0 \u2264 c\n\u22a2 0 \u2264 c * f x",["positivity","aesop"]],["NumberTheory/FermatPsp.lean",305,"b : \u2115\nb_ge_two : 2 \u2264 b\np : \u2115\np_prime : Prime p\np_gt_two : 2 < p\nA : \u2115 := (b ^ p - 1) / (b - 1)\nB : \u2115 := (b ^ p + 1) / (b + 1)\nAB_dvd : b ^ 2 - 1 \u2223 b ^ (2 * p) - 1\nh : p * b ^ 2 < (b ^ 2) ^ (p - 1) * b ^ 2\n\u22a2 0 < b ^ 2",["positivity"]],["NumberTheory/FermatPsp.lean",90,"case pos.H.intro.intro\nk : \u2115\nhk : Prime k\nm : \u2115\nh\u2081 : 1 \u2264 k * m\nh\u2083 : 2 \u2264 k * m\nj : \u2115\nh\u2082 : 1 \u2264 k * j\nh : k \u2223 (k * j) ^ (k * m - 1) - 1\n\u22a2 k * m - 1 \u2260 0",["omega"]],["NumberTheory/FermatPsp.lean",196,"b : \u2115\nb_ge_two : 2 \u2264 b\np : \u2115\np_prime : Prime p\np_gt_two : 2 < p\nnot_dvd : \u00acp \u2223 b * (b ^ 2 - 1)\nA : \u2115 := (b ^ p - 1) / (b - 1)\nB : \u2115 := (b ^ p + 1) / (b + 1)\nhi_A : 1 < A\nhi_B : 1 < B\nhi_AB : 1 < A * B\n\u22a2 0 < b",["omega","linarith","positivity"]],["NumberTheory/FermatPsp.lean",200,"b : \u2115\nb_ge_two : 2 \u2264 b\np : \u2115\np_prime : Prime p\np_gt_two : 2 < p\nnot_dvd : \u00acp \u2223 b * (b ^ 2 - 1)\nA : \u2115 := (b ^ p - 1) / (b - 1)\nB : \u2115 := (b ^ p + 1) / (b + 1)\nhi_A : 1 < A\nhi_B : 1 < B\nhi_AB : 1 < A * B\nhi_b : 0 < b\nhi_p : 1 \u2264 p\nthis : 2 ^ 2 \u2264 b ^ 2\n\u22a2 0 < b ^ 2 - 1",["omega"]],["NumberTheory/FermatPsp.lean",309,"b : \u2115\nb_ge_two : 2 \u2264 b\np : \u2115\np_prime : Prime p\np_gt_two : 2 < p\nA : \u2115 := (b ^ p - 1) / (b - 1)\nB : \u2115 := (b ^ p + 1) / (b + 1)\nAB_dvd : b ^ 2 - 1 \u2223 b ^ (2 * p) - 1\n\u22a2 4 \u2264 2 * p",["omega"]],["NumberTheory/FermatPsp.lean",310,"b : \u2115\nb_ge_two : 2 \u2264 b\np : \u2115\np_prime : Prime p\np_gt_two : 2 < p\nA : \u2115 := (b ^ p - 1) / (b - 1)\nB : \u2115 := (b ^ p + 1) / (b + 1)\nAB_dvd : b ^ 2 - 1 \u2223 b ^ (2 * p) - 1\nthis : 2 \u2264 2 * p - 2\n\u22a2 2 + p \u2264 2 * p",["omega"]],["NumberTheory/FermatPsp.lean",333,"b : \u2115\nh : 1 \u2264 b\nm : \u2115\nb_ge_two : 2 \u2264 b\np : \u2115\nhp\u2081 : b * (b ^ 2 - 1) + 1 + m \u2264 p\nhp\u2082 : Prime p\nh\u2081 : 0 < b\nh\u2082 : 4 \u2264 b ^ 2\nh\u2083 : 0 < b ^ 2 - 1\nh\u2084 : 0 < b * (b ^ 2 - 1)\n\u22a2 b * (b ^ 2 - 1) < p",["omega","linarith"]],["NumberTheory/FermatPsp.lean",346,"b : \u2115\nh : 1 \u2264 b\nm : \u2115\nb_ge_two : \u00ac2 \u2264 b\n\u22a2 b = 1",["omega"]],["NumberTheory/FermatPsp.lean",349,"b : \u2115\nh : 1 \u2264 b\nm : \u2115\nb_ge_two : \u00ac2 \u2264 b\nh\u2081 : b = 1\n\u22a2 m + 2 \u2260 1",["omega"]],["RingTheory/Filtration.lean",302,"R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nF : I.Filtration M\nn\u2080 : \u2115\nH :\n  \u2200 (i : \u2115),\n    \u21d1(single R i) '' \u2191(F.N i) \u2286 \u2191(Submodule.span (\u21a5(reesAlgebra I)) (\u22c3 i, \u22c3 (_ : i \u2264 n\u2080), \u21d1(single R i) '' \u2191(F.N i)))\nn : \u2115\nhn : n \u2265 n\u2080\nx : M\nhx : x \u2208 F.N (n + 1)\nl : \u2191(\u22c3 i, \u22c3 (_ : i \u2264 n\u2080), \u21d1(single R i) '' \u2191(F.N i)) \u2192\u2080 \u21a5(reesAlgebra I)\nhl : ((Finsupp.linearCombination (\u21a5(reesAlgebra I)) Subtype.val) l) (n + 1) = x\nn' : \u2115\nhn' : n' \u2264 n\u2080\nm : M\nhm : m \u2208 \u2191(F.N n')\n\u22a2 n' \u2264 n",["omega","linarith"]],["Probability/Moments/SubGaussian.lean",181,"\u03a9 : Type u_1\n\u03a9' : Type u_2\nm\u03a9 : MeasurableSpace \u03a9\nm\u03a9' : MeasurableSpace \u03a9'\n\u03bd : Measure \u03a9'\n\u03ba : Kernel \u03a9' \u03a9\nX : \u03a9 \u2192 \u211d\nc : \u211d\u22650\nh\u271d : HasSubgaussianMGF X c \u03ba \u03bd\n\u03c9' : \u03a9'\nh : \u2200 (t : \u211d), mgf X (\u03ba \u03c9') t \u2264 rexp (\u2191c * t ^ 2 / 2)\nh_int : \u2200 (t : \u211d), Integrable (fun \u03c9 \u21a6 rexp (t * X \u03c9)) (\u03ba \u03c9')\nt : \u211d\nh0 : \u03ba \u03c9' = 0\n\u22a2 0 \u2264 \u2191c * t ^ 2 / 2",["positivity"]],["Probability/Moments/SubGaussian.lean",264,"\u03a9 : Type u_1\n\u03a9' : Type u_2\nm\u03a9 : MeasurableSpace \u03a9\nm\u03a9' : MeasurableSpace \u03a9'\n\u03bd : Measure \u03a9'\n\u03ba : Kernel \u03a9' \u03a9\nX : \u03a9 \u2192 \u211d\nc : \u211d\u22650\nh\u271d : HasSubgaussianMGF X c \u03ba \u03bd\n\u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nhc0 : \u00acc = 0\n\u03c9' : \u03a9'\nh : \u2200 (t : \u211d), 0 \u2264 t \u2192 ((\u03ba \u03c9') {\u03c9 | \u03b5 \u2264 X \u03c9}).toReal \u2264 rexp (-t * \u03b5 + \u2191c * t ^ 2 / 2)\n\u22a2 0 \u2264 \u03b5 / \u2191c",["positivity"]],["Analysis/SpecialFunctions/Pow/Asymptotics.lean",60,"b : \u211d\nhb\u2080 : -1 < b\nhb\u2081 : b < 1\nhb : b < 0\n\u22a2 -b < 1",["linarith"]],["RingTheory/Derivation/Basic.lean",484,"case neg.inl.e_a.e_a.e_a\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nM : Type u_3\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nK : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Module K M\ninst\u271d : Algebra R K\nD : Derivation R K M\na : K\nn : \u2124\nhn : \u00acn = 0\nha : \u00aca = 0\nh : n = \u2191n.natAbs\n\u22a2 \u2191(n.natAbs - 1) = \u2191n.natAbs - 1",["omega"]],["RingTheory/Derivation/Basic.lean",493,"case e_a.e_a.e_a\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nM : Type u_3\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nK : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Module K M\ninst\u271d : Algebra R K\nD : Derivation R K M\na : K\nn : \u2124\nhn : \u00acn = 0\nha : \u00aca = 0\nh : n = -\u2191n.natAbs\n\u22a2 \u2191(n.natAbs - 1) - \u2191(n.natAbs * 2) = -\u2191n.natAbs - 1",["omega"]],["Analysis/Convex/Jensen.lean",250,"\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b2 : Type u_4\ninst\u271d\u2075 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b2\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Module \ud835\udd5c \u03b2\ninst\u271d : OrderedSMul \ud835\udd5c \u03b2\ns : Set E\nf : E \u2192 \u03b2\nt : Finset E\nhf : ConvexOn \ud835\udd5c s f\nhts : \u2191t \u2286 s\nw : E \u2192 \ud835\udd5c\nhw\u2080 : \u2200 y \u2208 t, 0 \u2264 w y\nhw\u2081 : \u2211 y \u2208 t, w y = 1\nhx : t.centerMass w _root_.id \u2208 (convexHull \ud835\udd5c) \u2191t\n\u22a2 0 < \u2211 i \u2208 t, w i",["positivity","aesop"]],["Probability/Distributions/Gaussian.lean",57,"\u03bc : \u211d\nv : \u211d\u22650\nx : \u211d\nhv : v \u2260 0\n\u22a2 0 < (\u221a(2 * \u03c0 * \u2191v))\u207b\u00b9 * rexp (-(x - \u03bc) ^ 2 / (2 * \u2191v))",["positivity"]],["Probability/Distributions/Gaussian.lean",62,"\u03bc : \u211d\nv : \u211d\u22650\nx : \u211d\n\u22a2 0 \u2264 (\u221a(2 * \u03c0 * \u2191v))\u207b\u00b9 * rexp (-(x - \u03bc) ^ 2 / (2 * \u2191v))",["positivity"]],["Algebra/Homology/TotalComplexShift.lean",262,"case pos.h.e_a.e_n\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\ny : \u2124\ninst\u271d : K.HasTotal (up \u2124)\nn\u2080 n\u2081 n\u2080' n\u2081' : \u2124\nh\u2080 : n\u2080 + y = n\u2080'\nh\u2081 : n\u2081 + y = n\u2081'\nh : n\u2080 + 1 = n\u2081\np q : \u2124\nhpq : p + q = n\u2080\n\u22a2 (p + 1) * y = y + p * y",["linarith"]],["Algebra/Homology/TotalComplexShift.lean",94,"case a.fst\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK L : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\nf : K \u27f6 L\nx y : \u2124\ninst\u271d : K.HasTotal (up \u2124)\nn a b : \u2124\nh : (a, b) \u2208 (up \u2124).\u03c0 (up \u2124) (up \u2124) \u207b\u00b9' {n + x}\n\u22a2 a - x + x = a",["omega"]],["Algebra/Homology/TotalComplexShift.lean",154,"case neg.h\u2081\u2082\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\nx : \u2124\ninst\u271d : K.HasTotal (up \u2124)\nn\u2080 n\u2081 n\u2080' n\u2081' : \u2124\nh\u2080 : n\u2080 + x = n\u2080'\nh\u2081 : n\u2081 + x = n\u2081'\nh : \u00ac(up \u2124).Rel n\u2080 n\u2081\nh' : n\u2080' + 1 = n\u2081'\n\u22a2 n\u2080 + 1 = n\u2081",["omega","linarith"]],["Algebra/Homology/TotalComplexShift.lean",176,"case neg.h\u2081\u2082\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\nx : \u2124\ninst\u271d : K.HasTotal (up \u2124)\nn\u2080 n\u2081 n\u2080' n\u2081' : \u2124\nh\u2080 : n\u2080 + x = n\u2080'\nh\u2081 : n\u2081 + x = n\u2081'\nh : \u00ac(up \u2124).Rel n\u2080 n\u2081\nh' : n\u2080' + 1 = n\u2081'\n\u22a2 n\u2080 + 1 = n\u2081",["omega","linarith"]],["Algebra/Homology/TotalComplexShift.lean",209,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\nx : \u2124\ninst\u271d : K.HasTotal (up \u2124)\na b n : \u2124\nh : a + b = n\na' : \u2124\nha' : a' + b = n + x\n\u22a2 a = a' - x",["omega","linarith"]],["Algebra/Homology/TotalComplexShift.lean",267,"case neg.h\u2081\u2082\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\ny : \u2124\ninst\u271d : K.HasTotal (up \u2124)\nn\u2080 n\u2081 n\u2080' n\u2081' : \u2124\nh\u2080 : n\u2080 + y = n\u2080'\nh\u2081 : n\u2081 + y = n\u2081'\nh : \u00ac(up \u2124).Rel n\u2080 n\u2081\nh' : n\u2080' + 1 = n\u2081'\n\u22a2 n\u2080 + 1 = n\u2081",["omega"]],["Algebra/Homology/TotalComplexShift.lean",292,"case neg.h\u2081\u2082\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\ny : \u2124\ninst\u271d : K.HasTotal (up \u2124)\nn\u2080 n\u2081 n\u2080' n\u2081' : \u2124\nh\u2080 : n\u2080 + y = n\u2080'\nh\u2081 : n\u2081 + y = n\u2081'\nh : \u00ac(up \u2124).Rel n\u2080 n\u2081\nh' : n\u2080' + 1 = n\u2081'\n\u22a2 n\u2080 + 1 = n\u2081",["omega"]],["Algebra/Homology/TotalComplexShift.lean",327,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\ny : \u2124\ninst\u271d : K.HasTotal (up \u2124)\na b n : \u2124\nh : a + b = n\nb' : \u2124\nhb' : a + b' = n + y\n\u22a2 b = b' - y",["omega","linarith"]],["Data/Real/Archimedean.lean",378,"a : \u211d\nha : \u2200 (k : \u2115), 0 < k \u2192 a \u2264 1 / \u2191k + 1\nq : \u211a\nhq : \u2191q.den < q.num\n\u22a2 1 \u2264 q.num - \u2191q.den",["omega","linarith"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",269,"b : \u2102\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\nhb : 0 < b.re\nc : \u2102\nw : EuclideanSpace \u211d \u03b9\nthis : MeasurePreserving (\u21d1(EuclideanSpace.measurableEquiv \u03b9)) volume volume\nv : \u03b9 \u2192 \u211d\ni : \u03b9\n_hi : i \u2208 Finset.univ\n\u22a2 0 \u2264 v i ^ 2",["positivity"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",314,"b : \u2102\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\nhb : 0 < b.re\nc : \u2102\nw : EuclideanSpace \u211d \u03b9\nthis : MeasurePreserving (\u21d1(EuclideanSpace.measurableEquiv \u03b9).symm) volume volume\ny : \u03b9 \u2192 \u211d\ni : \u03b9\n_hi : i \u2208 Finset.univ\n\u22a2 0 \u2264 y i ^ 2",["positivity"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",321,"b : \u2102\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\nhb : 0 < b.re\nc : \u2102\nw : EuclideanSpace \u211d \u03b9\nthis : MeasurePreserving (\u21d1(EuclideanSpace.measurableEquiv \u03b9).symm) volume volume\ni : \u03b9\n_hi : i \u2208 Finset.univ\n\u22a2 0 \u2264 w i ^ 2",["positivity"]],["Data/Nat/Log.lean",83,"case h.zero\nb : \u2115\nhb : 1 < b\ny : \u2115\nih : \u2200 (m : \u2115), m < y \u2192 \u2200 {x : \u2115}, m \u2260 0 \u2192 (b ^ x \u2264 m \u2194 x \u2264 log b m)\nhy : y \u2260 0\n\u22a2 1 \u2264 y \u2194 0 \u2264 log b y",["omega"]],["CategoryTheory/GlueData.lean",407,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData' C\ni j k : D.J\nhij : i = j\n\u22a2 D.f' i j \u226b eqToHom \u22ef = eqToHom \u22ef \u226b D.f' j i",["aesop","omega"]],["LinearAlgebra/BilinearForm/Orthogonal.lean",324,"V : Type u_5\nK : Type u_6\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nB : BilinForm K V\nhB : B.Nondegenerate\nhB\u2080 : B.IsRefl\nW : Submodule K V\nthis : finrank K \u21a5W + finrank K \u21a5(B.orthogonal W) = finrank K V\n\u22a2 finrank K \u21a5(B.orthogonal W) = finrank K V - finrank K \u21a5W",["omega"]],["LinearAlgebra/BilinearForm/Orthogonal.lean",330,"V : Type u_5\nK : Type u_6\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\nB : BilinForm K V\nhB : B.Nondegenerate\nhB\u2080 : B.IsRefl\nW : Submodule K V\n\u22a2 finrank K V - (finrank K V - finrank K \u21a5W) \u2264 finrank K \u21a5W",["omega"]],["Analysis/NormedSpace/HahnBanach/Separation.lean",66,"case refine_2.intro.intro\nE : Type u_2\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : IsTopologicalAddGroup E\ninst\u271d\u00b9 : Module \u211d E\ninst\u271d : ContinuousSMul \u211d E\ns : Set E\nhs\u2080 : 0 \u2208 s\nhs\u2081 : Convex \u211d s\nhs\u2082 : IsOpen s\nx\u2080 : E\nhx\u2080 : x\u2080 \u2209 s\nf : E \u2192\u2097.[\u211d] \u211d := LinearPMap.mkSpanSingleton x\u2080 1 \u22ef\n\u03c6 : E \u2192\u2097[\u211d] \u211d\nh\u03c6\u2081 : \u2200 (x : \u21a5f.domain), \u03c6 \u2191x = \u2191f x\nh\u03c6\u2082 : \u2200 (x : E), \u03c6 x \u2264 gauge s x\nh\u03c6\u2083 : \u03c6 x\u2080 = 1\nx : E\nhx : x \u2208 s\nh\u03c6\u2084 : \u03c6 x < 1\n\u22a2 -\u03c6 x\u2080 + \u03c6 x \u2260 0",["linarith"]],["Analysis/NormedSpace/HahnBanach/Separation.lean",107,"E : Type u_2\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ns t : Set E\ninst\u271d\u00b9 : IsTopologicalAddGroup E\ninst\u271d : ContinuousSMul \u211d E\nhs\u2081 : Convex \u211d s\nhs\u2082 : IsOpen s\nht : Convex \u211d t\ndisj : Disjoint s t\na\u2080 : E\nha\u2080 : a\u2080 \u2208 s\nb\u2080 : E\nhb\u2080 : b\u2080 \u2208 t\nx\u2080 : E := b\u2080 - a\u2080\nC : Set E := x\u2080 +\u1d65 s - t\nthis\u271d\u00b3 : 0 \u2208 C\nthis\u271d\u00b2 : Convex \u211d C\nthis\u271d\u00b9 : x\u2080 \u2209 C\nf : E \u2192L[\u211d] \u211d\nhf\u2081 : f x\u2080 = 1\nhf\u2082 : \u2200 x \u2208 C, f x < 1\nthis\u271d : f b\u2080 = f a\u2080 + 1\na : E\nha : a \u2208 s\nb : E\nhb : b \u2208 t\nthis : 1 + (f a - f b) < 1\n\u22a2 f a \u2264 f b",["linarith"]],["CategoryTheory/Monad/Comonadicity.lean",104,"C : Type u\u2081\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2081, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nA : adj.toComonad.Coalgebra\nB : C\ninst\u271d : HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nf : (comparison adj).obj B \u27f6 A\n\u22a2 (fun f \u21a6 { f := (adj.homEquiv B A.A).symm (f \u226b equalizer.\u03b9 (G.map A.a) (adj.unit.app (G.toPrefunctor.1 A.A))), h := \u22ef })\n      ((fun f \u21a6 equalizer.lift ((adj.homEquiv B A.A) f.f) \u22ef) f) =\n    f",["aesop","omega"]],["MeasureTheory/Measure/Tilted.lean",109,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u211d\nhs : MeasurableSet s\nhf : Integrable (fun x \u21a6 rexp (f x)) \u03bc\nx\u271d : \u03b1\n\u22a2 0 x\u271d \u2264 (fun a \u21a6 rexp (f a) / \u222b (x : \u03b1), rexp (f x) \u2202\u03bc) x\u271d",["positivity"]],["MeasureTheory/Measure/Tilted.lean",118,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nhf : Integrable (fun x \u21a6 rexp (f x)) \u03bc\nx\u271d : \u03b1\n\u22a2 0 x\u271d \u2264 (fun a \u21a6 rexp (f a) / \u222b (x : \u03b1), rexp (f x) \u2202\u03bc) x\u271d",["positivity"]],["MeasureTheory/Measure/Tilted.lean",303,"case a.h.e'_6.h.h.e'_5\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u03b1 \u2192 \u211d\nhf : Integrable (fun x \u21a6 rexp (f x)) \u03bc\ng : \u03b1 \u2192 E\nh\u03bc : \u00ac\u03bc = 0\nhf_meas : AEMeasurable f \u03bc\na : \u03b1\n\u22a2 0 \u2264 rexp (f a) / \u222b (a : \u03b1), rexp (f a) \u2202\u03bc",["positivity"]],["MeasureTheory/Measure/Tilted.lean",338,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : SigmaFinite \u03bc\ninst\u271d : SigmaFinite \u03bd\nhf : Integrable (fun x \u21a6 rexp (f x)) \u03bd\nx : \u03b1\nhx : \u03bc.rnDeriv (\u03bd.tilted f) x = ENNReal.ofReal (rexp (-f x) * \u222b (x : \u03b1), rexp (f x) \u2202\u03bd) * \u03bc.rnDeriv \u03bd x\n\u22a2 0 \u2264 rexp (-f x) * \u222b (x : \u03b1), rexp (f x) \u2202\u03bd",["positivity"]],["MeasureTheory/Measure/Tilted.lean",357,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\n\u03bd : Measure \u03b1\ninst\u271d\u00b9 : SigmaFinite \u03bc\ninst\u271d : SigmaFinite \u03bd\nhf\u03bd : AEMeasurable f \u03bd\nx : \u03b1\nhx : (\u03bc.tilted f).rnDeriv \u03bd x = ENNReal.ofReal (rexp (f x) / \u222b (x : \u03b1), rexp (f x) \u2202\u03bc) * \u03bc.rnDeriv \u03bd x\n\u22a2 0 \u2264 rexp (f x) / \u222b (x : \u03b1), rexp (f x) \u2202\u03bc",["positivity"]],["Analysis/InnerProductSpace/Calculus.lean",327,"n : \u2115\u221e\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nx : E\n\u22a2 0 < 1 + \u2016x\u2016 ^ 2",["positivity"]],["NumberTheory/ZetaValues.lean",321,"k : \u2115\nhk : k \u2260 0\n\u22a2 1 \u2264 2 * k",["omega"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",56,"z w : \u210d\n\u22a2 2 * \u221a(z.im * w.im) \u2260 0",["positivity"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",103,"z w : \u210d\n\u22a2 0 \u2264 dist \u2191z \u2191w / (2 * \u221a(z.im * w.im))",["positivity"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",140,"z w : \u210d\nr : \u211d\n\u22a2 2 * z.im * w.im \u2260 0",["positivity"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",157,"z w : \u210d\nr : \u211d\nthis : MetricSpace \u210d := metricSpaceAux\nhr\u2080 : 0 \u2264 r\n\u22a2 0 \u2264 w.im * Real.sinh r",["positivity"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",158,"z w : \u210d\nr : \u211d\nthis : MetricSpace \u210d := metricSpaceAux\nhr\u2080 : 0 \u2264 r\nhr\u2080' : 0 \u2264 w.im * Real.sinh r\n\u22a2 0 < 2 * z.im * w.im",["positivity"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",200,"z w : \u210d\nh : z.re = w.re\n\u22a2 0 < z.im / w.im",["positivity"]],["Analysis/Complex/UpperHalfPlane/Metric.lean",252,"z w : \u210d\nr : \u211d\nx : \u210d \u00d7 \u210d\n\u22a2 2 * \u221a(x.1.im * x.2.im) \u2260 0",["positivity"]],["Analysis/BoxIntegral/DivergenceTheorem.lean",232,"E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nn : \u2115\ninst\u271d : CompleteSpace E\nI : Box (Fin (n + 1))\nf : (Fin (n + 1) \u2192 \u211d) \u2192 E\nf' : (Fin (n + 1) \u2192 \u211d) \u2192 (Fin (n + 1) \u2192 \u211d) \u2192L[\u211d] E\ns : Set (Fin (n + 1) \u2192 \u211d)\nhs : s.Countable\nHs : \u2200 x \u2208 s, ContinuousWithinAt f (Box.Icc I) x\nHd : \u2200 x \u2208 Box.Icc I \\ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x\ni : Fin (n + 1)\nHc : ContinuousOn f (Box.Icc I)\nfI : \u211d \u2192 Box (Fin n) \u2192 E := fun y J \u21a6 integral J GP (fun x \u21a6 f (i.insertNth y x)) BoxAdditiveMap.volume\nfb : \u2191(Set.Icc (I.lower i) (I.upper i)) \u2192 Fin n \u2192\u1d47\u1d43[\u2191(I.face i)] E := fun x \u21a6 \u22ef.toBoxAdditive\nF : Fin (n + 1) \u2192\u1d47\u1d43[\u2191I] E := BoxAdditiveMap.upperSubLower I i fI fb \u22ef\nc : \u211d\u22650\nx : Fin (n + 1) \u2192 \u211d\nhx : x \u2208 Box.Icc I \u2229 s\n\u03b5 : \u211d\n\u03b50 : \u03b5 > 0\nthis :\n  \u2200\u1da0 (\u03b4 : \u211d) in \ud835\udcdd[>] 0,\n    \u03b4 \u2208 Set.Ioc 0 (1 / 2) \u2227\n      (\u2200 y\u2081 \u2208 closedBall x \u03b4 \u2229 Box.Icc I, \u2200 y\u2082 \u2208 closedBall x \u03b4 \u2229 Box.Icc I, \u2016f y\u2081 - f y\u2082\u2016 \u2264 \u03b5 / 2) \u2227\n        (2 * \u03b4) ^ (n + 1) * \u2016(f' x) (Pi.single i 1)\u2016 \u2264 \u03b5 / 2\n\u03b4 : \u211d\nh\u03b40 : 0 < \u03b4\nh\u03b412 : \u03b4 \u2264 1 / 2\nhdf\u03b4 : \u2200 y\u2081 \u2208 closedBall x \u03b4 \u2229 Box.Icc I, \u2200 y\u2082 \u2208 closedBall x \u03b4 \u2229 Box.Icc I, \u2016f y\u2081 - f y\u2082\u2016 \u2264 \u03b5 / 2\nh\u03b4 : (2 * \u03b4) ^ (n + 1) * \u2016(f' x) (Pi.single i 1)\u2016 \u2264 \u03b5 / 2\nJ : Box (Fin (n + 1))\nhJI : J \u2264 I\nhJ\u03b4 : Box.Icc J \u2286 closedBall x \u03b4\nx\u271d\u00b2 : x \u2208 Box.Icc J\nx\u271d\u00b9 : GP.bDistortion = true \u2192 J.distortion \u2264 c\nHl : J.lower i \u2208 Set.Icc (J.lower i) (J.upper i)\nHu : J.upper i \u2208 Set.Icc (J.lower i) (J.upper i)\nHi : \u2200 x \u2208 Set.Icc (J.lower i) (J.upper i), Integrable (J.face i) GP (fun y \u21a6 f (i.insertNth x y)) BoxAdditiveMap.volume\nhJ\u03b4' : Box.Icc J \u2286 closedBall x \u03b4 \u2229 Box.Icc I\nHmaps : \u2200 z \u2208 Set.Icc (J.lower i) (J.upper i), MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x \u03b4 \u2229 Box.Icc I)\nj : Fin n\nx\u271d : j \u2208 Finset.univ\n\u22a2 \u03b4 + \u03b4 \u2264 1 / 2 + 1 / 2",["gcongr","linarith"]],["Analysis/Convex/Slope.lean",29,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : 0 < y - x\nhyz : 0 < z - y\nhxz : 0 < z - x\nthis : f y * (y - x)\u207b\u00b9 + f y * (-y + z)\u207b\u00b9 \u2264 (y - x)\u207b\u00b9 * f x + (-y + z)\u207b\u00b9 * f z\n\u22a2 f y * (y - x)\u207b\u00b9 - (y - x)\u207b\u00b9 * f x \u2264 -(f y * (-y + z)\u207b\u00b9) + (-y + z)\u207b\u00b9 * f z",["linarith"]],["Analysis/Convex/Slope.lean",63,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : 0 < y - x\nhyz : 0 < z - y\nhxz : 0 < z - x\nhxz' : x \u2260 z\nthis : f y * (y - x)\u207b\u00b9 + f y * (-y + z)\u207b\u00b9 < (y - x)\u207b\u00b9 * f x + (-y + z)\u207b\u00b9 * f z\n\u22a2 f y * (y - x)\u207b\u00b9 - (y - x)\u207b\u00b9 * f x < -(f y * (-y + z)\u207b\u00b9) + (-y + z)\u207b\u00b9 * f z",["linarith"]],["Analysis/Convex/Slope.lean",220,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\n\u22a2 0 < y - x",["linarith","aesop"]],["Analysis/Convex/Slope.lean",221,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\n\u22a2 0 < z - y",["linarith"]],["Analysis/Convex/Slope.lean",222,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\nhyz' : 0 < z - y\n\u22a2 0 < z - x",["linarith"]],["Analysis/Convex/Slope.lean",238,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\n\u22a2 0 < y - x",["linarith","aesop"]],["Analysis/Convex/Slope.lean",239,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\n\u22a2 0 < z - x",["linarith"]],["Analysis/Convex/Slope.lean",245,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\n\u22a2 0 < z - y",["linarith","aesop"]],["Analysis/Convex/Slope.lean",246,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhyz' : 0 < z - y\n\u22a2 0 < z - x",["linarith"]],["Analysis/Convex/Slope.lean",266,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\n\u22a2 0 < y - x",["linarith","aesop"]],["Analysis/Convex/Slope.lean",267,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\n\u22a2 0 < z - y",["linarith"]],["Analysis/Convex/Slope.lean",268,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\nhyz' : 0 < z - y\n\u22a2 0 < z - x",["linarith"]],["Analysis/Convex/Slope.lean",284,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\n\u22a2 0 < y - x",["linarith","aesop"]],["Analysis/Convex/Slope.lean",285,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\n\u22a2 0 < z - x",["linarith"]],["Analysis/Convex/Slope.lean",291,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\n\u22a2 0 < z - y",["linarith","aesop"]],["Analysis/Convex/Slope.lean",292,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhyz' : 0 < z - y\n\u22a2 0 < z - x",["linarith"]],["Analysis/Convex/Slope.lean",224,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\nhyz' : 0 < z - y\nhxz' : 0 < z - x\n\u22a2 0 \u2264 (z - y) / (z - x)",["positivity"]],["Analysis/Convex/Slope.lean",225,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : ConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\nhyz' : 0 < z - y\nhxz' : 0 < z - x\nha : 0 \u2264 (z - y) / (z - x)\n\u22a2 0 \u2264 (y - x) / (z - x)",["positivity"]],["Analysis/Convex/Slope.lean",270,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\nhyz' : 0 < z - y\nhxz' : 0 < z - x\n\u22a2 0 < (z - y) / (z - x)",["positivity"]],["Analysis/Convex/Slope.lean",271,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\ns : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : StrictConvexOn \ud835\udd5c s f\nx y z : \ud835\udd5c\nhx : x \u2208 s\nhz : z \u2208 s\nhxy : x < y\nhyz : y < z\nhxy' : 0 < y - x\nhyz' : 0 < z - y\nhxz' : 0 < z - x\nha : 0 < (z - y) / (z - x)\n\u22a2 0 < (y - x) / (z - x)",["positivity"]],["Combinatorics/Additive/VerySmallDoubling.lean",150,"G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA\u271d : Finset G\na : G\nA : Finset G\nh : \u2191(#(A * A)) < 3 / 2 * \u2191(#A)\nx : G\nhx : x \u2208 A\ny : G\nhy : y \u2208 A\nthis : 2 * \u2191(#A) \u2264 \u2191(#(x \u2022> A \u2229 y \u2022> A)) + \u2191(#(A * A))\n\u22a2 1 / 2 * \u2191(#A) < \u2191(#(x \u2022> A \u2229 y \u2022> A))",["linarith"]],["Combinatorics/Additive/VerySmallDoubling.lean",170,"G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA\u271d : Finset G\na\u271d : G\nA : Finset G\nh : \u2191(#(A * A)) < 3 / 2 * \u2191(#A)\nh\u2081 : \u2200 x \u2208 A, \u2200 y \u2208 A, 1 / 2 * \u2191(#A) < \u2191(#(x \u2022> A \u2229 y \u2022> A))\na : G\nha : a\u207b\u00b9 \u2208 A\nb : G\nhb : b \u2208 A\nc : G\nhc : c\u207b\u00b9 \u2208 A\nd : G\nhd : d \u2208 A\nh\u2082 : 1 / 2 * \u2191(#A) < \u2191(#(A \u2229 (a * b)\u207b\u00b9 \u2022> A))\nh\u2083 : 1 / 2 * \u2191(#A) < \u2191(#(A \u2229 (c * d) \u2022> A))\nthis\u271d :\n  \u2191(#(A \u2229 (c * d) \u2022> A \u2229 (A \u2229 (a * b)\u207b\u00b9 \u2022> A))) + \u2191(#(A \u2229 (c * d) \u2022> A \u222a A \u2229 (a * b)\u207b\u00b9 \u2022> A)) =\n    \u2191(#(A \u2229 (c * d) \u2022> A)) + \u2191(#(A \u2229 (a * b)\u207b\u00b9 \u2022> A))\nthis : \u2191(#(A \u2229 (c * d) \u2022> A \u222a A \u2229 (a * b)\u207b\u00b9 \u2022> A)) \u2264 \u2191(#A)\n\u22a2 0 < \u2191(#(A \u2229 (c * d) \u2022> A \u2229 (A \u2229 (a * b)\u207b\u00b9 \u2022> A)))",["linarith"]],["Combinatorics/Additive/VerySmallDoubling.lean",181,"G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA : Finset G\nh : \u2191(#(A * A)) < 3 / 2 * \u2191(#A)\n\u22a2 \u2191(#(A * A)) < 2 * \u2191(#A)",["linarith"]],["Combinatorics/Additive/VerySmallDoubling.lean",193,"G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA : Finset G\nh : \u2191(#(A * A)) < 3 / 2 * \u2191(#A)\nh\u2080 : A.Nonempty\nx : G\nhx : x \u2208 A\ny : G\nhy : y \u2208 A\nthis : 2 * \u2191(#A) \u2264 \u2191(#(x \u2022> A \u2229 y \u2022> A)) + \u2191(#(A * A))\n\u22a2 1 / 2 * \u2191(#A) < \u2191(#(x \u2022> A \u2229 y \u2022> A))",["linarith"]],["MeasureTheory/Covering/LiminfLimsup.lean",210,"case neg\n\u03b1 : Type u_1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : BorelSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : IsUnifLocDoublingMeasure \u03bc\np : \u2115 \u2192 Prop\ns : \u2115 \u2192 Set \u03b1\nM : \u211d\nhM : 0 < M\nr : \u2115 \u2192 \u211d\nhr : Tendsto r atTop (\ud835\udcdd 0)\nthis :\n  \u2200 (p : \u2115 \u2192 Prop) {r : \u2115 \u2192 \u211d},\n    Tendsto r atTop (\ud835\udcdd[>] 0) \u2192\n      blimsup (fun i \u21a6 cthickening (M * r i) (s i)) atTop p =\u1da0[ae \u03bc] blimsup (fun i \u21a6 cthickening (r i) (s i)) atTop p\nr' : \u2115 \u2192 \u211d := fun i \u21a6 if 0 < r i then r i else 1 / (\u2191i + 1)\ni : \u2115\nhi : \u00ac0 < r i\n\u22a2 0 < \u2191i + 1",["positivity","linarith"]],["Analysis/CStarAlgebra/Module/Constructions.lean",111,"case bc.bc\nA : Type u_1\ninst\u271d\u2079 : NonUnitalCStarAlgebra A\ninst\u271d\u2078 : PartialOrder A\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : Module \u2102 E\ninst\u271d\u2075 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : Module \u2102 F\ninst\u271d\u00b2 : SMul A\u1d50\u1d52\u1d56 F\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : CStarModule A F\nx : C\u22c6\u1d50\u1d52\u1d48 (E \u00d7 F)\n\u22a2 0 \u2264 2 * \u2016x.1\u2016 * \u2016x.2\u2016",["positivity"]],["Data/Multiset/UnionInter.lean",240,"case a\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nM N P Q : Multiset \u03b1\nh : M + N = P + Q\nx : \u03b1\nh0 : count x M + count x N = count x P + count x Q\n\u22a2 count x N \u2293 count x Q + (count x P - count x M) = count x N",["omega"]],["Analysis/Asymptotics/AsymptoticEquivalent.lean",248,"\u03b1 : Type u_1\nE : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na b : \u03b1 \u2192 \ud835\udd5c\nu v : \u03b1 \u2192 E\nl : Filter \u03b1\nhab : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u03b1) in l, \u2016(a - b) x\u2016 \u2264 c * \u2016b x\u2016\n\u03c6 : \u03b1 \u2192 \ud835\udd5c\nhab\u03c6 : a =\u1da0[l] \u03c6 * b\nthis : ((fun x \u21a6 a x \u2022 u x) - fun x \u21a6 b x \u2022 v x) =\u1da0[l] fun x \u21a6 b x \u2022 (\u03c6 x \u2022 u x - v x)\nC : \u211d\nhC : C > 0\nhCuv : \u2200\u1da0 (x : \u03b1) in l, \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nc : \u211d\nhc : 0 < c\nh\u03c6 : \u2200\u1da0 (x : \u03b1) in l, \u2016\u03c6 x - 1\u2016 < c / 2 / C\nhuv : \u2200\u1da0 (x : \u03b1) in l, \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nx : \u03b1\nhCuvx : \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nhuvx : \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nh\u03c6x : \u2016\u03c6 x - 1\u2016 < c / 2 / C\nkey : \u2016\u03c6 x - 1\u2016 * \u2016u x\u2016 \u2264 c / 2 * \u2016v x\u2016\n\u22a2 \u2016\u03c6 x - 1\u2016 * \u2016u x\u2016 + \u2016u x - v x\u2016 \u2264 c / 2 * \u2016v x\u2016 + \u2016u x - v x\u2016",["gcongr","aesop","linarith"]],["Algebra/CharP/Defs.lean",210,"R : Type u_1\ninst\u271d\u00b2 : NonAssocSemiring R\ninst\u271d\u00b9 : NoZeroDivisors R\np : \u2115\ninst\u271d : CharP R p\nhp : 2 \u2264 p\nd : \u2115\nhdvd : \u2203 e, p = d * e\ne : \u2115\nhmul : p = d * e\nthis\u271d\u00b3 : \u2191p = 0\nthis\u271d\u00b2 : \u2191d * \u2191e = 0\nhe : \u2191e = 0\nthis\u271d\u00b9 : p \u2223 e\nthis\u271d : e \u2223 p\nthis : e = p\n\u22a2 0 < p",["omega"]],["Analysis/SpecificLimits/FloorPow.lean",233,"N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < c\u207b\u00b9 ^ 2\nB : c ^ 2 * (1 - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9\nC : c\u207b\u00b9 ^ 2 < 1\ni\u271d : \u2115\na\u271d\u00b9 : i\u271d \u2208 Ico \u230aReal.log j / Real.log c\u230b\u208a N\na\u271d : i\u271d \u2209 filter (fun i \u21a6 j < c ^ i) (range N)\n\u22a2 0 \u2264 1 / (c ^ i\u271d) ^ 2",["positivity"]],["Analysis/SpecificLimits/FloorPow.lean",253,"case a\nN : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < c\u207b\u00b9 ^ 2\nB : c ^ 2 * (1 - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9\nC : c\u207b\u00b9 ^ 2 < 1\n\u22a2 0 < 1 / j ^ 2",["positivity","aesop"]],["Analysis/SpecificLimits/FloorPow.lean",286,"N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < 1 - c\u207b\u00b9\nk : \u2115\nhk : j < \u2191\u230ac ^ k\u230b\u208a\n\u22a2 0 \u2264 c ^ k",["positivity"]],["Geometry/Euclidean/Angle/Unoriented/Basic.lean",268,"V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx y : V\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2016x\u2016 ^ 2 - 2 * inner x y + \u2016y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2\nhxy\u2081 : 0 \u2264 \u2016x - y\u2016\nhxy\u2082 : 0 \u2264 \u2016x\u2016 + \u2016y\u2016\n\u22a2 inner x y = (\u2016x\u2016 ^ 2 + \u2016y\u2016 ^ 2 - (\u2016x\u2016 + \u2016y\u2016) ^ 2) / 2",["linarith"]],["Geometry/Euclidean/Angle/Unoriented/Basic.lean",280,"V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx y : V\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2016x\u2016 ^ 2 + 2 * inner x y + \u2016y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2\nhxy\u2081 : 0 \u2264 \u2016x + y\u2016\nhxy\u2082 : 0 \u2264 \u2016x\u2016 + \u2016y\u2016\n\u22a2 inner x y = ((\u2016x\u2016 + \u2016y\u2016) ^ 2 - \u2016x\u2016 ^ 2 - \u2016y\u2016 ^ 2) / 2",["linarith"]],["Geometry/Euclidean/Angle/Unoriented/Basic.lean",294,"V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx y : V\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016|\nh1 : \u2016x\u2016 ^ 2 - 2 * inner x y + \u2016y\u2016 ^ 2 = (\u2016x\u2016 - \u2016y\u2016) ^ 2\n\u22a2 inner x y = ((\u2016x\u2016 + \u2016y\u2016) ^ 2 - \u2016x\u2016 ^ 2 - \u2016y\u2016 ^ 2) / 2",["linarith"]],["RingTheory/Polynomial/Cyclotomic/Eval.lean",258,"case h.e'_4.h.e'_5\nn : \u2115\nq : \u211d\nhn' : 3 \u2264 n\nhq' : 1 < q\nhn : 0 < n\nhq : 0 < q\nhfor : \u2200 \u03b6' \u2208 primitiveRoots n \u2102, \u2016\u2191q - \u03b6'\u2016 \u2264 q + 1\n\u03b6 : \u2102 := Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)\nh\u03b6 : IsPrimitiveRoot \u03b6 n\nhex : \u2203 \u03b6' \u2208 primitiveRoots n \u2102, \u2016\u2191q - \u03b6'\u2016 < q + 1\nthis\u271d : \u00aceval (\u2191q) (cyclotomic n \u2102) = 0\nthis : \u2016eval (\u2191q) (cyclotomic n \u2102)\u2016 < ((q + 1) \u2294 0) ^ \u03c6 n\n\u22a2 0 \u2264 q + 1",["linarith","positivity"]],["Analysis/SpecialFunctions/ContinuousFunctionalCalculus/PosPart/Basic.lean",140,"A : Type u_1\ninst\u271d\u2078 : NonUnitalRing A\ninst\u271d\u2077 : Module \u211d A\ninst\u271d\u2076 : SMulCommClass \u211d A A\ninst\u271d\u2075 : IsScalarTower \u211d A A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : NonUnitalContinuousFunctionalCalculus \u211d IsSelfAdjoint\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\nx : \u211d\nx\u271d : x \u2208 quasispectrum \u211d a\n\u22a2 0 \u2264 x\u207a",["positivity"]],["Analysis/SpecialFunctions/ContinuousFunctionalCalculus/PosPart/Basic.lean",145,"A : Type u_1\ninst\u271d\u2078 : NonUnitalRing A\ninst\u271d\u2077 : Module \u211d A\ninst\u271d\u2076 : SMulCommClass \u211d A A\ninst\u271d\u2075 : IsScalarTower \u211d A A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : NonUnitalContinuousFunctionalCalculus \u211d IsSelfAdjoint\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\na : A\nx : \u211d\nx\u271d : x \u2208 quasispectrum \u211d a\n\u22a2 0 \u2264 x\u207b",["positivity"]],["Analysis/MeanInequalitiesPow.lean",76,"\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 \u211d\nhw : \u2200 i \u2208 s, 0 \u2264 w i\nhw' : \u2211 i \u2208 s, w i = 1\nhz : \u2200 i \u2208 s, 0 \u2264 z i\np : \u211d\nhp : 1 \u2264 p\n\u22a2 0 < p",["positivity","linarith"]],["Analysis/MeanInequalitiesPow.lean",140,"p : \u211d\na b : \u211d\u22650\nhp1 : 1 \u2264 p\n\u22a2 0 < p",["positivity","linarith"]],["Analysis/MeanInequalitiesPow.lean",222,"\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 \u211d\u22650\u221e\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\n\u22a2 0 < p",["positivity","linarith"]],["Analysis/MeanInequalitiesPow.lean",223,"\u03b9 : Type u\ns : Finset \u03b9\nw z : \u03b9 \u2192 \u211d\u22650\u221e\nhw' : \u2211 i \u2208 s, w i = 1\np : \u211d\nhp : 1 \u2264 p\nhp_pos : 0 < p\n\u22a2 0 \u2264 p",["positivity","linarith","gcongr"]],["Analysis/MeanInequalitiesPow.lean",284,"p : \u211d\na b : \u211d\u22650\u221e\nhp1 : 1 \u2264 p\n\u22a2 0 < p",["positivity","linarith"]],["Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean",377,"A : Type u_1\ninst\u271d\u2077 : PartialOrder A\ninst\u271d\u2076 : Ring A\ninst\u271d\u2075 : StarRing A\ninst\u271d\u2074 : TopologicalSpace A\ninst\u271d\u00b3 : Algebra \u211d A\ninst\u271d\u00b2 : ContinuousFunctionalCalculus \u211d\u22650 fun a \u21a6 0 \u2264 a\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\na : A\nx : \u211d\u22650\nhtriv : 0 \u2264 a\nhx : \u00acx = 0\nh\u2081 : 0 < x\nh\u2082 : \u2191x / 2 = \u2191(x / 2)\n\u22a2 0 < x / 2",["positivity","aesop"]],["Algebra/Polynomial/UnitTrinomial.lean",249,"p q : \u2124[X]\nk m m' n : \u2115\nhkm : k < m\nhmn : m < n\nhkm' : k < m'\nhmn' : m' < n\nu v w : \u2124\u02e3\nhp : p = trinomial k m n \u2191u \u2191v \u2191w\nhq : q = trinomial k m' n \u2191u \u2191v \u2191w\nf : \u2124[X] \u2192 \u2124[X] := fun p \u21a6 { toFinsupp := Finsupp.filter (fun x \u21a6 x \u2208 Set.Ioo (k + n) (n + n)) p.toFinsupp }\nhm : m = n - m + k\nhm' : m' = n - m' + k\n\u22a2 m = m'",["omega"]],["NumberTheory/NumberField/FinitePlaces.lean",262,"case h\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv\u2081 v\u2082 : HeightOneSpectrum (\ud835\udcde K)\nh : v\u2081 \u2260 v\u2082\nx : \ud835\udcde K\nhx1 : \u2016(embedding v\u2081) \u2191x\u2016 < 1\nhx2 : \u2016(embedding v\u2082) \u2191x\u2016 = 1\n\u22a2 \u2016(embedding v\u2081) \u2191x\u2016 \u2260 \u2016(embedding v\u2082) \u2191x\u2016",["linarith"]],["NumberTheory/NumberField/FinitePlaces.lean",52,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nv : HeightOneSpectrum (\ud835\udcde K)\nh : absNorm v.asIdeal \u2264 1\nthis : 0 < absNorm v.asIdeal\n\u22a2 absNorm v.asIdeal = 1",["omega","linarith"]],["Analysis/Analytic/IteratedFDeriv.lean",162,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\np : FormalMultilinearSeries \ud835\udd5c E F\ns : Set E\nx : E\nr : \u211d\u22650\u221e\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : AnalyticOn \ud835\udd5c f s\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nn : \u2115\nv : Fin n \u2192 E\nh's : s \u2286 EMetric.ball x r\nI : insert x s \u2229 EMetric.ball x r = s\nfcont : ContDiffOn \ud835\udd5c (\u2191n) f s\ng : E \u2192 F := fun z \u21a6 (p n) fun x_1 \u21a6 z - x\ngcont : ContDiff \ud835\udd5c \u03c9 g\nq : FormalMultilinearSeries \ud835\udd5c E F := fun k \u21a6 if h : n = k then h \u25b8 p n else 0\nm : \u2115\nhm : n + 1 \u2264 m\n\u22a2 n \u2260 m",["omega","aesop","linarith"]],["NumberTheory/Transcendental/Liouville/LiouvilleWith.lean",173,"p x : \u211d\nh : LiouvilleWith p x\nr : \u211a\nC : \u211d\n_hC\u2080 : 0 < C\nhC : \u2203\u1da0 (n : \u2115) in atTop, 1 \u2264 n \u2227 \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p\nn : \u2115\nhn : 1 \u2264 n\nm : \u2124\nhne : x \u2260 \u2191m / \u2191n\nhlt : |x - \u2191m / \u2191n| < C / \u2191n ^ p\nthis : \u2191(\u2191r.den * m + r.num * \u2191n) / \u2191(r.den \u2022 id n) = \u2191m / \u2191n + \u2191r\n\u22a2 \u2191r.den ^ p \u2260 0",["positivity"]],["Analysis/InnerProductSpace/Orientation.lean",57,"E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \u211d E\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne f : OrthonormalBasis \u03b9 \u211d E\nh : e.toBasis.orientation = f.toBasis.orientation\nthis : 0 < e.toBasis.det \u21d1f\n\u22a2 \u00ace.toBasis.det \u21d1f = -1",["linarith"]],["Analysis/SpecialFunctions/Log/Deriv.lean",308,"a : \u211d\nh : 0 < a\n\u22a2 0 < 2 * a + 1",["linarith","positivity"]],["Analysis/SpecialFunctions/Log/Deriv.lean",310,"a : \u211d\nh : 0 < a\nh\u2081 : |1 / (2 * a + 1)| < 1\n\u22a2 2 * a + 1 \u2260 0",["linarith","positivity"]],["Analysis/SpecialFunctions/Log/Deriv.lean",317,"case h.e'_6.hx\na : \u211d\nh : 0 < a\nh\u2081 : |1 / (2 * a + 1)| < 1\nh\u2082 : 2 * a + 1 \u2260 0\nh\u2083 : a \u2260 0\n\u22a2 \u00ac2 * a + 1 + 1 = 0",["linarith","positivity"]],["Analysis/SpecialFunctions/Log/Deriv.lean",334,"x : \u211d\nhx : 0 < x\nj\u271d : \u2115\na\u271d : j\u271d \u2260 0\n\u22a2 0 \u2264 2 * (1 / (2 * \u2191j\u271d + 1)) * (x / (x + 2)) ^ (2 * j\u271d + 1)",["positivity"]],["Analysis/Analytic/OfScalars.lean",270,"case h.e'_3.h.e'_6.ha\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedRing E\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c E\nc : \u2115 \u2192 \ud835\udd5c\ninst\u271d : NormOneClass E\nhc\u271d : Tendsto (fun n \u21a6 \u2016c n.succ\u2016 / \u2016c n\u2016) atTop atTop\nr : \u211d\u22650\nhr : \u2191r < (ofScalars E c).radius\nthis : 0 < r\nn : \u2115\nhc : 2 * \u2191r\u207b\u00b9 \u2264 \u2016c n.succ\u2016 / \u2016c n\u2016\nhn : n \u2260 0\n\u22a2 \u2191r ^ n \u2260 0",["aesop","positivity"]],["Analysis/Analytic/OfScalars.lean",302,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedRing E\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c E\nc : \u2115 \u2192 \ud835\udd5c\ninst\u271d : NormOneClass E\nr : \u211d\u22650\u221e\nhr : r = \u22a4\nhc' : Tendsto (fun n \u21a6 ENNReal.ofReal \u2016c n.succ\u2016 / ENNReal.ofReal \u2016c n\u2016) atTop (\ud835\udcdd \u22a4)\nn : \u2115\nhn : ENNReal.ofReal \u2016c n.succ\u2016 / ENNReal.ofReal \u2016c n\u2016 \u2260 0\n\u22a2 \u2016c (n + 1)\u2016 \u2260 0",["aesop","omega","infer_instance"]],["AlgebraicTopology/DoldKan/FunctorGamma.lean",144,"C : Type u_1\ninst\u271d\u00b3 : Category.{u_2, u_1} C\ninst\u271d\u00b2 : Preadditive C\nK : ChainComplex C \u2115\n\u0394 \u0394' \u0394'' : SimplexCategory\ni' : \u0394'' \u27f6 \u0394'\ni : \u0394' \u27f6 \u0394\ninst\u271d\u00b9 : Mono i'\ninst\u271d : Mono i\nh\u2081 : \u00ac\u0394 = \u0394'\nh\u2082 : \u00ac\u0394' = \u0394''\nk : \u2115\nhk : \u0394.len = \u0394'.len + k + 1\nk' : \u2115\nhk' : \u0394'.len = \u0394''.len + k' + 1\n\u22a2 \u0394.len = \u0394''.len + (k + k' + 2)",["omega","linarith"]],["AlgebraicTopology/DoldKan/FunctorGamma.lean",150,"C : Type u_1\ninst\u271d\u00b3 : Category.{u_2, u_1} C\ninst\u271d\u00b2 : Preadditive C\nK : ChainComplex C \u2115\n\u0394 \u0394' \u0394'' : SimplexCategory\ni' : \u0394'' \u27f6 \u0394'\ni : \u0394' \u27f6 \u0394\ninst\u271d\u00b9 : Mono i'\ninst\u271d : Mono i\nh\u2081 : \u00ac\u0394 = \u0394'\nh\u2082 : \u00ac\u0394' = \u0394''\nk : \u2115\nhk : \u0394.len = \u0394'.len + k + 1\nk' : \u2115\nhk' : \u0394'.len = \u0394''.len + k' + 1\nh : Is\u03b4\u2080 (i' \u226b i)\neq : 1 = k + k' + 2\n\u22a2 False",["omega"]],["Data/Nat/Multiplicity.lean",135,"n p : \u2115\nhp : Prime p\nhp' : _root_.Prime p\nh0 : 2 \u2264 p\nh1 : 1 \u2264 p * n + 1\n\u22a2 p * n + 1 \u2264 p * (n + 1)",["linarith"]],["Data/Nat/Multiplicity.lean",136,"n p : \u2115\nhp : Prime p\nhp' : _root_.Prime p\nh0 : 2 \u2264 p\nh1 : 1 \u2264 p * n + 1\nh2 : p * n + 1 \u2264 p * (n + 1)\n\u22a2 p * n + 1 \u2264 p * (n + 1) + 1",["omega"]],["Data/Real/Pi/Irrational.lean",283,"h' : \u00acIrrational (\u03c0 / 2)\na : \u2124\nb : \u2115\nhb : 0 < b\nh : \u03c0 / 2 = \u2191a / \u2191b\nha : 0 < \u2191a\nn : \u2115\n\u22a2 0 < \u2191a ^ (2 * n + 1) / \u2191n !",["positivity"]],["Data/Real/Pi/Irrational.lean",303,"case intro.intro.intro.intro.intro\nh' : \u00acIrrational (\u03c0 / 2)\na : \u2124\nb : \u2115\nhb : 0 < b\nh : \u03c0 / 2 = \u2191a / \u2191b\nha : 0 < \u2191a\nk : \u2200 (n : \u2115), 0 < \u2191a ^ (2 * n + 1) / \u2191n !\nj : \u2200\u1da0 (n : \u2115) in atTop, \u2191a ^ (2 * n + 1) / \u2191n ! * I n (\u03c0 / 2) < 1\nn : \u2115\nhn : \u2191a ^ (2 * n + 1) / \u2191n ! * I n (\u03c0 / 2) < 1\nhn' : 0 < \u2191a ^ (2 * n + 1) / \u2191n ! * I n (\u03c0 / 2)\nz : \u2124\nhz : eval\u2082 (Int.castRingHom \u211d) (\u2191a / \u2191b) (sinPoly n) * \u2191b ^ (2 * n + 1) = \u2191z\ne : I n (\u03c0 / 2) * (\u03c0 / 2) ^ (2 * n + 1) = \u2191n ! * eval\u2082 (Int.castRingHom \u211d) (\u03c0 / 2) (sinPoly n)\nthis\u271d : \u2191a ^ (2 * n + 1) / \u2191n ! * I n (\u03c0 / 2) = eval\u2082 (Int.castRingHom \u211d) (\u03c0 / 2) (sinPoly n) * \u2191b ^ (2 * n + 1)\nthis : 0 < z \u2227 z < 1\n\u22a2 False",["omega","linarith"]],["GroupTheory/Coxeter/Length.lean",191,"case inl.h\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\nlt : cs.length (w * cs.simple i) < cs.length w\nlength_ge : cs.length w \u2264 cs.length (w * cs.simple i) + 1\n\u22a2 cs.length (w * cs.simple i) + 1 = cs.length w",["omega","linarith"]],["GroupTheory/Coxeter/Length.lean",197,"case inr.h\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\ngt : cs.length (w * cs.simple i) > cs.length w\nlength_le : cs.length (w * cs.simple i) \u2264 cs.length w + 1\n\u22a2 cs.length (w * cs.simple i) = cs.length w + 1",["omega"]],["GroupTheory/Coxeter/Length.lean",234,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n\u03c9 : List B\nh\u03c9 : cs.IsReduced \u03c9\nj : \u2115\nh\u2081 : cs.length (cs.wordProd (take j \u03c9)) \u2264 (take j \u03c9).length\nh\u2082 : cs.length (cs.wordProd (drop j \u03c9)) \u2264 (drop j \u03c9).length\nh\u2083 : (take j \u03c9).length + (drop j \u03c9).length \u2264 cs.length (cs.wordProd (take j \u03c9)) + cs.length (cs.wordProd (drop j \u03c9))\n\u22a2 cs.length (cs.wordProd (take j \u03c9)) = (take j \u03c9).length \u2227 cs.length (cs.wordProd (drop j \u03c9)) = (drop j \u03c9).length",["omega"]],["GroupTheory/Coxeter/Length.lean",251,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni i' : B\nm : \u2115\nhM : M.M i i' \u2260 0\nh : cs.length (cs.wordProd (alternatingWord i i' (M.M i i' + 1))) < M.M i i' + 1\n\u22a2 \u00accs.length (cs.wordProd (alternatingWord i i' (M.M i i' + 1))) = M.M i i' + 1",["omega","aesop","linarith"]],["GroupTheory/Coxeter/Length.lean",254,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni i' : B\nm : \u2115\nhM : M.M i i' \u2260 0\nthis : M.M i i' + 1 \u2264 M.M i i' * 2\n\u22a2 M.M i i' * 2 - (M.M i i' + 1) = M.M i i' - 1",["omega"]],["GroupTheory/Coxeter/Length.lean",310,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\na\u271d : cs.length (cs.simple i * w) < cs.length w\n\u22a2 \u00accs.length (cs.simple i * w) = cs.length w + 1",["omega","aesop","linarith"]],["GroupTheory/Coxeter/Length.lean",318,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\na\u271d : \u00accs.length (cs.simple i * w) < cs.length w\n\u22a2 \u00accs.length (cs.simple i * w) + 1 = cs.length w",["omega","linarith"]],["GroupTheory/Coxeter/Length.lean",326,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\na\u271d : cs.length (w * cs.simple i) < cs.length w\n\u22a2 \u00accs.length (w * cs.simple i) = cs.length w + 1",["omega","aesop","linarith"]],["GroupTheory/Coxeter/Length.lean",334,"B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\na\u271d : \u00accs.length (w * cs.simple i) < cs.length w\n\u22a2 \u00accs.length (w * cs.simple i) + 1 = cs.length w",["omega","linarith"]],["CategoryTheory/Skeletal.lean",113,"C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\nx\u271d : C\n\u22a2 { obj := toSkeleton, map := fun {X Y} f \u21a6 (preCounitIso X).hom \u226b f \u226b (preCounitIso Y).inv }.map (\ud835\udfd9 x\u271d) =\n    \ud835\udfd9 ({ obj := toSkeleton, map := fun {X Y} f \u21a6 (preCounitIso X).hom \u226b f \u226b (preCounitIso Y).inv }.obj x\u271d)",["aesop","omega"]],["Analysis/Calculus/Monotone.lean",118,"case h\nf : StieltjesFunction\nx : \u211d\nhx : Tendsto (fun a \u21a6 f.measure a / volume a) ((vitaliFamily volume 1).filterAt x) (\ud835\udcdd (f.measure.rnDeriv volume x))\nh'x : f.measure.rnDeriv volume x < \u22a4\nh''x : \u00acleftLim (\u2191f) x \u2260 \u2191f x\nL1 : Tendsto (fun y \u21a6 (\u2191f y - \u2191f x) / (y - x)) (\ud835\udcdd[>] x) (\ud835\udcdd (f.measure.rnDeriv volume x).toReal)\nL2 : Tendsto (fun y \u21a6 (leftLim (\u2191f) y - \u2191f x) / (y - x)) (\ud835\udcdd[<] x) (\ud835\udcdd (f.measure.rnDeriv volume x).toReal)\nL3 :\n  Tendsto (fun y \u21a6 (leftLim (\u2191f) (y + 1 * (y - x) ^ 2) - \u2191f x) / (y - x)) (\ud835\udcdd[<] x) (\ud835\udcdd (f.measure.rnDeriv volume x).toReal)\ny : \u211d\nhy : y < x\nthis : 0 < (x - y) ^ 2\n\u22a2 y < y + 1 * (y - x) ^ 2",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",202,"case pos\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u2191x \u2264 1 / 2\nh\u2082 : 2 * \u2191x \u2264 1 / 2\nh\u2083 : \u00ac\u2191x \u2264 1 / 4\nh\u2084 : \u2191x + 1 / 4 \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",204,"case pos\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u2191x \u2264 1 / 2\nh\u2082 : 2 * \u2191x \u2264 1 / 2\nh\u2083 : \u00ac\u2191x \u2264 1 / 4\nh\u2084 : \u00ac\u2191x + 1 / 4 \u2264 1 / 2\nh\u2085 : 2 * (\u2191x + 1 / 4) - 1 \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",206,"case neg\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u2191x \u2264 1 / 2\nh\u2082 : 2 * \u2191x \u2264 1 / 2\nh\u2083 : \u00ac\u2191x \u2264 1 / 4\nh\u2084 : \u00ac\u2191x + 1 / 4 \u2264 1 / 2\nh\u2085 : \u00ac2 * (\u2191x + 1 / 4) - 1 \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",208,"case pos\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u2191x \u2264 1 / 2\nh\u2082 : \u00ac2 * \u2191x \u2264 1 / 2\nh\u271d\u00b9 : \u2191x \u2264 1 / 4\nh\u271d : 2 * (2 * \u2191x) - 1 \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",210,"case neg\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u2191x \u2264 1 / 2\nh\u2082 : \u00ac2 * \u2191x \u2264 1 / 2\nh\u271d\u00b9 : \u2191x \u2264 1 / 4\nh\u271d : \u00ac2 * (2 * \u2191x) - 1 \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",212,"case pos\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u2191x \u2264 1 / 2\nh\u2082 : \u00ac2 * \u2191x \u2264 1 / 2\nh\u271d\u00b9 : \u00ac\u2191x \u2264 1 / 4\nh\u271d : \u2191x + 1 / 4 \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",216,"case neg\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u2191x \u2264 1 / 2\nh\u2082 : \u00ac2 * \u2191x \u2264 1 / 2\nh\u271d\u00b2 : \u00ac\u2191x \u2264 1 / 4\nh\u271d\u00b9 : \u00ac\u2191x + 1 / 4 \u2264 1 / 2\nh\u271d : \u00ac2 * (\u2191x + 1 / 4) - 1 \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",218,"case pos\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u00ac\u2191x \u2264 1 / 2\nh\u271d\u00b9 : \u2191x \u2264 1 / 4\nh\u271d : 2 * \u2191x \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",220,"case pos\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u00ac\u2191x \u2264 1 / 2\nh\u271d\u00b2 : \u2191x \u2264 1 / 4\nh\u271d\u00b9 : \u00ac2 * \u2191x \u2264 1 / 2\nh\u271d : 2 * (2 * \u2191x) - 1 \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",222,"case neg\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u00ac\u2191x \u2264 1 / 2\nh\u271d\u00b2 : \u2191x \u2264 1 / 4\nh\u271d\u00b9 : \u00ac2 * \u2191x \u2264 1 / 2\nh\u271d : \u00ac2 * (2 * \u2191x) - 1 \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",224,"case pos\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u00ac\u2191x \u2264 1 / 2\nh\u271d\u00b9 : \u00ac\u2191x \u2264 1 / 4\nh\u271d : 1 / 2 * (\u2191x + 1) \u2264 1 / 2\n\u22a2 False",["linarith"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",226,"case pos\nX : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\nx : \u2191I\nh\u2081 : \u00ac\u2191x \u2264 1 / 2\nh\u271d\u00b2 : \u00ac\u2191x \u2264 1 / 4\nh\u271d\u00b9 : \u00ac1 / 2 * (\u2191x + 1) \u2264 1 / 2\nh\u271d : 2 * (1 / 2 * (\u2191x + 1)) - 1 \u2264 1 / 2\n\u22a2 False",["linarith"]],["Data/Nat/Choose/Multinomial.lean",61,"\u03b1 : Type u_1\ns : Finset \u03b1\na : \u03b1\nha : a \u2209 s\nf : \u03b1 \u2192 \u2115\n\u22a2 0 < \u220f i \u2208 cons a s ha, (f i)!",["positivity"]],["Data/Nat/Choose/Multinomial.lean",310,"\u03b9 : Type u_1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u2115\n\u22a2 \u220f i \u2208 s, (f i)! \u2260 0",["positivity"]],["Analysis/Convex/Radon.lean",96,"case hn\n\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nn k : \u2115\nh_card : finrank \ud835\udd5c E + 1 \u2264 k\nhk :\n  \u2200 {\u03b9 : Type u_1} {F : \u03b9 \u2192 Set E} {s : Finset \u03b9},\n    (\u2200 i \u2208 s, Convex \ud835\udd5c (F i)) \u2192\n      (\u2200 I \u2286 s, #I \u2264 finrank \ud835\udd5c E + 1 \u2192 (\u22c2 i \u2208 I, F i).Nonempty) \u2192 #s = k \u2192 (\u22c2 i \u2208 s, F i).Nonempty\n\u03b9 : Type u_1\nF : \u03b9 \u2192 Set E\ns : Finset \u03b9\nh_convex : \u2200 i \u2208 s, Convex \ud835\udd5c (F i)\nh_inter : \u2200 I \u2286 s, #I \u2264 finrank \ud835\udd5c E + 1 \u2192 (\u22c2 i \u2208 I, F i).Nonempty\nhn : #s = k + 1\ni : { x // x \u2208 s }\n\u22a2 #s - 1 = k",["omega","aesop"]],["Analysis/Convex/Radon.lean",102,"\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nn k : \u2115\nh_card : finrank \ud835\udd5c E + 1 \u2264 k\nhk :\n  \u2200 {\u03b9 : Type u_1} {F : \u03b9 \u2192 Set E} {s : Finset \u03b9},\n    (\u2200 i \u2208 s, Convex \ud835\udd5c (F i)) \u2192\n      (\u2200 I \u2286 s, #I \u2264 finrank \ud835\udd5c E + 1 \u2192 (\u22c2 i \u2208 I, F i).Nonempty) \u2192 #s = k \u2192 (\u22c2 i \u2208 s, F i).Nonempty\n\u03b9 : Type u_1\nF : \u03b9 \u2192 Set E\ns : Finset \u03b9\nh_convex : \u2200 i \u2208 s, Convex \ud835\udd5c (F i)\nh_inter : \u2200 I \u2286 s, #I \u2264 finrank \ud835\udd5c E + 1 \u2192 (\u22c2 i \u2208 I, F i).Nonempty\nhn : #s = k + 1\na : { x // x \u2208 s } \u2192 E := fun i \u21a6 \u22ef.some\n\u22a2 #s = k - 1 + 2",["omega"]],["Combinatorics/SimpleGraph/Turan.lean",138,"case right\nV : Type u_1\ninst\u271d\u00b2 : Fintype V\nG\u271d : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G\u271d.Adj\nr : \u2115\ns\u271d t\u271d : V\nG : SimpleGraph V\ninst\u271d : DecidableRel G.Adj\ns t : V\nhn : \u00acG.Adj s t\nh : G.degree s \u2260 G.degree t\ncf : G.CliqueFree (r + 1)\nhd : G.degree t < G.degree s\nthis : #(G.replaceVertex s t).edgeFinset = #G.edgeFinset + G.degree s - G.degree t\n\u22a2 #G.edgeFinset < #(G.replaceVertex s t).edgeFinset",["omega"]],["Combinatorics/SimpleGraph/Turan.lean",167,"case right\nV : Type u_1\ninst\u271d\u00b9 : Fintype V\nG : SimpleGraph V\ninst\u271d : DecidableRel G.Adj\nr : \u2115\ns t u : V\nhts : \u00acG.Adj t s\nhsu : \u00acG.Adj s u\nhst : \u00acG.Adj s t\ndst : G.degree s = G.degree t\ndsu : G.degree s = G.degree u\nh : G.Adj t u\ncf : G.CliqueFree (r + 1)\nnst : s \u2260 t\nntu : t \u2260 u\nthis : \u00ac(G.replaceVertex s t).Adj s u\nl1 : (G.replaceVertex s t).degree s = G.degree s\nl2 : (G.replaceVertex s t).degree u = G.degree u - 1\nl3 : 0 < G.degree u\n\u22a2 #G.edgeFinset < #G.edgeFinset + (G.replaceVertex s t).degree s - (G.replaceVertex s t).degree u",["omega"]],["Combinatorics/SimpleGraph/Turan.lean",223,"V : Type u_1\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\nr : \u2115\nh : G.IsTuranMaximal r\ninst\u271d : DecidableEq V\nfp : Finpartition univ := h.finpartition\nlarge : Finset V\nhl : large \u2208 fp.parts\nsmall : Finset V\nhs : small \u2208 fp.parts\nineq : #large + 1 < #large\nw : V\nhw : w \u2208 large\nv : V\nhv : v \u2208 small\ncf : G.CliqueFree (r + 1)\nlarge_eq : fp.part w = large\nsmall_eq : fp.part v = small\nhn : small = large\n\u22a2 False",["omega","aesop"]],["Combinatorics/SimpleGraph/Turan.lean",227,"case right\nV : Type u_1\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableRel G.Adj\nr : \u2115\nh : G.IsTuranMaximal r\ninst\u271d : DecidableEq V\nfp : Finpartition univ := h.finpartition\nlarge : Finset V\nhl : large \u2208 fp.parts\nsmall : Finset V\nhs : small \u2208 fp.parts\nineq : #small + 1 < #large\nw : V\nhw : w \u2208 large\nv : V\nhv : v \u2208 small\ncf : G.CliqueFree (r + 1)\nlarge_eq : fp.part w = large\nsmall_eq : fp.part v = small\nha : G.Adj v w\nthis : #large \u2264 Fintype.card V\n\u22a2 #G.edgeFinset < #G.edgeFinset + (Fintype.card V - #small) - (Fintype.card V - #large) - 1",["omega"]],["Order/OrderIsoNat.lean",184,"case h.e'_2.h.e'_1\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u2115 \u2192 \u03b1\nbad : Set \u2115 := {m | \u2200 (n : \u2115), m < n \u2192 \u00acr (f m) (f n)}\nhbad : bad.Finite\nm : \u2115\nhm : \u2200 (n : \u2115), m \u2264 n \u2192 n \u2209 bad\nn n' : \u2115\nhn1 : n + m < n'\nhn2 : r (f (n + m)) (f n')\n\u22a2 n + n' - n - m + m = n'",["omega"]],["NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean",107,"Fq : Type u_1\ninst\u271d\u00b9 : Fintype Fq\ninst\u271d : Field Fq\nb : Fq[X]\nhb : b \u2260 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nA : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log \u2191(Fintype.card Fq)\u2309\u208a).succ \u2192 Fq[X]\nhb\u03b5 : 0 < cardPowDegree b \u2022 \u03b5\none_lt_q : 1 < Fintype.card Fq\none_lt_q' : 1 < \u2191(Fintype.card Fq)\n\u22a2 0 < Fintype.card Fq",["omega","linarith","positivity"]],["Algebra/Order/Antidiag/Nat.lean",139,"case inr\nd : \u2115\ni : Fin d\nhd : d \u2260 1\nk r : \u2115\nhn : \u00ack * r = 0\nhd' : d \u2260 0\n\u22a2 2 \u2264 d",["omega"]],["Computability/Ackermann.lean",158,"m n : \u2115\n\u22a2 m + 1 + n + 1 \u2264 m + (m + n + 2)",["omega","linarith"]],["Computability/Ackermann.lean",181,"m n : \u2115\nh : 0 < m + 1\n\u22a2 n + 1 + 1 \u2264 m + (m + 1 + n + 1)",["omega","linarith"]],["Computability/Ackermann.lean",222,"m n : \u2115\n\u22a2 n + 1 + 1 \u2264 m + 1 + n + 1",["omega","linarith"]],["RingTheory/Polynomial/HilbertPoly.lean",62,"F : Type u_1\ninst\u271d\u00b9 : Field F\ninst\u271d : CharZero F\nd k : \u2115\n\u22a2 \u00acd ! = 0",["positivity"]],["RingTheory/Polynomial/HilbertPoly.lean",69,"F : Type u_1\ninst\u271d\u00b9 : Field F\ninst\u271d : CharZero F\nd k : \u2115\n\u22a2 \u00acd ! = 0",["positivity"]],["RingTheory/Polynomial/HilbertPoly.lean",86,"F : Type u_1\ninst\u271d\u00b9 : Field F\ninst\u271d : CharZero F\nd k n : \u2115\nhkn : k \u2264 n\n\u22a2 \u00acd ! = 0",["positivity"]],["Combinatorics/SetFamily/Shadow.lean",294,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nk : \u2115\n\ud835\udc9c : Finset (Finset \u03b1)\ns t : Finset \u03b1\nht : t \u2208 \ud835\udc9c\nhts : t \u2286 s\nhcard : #t + (k + 1) = #s\n\u22a2 #t + 1 \u2264 #s",["omega"]],["Analysis/Complex/AbelLimit.lean",171,"f : \u2115 \u2192 \u2102\nl : \u2102\nh : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, f i) atTop (\ud835\udcdd l)\nM : \u211d\nhM : 1 < M\ns : \u2115 \u2192 \u2102 := fun n \u21a6 \u2211 i \u2208 range n, f i\ng : \u2102 \u2192 \u2102 := fun z \u21a6 \u2211' (n : \u2115), f n * z ^ n\nhm : \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, \u2016\u2211 i \u2208 range n, f i - l\u2016 < \u03b5\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u22a2 \u03b5 / 4 / M > 0",["positivity"]],["Analysis/Complex/AbelLimit.lean",174,"f : \u2115 \u2192 \u2102\nl : \u2102\nh : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, f i) atTop (\ud835\udcdd l)\nM : \u211d\nhM : 1 < M\ns : \u2115 \u2192 \u2102 := fun n \u21a6 \u2211 i \u2208 range n, f i\ng : \u2102 \u2192 \u2102 := fun z \u21a6 \u2211' (n : \u2115), f n * z ^ n\nhm : \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, \u2016\u2211 i \u2208 range n, f i - l\u2016 < \u03b5\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nB\u2081 : \u2115\nhB\u2081 : \u2200 n \u2265 B\u2081, \u2016\u2211 i \u2208 range n, f i - l\u2016 < \u03b5 / 4 / M\nF : \u211d := \u2211 i \u2208 range B\u2081, \u2016l - s (i + 1)\u2016\n\u22a2 \u03b5 / 4 / (F + 1) > 0",["positivity"]],["Analysis/Complex/AbelLimit.lean",179,"f : \u2115 \u2192 \u2102\nl : \u2102\nh : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, f i) atTop (\ud835\udcdd l)\nM : \u211d\nhM : 1 < M\ns : \u2115 \u2192 \u2102 := fun n \u21a6 \u2211 i \u2208 range n, f i\ng : \u2102 \u2192 \u2102 := fun z \u21a6 \u2211' (n : \u2115), f n * z ^ n\nhm : \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, \u2016\u2211 i \u2208 range n, f i - l\u2016 < \u03b5\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nB\u2081 : \u2115\nhB\u2081 : \u2200 n \u2265 B\u2081, \u2016\u2211 i \u2208 range n, f i - l\u2016 < \u03b5 / 4 / M\nF : \u211d := \u2211 i \u2208 range B\u2081, \u2016l - s (i + 1)\u2016\nz : \u2102\nzn : \u2016z\u2016 < 1\nzm : \u20161 - z\u2016 < M * (1 - \u2016z\u2016)\nzd : \u2016z - 1\u2016 < \u03b5 / 4 / (F + 1)\np :\n  \u2200 \u03b5 > 0,\n    \u2203 N, \u2200 n \u2265 N, \u2016l - \u2211' (n : \u2115), f n * z ^ n - (1 - z) * \u2211 i \u2208 range n, (l - \u2211 j \u2208 range (i + 1), f j) * z ^ i\u2016 < \u03b5\n\u22a2 \u03b5 / 2 > 0",["positivity","aesop","linarith"]],["Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",86,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : HasExt C\nX : C\nS : ShortComplex C\nhS : S.ShortExact\nn\u2080 n\u2081 : \u2115\nh : n\u2080 + 1 = n\u2081\nthis : HasDerivedCategory C := HasDerivedCategory.standard C\n\u22a2 \u2191n\u2080 + 1 = \u2191n\u2081",["omega","aesop","linarith"]],["Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",105,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : HasExt C\nX : C\nS : ShortComplex C\nhS : S.ShortExact\nn\u2080 n\u2081 : \u2115\nh : n\u2080 + 1 = n\u2081\nthis : HasDerivedCategory C := HasDerivedCategory.standard C\n\u22a2 \u2191n\u2080 + 1 = \u2191n\u2081",["omega","aesop","linarith"]],["Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",208,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : HasExt C\nS : ShortComplex C\nhS : S.ShortExact\nY : C\nn\u2080 n\u2081 : \u2115\nh : 1 + n\u2080 = n\u2081\nthis : HasDerivedCategory C := HasDerivedCategory.standard C\n\u22a2 \u2191n\u2080 + 1 = \u2191n\u2081",["omega","linarith"]],["Algebra/Homology/DerivedCategory/Ext/ExactSequences.lean",224,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\ninst\u271d : HasExt C\nS : ShortComplex C\nhS : S.ShortExact\nY : C\nn\u2080 n\u2081 : \u2115\nh : 1 + n\u2080 = n\u2081\nthis : HasDerivedCategory C := HasDerivedCategory.standard C\n\u22a2 \u2191n\u2080 + 1 = \u2191n\u2081",["omega","linarith"]],["Analysis/SpecialFunctions/Complex/LogBounds.lean",197,"case hab.c0\nz : \u2102\nhz : \u2016z\u2016 \u2264 1 / 2\nhz3 : (1 - \u2016z\u2016)\u207b\u00b9 \u2264 2\n\u22a2 0 \u2264 1 - \u2016z\u2016",["linarith"]],["Analysis/SpecialFunctions/Complex/LogBounds.lean",203,"z : \u2102\nhz : \u2016z\u2016 \u2264 1 / 2\nhz3 : (1 - \u2016z\u2016)\u207b\u00b9 \u2264 2\nhz4 : \u2016z\u2016 ^ 2 * (1 - \u2016z\u2016)\u207b\u00b9 / 2 \u2264 \u2016z\u2016 / 2\n\u22a2 \u2016z\u2016 ^ 2 * (1 - \u2016z\u2016)\u207b\u00b9 / 2 + \u2016z\u2016 \u2264 3 / 2 * \u2016z\u2016",["linarith"]],["NumberTheory/LSeries/Injectivity.lean",38,"m n : \u2115\nz : \u2102\nx : \u211d\n\u22a2 0 \u2264 (\u2191n + 1)\u207b\u00b9",["positivity"]],["NumberTheory/LSeries/Injectivity.lean",90,"f : \u2115 \u2192 \u2102\nn : \u2115\nh : \u2200 m \u2264 n, f m = 0\nha : abscissaOfAbsConv f < \u22a4\ny : \u211d\nhay : abscissaOfAbsConv f < \u2191y\nhyt : \u2191y < \u22a4\nF : \u211d \u2192 \u2115 \u2192 \u2102 := fun x \u21a6 {m | n + 1 < m}.indicator fun m \u21a6 f m / (\u2191m / (\u2191n + 1)) ^ \u2191x\nhF\u2080 : \u2200 (x : \u211d) {m : \u2115}, m \u2264 n + 1 \u2192 F x m = 0\nhF : \u2200 (x : \u211d) {m : \u2115}, m \u2260 n + 1 \u2192 F x m = (\u2191n + 1) ^ \u2191x * term f (\u2191x) m\nhs : \u2200 {x : \u211d}, x \u2265 y \u2192 Summable fun m \u21a6 (\u2191n + 1) ^ \u2191x * term f (\u2191x) m\nkey : \u2200 x \u2265 y, (\u2191n + 1) ^ \u2191x * LSeries f \u2191x = f (n + 1) + \u2211' (m : \u2115), F x m\nhys : Summable (F y)\nk : \u2115\nH : n + 1 < k\n\u22a2 0 \u2264 \u2191k / (\u2191n + 1)",["positivity"]],["NumberTheory/LSeries/Injectivity.lean",91,"f : \u2115 \u2192 \u2102\nn : \u2115\nh : \u2200 m \u2264 n, f m = 0\nha : abscissaOfAbsConv f < \u22a4\ny : \u211d\nhay : abscissaOfAbsConv f < \u2191y\nhyt : \u2191y < \u22a4\nF : \u211d \u2192 \u2115 \u2192 \u2102 := fun x \u21a6 {m | n + 1 < m}.indicator fun m \u21a6 f m / (\u2191m / (\u2191n + 1)) ^ \u2191x\nhF\u2080 : \u2200 (x : \u211d) {m : \u2115}, m \u2264 n + 1 \u2192 F x m = 0\nhF : \u2200 (x : \u211d) {m : \u2115}, m \u2260 n + 1 \u2192 F x m = (\u2191n + 1) ^ \u2191x * term f (\u2191x) m\nhs : \u2200 {x : \u211d}, x \u2265 y \u2192 Summable fun m \u21a6 (\u2191n + 1) ^ \u2191x * term f (\u2191x) m\nkey : \u2200 x \u2265 y, (\u2191n + 1) ^ \u2191x * LSeries f \u2191x = f (n + 1) + \u2211' (m : \u2115), F x m\nhys : Summable (F y)\nk : \u2115\nH : n + 1 < k\nH\u2080 : 0 \u2264 \u2191k / (\u2191n + 1)\n\u22a2 0 \u2264 (\u2191n + 1) / \u2191k",["positivity"]],["Analysis/Normed/Unbundled/SeminormFromConst.lean",147,"case h\nR : Type ?u.20102\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx y : R\nn : \u2115\n\u22a2 n \u2264 2 * n",["omega","linarith"]],["Algebra/BigOperators/Intervals.lean",180,"case refine_1.intro.intro.intro\nM : Type u_3\ninst\u271d : AddCommMonoid M\na\u271d b\u271d : \u2115\nf : \u2115 \u2192 \u2115 \u2192 M\na b : \u2115\nh\u2081 : a\u271d \u2264 a\nh\u2082 : a < b\u271d\nh\u2083 : a \u2264 b\nh\u2084 : b < b\u271d\n\u22a2 (a\u271d \u2264 b \u2227 b < b\u271d) \u2227 a\u271d \u2264 a \u2227 a < b + 1\n```\n---\n```lean\ncase refine_2.intro.intro.intro\nM : Type u_3\ninst\u271d : AddCommMonoid M\na\u271d b\u271d : \u2115\nf : \u2115 \u2192 \u2115 \u2192 M\na b : \u2115\nh\u2081 : a\u271d \u2264 a\nh\u2082 : a < b\u271d\nh\u2083 : a\u271d \u2264 b\nh\u2084 : b < a + 1\n\u22a2 (a\u271d \u2264 b \u2227 b < b\u271d) \u2227 b \u2264 a \u2227 a < b\u271d",["omega"]],["Algebra/BigOperators/Intervals.lean",191,"case refine_1.intro.intro.intro\nM : Type u_3\ninst\u271d : AddCommMonoid M\na\u271d b\u271d : \u2115\nf : \u2115 \u2192 \u2115 \u2192 M\na b : \u2115\nh\u2081 : a\u271d \u2264 a\nh\u2082 : a < b\u271d\nh\u2083 : a + 1 \u2264 b\nh\u2084 : b < b\u271d\n\u22a2 (a\u271d \u2264 b \u2227 b < b\u271d) \u2227 a\u271d \u2264 a \u2227 a < b\n```\n---\n```lean\ncase refine_2.intro.intro.intro\nM : Type u_3\ninst\u271d : AddCommMonoid M\na\u271d b\u271d : \u2115\nf : \u2115 \u2192 \u2115 \u2192 M\na b : \u2115\nh\u2081 : a\u271d \u2264 a\nh\u2082 : a < b\u271d\nh\u2083 : a\u271d \u2264 b\nh\u2084 : b < a\n\u22a2 (a\u271d \u2264 b \u2227 b < b\u271d) \u2227 b + 1 \u2264 a \u2227 a < b\u271d",["omega"]],["NumberTheory/FLT/Basic.lean",88,"n : \u2115\nh : FermatLastTheoremWith \u2115 n\na b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\nhabc : a ^ n + b ^ n = c ^ n\nhn : Even n\n\u22a2 c.natAbs \u2260 0",["positivity","omega","aesop"]],["NumberTheory/FLT/Basic.lean",94,"n : \u2115\nh : FermatLastTheoremWith \u2115 n\na b c : \u2124\nha\u271d : a \u2260 0\nhb\u271d : b \u2260 0\nhc\u271d : c \u2260 0\nhabc : a ^ n + b ^ n = c ^ n\nhn : Odd n\nha : a < 0\nhb : b < 0\nhc : c < 0\n\u22a2 c.natAbs \u2260 0",["positivity"]],["NumberTheory/FLT/Basic.lean",100,"n : \u2115\nh : FermatLastTheoremWith \u2115 n\na b c : \u2124\nha\u271d : a \u2260 0\nhb\u271d : b \u2260 0\nhc\u271d : c \u2260 0\nhabc : a ^ n + b ^ n = c ^ n\nhn : Odd n\nha : a < 0\nhb : 0 < b\nhc : c < 0\n\u22a2 a.natAbs \u2260 0",["positivity"]],["NumberTheory/FLT/Basic.lean",105,"n : \u2115\nh : FermatLastTheoremWith \u2115 n\na b c : \u2124\nha\u271d : a \u2260 0\nhb\u271d : b \u2260 0\nhc\u271d : c \u2260 0\nhabc : a ^ n + b ^ n = c ^ n\nhn : Odd n\nha : a < 0\nhb : 0 < b\nhc : 0 < c\n\u22a2 b.natAbs \u2260 0",["positivity"]],["NumberTheory/FLT/Basic.lean",110,"n : \u2115\nh : FermatLastTheoremWith \u2115 n\na b c : \u2124\nha\u271d : a \u2260 0\nhb\u271d : b \u2260 0\nhc\u271d : c \u2260 0\nhabc : a ^ n + b ^ n = c ^ n\nhn : Odd n\nha : 0 < a\nhb : b < 0\nhc : c < 0\n\u22a2 b.natAbs \u2260 0",["positivity"]],["NumberTheory/FLT/Basic.lean",115,"n : \u2115\nh : FermatLastTheoremWith \u2115 n\na b c : \u2124\nha\u271d : a \u2260 0\nhb\u271d : b \u2260 0\nhc\u271d : c \u2260 0\nhabc : a ^ n + b ^ n = c ^ n\nhn : Odd n\nha : 0 < a\nhb : b < 0\nhc : 0 < c\n\u22a2 a.natAbs \u2260 0",["positivity"]],["NumberTheory/FLT/Basic.lean",121,"n : \u2115\nh : FermatLastTheoremWith \u2115 n\na b c : \u2124\nha\u271d : a \u2260 0\nhb\u271d : b \u2260 0\nhc\u271d : c \u2260 0\nhabc : a ^ n + b ^ n = c ^ n\nhn : Odd n\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\n\u22a2 c.natAbs \u2260 0",["positivity"]],["NumberTheory/FLT/Basic.lean",130,"n : \u2115\ntfae_1_to_2 : FermatLastTheoremWith \u2115 n \u2192 FermatLastTheoremWith \u2124 n\nh : FermatLastTheoremWith \u2124 n\na b c : \u211a\nha : a.num \u2260 0\nhb : b.num \u2260 0\nhc : c.num \u2260 0\nhabc : a ^ n + b ^ n = c ^ n\n\u22a2 (\u2191a.den * \u2191b.den * \u2191c.den) ^ n \u2260 0",["positivity"]],["NumberTheory/ModularForms/JacobiTheta/Bounds.lean",73,"k : \u2115\na t : \u211d\nha : 0 \u2264 a\nht : 0 < t\nn : \u2115\n\u22a2 0 \u2264 (\u2191n + a) ^ k",["positivity"]],["Analysis/Normed/Algebra/TrivSqZeroExt.lean",233,"case h\n\ud835\udd5c : Type u_1\nS : Type u_2\nR : Type u_3\nM : Type u_4\ninst\u271d\u00b9\u00b9 : SeminormedCommRing S\ninst\u271d\u00b9\u2070 : SeminormedRing R\ninst\u271d\u2079 : SeminormedAddCommGroup M\ninst\u271d\u2078 : Algebra S R\ninst\u271d\u2077 : Module S M\ninst\u271d\u2076 : IsBoundedSMul S R\ninst\u271d\u2075 : IsBoundedSMul S M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : IsBoundedSMul R M\ninst\u271d\u00b2 : Module R\u1d50\u1d52\u1d56 M\ninst\u271d\u00b9 : IsBoundedSMul R\u1d50\u1d52\u1d56 M\ninst\u271d : SMulCommClass R R\u1d50\u1d52\u1d56 M\nr\u2081 : R\nm\u2081 : M\nr\u2082 : R\nm\u2082 : M\n\u22a2 0 \u2264 \u2016m\u2081\u2016 * \u2016m\u2082\u2016",["positivity"]],["Analysis/InnerProductSpace/Subspace.lean",212,"case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nG : \u03b9 \u2192 Type u_5\ninst\u271d\u00b2 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\nV : (i : \u03b9) \u2192 G i \u2192\u2097\u1d62[\ud835\udd5c] E\nhV : OrthogonalFamily \ud835\udd5c G V\ninst\u271d : CompleteSpace E\nf : (i : \u03b9) \u2192 G i\nhf : \u2200 \u03b5 > 0, \u2203 N, \u2200 (m : Finset \u03b9), N \u2264 m \u2192 \u2200 (n : Finset \u03b9), N \u2264 n \u2192 \u2016\u2211 i \u2208 m, (V i) (f i) - \u2211 i \u2208 n, (V i) (f i)\u2016 < \u03b5\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\na : Finset \u03b9\nH : \u2200 (m : Finset \u03b9), a \u2264 m \u2192 \u2200 (n : Finset \u03b9), a \u2264 n \u2192 \u2016\u2211 i \u2208 m, (V i) (f i) - \u2211 i \u2208 n, (V i) (f i)\u2016 < \u221a\u03b5\ns\u2081 : Finset \u03b9\nhs\u2081 : a \u2264 s\u2081\ns\u2082 : Finset \u03b9\nhs\u2082 : a \u2264 s\u2082\nthis\u271d : \u2200 (i : \u03b9), 0 \u2264 \u2016f i\u2016 ^ 2\nthis : \u2211 i \u2208 s\u2081 \\ s\u2082, \u2016f i\u2016 ^ 2 + \u2211 i \u2208 s\u2082 \\ s\u2081, \u2016f i\u2016 ^ 2 < \u221a\u03b5 ^ 2\nh\u03b7 : \u221a\u03b5 ^ 2 = \u03b5\n\u22a2 \u2211 x \u2208 s\u2081 \\ s\u2082, \u2016f x\u2016 ^ 2 + \u2211 x \u2208 s\u2082 \\ s\u2081, \u2016f x\u2016 ^ 2 < \u03b5",["linarith","aesop"]],["Analysis/InnerProductSpace/Subspace.lean",233,"case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nG : \u03b9 \u2192 Type u_5\ninst\u271d\u00b2 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\nV : (i : \u03b9) \u2192 G i \u2192\u2097\u1d62[\ud835\udd5c] E\nhV : OrthogonalFamily \ud835\udd5c G V\ninst\u271d : CompleteSpace E\nf : (i : \u03b9) \u2192 G i\nhf : \u2200 \u03b5 > 0, \u2203 N, \u2200 (m : Finset \u03b9), N \u2264 m \u2192 \u2200 (n : Finset \u03b9), N \u2264 n \u2192 |\u2211 i \u2208 m, \u2016f i\u2016 ^ 2 - \u2211 i \u2208 n, \u2016f i\u2016 ^ 2| < \u03b5\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh\u03b5' : 0 < \u03b5 ^ 2 / 2\na : Finset \u03b9\nH : \u2200 (m : Finset \u03b9), a \u2264 m \u2192 \u2200 (n : Finset \u03b9), a \u2264 n \u2192 |\u2211 i \u2208 m, \u2016f i\u2016 ^ 2 - \u2211 i \u2208 n, \u2016f i\u2016 ^ 2| < \u03b5 ^ 2 / 2\ns\u2081 : Finset \u03b9\nhs\u2081 : a \u2264 s\u2081\ns\u2082 : Finset \u03b9\nhs\u2082 : a \u2264 s\u2082\nhas : a \u2264 s\u2081 \u2293 s\u2082\nHs\u2081 : \u2211 x \u2208 s\u2081 \\ s\u2082, \u2016f x\u2016 ^ 2 < \u03b5 ^ 2 / 2\nHs\u2082 : \u2211 x \u2208 s\u2082 \\ s\u2081, \u2016f x\u2016 ^ 2 < \u03b5 ^ 2 / 2\n\u22a2 \u2211 i \u2208 s\u2081 \\ s\u2082, \u2016f i\u2016 ^ 2 + \u2211 i \u2208 s\u2082 \\ s\u2081, \u2016f i\u2016 ^ 2 < \u03b5 ^ 2",["linarith"]],["MeasureTheory/Integral/TorusIntegral.lean",180,"n : \u2115\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : (Fin n \u2192 \u2102) \u2192 E\nc : Fin n \u2192 \u2102\nR : Fin n \u2192 \u211d\nC : \u211d\nhf : \u2200 (\u03b8 : Fin n \u2192 \u211d), \u2016f (torusMap c R \u03b8)\u2016 \u2264 C\n\u03b8 : Fin n \u2192 \u211d\nx\u271d : \u03b8 \u2208 Icc 0 fun x \u21a6 2 * \u03c0\n\u22a2 0 \u2264 \u220f i : Fin n, |R i|",["positivity"]],["Analysis/Convex/Continuous.lean",28,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nx\u2080 : E\n\u03b5 r M : \u211d\nhf : ConvexOn \u211d (ball x\u2080 r) f\nh\u03b5 : 0 < \u03b5\nhM : \u2200 (a : E), dist a x\u2080 < r \u2192 |f a| \u2264 M\nK : \u211d := 2 * M / \u03b5\nhK : K = 2 * M / \u03b5\nx y : E\nhx : x \u2208 ball x\u2080 (r - \u03b5)\nhy : y \u2208 ball x\u2080 (r - \u03b5)\nhxy : x \u2260 y\n\u22a2 r - \u03b5 \u2264 r",["linarith"]],["NumberTheory/FLT/Polynomial.lean",222,"k : Type u_1\ninst\u271d : Field k\nn : \u2115\nhn : 3 \u2264 n\nchn : \u2191n \u2260 0\na b c : k[X]\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\nhab : IsCoprime a b\nheq : a ^ n + b ^ n = c ^ n\n\u22a2 0 < n",["linarith","omega","positivity"]],["NumberTheory/FLT/Polynomial.lean",184,"k : Type u_1\ninst\u271d : Field k\np q r : \u2115\nu v w : k\nhp : 0 < p\nhq : 0 < q\nhr : 0 < r\nhineq : q * r + r * p + p * q \u2264 p * q * r\nchp : \u2191p \u2260 0\nchq : \u2191q \u2260 0\nchr : \u2191r \u2260 0\nhu : u \u2260 0\nhv : v \u2260 0\nhw : w \u2260 0\nd : \u2115\na b c : k[X]\nheq : C u * a ^ p + C v * b ^ q + C w * c ^ r = 0\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\nhab : IsCoprime a b\neq_d : a.natDegree = d + 1\nad : derivative a = 0\nbd : derivative b = 0\ncd : derivative c = 0\nca : k[X]\nca_nz : ca \u2260 0\ncb : k[X]\ncb_nz : cb \u2260 0\ncc : k[X]\ncc_nz : cc \u2260 0\nch : \u2115 := ringChar k\nchn0 : ch \u2260 0\neq_a : a = (expand k ch) ca\neq_deg_a : a.natDegree = ca.natDegree * ch\neq_b : b = (expand k ch) cb\neq_deg_b : b.natDegree = cb.natDegree * ch\neq_c : c = (expand k ch) cc\neq_deg_c : c.natDegree = cc.natDegree * ch\nhnca : \u00acca.natDegree = 0\nx\u271d : ch \u2260 1\n\u22a2 2 \u2264 ch",["omega"]],["NumberTheory/FLT/Polynomial.lean",187,"k : Type u_1\ninst\u271d : Field k\np q r : \u2115\nu v w : k\nhp : 0 < p\nhq : 0 < q\nhr : 0 < r\nhineq : q * r + r * p + p * q \u2264 p * q * r\nchp : \u2191p \u2260 0\nchq : \u2191q \u2260 0\nchr : \u2191r \u2260 0\nhu : u \u2260 0\nhv : v \u2260 0\nhw : w \u2260 0\nd : \u2115\na b c : k[X]\nheq : C u * a ^ p + C v * b ^ q + C w * c ^ r = 0\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\nhab : IsCoprime a b\neq_d : a.natDegree = d + 1\nad : derivative a = 0\nbd : derivative b = 0\ncd : derivative c = 0\nca : k[X]\nca_nz : ca \u2260 0\ncb : k[X]\ncb_nz : cb \u2260 0\ncc : k[X]\ncc_nz : cc \u2260 0\nch : \u2115 := ringChar k\nchn0 : ch \u2260 0\neq_a : a = (expand k ch) ca\neq_deg_a : a.natDegree = ca.natDegree * ch\neq_b : b = (expand k ch) cb\neq_deg_b : b.natDegree = cb.natDegree * ch\neq_c : c = (expand k ch) cc\neq_deg_c : c.natDegree = cc.natDegree * ch\nhnca : \u00acca.natDegree = 0\nx\u271d : ch \u2260 1\nhch2 : 2 \u2264 ch\n\u22a2 ca.natDegree + 1 \u2264 ca.natDegree * 2",["omega"]],["NumberTheory/FLT/Polynomial.lean",245,"k : Type u_1\ninst\u271d : Field k\nn : \u2115\nhn : 3 \u2264 n\nchn : \u2191n \u2260 0\na b c : k[X]\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\na' b' : k[X]\nd : k[X] := gcd a b\nheq : d ^ n * (a' ^ n + b' ^ n) = c ^ n\neq_a : a = d * a'\neq_b : b = d * b'\nhd : d \u2260 0\n\u22a2 0 < n",["omega","linarith","positivity"]],["NumberTheory/LSeries/HurwitzZetaValues.lean",147,"k : \u2115\nx : \u211d\nhk : k \u2260 0\nhx : x \u2208 Icc 0 1\nn : \u2115\n\u22a2 0 < 2 * \u2191k + 1",["positivity","omega","linarith"]],["NumberTheory/LSeries/HurwitzZetaValues.lean",65,"k : \u2115\nx : \u211d\nhk : k \u2260 0\nhx : x \u2208 Icc 0 1\n\u22a2 1 < 2 * k",["omega"]],["NumberTheory/LSeries/HurwitzZetaValues.lean",91,"k : \u2115\nx : \u211d\nhk : k \u2260 0\nhx : x \u2208 Icc 0 1\n\u22a2 1 < 2 * k + 1",["omega"]],["Computability/RegularExpressions.lean",263,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nP : RegularExpression \u03b1\na : \u03b1\nx : List \u03b1\nIH :\n  \u2200 (t : List \u03b1),\n    t.length < (a :: x).length \u2192 (P.star.rmatch t = true \u2194 \u2203 S, t = S.flatten \u2227 \u2200 t \u2208 S, t \u2260 [] \u2227 P.rmatch t = true)\nt u : List \u03b1\nhs : x = t ++ u\nht : (P.deriv a).rmatch t = true\nhu : P.star.rmatch u = true\n\u22a2 u.length < t.length + u.length + 1",["omega"]],["Computability/RegularExpressions.lean",293,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nP : RegularExpression \u03b1\na : \u03b1\nx : List \u03b1\nIH :\n  \u2200 (t : List \u03b1),\n    t.length < (a :: x).length \u2192 (P.star.rmatch t = true \u2194 \u2203 S, t = S.flatten \u2227 \u2200 t \u2208 S, t \u2260 [] \u2227 P.rmatch t = true)\nU : List (List \u03b1)\nb : \u03b1\nt : List \u03b1\nhelem : \u2200 t_1 \u2208 (b :: t) :: U, t_1 \u2260 [] \u2227 P.rmatch t_1 = true\nhsum : a = b \u2227 x = t ++ U.flatten\n\u22a2 (map length U).sum < t.length + (map length U).sum + 1",["omega"]],["Order/Interval/Finset/Nat.lean",33,"a\u271d b\u271d c a b x : \u2115\n\u22a2 a \u2264 x \u2227 x < a + (b + 1 - a) \u2194 a \u2264 x \u2227 x \u2264 b",["omega"]],["Order/Interval/Finset/Nat.lean",34,"a\u271d b\u271d c a b x : \u2115\n\u22a2 a \u2264 x \u2227 x < a + (b - a) \u2194 a \u2264 x \u2227 x < b",["omega"]],["Order/Interval/Finset/Nat.lean",35,"a\u271d b\u271d c a b x : \u2115\n\u22a2 a + 1 \u2264 x \u2227 x < a + 1 + (b - a) \u2194 a < x \u2227 x \u2264 b",["omega"]],["Order/Interval/Finset/Nat.lean",36,"a\u271d b\u271d c a b x : \u2115\n\u22a2 a + 1 \u2264 x \u2227 x < a + 1 + (b - a - 1) \u2194 a < x \u2227 x < b",["omega"]],["Order/Interval/Finset/Nat.lean",150,"case h\na b : \u2115\nh : a \u2264 b\nx : \u2115\n\u22a2 x = a \u2228 a + 1 \u2264 x \u2227 x \u2264 b \u2194 a \u2264 x \u2227 x \u2264 b",["omega"]],["Order/Interval/Finset/Nat.lean",155,"case h\na b : \u2115\nh : a \u2264 b + 1\nx : \u2115\n\u22a2 x = b + 1 \u2228 a \u2264 x \u2227 x \u2264 b \u2194 a \u2264 x \u2227 x \u2264 b + 1",["omega"]],["Order/Interval/Finset/Nat.lean",163,"case h.intro.intro\na b c : \u2115\nh : c \u2264 a\nx : \u2115\nhx : a \u2264 x \u2227 x < b\n\u22a2 a - c \u2264 x - c \u2227 x - c < b - c",["omega"]],["Order/Interval/Finset/Nat.lean",171,"case h.intro.intro\na b c : \u2115\nhac : a \u2264 c\nx : \u2115\nhx : a \u2264 x \u2227 x < b\n\u22a2 c + 1 - b \u2264 c - x \u2227 c - x < c + 1 - a",["omega"]],["Analysis/Fourier/PoissonSummation.lean",138,"E : Type u_1\ninst\u271d : NormedAddCommGroup E\nf : C(\u211d, E)\nb : \u211d\nhb : 0 < b\nhf : \u21d1f =O[atTop] fun x \u21a6 |x| ^ (-b)\nR S : \u211d\nclaim : \u2200 (x : \u211d), 0 \u2294 -2 * R < x \u2192 \u2200 (y : \u211d), x + R \u2264 y \u2192 y ^ (-b) \u2264 (1 / 2) ^ (-b) * x ^ (-b)\nc : \u211d\nhc : c > 0\nd : \u211d\nhd : \u2200 b_1 \u2265 d, \u2016f b_1\u2016 \u2264 c * \u2016|b_1| ^ (-b)\u2016\nx : \u211d\nhx : 1 + 0 \u2294 -2 * R \u2264 x \u2227 d - R \u2264 x\n\u22a2 0 \u2294 -2 * R < x",["linarith"]],["Analysis/Fourier/PoissonSummation.lean",142,"E : Type u_1\ninst\u271d : NormedAddCommGroup E\nf : C(\u211d, E)\nb : \u211d\nhb : 0 < b\nhf : \u21d1f =O[atTop] fun x \u21a6 |x| ^ (-b)\nR S : \u211d\nclaim : \u2200 (x : \u211d), 0 \u2294 -2 * R < x \u2192 \u2200 (y : \u211d), x + R \u2264 y \u2192 y ^ (-b) \u2264 (1 / 2) ^ (-b) * x ^ (-b)\nc : \u211d\nhc : c > 0\nd : \u211d\nhd : \u2200 b_1 \u2265 d, \u2016f b_1\u2016 \u2264 c * \u2016|b_1| ^ (-b)\u2016\nx\u271d : \u211d\nhx : 1 + 0 \u2294 -2 * R \u2264 x\u271d \u2227 d - R \u2264 x\u271d\nhx' : 0 < x\u271d \u2227 -2 * R < x\u271d\ny : \u2191(Icc (x\u271d + R) (x\u271d + S))\nx : \u211d\n\u22a2 0 \u2264 |x| ^ (-b)",["positivity"]],["Combinatorics/Schnirelmann.lean",180,"A : Set \u2115\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 A\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhA : schnirelmannDensity A = 0\nh : \u03b5 \u2264 schnirelmannDensity A\n\u22a2 False",["linarith"]],["Combinatorics/Schnirelmann.lean",56,"A : Set \u2115\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 A\nx\u271d : { n // 0 < n }\n\u22a2 0 \u2264 \u2191(#(filter (fun a \u21a6 a \u2208 A) (Ioc 0 \u2191x\u271d))) / \u2191\u2191x\u271d",["positivity"]],["Algebra/Homology/HomotopyCategory/DegreewiseSplit.lean",81,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.47183, u_1} C\ninst\u271d\u00b9 : Preadditive C\nS : ShortComplex (CochainComplex C \u2124)\n\u03c3 : (n : \u2124) \u2192 (S.map (eval C (ComplexShape.up \u2124) n)).Splitting\ninst\u271d : HasBinaryBiproducts C\np q : \u2124\nhpq : p + 1 = q\n\u22a2 p + 1 + 0 = q",["omega","aesop","linarith"]],["Analysis/SpecialFunctions/Bernstein.lean",65,"n \u03bd : \u2115\nx : \u2191I\nh\u2081 : 0 \u2264 \u2191x\nh\u2082 : 0 \u2264 1 - \u2191x\n\u22a2 0 \u2264 \u2191(n.choose \u03bd) * \u2191x ^ \u03bd * (1 - \u2191x) ^ (n - \u03bd)",["positivity"]],["Analysis/SpecialFunctions/Bernstein.lean",221,"f : C(\u2191I, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n \u21a6 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (\ud835\udcdd 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\n\u22a2 0 < \u2191n",["positivity","aesop"]],["Combinatorics/Extremal/RuzsaSzemeredi.lean",266,"n : \u2115\nhn : 6 \u2264 \u2191n\n\u22a2 0 \u2264 \u2191n / 3 - 2",["linarith"]],["Combinatorics/Extremal/RuzsaSzemeredi.lean",262,"case refine_3.h.hx\nx : \u2115\nhx : x \u2265 9\n\u22a2 6 \u2264 x - 3",["omega"]],["Algebra/Lie/LieTheorem.lean",74,"R : Type u_1\nL : Type u_2\nA : Type u_3\nV : Type u_4\ninst\u271d\u00b9\u2079 : CommRing R\ninst\u271d\u00b9\u2078 : IsPrincipalIdealRing R\ninst\u271d\u00b9\u2077 : IsDomain R\ninst\u271d\u00b9\u2076 : CharZero R\ninst\u271d\u00b9\u2075 : LieRing L\ninst\u271d\u00b9\u2074 : LieAlgebra R L\ninst\u271d\u00b9\u00b3 : LieRing A\ninst\u271d\u00b9\u00b2 : LieAlgebra R A\ninst\u271d\u00b9\u00b9 : Bracket L A\ninst\u271d\u00b9\u2070 : Bracket A L\ninst\u271d\u2079 : AddCommGroup V\ninst\u271d\u2078 : Module R V\ninst\u271d\u2077 : Module.Free R V\ninst\u271d\u2076 : Module.Finite R V\ninst\u271d\u2075 : LieRingModule L V\ninst\u271d\u2074 : LieModule R L V\ninst\u271d\u00b3 : LieRingModule A V\ninst\u271d\u00b2 : LieModule R A V\ninst\u271d\u00b9 : IsLieTower L A V\ninst\u271d : IsLieTower A L V\n\u03c7 : A \u2192 R\nz : L\nv : V\nhv : \u2200 (x : A), \u2045x, v\u2046 = \u03c7 x \u2022 v\na : A\nhv' : v \u2260 0\nU' : \u2115 \u2192o Submodule R V :=\n  { toFun := fun n \u21a6 Submodule.span R {x | \u2203 i < n, ((toEnd R L V) z ^ i) v = x}, monotone' := \u22ef }\nmap_U'_le : \u2200 (n : \u2115), Submodule.map ((toEnd R L V) z) (U' n) \u2264 U' (n + 1)\nn : \u2115\nhn :\n  \u2200 (w : A),\n    \u2200 a < n + 1, (LieModule.T \u03c7 w) (((toEnd R L V) z ^ a) v) \u2208 Submodule.span R {x | \u2203 i < n, ((toEnd R L V) z ^ i) v = x}\nw : A\nm : \u2115\nhm : m < n + 1 + 1\n\u22a2 m < n + 1 \u2228 m = n + 1",["omega"]],["Logic/Denumerable.lean",207,"s : Set \u2115\ninst\u271d\u00b9 : Infinite \u2191s\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 s\nx y : \u2191s\nh : y < x\nhx : \u2203 m, \u2191y + m + 1 \u2208 s\nk : \u2115\nhk : \u2191x = \u2191y + k + 1\nthis : Nat.find hx \u2264 k\n\u22a2 \u2191y + Nat.find hx + 1 \u2264 \u2191x",["omega","aesop"]],["NumberTheory/Bertrand.lean",117,"n : \u2115\nn_large : 512 \u2264 n\n\u22a2 0 < 2 * n",["positivity","omega","linarith"]],["Algebra/Squarefree/Basic.lean",83,"R : Type u_1\ninst\u271d : Monoid R\nx : R\nn : \u2115\nh : Squarefree (x ^ n)\nh' : n \u2260 0 \u2227 n \u2260 1\n\u22a2 2 \u2264 n",["omega"]],["CategoryTheory/Triangulated/Opposite/Functor.lean",75,"C : Type u_1\nD : Type u_2\ninst\u271d\u2074 : Category.{u_4, u_1} C\ninst\u271d\u00b3 : Category.{u_3, u_2} D\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : HasShift D \u2124\nF : C \u2964 D\ninst\u271d : F.CommShift \u2124\nX : C\u1d52\u1d56\nn m : \u2124\nh : n + m = 0\n\u22a2 m = -n",["omega"]],["NumberTheory/Harmonic/GammaDeriv.lean",45,"n : \u2115\nf : \u211d \u2192 \u211d := log \u2218 Gamma\nhc : ConvexOn \u211d (Ioi 0) f\nh_rec : \u2200 (x : \u211d), 0 < x \u2192 f (x + 1) = f x + log x\nx : \u211d\nhx : 0 < x\nm : \u2115\n\u22a2 -\u2191m < x\n```\n---\n```lean\nn : \u2115\nf : \u211d \u2192 \u211d := log \u2218 Gamma\nhc : ConvexOn \u211d (Ioi 0) f\nh_rec : \u2200 (x : \u211d), 0 < x \u2192 f (x + 1) = f x + log x\nx : \u211d\nhx : 0 < x\nm : \u2115\n\u22a2 -\u2191m < x",["linarith"]],["NumberTheory/Harmonic/GammaDeriv.lean",63,"n\u271d : \u2115\nf : \u211d \u2192 \u211d := log \u2218 Gamma\nhc : ConvexOn \u211d (Ioi 0) f\nh_rec : \u2200 (x : \u211d), 0 < x \u2192 f (x + 1) = f x + log x\nhder : \u2200 {x : \u211d}, 0 < x \u2192 DifferentiableAt \u211d f x\nhder_rec : \u2200 (x : \u211d), 0 < x \u2192 deriv f (x + 1) = deriv f x + 1 / x\nhder_nat : \u2200 (n : \u2115), deriv f (\u2191n + 1) = deriv f 1 + \u2191(harmonic n)\nn : \u2115\nhn : 0 < n\n\u22a2 0 < \u2191n + 1",["positivity","linarith"]],["NumberTheory/Harmonic/GammaDeriv.lean",165,"n m : \u2115\n\u22a2 \u00ac\u2191n + 1 + \u2191m = 0",["positivity","linarith"]],["NumberTheory/Harmonic/GammaDeriv.lean",210,"f : \u2102 \u2192 \u2102 := fun s \u21a6 \u2191\u03c0 ^ (-s / 2)\ng : \u2102 \u2192 \u2102 := fun s \u21a6 Gamma (s / 2)\naux : \u2191\u03c0 ^ (1 / 2) = \u2191\u221a\u03c0\n\u22a2 \u221a\u03c0 \u2260 0",["positivity"]],["LinearAlgebra/RootSystem/Finite/Nondegenerate.lean",164,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Field R\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d : P.IsAnisotropic\n_iM : IsReflexive R M\n_iN : IsReflexive R N\naux0 : finrank R \u21a5P.corootSpan + finrank R \u21a5P.corootSpan.dualAnnihilator = finrank R N\naux1 : finrank R \u21a5P.corootSpan + finrank R \u21a5(LinearMap.ker P.RootForm) = finrank R N\n\u22a2 finrank R \u21a5(LinearMap.ker P.RootForm) = finrank R \u21a5P.corootSpan.dualAnnihilator",["omega","linarith"]],["Combinatorics/SimpleGraph/Connectivity/WalkDecomp.lean",203,"case neg\nV : Type u\nG : SimpleGraph V\nw : V\ninst\u271d : DecidableEq V\nu v : V\nn : \u2115\nv\u271d : V\nh : G.Adj u v\u271d\nq : G.Walk v\u271d v\nhw\u271d : w \u2208 (cons h q).support\nhuw : \u00acw = u\nhw : w \u2208 q.support\nhn0 : \u00acn = 0\nhn : n \u2264 (q.takeUntil w hw).length + 1\n\u22a2 n - 1 \u2264 (q.takeUntil w hw).length",["omega"]],["Combinatorics/SimpleGraph/Connectivity/WalkDecomp.lean",255,"V : Type u\nG : SimpleGraph V\nv u : V\ninst\u271d : DecidableEq V\np : G.Walk u v\nw x : V\nh : x \u2260 w\nhw : w \u2208 p.support\nhx : x \u2208 (p.takeUntil w hw).support\nhw' : w \u2208 ((p.takeUntil w hw).takeUntil x hx).support\nh1 : (p.takeUntil w \u22ef).length < (p.takeUntil x \u22ef).length\nh2 : (p.takeUntil x \u22ef).length < (p.takeUntil w hw).length\n\u22a2 False",["omega"]],["Combinatorics/SimpleGraph/Connectivity/WalkDecomp.lean",302,"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk v w\nn : \u2115\nhn : p.getVert (n + 1) = u \u2227 n + 1 \u2264 p.length\n\u22a2 \u00acp.length = 0",["omega","aesop"]],["Data/Nat/Choose/Sum.lean",106,"case e_a.e_s.e_a\nm : \u2115\nthis : \u2211 i \u2208 range (m + 1), (2 * m + 1).choose (2 * m + 1 - i) = \u2211 i \u2208 range (m + 1), (2 * m + 1).choose i\n\u22a2 2 * m + 1 + 1 - (m + 1) = m + 1",["omega"]],["Data/Nat/Choose/Sum.lean",107,"m : \u2115\nthis : \u2211 i \u2208 range (m + 1), (2 * m + 1).choose (2 * m + 1 - i) = \u2211 i \u2208 range (m + 1), (2 * m + 1).choose i\n\u22a2 m + 1 \u2264 2 * m + 2",["omega"]],["Combinatorics/SimpleGraph/Regularity/Bound.lean",105,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nP : Finpartition univ\n\u22a2 0 < \u2191m + 1",["positivity","linarith"]],["Combinatorics/SimpleGraph/Regularity/Bound.lean",248,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nP : Finpartition univ\nu : Finset \u03b1\n\u03b5\u271d \u03b5 : \u211d\nl : \u2115\n\u22a2 0 < initialBound \u03b5 l",["positivity"]],["Analysis/Normed/Ring/Units.lean",138,"R : Type u_1\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nt : R\nht : \u2016t\u2016 < 2\u207b\u00b9\n\u22a2 \u2016t\u2016 < 1",["linarith"]],["Analysis/Normed/Ring/Units.lean",145,"R : Type u_1\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nt : R\nht : \u2016t\u2016 < 2\u207b\u00b9\nht' : \u2016t\u2016 < 1\nthis : \u2016\u2211' (n : \u2115), t ^ n\u2016 \u2264 \u20161\u2016 - 1 + (1 - \u2016t\u2016)\u207b\u00b9\n\u22a2 2\u207b\u00b9 \u2264 1 - \u2016t\u2016",["linarith"]],["Analysis/Normed/Ring/Units.lean",146,"R : Type u_1\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nt : R\nht : \u2016t\u2016 < 2\u207b\u00b9\nht' : \u2016t\u2016 < 1\nthis\u271d : \u2016\u2211' (n : \u2115), t ^ n\u2016 \u2264 \u20161\u2016 - 1 + (1 - \u2016t\u2016)\u207b\u00b9\nthis : (1 - \u2016t\u2016)\u207b\u00b9 \u2264 2\n\u22a2 \u2016\u2211' (n : \u2115), t ^ n\u2016 \u2264 \u20161\u2016 + 1",["linarith"]],["Analysis/SpecialFunctions/Stirling.lean",150,"d : \u211d := \u2211' (k : \u2115), 1 / \u2191(k + 1) ^ 2\nlog_stirlingSeq' : \u2115 \u2192 \u211d := fun k \u21a6 Real.log (stirlingSeq (k + 1))\nn : \u2115\nh\u2081 : \u2200 (k : \u2115), log_stirlingSeq' k - log_stirlingSeq' (k + 1) \u2264 1 / 4 * (1 / \u2191(k + 1) ^ 2)\nh\u2082 : \u2211 k \u2208 range n, 1 / \u2191(k + 1) ^ 2 \u2264 d\n\u22a2 1 / 4 * \u2211 k \u2208 range n, 1 / \u2191(k + 1) ^ 2 \u2264 1 / 4 * d",["gcongr","aesop","linarith"]],["Analysis/SpecialFunctions/Stirling.lean",90,"n m : \u2115\n\u22a2 0 \u2264 1 / (2 * \u2191(m + 1) + 1) * ((1 / (2 * \u2191(n + 1) + 1)) ^ 2) ^ (m + 1)",["positivity"]],["Analysis/SpecialFunctions/Stirling.lean",109,"n : \u2115\nh_nonneg : 0 \u2264 (1 / (2 * \u2191(n + 1) + 1)) ^ 2\ng :\n  HasSum (fun k \u21a6 ((1 / (2 * \u2191(n + 1) + 1)) ^ 2) ^ (k + 1))\n    ((1 / (2 * \u2191(n + 1) + 1)) ^ 2 / (1 - (1 / (2 * \u2191(n + 1) + 1)) ^ 2))\nk : \u2115\n\u22a2 0 \u2264 2 * \u2191(k + 1)",["positivity","linarith"]],["Analysis/SpecialFunctions/Stirling.lean",116,"n : \u2115\n\u22a2 0 < 4 * (\u2191n + 1) ^ 2",["positivity"]],["Analysis/SpecialFunctions/Stirling.lean",117,"n : \u2115\nh\u2081 : 0 < 4 * (\u2191n + 1) ^ 2\n\u22a2 0 < (2 * (\u2191n + 1) + 1) ^ 2",["positivity"]],["Analysis/SpecialFunctions/Stirling.lean",158,"n : \u2115\n\u22a2 0 < \u2191(n + 1)! / (\u221a(2 * \u2191(n + 1)) * (\u2191(n + 1) / rexp 1) ^ (n + 1))",["positivity"]],["Analysis/SpecialFunctions/Stirling.lean",237,"n : \u2115\nhn : n \u2260 0\nh : \u221a(2 * \u2191n * \u03c0) * (\u2191n / rexp 1) ^ n = 0\n\u22a2 \u00ac\u221a(2 * \u2191n * \u03c0) * (\u2191n / rexp 1) ^ n = 0",["positivity"]],["Analysis/SpecialFunctions/Stirling.lean",238,"\u22a2 \u221a\u03c0 \u2260 0",["positivity"]],["Analysis/SpecialFunctions/Stirling.lean",129,"n : \u2115\nh\u2081 : 0 < 4 * (\u2191n + 1) ^ 2\nh\u2083 : 0 < (2 * (\u2191n + 1) + 1) ^ 2\nh\u2082 : 0 < 1 - (1 / (2 * (\u2191n + 1) + 1)) ^ 2\n\u22a2 4 + n * 8 + n ^ 2 * 4 \u2264 8 + n * 12 + n ^ 2 * 4",["omega","linarith"]],["Geometry/Manifold/IntegralCurve/UniformTime.lean",72,"E : Type u_1\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\nH : Type u_2\ninst\u271d\u2075 : TopologicalSpace H\nI : ModelWithCorners \u211d E H\nM : Type u_3\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : IsManifold I 1 M\ninst\u271d\u00b9 : T2Space M\nv : (x : M) \u2192 TangentSpace I x\ninst\u271d : BoundarylessManifold I M\nhv : ContMDiff I I.tangent 1 fun x \u21a6 { proj := x, snd := v x }\nx : M\n\u03b3 : \u211d \u2192 \u211d \u2192 M\nh\u03b3x : \u2200 (a : \u211d), \u03b3 a 0 = x\nh\u03b3 : \u2200 a > 0, IsIntegralCurveOn (\u03b3 a) v (Ioo (-a) a)\nt : \u211d\n\u22a2 |t| + 1 > 0",["positivity"]],["AlgebraicTopology/SimplicialSet/Coskeletal.lean",168,"X : SSet\ninst\u271d : X.StrictSegal\nn : \u2115\ns : Cone (proj (op \u298bn\u298c) (inclusion 2).op \u22d9 (inclusion 2).op \u22d9 X)\nx : s.pt\ni j : Fin (n + 1)\nhij : i \u2264 j\n\u22a2 \u2191j \u2264 n",["omega"]],["GroupTheory/SpecificGroups/Alternating/Centralizer.lean",137,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh : Subgroup.centralizer {g} \u2264 alternatingGroup \u03b1\nhm : g.cycleType.sum + 1 < Fintype.card \u03b1\n\u22a2 2 + g.cycleType.sum \u2264 Fintype.card \u03b1",["omega"]],["GroupTheory/SpecificGroups/Alternating/Centralizer.lean",242,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_odd : \u2200 c \u2208 g.cycleType, Odd c\nh_fixed : Fintype.card \u03b1 \u2264 g.cycleType.sum + 1\nh_count : \u2200 (i : \u2115), Multiset.count i g.cycleType \u2264 1\ny : Perm \u2191(Function.fixedPoints \u21d1g)\nuv : (c : { x // x \u2208 g.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\nhx : (kerParam g) (y, uv) \u2208 (kerParam g).range\nthis : Fintype.card \u2191(Function.fixedPoints \u21d1g) = Fintype.card \u03b1 - g.cycleType.sum\n\u22a2 Fintype.card \u2191(Function.fixedPoints \u21d1g) \u2264 1",["omega"]],["Algebra/MvPolynomial/SchwartzZippel.lean",120,"R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : DecidableEq R\nn : \u2115\np : MvPolynomial (Fin (n + 1)) R\nhp : p \u2260 0\nS : Fin (n + 1) \u2192 Finset R\np' : Polynomial (MvPolynomial (Fin n) R) := (finSuccEquiv R n) p\nhp' : p' = (finSuccEquiv R n) p\nk : \u2115 := p'.natDegree\nhk : k = p'.natDegree\np\u2096 : MvPolynomial (Fin n) R := p'.leadingCoeff\nhp\u2096 : p\u2096 = p'.leadingCoeff\nhp'\u2080 : p' \u2260 0\nhp\u2096\u2080 : p\u2096 \u2260 0\n\u22a2 0 \u2264 \u2191(degreeOf 0 p) / \u2191(#(S 0))",["positivity"]],["NumberTheory/EulerProduct/DirichletLSeries.lean",71,"s : \u2102\nN : \u2115\n\u03c7 : DirichletCharacter \u2102 N\nhs : 1 < s.re\nx\u271d : \u2115\n\u22a2 0 \u2264 \u2016\u03c7 \u2191x\u271d\u2016 * \u2016\u2191x\u271d ^ (-s)\u2016",["positivity"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",191,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nb : P.Base\ni j k : \u03b9\nhij : i \u2260 j\nhi : i \u2208 b.support\nhj : j \u2208 b.support\nhkj : k \u2260 j\nhk' : P.root k + P.root i \u2208 range \u21d1P.root\nhm : P.pairingIn \u2124 j k \u2264 0\nl : \u03b9\nhl : P.root l = P.root k + P.root i - P.root j\nhli : l \u2260 i\nhkl : P.pairingIn \u2124 l k \u2264 0\nthis : P.pairingIn \u2124 l k = 2 + P.pairingIn \u2124 i k - P.pairingIn \u2124 j k\n\u22a2 P.pairingIn \u2124 i k \u2264 -2",["linarith","omega"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",88,"case intro\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : CharZero R\ninst\u271d : P.IsCrystallographic\ni j : \u03b9\nthis\u271d : Fintype \u03b9\nn : \u2115\nhcn : P.coxeterWeightIn \u2124 i j = \u2191n\nthis : n \u2264 4\n\u22a2 n = 0 \u2228 n = 1 \u2228 n = 2 \u2228 n = 3 \u2228 n = 4",["omega"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",133,"case pos\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ni j : \u03b9\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nh : 0 < P.pairingIn \u2124 i j\nh' : i \u2260 j\n_i : NoZeroSMulDivisors \u2124 M\nhli : LinearIndependent R ![P.root i, P.root j]\nthis :\n  P.pairingIn \u2124 i j = 1 \u2227 P.pairingIn \u2124 j i = 1 \u2228\n    P.pairingIn \u2124 i j = -1 \u2227 P.pairingIn \u2124 j i = -1 \u2228\n      P.pairingIn \u2124 i j = 1 \u2227 P.pairingIn \u2124 j i = 2 \u2228\n        P.pairingIn \u2124 i j = 2 \u2227 P.pairingIn \u2124 j i = 1 \u2228\n          P.pairingIn \u2124 i j = -1 \u2227 P.pairingIn \u2124 j i = -2 \u2228\n            P.pairingIn \u2124 i j = -2 \u2227 P.pairingIn \u2124 j i = -1 \u2228\n              P.pairingIn \u2124 i j = 1 \u2227 P.pairingIn \u2124 j i = 3 \u2228\n                P.pairingIn \u2124 i j = 3 \u2227 P.pairingIn \u2124 j i = 1 \u2228\n                  P.pairingIn \u2124 i j = -1 \u2227 P.pairingIn \u2124 j i = -3 \u2228 P.pairingIn \u2124 i j = -3 \u2227 P.pairingIn \u2124 j i = -1\n\u22a2 P.pairingIn \u2124 i j = 1 \u2228 P.pairingIn \u2124 j i = 1",["omega"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",214,"case inr.intro\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nb : P.Base\ni j k : \u03b9\nhi : i \u2208 b.support\nhj : j \u2208 b.support\nhkj : k \u2260 j\nhk' : P.root k + P.root i \u2208 range \u21d1P.root\nhm : P.pairingIn \u2124 j k \u2264 0\nl : \u03b9\nhl : P.root l = P.root k + P.root i - P.root j\nhli : l \u2260 i\nhkl : P.pairingIn \u2124 l k \u2264 0\nhki : P.pairing k i = -1\nthis : P.pairingIn \u2124 l i = 1 - P.pairingIn \u2124 j i\nhij : P.pairingIn \u2124 j i \u2264 0\n\u22a2 0 < P.pairingIn \u2124 l i",["omega"]],["Analysis/Normed/Order/UpperLower.lean",163,"case refine_2.intro.intro\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nx : \u03b9 \u2192 \u211d\n\u03b4 : \u211d\nhs : IsUpperSet s\nhx : x \u2208 closure s\nh\u03b4 : 0 < \u03b4\ny : \u03b9 \u2192 \u211d\nhy : y \u2208 s\nz : \u03b9 \u2192 \u211d\ni : \u03b9\nhxy : x i - y i \u2264 \u03b4 / 4 \u2227 y i - x i \u2264 \u03b4 / 4\nhz : x i + 3 / 4 * \u03b4 - z i \u2264 \u03b4 / 4 \u2227 z i - (x i + 3 / 4 * \u03b4) \u2264 \u03b4 / 4\n\u22a2 y i < z i",["linarith"]],["Analysis/Normed/Order/UpperLower.lean",181,"case refine_2.intro.intro\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nx : \u03b9 \u2192 \u211d\n\u03b4 : \u211d\nhs : IsLowerSet s\nhx : x \u2208 closure s\nh\u03b4 : 0 < \u03b4\ny : \u03b9 \u2192 \u211d\nhy : y \u2208 s\nz : \u03b9 \u2192 \u211d\ni : \u03b9\nhxy : x i - y i \u2264 \u03b4 / 4 \u2227 y i - x i \u2264 \u03b4 / 4\nhz : x i - 3 / 4 * \u03b4 - z i \u2264 \u03b4 / 4 \u2227 z i - (x i - 3 / 4 * \u03b4) \u2264 \u03b4 / 4\n\u22a2 z i < y i",["linarith"]],["Analysis/Convex/SpecificFunctions/Basic.lean",40,"x y z : \u211d\nhxy : x < y\nhyz : y < z\n\u22a2 0 < y - x",["linarith","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",41,"x y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\n\u22a2 x - y < 0",["linarith","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",48,"x y z : \u211d\nhxy : x < y\nhyz : y < z\n\u22a2 0 < z - y",["linarith","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",67,"x y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\n\u22a2 0 < z - y",["linarith","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",78,"x y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\n\u22a2 0 < y - x",["linarith","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",206,"x : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 0 < -x",["linarith","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",207,"x : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\n\u22a2 0 < -y",["linarith","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",208,"x : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\nhxy : -x = -y\n\u22a2 x = y",["linarith","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",69,"x y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < z - y\n\u22a2 0 < z / y",["positivity","aesop"]],["Analysis/Convex/SpecificFunctions/Basic.lean",80,"x y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\n\u22a2 0 < x / y",["positivity","aesop"]],["NumberTheory/SumFourSquares.lean",66,"p : \u2115\nhp : Fact (Nat.Prime p)\nhodd : Odd p\na b : \u2115\nha : a \u2264 p / 2\nhb : b \u2264 p / 2\nhab : \u2191a ^ 2 + \u2191b ^ 2 \u2261 -1 [ZMOD \u2191p]\nk : \u2124\nhk : \u2191a ^ 2 + \u2191b ^ 2 + 1 = k * \u2191p\n\u22a2 0 < \u2191a ^ 2 + \u2191b ^ 2 + 1",["positivity"]],["Analysis/SpecialFunctions/Trigonometric/Bounds.lean",116,"x : \u211d\nhx : x \u2260 0\nthis : 1 / 2 + cos x * (-1 / 2) < x ^ 2 * (1 / 4)\n\u22a2 1 - x ^ 2 / 2 < cos x",["linarith"]],["Analysis/SpecialFunctions/Trigonometric/Bounds.lean",130,"x : \u211d\nhx\u2080 : -(\u03c0 / 2) \u2264 x\nhx : x \u2264 0\n\u22a2 -x \u2264 \u03c0 / 2",["linarith"]],["Analysis/SpecialFunctions/Trigonometric/Bounds.lean",136,"x\u271d x : \u211d\nhx : x \u2264 \u03c0\nhx\u2080 : 0 \u2264 x\n\u22a2 x / 2 \u2264 \u03c0 / 2",["linarith","gcongr"]],["Analysis/SpecialFunctions/Trigonometric/Bounds.lean",139,"x\u271d x : \u211d\nhx : x \u2264 \u03c0\nhx\u2080 : 0 \u2264 x\nthis\u271d : x / \u03c0 \u2264 sin (x / 2)\nthis : x ^ 2 * \u03c0\u207b\u00b9 ^ 2 \u2264 1 / 2 + cos x * (-1 / 2)\n\u22a2 cos x \u2264 1 - x ^ 2 * \u03c0\u207b\u00b9 ^ 2 * 2",["linarith"]],["SetTheory/Surreal/Dyadic.lean",218,"case intro.mk.intro.inr\nx : Localization.Away 2\nm\u2081 m\u2082 : \u2124\nn\u2081 n\u2082 : \u21a5(Submonoid.powers 2)\nh\u2081 : (Localization.r (Submonoid.powers 2)) (m\u2081, n\u2081) (m\u2082, n\u2082)\nn\u2083 : \u2124\ny\u2083 : \u2115\nhn\u2083 : (fun x \u21a6 2 ^ x) y\u2083 = n\u2083\nh\u271d : n\u2083 = 0\nthis : 1 \u2264 2 ^ y\u2083\n\u22a2 \u2191m\u2081 * powHalf (Submonoid.log n\u2081) = \u2191m\u2082 * powHalf (Submonoid.log n\u2082)",["linarith","aesop"]],["SetTheory/Surreal/Dyadic.lean",198,"case intro.inr\ny\u2081 : \u2115\nm\u2081 m\u2082 : \u2124\nc : \u2115\nh : y\u2081 \u2264 y\u2081 + c\nthis : 1 \u2264 2 ^ y\u2081\nh\u2082 : 2 ^ y\u2081 = 0\n\u22a2 \u2191m\u2081 * powHalf (y\u2081 + c) = \u2191m\u2082 * powHalf y\u2081",["omega","aesop","linarith"]],["RingTheory/Nilpotent/Exp.lean",99,"case calc_3.hi\nA : Type u_1\ninst\u271d\u00b9 : Ring A\ninst\u271d : Module \u211a A\na b : A\nh\u2081 : Commute a b\nn\u2081 : \u2115\nhn\u2081 : a ^ n\u2081 = 0\nn\u2082 : \u2115\nhn\u2082 : b ^ n\u2082 = 0\nN : \u2115 := n\u2081 \u2294 n\u2082\nh\u2084 : a ^ (N + 1) = 0\nh\u2085 : b ^ (N + 1) = 0\nR2N : Finset \u2115 := range (2 * N + 1)\nhR2N : R2N = range (2 * N + 1)\nRN : Finset \u2115 := range (N + 1)\nhRN : RN = range (N + 1)\n\u22a2 \u2200 (a : (_ : \u2115) \u00d7 \u2115),\n    a.fst < 2 * N + 1 \u2192\n      a.snd < a.fst + 1 \u2192 (a.snd < 2 * N + 1 \u2227 a.fst - a.snd < 2 * N + 1) \u2227 a.snd + (a.fst - a.snd) \u2264 2 * N",["omega"]],["RingTheory/Nilpotent/Exp.lean",103,"case calc_3.i_inj.mk.mk\nA : Type u_1\ninst\u271d\u00b9 : Ring A\ninst\u271d : Module \u211a A\na b : A\nh\u2081\u271d : Commute a b\nn\u2081 : \u2115\nhn\u2081 : a ^ n\u2081 = 0\nn\u2082 : \u2115\nhn\u2082 : b ^ n\u2082 = 0\nN : \u2115 := n\u2081 \u2294 n\u2082\nh\u2084\u271d : a ^ (N + 1) = 0\nh\u2085 : b ^ (N + 1) = 0\nR2N : Finset \u2115 := range (2 * N + 1)\nhR2N : R2N = range (2 * N + 1)\nRN : Finset \u2115 := range (N + 1)\nhRN : RN = range (N + 1)\nx\u2081 y\u2081 x\u2082 y\u2082 : \u2115\nh\u2081 : y\u2082 < x\u2081 + 1\nh\u2082 : y\u2082 < x\u2082 + 1\nh\u2083 : y\u2081 = y\u2082\nh\u2084 : x\u2081 - y\u2082 = x\u2082 - y\u2082\n\u22a2 x\u2081 = x\u2082",["omega"]],["RingTheory/Nilpotent/Exp.lean",138,"case h.h\nA : Type u_1\ninst\u271d\u00b9 : Ring A\ninst\u271d : Module \u211a A\na b : A\nh\u2081 : Commute a b\nn\u2081 : \u2115\nhn\u2081 : a ^ n\u2081 = 0\nn\u2082 : \u2115\nhn\u2082 : b ^ n\u2082 = 0\nN : \u2115 := n\u2081 \u2294 n\u2082\nh\u2084 : a ^ (N + 1) = 0\nh\u2085 : b ^ (N + 1) = 0\nR2N : Finset \u2115 := range (2 * N + 1)\nhR2N : R2N = range (2 * N + 1)\nRN : Finset \u2115 := range (N + 1)\nhRN : RN = range (N + 1)\ns\u2081 :\n  \u2211 i \u2208 R2N, (\u2191i !)\u207b\u00b9 \u2022 (a + b) ^ i =\n    \u2211 x \u2208 filter (fun x \u21a6 x.1 \u2264 N \u2227 x.2 \u2264 N) (R2N \u00d7\u02e2 R2N), ((\u2191x.1!)\u207b\u00b9 * (\u2191x.2!)\u207b\u00b9) \u2022 (a ^ x.1 * b ^ x.2)\nz\u2081 : \u2211 ij \u2208 filter (fun ij \u21a6 \u00acij.1 + ij.2 \u2264 2 * N) (R2N \u00d7\u02e2 R2N), ((\u2191ij.1!)\u207b\u00b9 * (\u2191ij.2!)\u207b\u00b9) \u2022 (a ^ ij.1 * b ^ ij.2) = 0\nsplit\u2081 :\n  \u2211 x \u2208 filter (fun x \u21a6 x.1 + x.2 \u2264 2 * N) (R2N \u00d7\u02e2 R2N), ((\u2191x.1!)\u207b\u00b9 * (\u2191x.2!)\u207b\u00b9) \u2022 (a ^ x.1 * b ^ x.2) =\n    \u2211 x \u2208 R2N \u00d7\u02e2 R2N, ((\u2191x.1!)\u207b\u00b9 * (\u2191x.2!)\u207b\u00b9) \u2022 (a ^ x.1 * b ^ x.2)\nz\u2082 : \u2211 ij \u2208 filter (fun ij \u21a6 \u00ac(ij.1 \u2264 N \u2227 ij.2 \u2264 N)) (R2N \u00d7\u02e2 R2N), ((\u2191ij.1!)\u207b\u00b9 * (\u2191ij.2!)\u207b\u00b9) \u2022 (a ^ ij.1 * b ^ ij.2) = 0\nsplit\u2082 :\n  \u2211 x \u2208 filter (fun x \u21a6 x.1 \u2264 N \u2227 x.2 \u2264 N) (R2N \u00d7\u02e2 R2N), ((\u2191x.1!)\u207b\u00b9 * (\u2191x.2!)\u207b\u00b9) \u2022 (a ^ x.1 * b ^ x.2) =\n    \u2211 x \u2208 R2N \u00d7\u02e2 R2N, ((\u2191x.1!)\u207b\u00b9 * (\u2191x.2!)\u207b\u00b9) \u2022 (a ^ x.1 * b ^ x.2)\nx : \u2115 \u00d7 \u2115\n\u22a2 (x.1 < 2 * N + 1 \u2227 x.2 < 2 * N + 1) \u2227 x.1 \u2264 N \u2227 x.2 \u2264 N \u2194 x.1 < N + 1 \u2227 x.2 < N + 1",["omega"]],["Analysis/Convex/Visible.lean",79,"\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ns : Set V\nx : V\n\u03b9 : Type u_4\nt : Finset \u03b9\na : \u03b9 \u2192 V\nw : \u03b9 \u2192 \ud835\udd5c\nhw\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nhw\u2081 : \u2211 i \u2208 t, w i = 1\nha : \u2200 i \u2208 t, a i \u2208 s\nhx : x \u2209 (convexHull \ud835\udd5c) s\nhw : IsVisible \ud835\udd5c ((convexHull \ud835\udd5c) s) x (\u2211 i \u2208 t, w i \u2022 a i)\ni : \u03b9\nhi : i \u2208 t\nhwi\u271d : 0 < w i\nhwi : w i < 1\n\u03b5 : \ud835\udd5c\nh\u03b5 : (lineMap x (a i)) \u03b5 \u2208 (convexHull \ud835\udd5c) s\nh : (lineMap x (a i)) \u03b5 \u2260 x \u2227 (lineMap x (a i)) \u03b5 \u2260 a i\nh\u03b5\u2080 : 0 < \u03b5\nh\u03b5\u2081 : \u03b5 < 1\n\u22a2 0 < 1 - \u03b5",["linarith","aesop"]],["Analysis/Convex/Visible.lean",80,"\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ns : Set V\nx : V\n\u03b9 : Type u_4\nt : Finset \u03b9\na : \u03b9 \u2192 V\nw : \u03b9 \u2192 \ud835\udd5c\nhw\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nhw\u2081 : \u2211 i \u2208 t, w i = 1\nha : \u2200 i \u2208 t, a i \u2208 s\nhx : x \u2209 (convexHull \ud835\udd5c) s\nhw : IsVisible \ud835\udd5c ((convexHull \ud835\udd5c) s) x (\u2211 i \u2208 t, w i \u2022 a i)\ni : \u03b9\nhi : i \u2208 t\nhwi\u271d : 0 < w i\nhwi : w i < 1\n\u03b5 : \ud835\udd5c\nh\u03b5 : (lineMap x (a i)) \u03b5 \u2208 (convexHull \ud835\udd5c) s\nh : (lineMap x (a i)) \u03b5 \u2260 x \u2227 (lineMap x (a i)) \u03b5 \u2260 a i\nh\u03b5\u2080 : 0 < \u03b5\nh\u03b5\u2081 : \u03b5 < 1\nthis : 0 < 1 - \u03b5\n\u22a2 0 < 1 - w i",["linarith","aesop"]],["Analysis/Convex/Visible.lean",104,"case inr.intro.intro.intro.intro.refine_1.refine_1\n\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ns : Set V\nx : V\n\u03b9 : Type u_4\nt : Finset \u03b9\na : \u03b9 \u2192 V\nw : \u03b9 \u2192 \ud835\udd5c\nhw\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nhw\u2081 : \u2211 i \u2208 t, w i = 1\nha : \u2200 i \u2208 t, a i \u2208 s\nhx : x \u2209 (convexHull \ud835\udd5c) s\nhw : IsVisible \ud835\udd5c ((convexHull \ud835\udd5c) s) x (\u2211 i \u2208 t, w i \u2022 a i)\ni : \u03b9\nhi : i \u2208 t\nhwi\u271d\u00b9 : 0 < w i\nhwi\u271d : w i < 1\n\u03b5 : \ud835\udd5c\nh\u03b5 : (lineMap x (a i)) \u03b5 \u2208 (convexHull \ud835\udd5c) s\nh : (lineMap x (a i)) \u03b5 \u2260 x \u2227 (lineMap x (a i)) \u03b5 \u2260 a i\nh\u03b5\u2080 : 0 < \u03b5\nh\u03b5\u2081 : \u03b5 < 1\nthis\u271d\u00b9 : 0 < 1 - \u03b5\nhwi : 0 < 1 - w i\nthis\u271d :\n  Wbtw \ud835\udd5c ((lineMap x (a i)) \u03b5) ((lineMap x (\u2211 j \u2208 t, w j \u2022 a j)) ((w i)\u207b\u00b9 / ((1 - \u03b5) / \u03b5 + (w i)\u207b\u00b9)))\n    (\u2211 j \u2208 t.erase i, (w j / (1 - w i)) \u2022 a j)\nj : \u03b9\nhj : j \u2208 t.erase i\nthis : 0 \u2264 w j\n\u22a2 0 \u2264 w j / (1 - w i)",["positivity"]],["Analysis/Convex/Visible.lean",107,"\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ns : Set V\nx : V\n\u03b9 : Type u_4\nt : Finset \u03b9\na : \u03b9 \u2192 V\nw : \u03b9 \u2192 \ud835\udd5c\nhw\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nhw\u2081 : \u2211 i \u2208 t, w i = 1\nha : \u2200 i \u2208 t, a i \u2208 s\nhx : x \u2209 (convexHull \ud835\udd5c) s\nhw : IsVisible \ud835\udd5c ((convexHull \ud835\udd5c) s) x (\u2211 i \u2208 t, w i \u2022 a i)\ni : \u03b9\nhi : i \u2208 t\nhwi\u271d\u00b9 : 0 < w i\nhwi\u271d : w i < 1\n\u03b5 : \ud835\udd5c\nh\u03b5 : (lineMap x (a i)) \u03b5 \u2208 (convexHull \ud835\udd5c) s\nh : (lineMap x (a i)) \u03b5 \u2260 x \u2227 (lineMap x (a i)) \u03b5 \u2260 a i\nh\u03b5\u2080 : 0 < \u03b5\nh\u03b5\u2081 : \u03b5 < 1\nthis : 0 < 1 - \u03b5\nhwi : 0 < 1 - w i\n\u22a2 0 < (1 - \u03b5) / \u03b5",["positivity","aesop"]],["Data/List/Infix.lean",51,"\u03b1 : Type u_1\nl : List \u03b1\nm n : \u2115\n\u22a2 m \u2293 l.length \u2264 n \u2194 m \u2264 n \u2228 l.length \u2264 n",["omega"]],["Data/List/Infix.lean",267,"case hl\n\u03b1 : Type u_1\nl : List \u03b1\nn : \u2115\n\u22a2 n \u2293 l.length + 1 = (n + 1) \u2293 (l.length + 1)\n```\n---\n```lean\ncase h\n\u03b1 : Type u_1\nl : List \u03b1\nn : \u2115\n\u22a2 \u2200 (i : \u2115), i < n \u2293 l.length + 1 \u2192 i < (n + 1) \u2293 (l.length + 1) \u2192 i \u2293 (n \u2293 l.length) = i \u2293 l.length",["omega"]],["NumberTheory/ModularForms/EisensteinSeries/UniformConvergence.lean",56,"z : \u210d\n\u22a2 0 < z.im ^ 2 / (z.re ^ 2 + z.im ^ 2)",["positivity"]],["Algebra/Order/CauSeq/BigOperators.lean",212,"case inr.zero.hb\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f m.succ) \u2264 r * abv (f m)\nm : \u2115\nhmn : n.succ \u2264 m\nhk : m = 0 + n.succ\n\u22a2 r ^ n.succ \u2260 0",["positivity","aesop"]],["RingTheory/Ideal/Basic.lean",75,"case neg\n\u03b1 : Type u_6\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\nm n k : \u2115\nha : a ^ m \u2208 I\nhb : b ^ n \u2208 I\nhk : m + n \u2264 k + 1\nhab : Commute a b\nc : \u2115\na\u271d : c \u2208 Finset.range (k + 1)\nh : \u00acm \u2264 c\n\u22a2 n \u2264 k - c",["omega"]],["Data/Nat/Bits.lean",109,"case true\nn : \u2115\n\u22a2 (n.div2 + 1) * 2 = 1 + (1 + n.div2 * 2)",["omega"]],["Data/Nat/Bits.lean",221,"x\u271d\u00b9 x\u271d : \u2115\n\u22a2 2 * (x\u271d\u00b9 + x\u271d) + 1 = 2 * x\u271d\u00b9 + (2 * x\u271d + 1)",["omega"]],["Data/Nat/Bits.lean",222,"x\u271d\u00b9 x\u271d : \u2115\n\u22a2 2 * (x\u271d\u00b9 + x\u271d) = 2 * x\u271d\u00b9 + 2 * x\u271d",["omega"]],["Data/Nat/Bits.lean",225,"x\u271d\u00b9 x\u271d : \u2115\n\u22a2 2 * (x\u271d\u00b9 + x\u271d) + 1 = 2 * x\u271d\u00b9 + 1 + 2 * x\u271d",["omega"]],["Data/Nat/Bits.lean",226,"x\u271d\u00b9 x\u271d : \u2115\n\u22a2 2 * (x\u271d\u00b9 + x\u271d) = 2 * x\u271d\u00b9 + 2 * x\u271d",["omega"]],["Data/Nat/Bits.lean",253,"x\u271d\u00b9 x\u271d : \u2115\nh : x\u271d\u00b9 \u2264 x\u271d\n\u22a2 2 * x\u271d\u00b9 + 1 \u2264 2 * x\u271d + 1",["omega"]],["Data/Nat/Bits.lean",254,"x\u271d\u00b9 x\u271d : \u2115\nh : x\u271d\u00b9 \u2264 x\u271d\n\u22a2 2 * x\u271d\u00b9 \u2264 2 * x\u271d",["omega"]],["CategoryTheory/Limits/Shapes/SequentialProduct.lean",93,"C : Type u_1\nM N : \u2115 \u2192 C\ninst\u271d\u00b9 : Category.{u_2, u_1} C\nf : (n : \u2115) \u2192 M n \u27f6 N n\ninst\u271d : HasProductsOfShape \u2115 C\nn : \u2115\nh : \u00ac0 < n\n\u22a2 n = 0",["omega","aesop"]],["CategoryTheory/Limits/Shapes/SequentialProduct.lean",107,"C : Type u_1\nM N : \u2115 \u2192 C\ninst\u271d\u00b9 : Category.{u_2, u_1} C\nf : (n : \u2115) \u2192 M n \u27f6 N n\ninst\u271d : HasProductsOfShape \u2115 C\nn m : \u2115\nh : \u00acm + 1 < n\nthis : homOfLE \u22ef = homOfLE \u22ef \u226b homOfLE \u22ef\n\u22a2 \u00acm + 1 < m + 1",["omega"]],["Analysis/Convex/Mul.lean",180,"\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\nn : \u2115\nx : \ud835\udd5c\nhx : 0 < x\ny : \ud835\udd5c\nhy : 0 < y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 0 \u2264 a * b * (x - y) ^ 2",["positivity"]],["Analysis/Normed/Group/AddCircle.lean",181,"case inr.inr.intro.intro.intro.inr.inl\nx \u03b5 : \u211d\ns : Set \u211d\nz : \u2124\nhz : z \u2260 0\ny : \u211d\nhy\u2080 : y \u2208 s\nhs : s \u2286 Icc (x - |0| / 2) (x + |0| / 2)\nhy\u2083 : x - |0| / 2 \u2264 y\nhy\u2084 : y \u2264 x + |0| / 2\nhy\u2081 : x - \u03b5 \u2264 y\nhy\u2082 : y \u2264 x + \u03b5\nh\u03b5 : \u03b5 < 0\n\u22a2 False",["linarith"]],["Algebra/Order/BigOperators/Expect.lean",203,"\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\nn : \u2115\na : \u2115 \u2192 \u211a\n\u22a2 0 \u2264 \ud835\udd3c j \u2208 range n, a j ^ 2",["positivity"]],["Algebra/Order/BigOperators/Expect.lean",204,"\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\na : ULift.{2, 0} \u2115 \u2192 \u211a\ns : Finset (ULift.{2, 0} \u2115)\n\u22a2 0 \u2264 \ud835\udd3c j \u2208 s, a j ^ 2",["positivity"]],["Algebra/Order/BigOperators/Expect.lean",205,"\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\nn : \u2115\na : \u2115 \u2192 \u211a\n\u22a2 0 \u2264 \ud835\udd3c j : Fin 8, \ud835\udd3c i \u2208 range n, (a \u2191j ^ 2 + \u2191i ^ 2)",["positivity"]],["Algebra/Order/BigOperators/Expect.lean",206,"\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\nn : \u2115\na : \u2115 \u2192 \u211a\n\u22a2 0 < \ud835\udd3c j : Fin (n + 1), (a \u2191j ^ 2 + 1)",["positivity"]],["Algebra/Order/BigOperators/Expect.lean",207,"\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\na : \u2115 \u2192 \u211a\n\u22a2 0 < \ud835\udd3c j \u2208 {1}, (a j ^ 2 + 1)",["positivity"]],["NumberTheory/Transcendental/Lindemann/Init/AnalyticalPart.lean",99,"f : \u2115 \u2192 \u2102[X]\ns : \u2102\nc' : \u211d\nhc' : c' \u2265 0\nh' : \u2200 (p : \u2115), \u2016LindemannWeierstrass.P (f p) s\u2016 \u2264 Real.exp s.re * (Real.exp \u2016s\u2016 * c' ^ p * \u2016s\u2016)\nc\u2081 : \u211d := Real.exp s.re \u2294 1\nc\u2082 : \u211d := Real.exp \u2016s\u2016 \u2294 1\nc\u2083 : \u211d := \u2016s\u2016 \u2294 1\n\u22a2 c\u2081 * (c\u2082 * c' * c\u2083) \u2265 0",["positivity"]],["NumberTheory/Fermat.lean",49,"n : \u2115\nthis : 3 \u2264 n.fermatNumber\n\u22a2 n.fermatNumber \u2260 1",["omega","aesop","linarith"]],["NumberTheory/Fermat.lean",59,"case succ\nn : \u2115\nhn : \u220f k \u2208 range n, k.fermatNumber = n.fermatNumber - 2\n\u22a2 2 ^ (2 ^ n * 2) - 1 = 1 + 2 ^ (2 ^ n * 2) - 2",["omega"]],["NumberTheory/Fermat.lean",76,"n : \u2115\nthis : 0 \u2264 1 + 2 ^ (2 ^ n * 4)\n\u22a2 2 ^ (2 ^ n * 2) * 2 \u2264 1 + 2 ^ (2 ^ n * 2) * 2 + 2 ^ (2 ^ n * 4)",["omega","linarith"]],["NumberTheory/Fermat.lean",105,"m n : \u2115\nhmn : m \u2260 n\nthis : \u2200 {m n : \u2115}, m \u2260 n \u2192 m < n \u2192 m.fermatNumber.Coprime n.fermatNumber\nhmn' : \u00acm < n\n\u22a2 n < m",["omega"]],["Analysis/Fourier/Inversion.lean",66,"case h.h.h\nV : Type u_1\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup V\ninst\u271d\u2075 : InnerProductSpace \u211d V\ninst\u271d\u2074 : MeasurableSpace V\ninst\u271d\u00b3 : BorelSpace V\ninst\u271d\u00b2 : FiniteDimensional \u211d V\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : V \u2192 E\nhf : Integrable f volume\nc : \u211d\nhc : 0 \u2264 c\nv : V\n\u22a2 0 \u2264 c\u207b\u00b9 * \u2016v\u2016 ^ 2",["positivity"]],["Analysis/Fourier/Inversion.lean",111,"V : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : InnerProductSpace \u211d V\ninst\u271d\u2075 : MeasurableSpace V\ninst\u271d\u2074 : BorelSpace V\ninst\u271d\u00b3 : FiniteDimensional \u211d V\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nf : V \u2192 E\ninst\u271d : CompleteSpace E\nhf : Integrable f volume\nv : V\nh'f : ContinuousAt f v\n\u03c6 : V \u2192 \u211d := fun w \u21a6 \u03c0 ^ (\u2191(finrank \u211d V) / 2) * rexp (-\u03c0 ^ 2 * \u2016w\u2016 ^ 2)\nx : V\n\u22a2 0 \u2264 \u03c6 x",["positivity"]],["Analysis/Complex/Polynomial/Basic.lean",159,"p : \u211a[X]\np_irr : Irreducible p\np_deg : Nat.Prime p.natDegree\np_roots1 : Fintype.card \u2191(p.rootSet \u211d) + 1 \u2264 Fintype.card \u2191(p.rootSet \u2102)\np_roots2 : Fintype.card \u2191(p.rootSet \u2102) \u2264 Fintype.card \u2191(p.rootSet \u211d) + 3\nn : \u2115 := ((galActionHom p \u2102) ((restrict p \u2102) (AlgEquiv.restrictScalars \u211a conjAe))).support.card\nhn : 2 \u2223 n\nkey :\n  Fintype.card \u2191(p.rootSet \u2102) =\n    Fintype.card \u2191(p.rootSet \u211d) + ((galActionHom p \u2102) ((restrict p \u2102) (AlgEquiv.restrictScalars \u211a conjAe))).support.card\n\u22a2 Fintype.card \u2191(p.rootSet \u2102) = Fintype.card \u2191(p.rootSet \u211d) + 2",["omega"]],["Analysis/Analytic/Within.lean",45,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ns : Set E\nx : E\nh : {x} \u2208 \ud835\udcdd[s] x\nt : Set E\not : IsOpen t\nxt : x \u2208 t\nst : t \u2229 s \u2286 {x}\nr : \u211d\nr0 : r > 0\nrt : Metric.ball x r \u2286 t\n\u22a2 0 < ENNReal.ofReal r",["positivity","aesop"]],["Combinatorics/Additive/Corner/Roth.lean",91,"G : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Fintype G\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhG : (triangleRemovalBound (\u03b5 / 9) * 27)\u207b\u00b9 < \u2191(Fintype.card G)\nA : Finset (G \u00d7 G)\nhA\u03b5 : \u03b5 * \u2191(Fintype.card G) ^ 2 \u2264 \u2191(#A)\nhA : IsCornerFree \u2191A\nh\u03b5\u2081 : \u03b5 \u2264 1\nthis : NoAccidental (Corners.triangleIndices A)\n\u22a2 \u03b5 / 9 \u2264 1",["linarith"]],["Combinatorics/Additive/Corner/Roth.lean",92,"G : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Fintype G\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhG : (triangleRemovalBound (\u03b5 / 9) * 27)\u207b\u00b9 < \u2191(Fintype.card G)\nA : Finset (G \u00d7 G)\nhA\u03b5 : \u03b5 * \u2191(Fintype.card G) ^ 2 \u2264 \u2191(#A)\nhA : IsCornerFree \u2191A\nh\u03b5\u2081 : \u03b5 \u2264 1\nthis\u271d : NoAccidental (Corners.triangleIndices A)\nthis : \u03b5 / 9 \u2264 1\n\u22a2 0 < triangleRemovalBound (\u03b5 / 9) * 27",["positivity"]],["Combinatorics/Additive/Corner/Roth.lean",116,"n : \u2115\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhn : cornersTheoremBound (\u03b5 / 9) \u2264 n\nA : Finset (\u2115 \u00d7 \u2115)\nhAn : \u2191A \u2286 \u2191(range n) \u00d7\u02e2 \u2191(range n)\nhA\u03b5 : \u03b5 * \u2191n ^ 2 \u2264 \u2191(#A)\nhA : IsCornerFree \u2191A\na b : \u2115\nhab : (a, b) \u2208 A\nthis : a < n \u2227 b < n\n\u22a2 a < 2 * n + 1 \u2227 b < 2 * n + 1",["omega"]],["Combinatorics/Additive/Corner/Roth.lean",127,"case h.hab.bc\nn : \u2115\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhn : \u230a(triangleRemovalBound (\u03b5 / 9 / 9) * 27)\u207b\u00b9\u230b\u208a + 1 \u2264 n\nA : Finset (\u2115 \u00d7 \u2115)\nhAn : \u2191A \u2286 \u2191(range n) \u00d7\u02e2 \u2191(range n)\nhA\u03b5 : \u03b5 * \u2191n ^ 2 \u2264 \u2191(#A)\nhA : IsCornerFree (Prod.map Fin.val Fin.val '' (Prod.map Nat.cast Nat.cast '' \u2191A))\nthis\u271d\u00b9 : \u2191A = Prod.map Fin.val Fin.val '' (Prod.map Nat.cast Nat.cast '' \u2191A)\nthis\u271d : IsAddFreimanIso 2 (Set.Iio \u2191n) (Set.Iio n) Fin.val\nthis : IsCornerFree \u2191(image (Prod.map Nat.cast Nat.cast) A)\n\u22a2 1 \u2264 n",["omega","linarith"]],["Combinatorics/Additive/Corner/Roth.lean",133,"n : \u2115\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhn : cornersTheoremBound (\u03b5 / 9) \u2264 n\nA : Finset (\u2115 \u00d7 \u2115)\nhAn : \u2191A \u2286 \u2191(range n) \u00d7\u02e2 \u2191(range n)\nhA\u03b5 : \u03b5 * \u2191n ^ 2 \u2264 \u2191(#A)\nhA : IsCornerFree (Prod.map Fin.val Fin.val '' (Prod.map Nat.cast Nat.cast '' \u2191A))\nthis\u271d\u00b9 : \u2191A = Prod.map Fin.val Fin.val '' (Prod.map Nat.cast Nat.cast '' \u2191A)\nthis\u271d : IsAddFreimanIso 2 (Set.Iio \u2191n) (Set.Iio n) Fin.val\nthis : IsCornerFree \u2191(image (Prod.map Nat.cast Nat.cast) A)\n\u22a2 n \u2264 2 * n + 1",["omega","linarith"]],["Combinatorics/Additive/Corner/Roth.lean",174,"n : \u2115\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhG : cornersTheoremBound (\u03b5 / 3) \u2264 n\nA : Finset \u2115\nhAn : \u2191A \u2286 Set.Iio n\nhA\u03b5 : \u03b5 * \u2191n \u2264 \u2191(#A)\nhA : ThreeAPFree \u2191A\na : \u2115\nha : a \u2208 A\nthis : a < n\n\u22a2 a < 2 * n + 1",["omega","linarith"]],["Combinatorics/Additive/Corner/Roth.lean",184,"case h.bc\nn : \u2115\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhG : \u230a(triangleRemovalBound (\u03b5 / 3 / 9) * 27)\u207b\u00b9\u230b\u208a + 1 \u2264 n\nA : Finset \u2115\nhAn : \u2191A \u2286 Set.Iio n\nhA\u03b5 : \u03b5 * \u2191n \u2264 \u2191(#A)\nhA : ThreeAPFree (Fin.val '' (Nat.cast '' \u2191A))\nthis\u271d\u00b9 : \u2191A = Fin.val '' (Nat.cast '' \u2191A)\nthis\u271d : IsAddFreimanIso 2 (Set.Iio \u2191n) (Set.Iio n) Fin.val\nthis : ThreeAPFree \u2191(image (fun x \u21a6 \u2191x) A)\n\u22a2 1 \u2264 n",["omega","linarith"]],["Combinatorics/Additive/Corner/Roth.lean",190,"n : \u2115\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhG : cornersTheoremBound (\u03b5 / 3) \u2264 n\nA : Finset \u2115\nhAn : \u2191A \u2286 Set.Iio n\nhA\u03b5 : \u03b5 * \u2191n \u2264 \u2191(#A)\nhA : ThreeAPFree (Fin.val '' (Nat.cast '' \u2191A))\nthis\u271d\u00b9 : \u2191A = Fin.val '' (Nat.cast '' \u2191A)\nthis\u271d : IsAddFreimanIso 2 (Set.Iio \u2191n) (Set.Iio n) Fin.val\nthis : ThreeAPFree \u2191(image (fun x \u21a6 \u2191x) A)\n\u22a2 n \u2264 2 * n + 1",["omega","linarith"]],["Analysis/Calculus/Deriv/Abs.lean",187,"h : DifferentiableAt \u211d abs 0\nh\u2081 : deriv abs 0 = 1\nh\u2082 : deriv abs 0 = -1\n\u22a2 False",["linarith"]],["Algebra/Homology/HomotopyCategory/ShiftSequence.lean",51,"C : Type u_1\ninst\u271d\u00b9 : Category.{?u.34747, u_1} C\ninst\u271d : Preadditive C\nn i i' : \u2124\nhi : n + i = i'\n\u22a2 n + (i + 1) = i' + 1",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/ShiftSequence.lean",156,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.82830, u_1} C\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : CategoryWithHomology C\nK : CochainComplex C \u2124\nA : C\nn i : \u2124\nf : A \u27f6 ((CategoryTheory.shiftFunctor (CochainComplex C \u2124) n).obj K).X i\nj : \u2124\nhf : f \u226b ((CategoryTheory.shiftFunctor (CochainComplex C \u2124) n).obj K).d i j = 0\ni' : \u2124\nhi' : n + i = i'\nj' : \u2124\nhj : i + 1 = j\nhj' : i' + 1 = j'\n\u22a2 i' = i + n",["omega","linarith"]],["Algebra/Homology/HomotopyCategory/ShiftSequence.lean",157,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.82830, u_1} C\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : CategoryWithHomology C\nK : CochainComplex C \u2124\nA : C\nn i : \u2124\nf : A \u27f6 ((CategoryTheory.shiftFunctor (CochainComplex C \u2124) n).obj K).X i\nj : \u2124\nhf : f \u226b ((CategoryTheory.shiftFunctor (CochainComplex C \u2124) n).obj K).d i j = 0\nj' : \u2124\nhj : i + 1 = j\nhi' : n + i = i + n\nhj' : i + n + 1 = j'\n\u22a2 j' = j + n",["omega"]],["AlgebraicTopology/DoldKan/Faces.lean",54,"case intro\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\ni : Fin (n + 1)\nhj\u2081 : i.succ \u2260 0\nhj\u2082 : n + 2 \u2264 \u2191i + 1 + q\n\u22a2 n + 1 \u2264 \u2191i + q",["omega","linarith"]],["AlgebraicTopology/DoldKan/Faces.lean",81,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn a q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhnaq : n = a + q\nhnaq_shift : \u2200 (d : \u2115), n + d = a + d + q\nk : \u2115\nhk : k < q\n\u22a2 n + 1 \u2264 a + k + 1 + q",["omega","aesop","linarith"]],["AlgebraicTopology/DoldKan/Faces.lean",83,"case h.e'_2.h.e'_7.h.e'_5.h.e'_2\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn a q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhnaq : n = a + q\nhnaq_shift : \u2200 (d : \u2115), n + d = a + d + q\nk : \u2115\nhk : k < q\n\u22a2 a + 2 + k = a + k + 1 + 1",["omega"]],["AlgebraicTopology/DoldKan/Faces.lean",91,"case hf.mk\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn a q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhnaq : n = a + q\nhnaq_shift : \u2200 (d : \u2115), n + d = a + d + q\nk : \u2115\nhk : k < q\n\u22a2 a + 1 + 1 < a + 3 + k",["omega"]],["AlgebraicTopology/DoldKan/Faces.lean",95,"case hf.mk.hj\u2081\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn a q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhnaq : n = a + q\nhnaq_shift : \u2200 (d : \u2115), n + d = a + d + q\nk : \u2115\nhk : k < q\nh : a + 3 + k = 1\n\u22a2 False",["omega"]],["AlgebraicTopology/DoldKan/Faces.lean",98,"case hf.mk.hj\u2082\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn a q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhnaq : n = a + q\nhnaq_shift : \u2200 (d : \u2115), n + d = a + d + q\nk : \u2115\nhk : k < q\n\u22a2 n + 2 \u2264 a + k + (3 - 1) + q",["omega"]],["AlgebraicTopology/DoldKan/Faces.lean",129,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn a q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhnaq : n = a + q\nhnaq_shift : \u2200 (d : \u2115), n + d = a + d + q\nsimplif : \u2200 (a b c d e f : Y \u27f6 X _\u298bn + 1\u298c), b = f \u2192 d + e = 0 \u2192 c + a = 0 \u2192 a + b + (c + d + e) = f\ni : \u2115\nhi : i < a + 1\na\u271d : \u27e8i, hi\u27e9 \u2208 Finset.univ\n\u22a2 i \u2264 a",["omega"]],["AlgebraicTopology/DoldKan/Faces.lean",156,"case neg.hf.H\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhqn : n < q\nhqn' : \u00acn + 1 < q\nj : Fin (n + 1)\n\u22a2 1 < 2 + \u2191j",["omega","linarith"]],["AlgebraicTopology/DoldKan/Faces.lean",161,"case neg.hf.hj\u2082\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhqn : n < q\nhqn' : \u00acn + 1 < q\nj : Fin (n + 1)\n\u22a2 n + 2 \u2264 1 + \u2191j + q",["omega"]],["AlgebraicTopology/DoldKan/Faces.lean",185,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nq a m : \u2115\n\u03c6 : Y \u27f6 X _\u298bm + 1 + 1\u298c\nv : HigherFacesVanish q \u03c6\nj : Fin (m + 1 + 1)\nhj\u2081 : m + 1 + 1 \u2264 \u2191j + (q + 1)\nhqn : \u00acm + 1 < q\nha : q + a = m + 1\nhj\u2082 : \u00aca = \u2191j\n\u22a2 a \u2264 \u2191j",["omega","linarith"]],["AlgebraicTopology/DoldKan/Faces.lean",186,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nq a m : \u2115\n\u03c6 : Y \u27f6 X _\u298bm + 1 + 1\u298c\nv : HigherFacesVanish q \u03c6\nj : Fin (m + 1 + 1)\nhj\u2081 : m + 1 + 1 \u2264 \u2191j + (q + 1)\nhqn : \u00acm + 1 < q\nha : q + a = m + 1\nhj\u2082 : \u00aca = \u2191j\nhaj : a < \u2191j\n\u22a2 a \u2264 m",["omega"]],["AlgebraicTopology/DoldKan/Faces.lean",197,"case neg.inl.H\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nq a m : \u2115\n\u03c6 : Y \u27f6 X _\u298bm + 1 + 1\u298c\nv : HigherFacesVanish q \u03c6\nj : Fin (m + 1 + 1)\nhj\u2081 : m + 1 + 1 \u2264 \u2191j + (q + 1)\nhqn : \u00acm + 1 < q\nha : q + a = m + 1\nhj\u2082 : \u00aca = \u2191j\nhaj : a < \u2191j\nham : a \u2264 m\nh\u271d : a < m\n\u22a2 a + 1 \u2264 \u2191j",["omega"]],["AlgebraicTopology/DoldKan/Faces.lean",206,"case neg.inr.H.h.mk\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nq a m : \u2115\n\u03c6 : Y \u27f6 X _\u298bm + 1 + 1\u298c\nv : HigherFacesVanish q \u03c6\nhqn : \u00acm + 1 < q\nha : q + a = m + 1\nham : a \u2264 m\nham'' : a = m\nval\u271d : \u2115\nisLt\u271d : val\u271d < m + 1 + 1\nhj\u2081 : m + 1 + 1 \u2264 val\u271d + (q + 1)\nhj\u2082 : \u00aca = val\u271d\nhaj : a < val\u271d\n\u22a2 a + 1 = val\u271d",["omega"]],["GroupTheory/CommutingProbability.lean",209,"case neg.inr.hb\nn : \u2115\nh0 : \u00acn = 0\nh1 : \u00acn = 1\nh2 : Odd n\nthis\u271d : n / 4 + 1 < n\nkey : n % 4 = 1 \u2228 n % 4 = 3\nhn : Odd (n % 4)\nthis : n % 4 \u2260 0\n\u22a2 \u00ac4 * (n % 4 * n) * (n / 4 + 1) = 0",["positivity","aesop"]],["GroupTheory/CommutingProbability.lean",143,"n : \u2115\n\u22a2 n + 4 \u2260 0 \u2192 n + 4 \u2260 1 \u2192 (n + 4) / 4 + 1 < n + 4",["omega"]],["Analysis/Convex/Strong.lean",75,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 : \u211d \u2192 \u211d\ns : Set E\nf : E \u2192 \u211d\nhf : UniformConvexOn s \u03c6 f\nh\u03c6 : \u2200 (r : \u211d), r \u2260 0 \u2192 0 < \u03c6 r\nx : E\nhx : x \u2208 s\ny : E\nhy : y \u2208 s\nhxy : 0 < \u2016x - y\u2016\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nthis : 0 < \u03c6 \u2016x - y\u2016\n\u22a2 0 < a * b * \u03c6 \u2016x - y\u2016",["positivity","aesop"]],["Analysis/Convex/Strong.lean",83,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 : \u211d \u2192 \u211d\ns : Set E\nf : E \u2192 \u211d\nhf : UniformConcaveOn s \u03c6 f\nh\u03c6 : \u2200 (r : \u211d), r \u2260 0 \u2192 0 < \u03c6 r\nx : E\nhx : x \u2208 s\ny : E\nhy : y \u2208 s\nhxy : 0 < \u2016x - y\u2016\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nthis : 0 < \u03c6 \u2016x - y\u2016\n\u22a2 0 < a * b * \u03c6 \u2016x - y\u2016",["positivity","aesop"]],["Analysis/Convex/Strong.lean",140,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\nf : E \u2192 \u211d\nm : \u211d\nhf : StrongConvexOn s m f\nhm : 0 < m\nr : \u211d\nhr : r \u2260 0\n\u22a2 0 < m / 2 * r ^ 2",["positivity"]],["Analysis/Convex/Strong.lean",143,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\nf : E \u2192 \u211d\nm : \u211d\nhf : StrongConcaveOn s m f\nhm : 0 < m\nr : \u211d\nhr : r \u2260 0\n\u22a2 0 < m / 2 * r ^ 2",["positivity"]],["Combinatorics/Additive/DoublingConst.lean",69,"G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\nhA : A.Nonempty\n\u22a2 \u2191(#A) \u2260 0",["positivity","aesop"]],["Combinatorics/Additive/DoublingConst.lean",75,"G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA B : Finset G\nhA : A.Nonempty\n\u22a2 \u2191(#A) \u2260 0",["positivity","aesop"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",36,"\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b5\u2081 : \u03b5 \u2264 1\n\u22a2 0 < 1 - \u03b5 / 4",["linarith"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",83,"\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\nP : Finpartition univ\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhP\u2081 : P.IsEquipartition\nhP\u2083 : #P.parts \u2264 bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a\nx y z : \u03b1\ns : Finset \u03b1\nhX : s \u2208 P.parts\nY : Finset \u03b1\nhY : Y \u2208 P.parts\nxX : x \u2208 s\nyY : y \u2208 Y\nnXY : s \u2260 Y\nuXY : G.IsUniform (\u03b5 / 8) s Y\ndXY\u271d : \u03b5 / 4 \u2264 \u2191(G.edgeDensity s Y)\nZ : Finset \u03b1\nhZ : Z \u2208 P.parts\nzZ : z \u2208 Z\nhX' : s \u2208 P.parts\nxX' : x \u2208 s\nnXZ : s \u2260 Z\nuXZ : G.IsUniform (\u03b5 / 8) s Z\ndXZ\u271d : \u03b5 / 4 \u2264 \u2191(G.edgeDensity s Z)\nhY' : Y \u2208 P.parts\nyY' : y \u2208 Y\nhZ' : Z \u2208 P.parts\nzZ' : z \u2208 Z\nnYZ : Y \u2260 Z\nuYZ : G.IsUniform (\u03b5 / 8) Y Z\ndYZ\u271d : \u03b5 / 4 \u2264 \u2191(G.edgeDensity Y Z)\ndXY : Function.onFun Disjoint id s Y\ndXZ : Function.onFun Disjoint id s Z\ndYZ : Function.onFun Disjoint id Y Z\nthat : 2 * (\u03b5 / 8) = \u03b5 / 4\nthis : \u03b5 / 4 \u2264 1\n\u22a2 0 \u2264 1 - 2 * (\u03b5 / 8)",["linarith","aesop"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",38,"\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b5\u2081 : \u03b5 \u2264 1\nthis : 0 < 1 - \u03b5 / 4\n\u22a2 0 < (2 * \u2191\u23084 / \u03b5\u2309\u208a ^ 3)\u207b\u00b9 \u2293 (1 - \u03b5 / 4) * (\u03b5 / (16 * \u2191(bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a))) ^ 3",["positivity"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",47,"case h\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 \u2191\u23084 / \u03b5\u2309\u208a ^ 3 \u2260 0",["positivity","aesop"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",117,"\u03b1 : Type u_1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\nP : Finpartition univ\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nh\u03b5 : 0 < \u03b5\nhP : P.IsEquipartition\nhP\u03b5 : P.IsUniform G (\u03b5 / 8)\nhP' : 4 / \u03b5 \u2264 \u2191(#P.parts)\nA : Finset (\u03b1 \u00d7 \u03b1) :=\n  (P.nonUniforms G (\u03b5 / 8)).biUnion fun x \u21a6\n    match x with\n    | (U, V) => U \u00d7\u02e2 V\nB : Finset (\u03b1 \u00d7 \u03b1) := P.parts.biUnion offDiag\nC : Finset (\u03b1 \u00d7 \u03b1) :=\n  (P.sparsePairs G (\u03b5 / 4)).biUnion fun x \u21a6\n    match x with\n    | (U, V) => G.interedges U V\n\u22a2 0 \u2264 \u03b5 / 4",["positivity","linarith"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",174,"\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\ns t : Finset \u03b1\nP : Finpartition univ\n\u03b5\u271d \u03b5 : \u211d\nh\u03b5\u2080 : 0 < \u03b5\nh\u03b5\u2081 : \u03b5 \u2264 1\n\u22a2 0 < triangleRemovalBound \u03b5",["positivity"]],["Analysis/SpecialFunctions/Log/NegMulLog.lean",126,"x : \u211d\nhx : 0 < x\n\u22a2 0 < x\u207b\u00b9",["positivity","aesop"]],["Combinatorics/SimpleGraph/Regularity/Increment.lean",139,"case ha\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nhP : P.IsEquipartition\nhP\u2087 : 7 \u2264 #P.parts\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhPG : \u00acP.IsUniform G \u03b5\nh\u03b5\u2080 : 0 \u2264 \u03b5\nh\u03b5\u2081 : \u03b5 \u2264 1\n\u22a2 \u2191(#P.parts) ^ 2 \u2260 0",["positivity"]],["Analysis/SpecialFunctions/Log/ENNRealLog.lean",164,"case inr.inr.inr.inr\nx y : \u211d\u22650\u221e\nx_real : 0 < x.toReal\ny_real : 0 < y.toReal\n\u22a2 0 < x.toReal * y.toReal",["positivity","aesop"]],["Data/Vector3.lean",177,"\u03b1 : Type u_1\nm n : \u2115\na : \u03b1\nt\u271d : Vector3 \u03b1 m\nv : Vector3 \u03b1 n\ni : Fin2 (n + 1)\ne : n + 1 + m = n + m + 1\nk : \u2115\nb : \u03b1\nt : Vector3 \u03b1 k\nIH : \u2200 (x : n + 1 + k = n + k + 1), insert a (t +-+ v) (Eq.recOn x (i.add k)) = Eq.recOn x (t +-+ insert a v i)\nx\u271d : n + 1 + (k + 1) = n + (k + 1) + 1\n\u22a2 n + 1 + k = n + k + 1",["omega"]],["Combinatorics/Additive/SmallTripling.lean",42,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nk : \u211d\nm\u271d : \u2115\nh : \u2200 (\u03b5 : Fin 3 \u2192 \u2124), (\u2200 (i : Fin 3), |\u03b5 i| = 1) \u2192 \u2191(#(List.map (fun i \u21a6 A ^ \u03b5 i) (finRange 3)).prod) \u2264 k * \u2191(#A)\nm : \u2115\nih :\n  \u2200 (\u03b5 : Fin (m + 1) \u2192 \u2124),\n    (\u2200 (i : Fin (m + 1)), |\u03b5 i| = 1) \u2192 \u2191(#(List.map (fun i \u21a6 A ^ \u03b5 i) (finRange (m + 1))).prod) \u2264 k ^ (m + 1 - 2) * \u2191(#A)\n\u03b5 : Fin (m + 1 + 1) \u2192 \u2124\nh\u03b5 : \u2200 (i : Fin (m + 1 + 1)), |\u03b5 i| = 1\nhm : 2 \u2264 m\n\u22a2 m \u2260 0",["positivity","omega","aesop","linarith"]],["Combinatorics/Additive/SmallTripling.lean",47,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nk : \u211d\nm\u271d : \u2115\nh : \u2200 (\u03b5 : Fin 3 \u2192 \u2124), (\u2200 (i : Fin 3), |\u03b5 i| = 1) \u2192 \u2191(#(List.map (fun i \u21a6 A ^ \u03b5 i) (finRange 3)).prod) \u2264 k * \u2191(#A)\nm : \u2115\nhm : 3 \u2264 m + 1\nih :\n  \u2200 (\u03b5 : Fin (m + 1) \u2192 \u2124),\n    (\u2200 (i : Fin (m + 1)), |\u03b5 i| = 1) \u2192 \u2191(#(List.map (fun i \u21a6 A ^ \u03b5 i) (finRange (m + 1))).prod) \u2264 k ^ (m + 1 - 2) * \u2191(#A)\n\u03b5 : Fin (m + 1 + 1) \u2192 \u2124\nh\u03b5 : \u2200 (i : Fin (m + 1 + 1)), |\u03b5 i| = 1\nhm\u2080 : m \u2260 0\nh\u03b5\u2080 : \u2200 (i : Fin (m + 1 + 1)), \u03b5 i \u2260 0\nhA : A.Nonempty\n\u22a2 0 < \u2191(#A)",["positivity"]],["Combinatorics/Additive/SmallTripling.lean",69,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\nhA\u2080 : A.Nonempty\n\u22a2 0 < \u2191(#A)",["positivity","aesop"]],["Combinatorics/Additive/SmallTripling.lean",101,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\nhA\u2080 : A.Nonempty\n\u22a2 0 < \u2191(#A)",["positivity","aesop"]],["Combinatorics/Additive/SmallTripling.lean",136,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nm : \u2115\nhm : 3 \u2264 m\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\n\u03b5 : Fin m \u2192 \u2124\nh\u03b5 : \u2200 (i : Fin m), |\u03b5 i| = 1\n\u22a2 m \u2260 0",["positivity","omega","aesop","linarith"]],["Combinatorics/Additive/SmallTripling.lean",141,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nm : \u2115\nhm : 3 \u2264 m\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\n\u03b5 : Fin m \u2192 \u2124\nh\u03b5 : \u2200 (i : Fin m), |\u03b5 i| = 1\nhm\u2080 : m \u2260 0\nh\u03b5\u2080 : \u2200 (i : Fin m), \u03b5 i \u2260 0\nhA\u2080 : A.Nonempty\n\u22a2 0 < \u2191(#A)",["positivity"]],["Combinatorics/Additive/SmallTripling.lean",149,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Group G\nA : Finset G\nK : \u211d\nm : \u2115\nhm : 3 \u2264 m\nhA : \u2191(#(A ^ 3)) \u2264 K * \u2191(#A)\n\u03b5 : Fin m \u2192 \u2124\nh\u03b5 : \u2200 (i : Fin m), |\u03b5 i| = 1\nhm\u2080 : m \u2260 0\nh\u03b5\u2080 : \u2200 (i : Fin m), \u03b5 i \u2260 0\nhA\u2080 : A.Nonempty\nhK\u2081 : 1 \u2264 K\n\u03b4 : Fin 3 \u2192 \u2124\nh\u03b4 : (\u03b4 0 = 1 \u2228 \u03b4 0 = -1) \u2227 (\u03b4 1 = 1 \u2228 \u03b4 1 = -1) \u2227 (\u03b4 2 = 1 \u2228 \u03b4 2 = -1)\n\u22a2 3 \u2260 0",["omega"]],["Combinatorics/SimpleGraph/Triangle/Counting.lean",87,"\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\ns t u : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ndst : 2 * \u03b5 \u2264 \u2191(G.edgeDensity s t)\ndsu : 2 * \u03b5 \u2264 \u2191(G.edgeDensity s u)\ndtu : 2 * \u03b5 \u2264 \u2191(G.edgeDensity t u)\nutu : G.IsUniform \u03b5 t u\nx : \u03b1\nhxY : \u2191(#t) * (\u2191(G.edgeDensity s t) - \u03b5) \u2264 \u2191(#(filter (fun y \u21a6 G.Adj x y) t))\nhsu : \u2191(#u) * (\u2191(G.edgeDensity s u) - \u03b5) \u2264 \u2191(#(filter (fun y \u21a6 G.Adj x y) u))\nhY : \u2191(#t) * \u03b5 \u2264 \u2191(#(filter (fun y \u21a6 G.Adj x y) t))\nhZ : \u2191(#u) * \u03b5 \u2264 \u2191(#(filter (fun y \u21a6 G.Adj x y) u))\nthis :\n  \u2191(G.edgeDensity (filter (G.Adj x) t) (filter (G.Adj x) u)) - \u2191(G.edgeDensity t u) < \u03b5 \u2227\n    \u2191(G.edgeDensity t u) - \u2191(G.edgeDensity (filter (G.Adj x) t) (filter (G.Adj x) u)) < \u03b5\n\u22a2 \u03b5 \u2264 \u2191(G.edgeDensity (filter (fun y \u21a6 G.Adj x y) t) (filter (fun y \u21a6 G.Adj x y) u))",["linarith"]],["Combinatorics/SimpleGraph/Triangle/Counting.lean",117,"\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\ns t u : Finset \u03b1\ndst : 2 * \u03b5 \u2264 \u2191(G.edgeDensity s t)\nhst : G.IsUniform \u03b5 s t\ndsu : 2 * \u03b5 \u2264 \u2191(G.edgeDensity s u)\nusu : G.IsUniform \u03b5 s u\ndtu : 2 * \u03b5 \u2264 \u2191(G.edgeDensity t u)\nutu : G.IsUniform \u03b5 t u\nh\u2081 : \u2191(#(SimpleGraph.badVertices G \u03b5 s t)) \u2264 \u2191(#s) * \u03b5\nh\u2082 : \u2191(#(SimpleGraph.badVertices G \u03b5 s u)) \u2264 \u2191(#s) * \u03b5\nX' : Finset \u03b1 := s \\ (SimpleGraph.badVertices G \u03b5 s t \u222a SimpleGraph.badVertices G \u03b5 s u)\nthis\u271d :\n  (X'.biUnion fun x \u21a6\n      image (fun x_1 \u21a6 (x, x_1)) (G.interedges (filter (fun y \u21a6 G.Adj x y) t) (filter (fun y \u21a6 G.Adj x y) u))) \u2286\n    filter\n      (fun x \u21a6\n        match x with\n        | (a, b, c) => G.Adj a b \u2227 G.Adj a c \u2227 G.Adj b c)\n      (s \u00d7\u02e2 t \u00d7\u02e2 u)\nthis : 0 \u2264 \u03b5\nhX' : (1 - 2 * \u03b5) * \u2191(#s) \u2264 \u2191(#X')\n\u22a2 0 \u2264 \u03b5 ^ 3 * \u2191(#t) * \u2191(#u)",["positivity"]],["MeasureTheory/Covering/DensityTheorem.lean",63,"\u03b1 : Type u_1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : IsUnifLocDoublingMeasure \u03bc\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nK : \u211d\nR : \u211d := scalingScaleOf \u03bc ((4 * K + 3) \u2294 3)\nRpos : 0 < R\nA :\n  \u2200 (x : \u03b1),\n    \u2203\u1da0 (r : \u211d) in \ud835\udcdd[>] 0, \u03bc (closedBall x (3 * r)) \u2264 \u2191(scalingConstantOf \u03bc ((4 * K + 3) \u2294 3)) * \u03bc (closedBall x r)\n\u22a2 0 < R / 4",["linarith","aesop","positivity"]],["MeasureTheory/Covering/DensityTheorem.lean",87,"case pos.h.inl.left.h\n\u03b1 : Type u_1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : IsUnifLocDoublingMeasure \u03bc\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nK : \u211d\nx y : \u03b1\nr : \u211d\nh : dist x y \u2264 K * r\nrpos : 0 < r\nR : \u211d := scalingScaleOf \u03bc ((4 * K + 3) \u2294 3)\nH : closedBall y r \u2286 closedBall x (R / 4)\nhr : r \u2264 R\n\u22a2 r + dist x y \u2264 (K + 1) * r",["linarith"]],["MeasureTheory/Covering/DensityTheorem.lean",90,"case h\n\u03b1 : Type u_1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : IsUnifLocDoublingMeasure \u03bc\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nK : \u211d\nx y : \u03b1\nr : \u211d\nh : dist x y \u2264 K * r\nrpos : 0 < r\nR : \u211d := scalingScaleOf \u03bc ((4 * K + 3) \u2294 3)\nH : closedBall y r \u2286 closedBall x (R / 4)\nhr : r \u2264 R\n\u22a2 3 * ((K + 1) * r) + dist x y \u2264 (4 * K + 3) * r",["linarith"]],["MeasureTheory/Covering/DensityTheorem.lean",102,"case h\n\u03b1 : Type u_1\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : IsUnifLocDoublingMeasure \u03bc\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nK : \u211d\nx y : \u03b1\nr : \u211d\nh : dist x y \u2264 K * r\nrpos : 0 < r\nR : \u211d := scalingScaleOf \u03bc ((4 * K + 3) \u2294 3)\nH : closedBall y r \u2286 closedBall x (R / 4)\nhr : R < r\nA : y \u2208 closedBall y r\nB : dist x y \u2264 R / 4\n\u22a2 3 * (R / 4) + dist x y \u2264 r",["linarith"]],["Topology/Algebra/Polynomial.lean",159,"case inr.inl\nF : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : CommRing F\ninst\u271d : NormedField K\np : F[X]\nf : F \u2192+* K\nB : \u211d\ni : \u2115\nh1 : p.Monic\nh2 : Splits f p\nh3 : \u2200 z \u2208 (map f p).roots, \u2016z\u2016 \u2264 B\nhB : 0 \u2264 B\nhi : (map f p).natDegree < i\n\u22a2 0 \u2264 B ^ ((map f p).natDegree - i) * \u2191((map f p).natDegree.choose i)",["positivity"]],["Combinatorics/SimpleGraph/LapMatrix.lean",97,"case right\nV : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Fintype V\nG : SimpleGraph V\ninst\u271d\u2074 : DecidableRel G.Adj\ninst\u271d\u00b3 : DecidableEq V\ninst\u271d\u00b2 : LinearOrderedField R\ninst\u271d\u00b9 : StarRing R\ninst\u271d : TrivialStar R\nx : V \u2192 R\n\u22a2 0 \u2264 (\u2211 i : V, \u2211 j : V, if G.Adj i j then (x i - x j) ^ 2 else 0) / 2",["positivity"]],["Combinatorics/SimpleGraph/LapMatrix.lean",101,"",["positivity"]],["AlgebraicTopology/SimplicialSet/Horn.lean",105,"n : \u2115\ni a b : Fin (n + 1)\nhab : a \u2264 b\nH : #{i, a, b} \u2264 n\nhS : {i, a, b} = univ\nthis : n + 1 \u2264 #{i, a, b}\n\u22a2 False",["omega","aesop","linarith"]],["AlgebraicTopology/SimplicialSet/Horn.lean",137,"n : \u2115\ni : Fin (n + 1)\nj : Fin n\nh\u2080 : 0 < \u2191i\nh\u2099 : \u2191i < n\n\u22a2 2 \u2264 n",["omega","linarith"]],["AlgebraicTopology/SimplicialSet/Horn.lean",169,"case pos\nn i : \u2115\nhi : i < n + 4\nh\u2080 : 0 < \u27e8i, hi\u27e9\nh : 0 < n + 2\nhS : {\u27e8i, hi\u27e9, \u27e80, \u22ef\u27e9, \u27e80 + 1, \u22ef\u27e9, \u27e80 + 2, \u22ef\u27e9} = univ\nthis : n + 3 = i\nh\u2099 : i < n + 3\n\u22a2 False",["omega","aesop","linarith"]],["NumberTheory/Transcendental/Liouville/LiouvilleNumber.lean",82,"m : \u211d\nhm : 1 < m\nk : \u2115\n\u22a2 0 < 1 / m ^ (0 + (k + 1))!",["positivity"]],["NumberTheory/Transcendental/Liouville/LiouvilleNumber.lean",131,"n : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 0 \u2264 1 / m ^ (n + 1)!",["positivity"]],["Data/Nat/Sqrt.lean",75,"n guess : \u2115\nhn : n < (guess + 1) * (guess + 1)\nm : \u2115 := (guess + n / guess) / 2\nh : (guess + n / guess) / 2 < guess\na : \u2115\n\u22a2 a \u2264 2 * ((a + 1) / 2)",["omega"]],["Analysis/Normed/Affine/Simplex.lean",122,"R : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : PseudoMetricSpace P\ninst\u271d\u00b9 : Module R V\ninst\u271d : NormedAddTorsor V P\nn : \u2115\ns : Simplex R P n\nhr : s.Regular\ni j : Fin (n + 1)\nhij : i \u2260 j\n\u22a2 n \u2260 0",["omega"]],["GroupTheory/Coxeter/Matrix.lean",106,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn : \u2115\n\u22a2 (Matrix.of fun i j \u21a6 if i = j then 1 else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2).transpose =\n    Matrix.of fun i j \u21a6 if i = j then 1 else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2",["aesop","omega"]],["GroupTheory/Coxeter/Matrix.lean",157,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn m : \u2115\n\u22a2 (Matrix.of fun i j \u21a6 if i = j then 1 else m + 2).transpose = Matrix.of fun i j \u21a6 if i = j then 1 else m + 2",["aesop","omega"]],["Algebra/Polynomial/Sequence.lean",135,"R : Type u_1\ninst\u271d : Ring R\nS : Sequence R\nhCoeff : \u2200 (i : \u2115), IsUnit (\u2191S i).leadingCoeff\na\u271d : Nontrivial R\nn : \u2115\nih : \u2200 m < n, \u2200 (P : R[X]), P.natDegree = m \u2192 P \u2208 span R (Set.range \u2191S)\nP : R[X]\nhp : P.natDegree = n\np_ne_zero : \u00acP = 0\nu : R\nleftinv : (\u2191S n).leadingCoeff * u = 1\nrightinv : u * (\u2191S n).leadingCoeff = 1\nhead : R[X] := P.leadingCoeff \u2022 u \u2022 \u2191S n\ntail : R[X] := P - head\nhead_mem_span : head \u2208 span R (Set.range \u2191S)\ntail_eq_zero : \u00actail = 0\nisRightRegular_smul_leadingCoeff : IsRightRegular (u \u2022 \u2191S n).leadingCoeff\nu_degree_same : (u \u2022 \u2191S n).degree = (\u2191S n).degree\nhead_degree_eq : P.degree = (P.leadingCoeff \u2022 u \u2022 \u2191S n).degree\nn_eq_zero : \u00acn = 0\n\u22a2 0 < P.natDegree",["omega"]],["Combinatorics/SimpleGraph/Regularity/Lemma.lean",133,"\u03b1 : Type u_1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\nl : \u2115\nh\u03b5 : 0 < \u03b5\nhl : l \u2264 Fintype.card \u03b1\nh\u03b1 : bound \u03b5 l \u2264 Fintype.card \u03b1\nt : \u2115 := initialBound \u03b5 l\nht\u03b1 : t \u2264 #univ\ndum : Finpartition univ\nhdum\u2081 : dum.IsEquipartition\nhdum\u2082 : #dum.parts = initialBound \u03b5 l\nh\u03b5\u2081 : \u03b5 \u2264 1\nthis : Nonempty \u03b1\ni : \u2115\nP : Finpartition univ\nhP\u2081 : P.IsEquipartition\nhP\u2082 : t \u2264 #P.parts\nhP\u2083 : #P.parts \u2264 stepBound^[i] t\nhuniform : \u00acP.IsUniform G \u03b5\nhP\u2084 : \u03b5 ^ 5 / 4 * \u2191i \u2264 \u2191(P.energy G)\n\u22a2 0 \u2264 \u03b5 ^ 5",["positivity"]],["NumberTheory/SiegelsLemma.lean",185,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nA : Matrix \u03b1 \u03b2 \u2124\nhn : m < n\nhm : 0 < m\nx : \u03b2 \u2192 \u2124\nhxT : x \u2208 T\ny : \u03b2 \u2192 \u2124\nhyT : y \u2208 T\nhneq : x \u2260 y\nhfeq : A *\u1d65 x = A *\u1d65 y\n\u22a2 0 \u2264 (\u2191n * (1 \u2294 \u2016A\u2016)) ^ e",["positivity"]],["NumberTheory/LSeries/MellinEqDirichlet.lean",107,"case pos\n\u03b9 : Type u_1\ninst\u271d : Countable \u03b9\na : \u03b9 \u2192 \u2102\np : \u03b9 \u2192 \u211d\nF : \u211d \u2192 \u2102\ns : \u2102\nhp : \u2200 (i : \u03b9), 0 \u2264 p i\nhs : 0 < s.re\nh_sum : Summable fun i \u21a6 \u2016a i\u2016 / p i ^ s.re\nhs' : s \u2260 0\na' : \u03b9 \u2192 \u2102 := fun i \u21a6 if p i = 0 then 0 else a i\nhp' : \u2200 (i : \u03b9), a' i = 0 \u2228 0 < p i\nthis : \u2200 (i : \u03b9) (t : \u211d), (if p i = 0 then 0 else a i * \u2191(rexp (-\u03c0 * p i * t))) = a' i * \u2191(rexp (-\u03c0 * p i * t))\nhF : \u2200 t \u2208 Ioi 0, HasSum (fun i \u21a6 a' i * \u2191(rexp (-\u03c0 * p i * t))) (F t)\ni : \u03b9\nh\u271d : p i = 0\n\u22a2 0 \u2264 \u2016a i\u2016 / p i ^ s.re",["positivity"]],["NumberTheory/LSeries/MellinEqDirichlet.lean",116,"\u03b9 : Type u_1\ninst\u271d : Countable \u03b9\na : \u03b9 \u2192 \u2102\nr : \u03b9 \u2192 \u211d\nF : \u211d \u2192 \u2102\ns : \u2102\nhs : 0 < s.re\nhF : \u2200 t \u2208 Ioi 0, HasSum (fun i \u21a6 if r i = 0 then 0 else a i * \u2191(rexp (-\u03c0 * r i ^ 2 * t))) (F t)\nh_sum : Summable fun i \u21a6 \u2016a i\u2016 / |r i| ^ s.re\n\u22a2 0 < s.re / 2",["positivity","aesop","linarith"]],["NumberTheory/LSeries/MellinEqDirichlet.lean",134,"\u03b9 : Type u_1\ninst\u271d : Countable \u03b9\na : \u03b9 \u2192 \u2102\nr : \u03b9 \u2192 \u211d\nF : \u211d \u2192 \u2102\ns : \u2102\nhs : 0 < s.re\nhF : \u2200 t \u2208 Ioi 0, HasSum (fun i \u21a6 a i * \u2191(r i) * \u2191(rexp (-\u03c0 * r i ^ 2 * t))) (F t)\nh_sum : Summable fun i \u21a6 \u2016a i\u2016 / |r i| ^ s.re\nhs\u2081 : s \u2260 0\n\u22a2 0 < s.re + 1",["positivity","linarith"]],["MeasureTheory/Decomposition/UnsignedHahn.lean",92,"case refine_1\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nd : Set \u03b1 \u2192 \u211d := fun s \u21a6 \u2191(\u03bc s).toNNReal - \u2191(\u03bd s).toNNReal\nc : Set \u211d := d '' {s | MeasurableSet s}\n\u03b3 : \u211d := sSup c\nh\u03bc : \u2200 (s : Set \u03b1), \u03bc s \u2260 \u22a4\nh\u03bd : \u2200 (s : Set \u03b1), \u03bd s \u2260 \u22a4\nto_nnreal_\u03bc : \u2200 (s : Set \u03b1), \u2191(\u03bc s).toNNReal = \u03bc s\nto_nnreal_\u03bd : \u2200 (s : Set \u03b1), \u2191(\u03bd s).toNNReal = \u03bd s\nd_split : \u2200 (s t : Set \u03b1), MeasurableSet t \u2192 d s = d (s \\ t) + d (s \u2229 t)\nd_Union : \u2200 (s : \u2115 \u2192 Set \u03b1), Monotone s \u2192 Tendsto (fun n \u21a6 d (s n)) atTop (\ud835\udcdd (d (\u22c3 n, s n)))\nd_Inter :\n  \u2200 (s : \u2115 \u2192 Set \u03b1),\n    (\u2200 (n : \u2115), MeasurableSet (s n)) \u2192\n      (\u2200 (n m : \u2115), n \u2264 m \u2192 s m \u2286 s n) \u2192 Tendsto (fun n \u21a6 d (s n)) atTop (\ud835\udcdd (d (\u22c2 n, s n)))\nbdd_c : BddAbove c\nc_nonempty : c.Nonempty\nd_le_\u03b3 : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 d s \u2264 \u03b3\nthis\u271d : \u2200 (n : \u2115), \u2203 s, MeasurableSet s \u2227 \u03b3 - (1 / 2) ^ n < d s\ne : \u2115 \u2192 Set \u03b1\nhe : \u2200 (x : \u2115), MeasurableSet (e x) \u2227 \u03b3 - (1 / 2) ^ x < d (e x)\nhe\u2081 : \u2200 (n : \u2115), MeasurableSet (e n)\nhe\u2082 : \u2200 (n : \u2115), \u03b3 - (1 / 2) ^ n < d (e n)\nf : \u2115 \u2192 \u2115 \u2192 Set \u03b1 := fun n m \u21a6 (Finset.Ico n (m + 1)).inf e\nhf : \u2200 (n m : \u2115), MeasurableSet (f n m)\nf_subset_f : \u2200 {a b c d : \u2115}, a \u2264 b \u2192 c \u2264 d \u2192 f a d \u2286 f b c\nf_succ : \u2200 (n m : \u2115), n \u2264 m \u2192 f n (m + 1) = f n m \u2229 e (m + 1)\nn m : \u2115\nh : m \u2264 n\nthis : \u03b3 - (1 / 2) ^ m < d (e m)\n\u22a2 \u03b3 - 2 * (1 / 2) ^ m + (1 / 2) ^ m \u2264 d (e m)",["linarith"]],["MeasureTheory/Decomposition/UnsignedHahn.lean",151,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nd : Set \u03b1 \u2192 \u211d := fun s \u21a6 \u2191(\u03bc s).toNNReal - \u2191(\u03bd s).toNNReal\nc : Set \u211d := d '' {s | MeasurableSet s}\n\u03b3 : \u211d := sSup c\nh\u03bc : \u2200 (s : Set \u03b1), \u03bc s \u2260 \u22a4\nh\u03bd : \u2200 (s : Set \u03b1), \u03bd s \u2260 \u22a4\nto_nnreal_\u03bc : \u2200 (s : Set \u03b1), \u2191(\u03bc s).toNNReal = \u03bc s\nto_nnreal_\u03bd : \u2200 (s : Set \u03b1), \u2191(\u03bd s).toNNReal = \u03bd s\nd_split : \u2200 (s t : Set \u03b1), MeasurableSet t \u2192 d s = d (s \\ t) + d (s \u2229 t)\nd_Union : \u2200 (s : \u2115 \u2192 Set \u03b1), Monotone s \u2192 Tendsto (fun n \u21a6 d (s n)) atTop (\ud835\udcdd (d (\u22c3 n, s n)))\nd_Inter :\n  \u2200 (s : \u2115 \u2192 Set \u03b1),\n    (\u2200 (n : \u2115), MeasurableSet (s n)) \u2192\n      (\u2200 (n m : \u2115), n \u2264 m \u2192 s m \u2286 s n) \u2192 Tendsto (fun n \u21a6 d (s n)) atTop (\ud835\udcdd (d (\u22c2 n, s n)))\nbdd_c : BddAbove c\nc_nonempty : c.Nonempty\nd_le_\u03b3 : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 d s \u2264 \u03b3\nthis : \u2200 (n : \u2115), \u2203 s, MeasurableSet s \u2227 \u03b3 - (1 / 2) ^ n < d s\ne : \u2115 \u2192 Set \u03b1\nhe : \u2200 (x : \u2115), MeasurableSet (e x) \u2227 \u03b3 - (1 / 2) ^ x < d (e x)\nhe\u2081 : \u2200 (n : \u2115), MeasurableSet (e n)\nhe\u2082 : \u2200 (n : \u2115), \u03b3 - (1 / 2) ^ n < d (e n)\nf : \u2115 \u2192 \u2115 \u2192 Set \u03b1 := fun n m \u21a6 (Finset.Ico n (m + 1)).inf e\nhf : \u2200 (n m : \u2115), MeasurableSet (f n m)\nf_subset_f : \u2200 {a b c d : \u2115}, a \u2264 b \u2192 c \u2264 d \u2192 f a d \u2286 f b c\nf_succ : \u2200 (n m : \u2115), n \u2264 m \u2192 f n (m + 1) = f n m \u2229 e (m + 1)\nle_d_f : \u2200 (n m : \u2115), m \u2264 n \u2192 \u03b3 - 2 * (1 / 2) ^ m + (1 / 2) ^ n \u2264 d (f m n)\ns : Set \u03b1 := \u22c3 m, \u22c2 n, f m n\n\u03b3_le_d_s : \u03b3 \u2264 d s\nhs : MeasurableSet s\nt : Set \u03b1\nht : MeasurableSet t\nhts : t \u2286 s\u1d9c\n\u22a2 \u03b3 + d t \u2264 d s + d t",["gcongr","aesop","linarith"]],["Dynamics/Ergodic/AddCircle.lean",70,"T : \u211d\nhT : Fact (0 < T)\ns : Set (AddCircle T)\n\u03b9 : Type u_1\nl : Filter \u03b9\ninst\u271d : l.NeBot\nu : \u03b9 \u2192 AddCircle T\n\u03bc : Measure (AddCircle T) := volume\nhs : NullMeasurableSet s \u03bc\nhu\u2081 : \u2200 (i : \u03b9), u i +\u1d65 s =\u1da0[ae \u03bc] s\nn : \u03b9 \u2192 \u2115 := addOrderOf \u2218 u\nhu\u2082 : Tendsto n l atTop\nhT\u2080 : 0 < T\nhT\u2081 : ENNReal.ofReal T \u2260 0\nh : \u03bc s \u2260 0\nd : AddCircle T\nhd :\n  \u2200 {\u03b9' : Type ?u.5795} {l : Filter \u03b9'} (w : \u03b9' \u2192 AddCircle T) (\u03b4 : \u03b9' \u2192 \u211d),\n    Tendsto \u03b4 l (\ud835\udcdd[>] 0) \u2192\n      (\u2200\u1da0 (j : \u03b9') in l, d \u2208 closedBall (w j) (1 * \u03b4 j)) \u2192\n        Tendsto (fun j \u21a6 \u03bc (s \u2229 closedBall (w j) (\u03b4 j)) / \u03bc (closedBall (w j) (\u03b4 j))) l (\ud835\udcdd 1)\nI : \u03b9 \u2192 Set (AddCircle T) := fun j \u21a6 closedBall d (T / (2 * \u2191(n j)))\n\u03b4 : \u03b9 \u2192 \u211d := fun j \u21a6 T / (2 * \u2191(n j))\nj : \u03b9\nhj : 0 < n j\n\u22a2 0 < 2 * \u2191(n j)",["positivity","aesop"]],["Analysis/SpecialFunctions/Complex/Circle.lean",161,"case h\nT : \u211d\nhT : T \u2260 0\nz\u271d\u00b9 z\u271d : \u211d\nh : Circle.exp (2 * \u03c0 / T * z\u271d\u00b9) = Circle.exp (2 * \u03c0 / T * z\u271d)\nm : \u2124\nhm : 2 * \u03c0 * z\u271d = 2 * \u03c0 * z\u271d\u00b9 + \u2191m * (2 * \u03c0) * T\n\u22a2 2 * \u03c0 * (\u2191m * T) = 2 * \u03c0 * (-z\u271d\u00b9 + z\u271d)",["linarith"]],["RingTheory/FractionalIdeal/Norm.lean",84,"R : Type u_1\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : IsDedekindDomain R\ninst\u271d\u2074 : Module.Free \u2124 R\ninst\u271d\u00b3 : Module.Finite \u2124 R\nK : Type u_2\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nI : FractionalIdeal R\u2070 K\n\u22a2 0 \u2264 \u2191(Ideal.absNorm I.num) / \u2191|(Algebra.norm \u2124) \u2191I.den|",["positivity"]],["Analysis/SpecialFunctions/MulExpNegMulSq.lean",128,"\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nx : \u211d\nh\u271d : \u221a\u03b5 * x * (\u221a\u03b5 * x) = \u03b5 * x * x\nh : \u03b5 = 0\n\u22a2 False",["linarith","aesop"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",143,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 kernel.map f (f \u226b g) (\ud835\udfd9 X) g \u22ef \u226b kernel.map (f \u226b g) g f (\ud835\udfd9 Z) \u22ef = 0",["aesop","omega","infer_instance"]],["NumberTheory/FactorisationProperties.lean",95,"n : \u2115\nhn : n \u2260 0\n\u22a2 \u2211 i \u2208 n.properDivisors, i < n \u2194 \u00acn < \u2211 i \u2208 n.properDivisors, i \u2227 \u00ac(\u2211 i \u2208 n.properDivisors, i = n \u2227 0 < n)",["omega"]],["NumberTheory/FactorisationProperties.lean",100,"n : \u2115\nhn : 0 \u2260 n\n\u22a2 \u2211 i \u2208 n.properDivisors, i = n \u2227 0 < n \u2194 \u00acn < \u2211 i \u2208 n.properDivisors, i \u2227 \u00ac\u2211 i \u2208 n.properDivisors, i < n",["omega"]],["NumberTheory/FactorisationProperties.lean",105,"n : \u2115\nhn : 0 \u2260 n\n\u22a2 n < \u2211 i \u2208 n.properDivisors, i \u2194 \u00ac(\u2211 i \u2208 n.properDivisors, i = n \u2227 0 < n) \u2227 \u00ac\u2211 i \u2208 n.properDivisors, i < n",["omega"]],["NumberTheory/FactorisationProperties.lean",111,"n : \u2115\nhn : 0 \u2260 n\n\u22a2 \u2211 i \u2208 n.properDivisors, i < n \u2228 n < \u2211 i \u2208 n.properDivisors, i \u2228 \u2211 i \u2208 n.properDivisors, i = n \u2227 0 < n",["omega"]],["Analysis/Asymptotics/SpecificAsymptotics.lean",111,"\u03b1 : Type u_1\ninst\u271d : NormedAddCommGroup \u03b1\nf : \u2115 \u2192 \u03b1\ng : \u2115 \u2192 \u211d\nh : f =o[atTop] g\nhg : 0 \u2264 g\nh'g : Tendsto (fun n \u21a6 \u2211 i \u2208 range n, g i) atTop atTop\nA : \u2200 (i : \u2115), \u2016g i\u2016 = g i\nB : \u2200 (n : \u2115), \u2016\u2211 i \u2208 range n, g i\u2016 = \u2211 i \u2208 range n, g i\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nN : \u2115\nhN : \u2200 (b : \u2115), N \u2264 b \u2192 \u2016f b\u2016 \u2264 \u03b5 / 2 * g b\nthis : (fun x \u21a6 \u2211 i \u2208 range N, f i) =o[atTop] fun n \u21a6 \u2211 i \u2208 range n, g i\nn : \u2115\nhn : \u2016\u2211 i \u2208 range N, f i\u2016 \u2264 \u03b5 / 2 * \u2016\u2211 i \u2208 range n, g i\u2016\nNn : n \u2208 Set.Ici N\n\u22a2 \u2016\u2211 i \u2208 range N, f i\u2016 + \u03b5 / 2 * \u2211 i \u2208 range n, g i \u2264 \u03b5 / 2 * \u2016\u2211 i \u2208 range n, g i\u2016 + \u03b5 / 2 * \u2211 i \u2208 range n, g i",["gcongr","aesop","linarith"]],["Analysis/Asymptotics/SpecificAsymptotics.lean",53,"case hn\n\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nhpq : q < p\n\u22a2 0 < \u2191p - \u2191q",["omega","aesop","linarith"]],["Analysis/Asymptotics/SpecificAsymptotics.lean",59,"case hn\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\np q : \u2115\nhpq : p < q\n\u22a2 \u2191p - \u2191q < 0",["omega","aesop","linarith"]],["Analysis/Convex/SpecificFunctions/Deriv.lean",41,"n : \u2115\nhn : 2 \u2264 n\nx : \u211d\nhx : 0 < x\ny : \u211d\nx\u271d : y \u2208 Ioi 0\nhxy : x < y\n\u22a2 0 < \u2191n",["positivity"]],["CategoryTheory/Abelian/Projective/Dimension.lean",97,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Abelian C\nX : C\nn m : \u2115\nh : n \u2264 m\ninst\u271d : HasProjectiveDimensionLT X n\nthis : HasExt C := HasExt.standard C\ni : \u2115\nhi : m \u2264 i\nY : C\ne : Ext X Y i\n\u22a2 n \u2264 i",["omega","linarith"]],["Data/Int/Interval.lean",136,"case h\na a\u271d : \u2124\n\u22a2 a \u2264 a\u271d \u2227 a\u271d \u2264 a + 1 \u2194 a\u271d = a \u2228 a\u271d = a + 1",["omega"]],["Data/Int/CardIntervalMod.lean",124,"b r : \u2115\nhr : 0 < r\nv : \u2115\n\u22a2 0 < \u2191r",["positivity","aesop"]],["Data/Int/CardIntervalMod.lean",139,"b r : \u2115\nhr : 0 < r\nv : \u2115\n\u22a2 0 < \u2191r",["positivity","aesop"]],["AlgebraicTopology/DoldKan/Projections.lean",89,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nn : \u2115\nj : Fin (n + 1)\nhj\u2081 : n + 1 \u2264 \u2191j + 0\n\u22a2 (P 0).f (n + 1) \u226b X.\u03b4 j.succ = 0",["omega"]],["AlgebraicTopology/DoldKan/Projections.lean",105,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nY : C\nn : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nq : \u2115\nhq : HigherFacesVanish q \u03c6 \u2192 \u03c6 \u226b (P q).f (n + 1) = \u03c6\nv : HigherFacesVanish (q + 1) \u03c6\nhqn : \u00acn < q\na : \u2115\nha : q + a = n\n\u22a2 n = a + q",["omega","linarith"]],["Data/List/Intervals.lean",58,"n m l : \u2115\n\u22a2 n \u2264 l \u2227 l < n + (m - n) \u2194 n \u2264 l \u2227 l < m",["omega"]],["Analysis/InnerProductSpace/Positive.lean",123,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : CompleteSpace E\nf : E \u2192L[\ud835\udd5c] E\nc : \u211d\u22650\nhc : 0 < c\nh : \u2200 (x : E), \u2016x\u2016 ^ 2 * \u2191c \u2264 \u2016\u27eaf x, x\u27eb_\ud835\udd5c\u2016\nh_anti : AntilipschitzWith c\u207b\u00b9 \u21d1f\n_inst : CompleteSpace \u21a5(LinearMap.range f)\nx : E\nhx : x \u2208 (LinearMap.range f)\u15ee\n\u22a2 0 \u2264 \u2016x\u2016 ^ 2 * \u2191c",["positivity","aesop"]],["Analysis/SpecialFunctions/JapaneseBracket.lean",42,"case h\nE : Type u_1\ninst\u271d : NormedAddCommGroup E\nx : E\nthis : 0 \u2264 (\u2016x\u2016 - 1) ^ 2\n\u22a2 (1 + \u2016x\u2016) ^ 2 \u2264 2 * (1 + \u2016x\u2016 ^ 2)",["linarith"]],["Analysis/SpecialFunctions/JapaneseBracket.lean",54,"case hx\nE : Type u_1\ninst\u271d : NormedAddCommGroup E\nr : \u211d\nx : E\nhr : 0 < r\n\u22a2 0 \u2264 1 + \u2016x\u2016",["positivity"]],["Analysis/SpecialFunctions/JapaneseBracket.lean",95,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nr : \u211d\nhnr : \u2191(finrank \u211d E) < r\nhr : 0 < r\nh_meas : Measurable fun \u03c9 \u21a6 (1 + \u2016\u03c9\u2016) ^ (-r)\nx : E\n\u22a2 0 \u2264 (1 + \u2016x\u2016) ^ (-r)",["positivity"]],["Analysis/SpecialFunctions/JapaneseBracket.lean",146,"case refine_2\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nr : \u211d\nhnr : \u2191(finrank \u211d E) < r\nhr : 0 < r\nx : E\n\u22a2 0 < (1 + \u2016x\u2016 ^ 2) ^ (-r / 2)",["positivity"]],["Algebra/Homology/Embedding/Boundary.lean",179,"case mpr.right\np : \u2124\ni : \u2115\nhi : p + \u2191i + 1 = p + 0\n\u22a2 False",["omega"]],["Algebra/Homology/Embedding/Boundary.lean",195,"case mpr.right\np : \u2124\ni : \u2115\nhi : p + \u2191i + 1 = p + 0\n\u22a2 False",["omega"]],["Analysis/Normed/Affine/MazurUlam.lean",78,"E : Type u_1\nPE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : MetricSpace PE\ninst\u271d : NormedAddTorsor E PE\nx y : PE\nz : PE := midpoint \u211d x y\ns : Set (PE \u2243\u1d62 PE) := {e | e x = x \u2227 e y = y}\nthis\u271d : Nonempty \u2191s\nh_bdd : BddAbove (range fun e \u21a6 dist (\u2191e z) z)\nR : PE \u2243\u1d62 PE := (pointReflection \u211d z).toIsometryEquiv\nf : PE \u2243\u1d62 PE \u2192 PE \u2243\u1d62 PE := fun e \u21a6 ((e.trans R).trans e.symm).trans R\nhf_dist : \u2200 (e : PE \u2243\u1d62 PE), dist ((f e) z) z = 2 * dist (e z) z\nhf_maps_to : MapsTo f s s\nc : \u211d := \u2a06 e, dist (\u2191e z) z\nthis : c \u2264 c / 2\n\u22a2 c \u2264 0",["linarith"]],["NumberTheory/ModularForms/JacobiTheta/OneVariable.lean",92,"\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nthis : \u2016\u2211' (n : \u2115), cexp (\u2191\u03c0 * I * (\u2191n + 1) ^ 2 * \u03c4)\u2016 \u2264 rexp (-\u03c0 * \u03c4.im) / (1 - rexp (-\u03c0 * \u03c4.im))\n\u22a2 2 * \u2016\u2211' (n : \u2115), cexp (\u2191\u03c0 * I * (\u2191n + 1) ^ 2 * \u03c4)\u2016 \u2264 2 * (rexp (-\u03c0 * \u03c4.im) / (1 - rexp (-\u03c0 * \u03c4.im)))",["gcongr","aesop","linarith"]],["Topology/MetricSpace/CantorScheme.lean",122,"\u03b2 : Type u_1\n\u03b1 : Type u_2\nA : List \u03b2 \u2192 Set \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\nx : \u2115 \u2192 \u03b2\nhA : \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, EMetric.diam (A (res x n)) \u2264 \u03b5\n\u22a2 0 < \u03b5 / 2",["linarith","aesop","positivity"]],["Topology/MetricSpace/CantorScheme.lean",129,"case h\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nA : List \u03b2 \u2192 Set \u03b1\ninst\u271d : PseudoMetricSpace \u03b1\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\nx : \u2115 \u2192 \u03b2\nhA : \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, EMetric.diam (A (res x n)) \u2264 \u03b5\nn : \u2115\nhn : \u2200 n_1 \u2265 n, EMetric.diam (A (res x n_1)) \u2264 ENNReal.ofReal (\u03b5 / 2)\ny : \u03b1\nhy : y \u2208 A (res x n)\nz : \u03b1\nhz : z \u2208 A (res x n)\n\u22a2 \u03b5 / 2 < \u03b5",["linarith","aesop"]],["Data/ZMod/ValMinAbs.lean",144,"n : \u2115\nhpos : NeZero n\na : ZMod n\nthis : a.val < n\n\u22a2 (if a.val \u2264 n / 2 then \u2191a.val else \u2191a.val - \u2191n).natAbs = a.val \u2293 (n - a.val)",["omega"]],["Probability/Distributions/Gamma.lean",34,"y z : \u211d\nf : \u211d \u2192 \u211d\u22650\u221e\nhzy : z \u2264 y\na\u271d\u00b2 : \u211d\na\u271d\u00b9 : a\u271d\u00b2 < z\nb\u271d : \u211d\na\u271d : z \u2264 b\u271d \u2227 b\u271d \u2264 y\n\u22a2 a\u271d\u00b2 \u2260 b\u271d",["linarith"]],["Probability/Distributions/Gamma.lean",87,"x a r : \u211d\nha : 0 < a\nhr : 0 < r\nhx : 0 < x\n\u22a2 0 < r ^ a / Gamma a * x ^ (a - 1) * rexp (-(r * x))",["positivity"]],["Probability/Distributions/Gamma.lean",114,"a r : \u211d\nha : 0 < a\nhr : 0 < r\nleftSide : \u222b\u207b (x : \u211d) in Iio 0, gammaPDF a r x = 0\nrightSide :\n  \u222b\u207b (x : \u211d) in Ici 0, gammaPDF a r x =\n    \u222b\u207b (x : \u211d) in Ici 0, ENNReal.ofReal (r ^ a / Gamma a * x ^ (a - 1) * rexp (-(r * x)))\nx : \u211d\nhx : 0 \u2264 x\n\u22a2 0 x \u2264 r ^ a / Gamma a * x ^ (a - 1) * rexp (-(r * x))",["positivity"]],["Algebra/Order/Round.lean",148,"case left\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\nhx : 1 / 2 \u2264 fract x\n\u22a2 1 \u2264 fract x + 1 / 2",["linarith"]],["Data/Nat/Pairing.lean",146,"case pos\nm n : \u2115\nh\u271d : m < n\nthis : n \u2264 n * n\n\u22a2 m + n \u2264 n * n + m",["omega"]],["Topology/MetricSpace/Kuratowski.lean",70,"\u03b1 : Type u\ninst\u271d : MetricSpace \u03b1\nx : \u2115 \u2192 \u03b1\nH : DenseRange x\na b : \u03b1\ne : \u211d\nepos : 0 < e\nn : \u2115\nhn : dist a (x n) < e / 2\nC : dist b (x n) - dist a (x n) = \u2191(embeddingOfSubset x b) n - \u2191(embeddingOfSubset x a) n\n\u22a2 2 * dist a (x n) + |\u2191(embeddingOfSubset x b) n - \u2191(embeddingOfSubset x a) n| \u2264\n    2 * (e / 2) + |\u2191(embeddingOfSubset x b) n - \u2191(embeddingOfSubset x a) n|",["gcongr","linarith"]],["Analysis/NormedSpace/HomeomorphBall.lean",46,"E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nx\u271d : x \u2208 univ\n\u22a2 0 < 1 + \u2016x\u2016 ^ 2",["positivity"]],["Analysis/NormedSpace/HomeomorphBall.lean",64,"E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\n\u22a2 0 < 1 + \u2016x\u2016 ^ 2",["positivity"]],["Data/Multiset/Basic.lean",96,"\u03b1 : Type u_1\nn : \u2115\ns t : Multiset \u03b1\nht : t.card \u2264 n\n_h : s < t\nthis : s.card < t.card\n\u22a2 n - t.card < n - s.card",["omega"]],["Algebra/QuadraticDiscriminant.lean",138,"case inr.inl.inr\nK : Type u_1\ninst\u271d : LinearOrderedField K\nb c : K\nh : \u2200 (x : K), 0 \u2264 0 * (x * x) + b * x + c\nhb : b \u2260 0\nthis : 0 \u2264 0 * ((-c - 1) / b * ((-c - 1) / b)) + (-c - 1) + c\n\u22a2 b * b - 4 * 0 * c \u2264 0",["linarith"]],["Algebra/QuadraticDiscriminant.lean",158,"K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * (x * x) + b * x + c\nthis\u271d\u00b9 : \u2200 (x : K), 0 \u2264 a * (x * x) + b * x + c\nh' : discrim a b c = 0\nthis\u271d : 0 < a * (-b / (2 * a) * (-b / (2 * a))) + b * (-b / (2 * a)) + c\nthis : a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c = 0\n\u22a2 False",["linarith"]],["Analysis/Normed/Group/ControlledClosure.lean",83,"G : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup G\ninst\u271d\u00b9 : CompleteSpace G\nH : Type u_2\ninst\u271d : NormedAddCommGroup H\nf : NormedAddGroupHom G H\nK : AddSubgroup H\nC \u03b5 : \u211d\nhC : 0 < C\nh\u03b5 : 0 < \u03b5\nhyp : f.SurjectiveOnWith K C\nh : H\nh_in : h \u2208 K.topologicalClosure\nhyp_h : \u00ach = 0\nb : \u2115 \u2192 \u211d := fun i \u21a6 (1 / 2) ^ i * (\u03b5 * \u2016h\u2016 / 2) / C\nb_pos : \u2200 (i : \u2115), 0 < b i\nv : \u2115 \u2192 H\nlim_v : Tendsto (fun n \u21a6 \u2211 k \u2208 range (n + 1), v k) atTop (\ud835\udcdd h)\nv_in : \u2200 (n : \u2115), v n \u2208 K\nhv\u2080 : \u2016v 0 - h\u2016 < b 0\nhv : \u2200 n > 0, \u2016v n\u2016 < b n\nu : \u2115 \u2192 G\nhu : \u2200 (n : \u2115), f (u n) = v n\nhnorm_u : \u2200 (n : \u2115), \u2016u n\u2016 \u2264 C * \u2016v n\u2016\ns : \u2115 \u2192 G := fun n \u21a6 \u2211 k \u2208 range (n + 1), u k\nthis : CauchySeq s\ng : G\nhg : Tendsto s atTop (\ud835\udcdd g)\nn : \u2115\n\u22a2 \u2016h\u2016 + \u2016v 0 - h\u2016 \u2264 \u2016h\u2016 + b 0",["gcongr","linarith"]],["NumberTheory/Transcendental/Liouville/Measure.lean",97,"r : \u211d\nhr : 2 < r\nB : \u2124 \u2192 \u2115 \u2192 Set \u211d := fun a b \u21a6 ball (\u2191a / \u2191b) (1 / \u2191b ^ r)\nhB : \u2200 (a : \u2124) (b : \u2115), volume (B a b) = \u2191(2 / \u2191b ^ r)\nb : \u2115\n\u22a2 1 - r \u2260 0",["linarith"]],["Algebra/Lie/EngelSubalgebra.lean",58,"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nx y z : L\nm : \u2115\nhm : ((ad R L) x ^ m) y = 0\nn : \u2115\nhn : ((ad R L) x ^ n) z = 0\nij : \u2115 \u00d7 \u2115\nhij : ij.1 + ij.2 = m + n\n\u22a2 m \u2264 ij.1 \u2228 n \u2264 ij.2",["omega"]],["CategoryTheory/Functor/OfSequence.lean",48,"C : Type u_1\ninst\u271d : Category.{?u.784, u_1} C\nX : \u2115 \u2192 C\nf\u271d : (n : \u2115) \u2192 X n \u27f6 X (n + 1)\nx\u271d\u00b9 : \u2115 \u2192 C\nf : (n : \u2115) \u2192 x\u271d\u00b9 n \u27f6 x\u271d\u00b9 (n + 1)\nk l : \u2115\nx\u271d : k + 1 \u2264 l + 1\n\u22a2 k \u2264 l",["omega"]],["CategoryTheory/Functor/OfSequence.lean",81,"C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nj : \u2115\nhj :\n  \u2200 {X : \u2115 \u2192 C} (f : (n : \u2115) \u2192 X n \u27f6 X (n + 1)) (k : \u2115) (hij : 0 \u2264 j) (hjk : j \u2264 k),\n    map f 0 k \u22ef = map f 0 j hij \u226b map f j k hjk\nX : \u2115 \u2192 C\nf : (n : \u2115) \u2192 X n \u27f6 X (n + 1)\nhij : 0 \u2264 j + 1\nhjk : j + 1 \u2264 0 + 1\n\u22a2 j = 0",["omega","aesop"]],["CategoryTheory/Functor/OfSequence.lean",93,"C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\ni : \u2115\nhi :\n  \u2200 {X : \u2115 \u2192 C} (f : (n : \u2115) \u2192 X n \u27f6 X (n + 1)) (j k : \u2115) (hij : i \u2264 j) (hjk : j \u2264 k),\n    map f i k \u22ef = map f i j hij \u226b map f j k hjk\nX : \u2115 \u2192 C\nf : (n : \u2115) \u2192 X n \u27f6 X (n + 1)\nj k : \u2115\nhij\u271d : i + 1 \u2264 j + 1\nhjk\u271d : j + 1 \u2264 k + 1\n\u22a2 j \u2264 k",["omega"]],["CategoryTheory/Functor/OfSequence.lean",142,"C : Type u_1\ninst\u271d : Category.{?u.15919, u_1} C\nF G : \u2115 \u2964 C\napp : (n : \u2115) \u2192 F.obj n \u27f6 G.obj n\nnaturality : \u2200 (n : \u2115), F.map (homOfLE \u22ef) \u226b app (n + 1) = app n \u226b G.map (homOfLE \u22ef)\nk : \u2115\nhk : \u2200 \u2983i j : \u2115\u2984 (hk : j = i + k), F.map (homOfLE \u22ef) \u226b app j = app i \u226b G.map (homOfLE \u22ef)\ni j : \u2115\nhk' : j = i + (k + 1)\n\u22a2 j = i + k + 1",["omega"]],["AlgebraicTopology/DoldKan/Degeneracies.lean",48,"case H\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nY : C\nX : SimplicialObject C\nn b q : \u2115\n\u03c6 : Y \u27f6 X _\u298bn + 1\u298c\nv : HigherFacesVanish q \u03c6\nhnbq : n + 1 = b + q\nj : Fin (n + 1 + 1)\nhj : n + 1 + 1 \u2264 \u2191j + q\n\u22a2 \u2191\u27e8b + 1, \u22ef\u27e9 < \u2191j + 1",["linarith"]],["AlgebraicTopology/DoldKan/Degeneracies.lean",58,"case zero\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nn : \u2115\ni : Fin (n + 1)\nhi : n + 1 \u2264 \u2191i\n\u22a2 X.\u03c3 i \u226b (P 0).f (n + 1) = 0",["omega"]],["AlgebraicTopology/DoldKan/Degeneracies.lean",116,"case neg.succ.intro.H\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq n : \u2115\nhq : \u2200 (i : Fin (n + 1 + 1)), n + 1 + 1 \u2264 \u2191i + q \u2192 X.\u03c3 i \u226b (P q).f (n + 1 + 1) = 0\ni : Fin (n + 1 + 1)\nh : \u00acn + 1 + 1 \u2264 \u2191i + q\nhi : n + 1 = \u2191i + q\nv : HigherFacesVanish q ((P q).f n.succ \u226b X.\u03c3 i)\nj : Fin (n + 1)\nhj : True \u2227 \u2191j < q\nk : \u2115\nhk : k + \u2191j = n\nhi' : i = \u27e8\u2191i, \u22ef\u27e9.castSucc\neq : X.\u03c3 j.rev.succ \u226b (P q).f (n + 1 + 1) = 0\n\u22a2 \u2191i \u2264 k",["omega"]],["Analysis/InnerProductSpace/NormPow.lean",81,"E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : F \u2192 E\nhf : Differentiable \u211d f\nx : F\np : \u211d\nhp : 1 < p\n\u22a2 0 \u2264 \u2016f x\u2016 ^ (p - 2)",["positivity"]],["Analysis/SpecialFunctions/Log/PosLog.lean",87,"case neg.h\nx : \u211d\nhx : x \u2208 Set.Ici 0\ny : \u211d\nhy : y \u2208 Set.Ici 0\nhxy : x \u2264 y\nh : \u00aclog x \u2264 0\nthis : log x \u2264 log y\n\u22a2 0 \u2264 log y",["linarith"]],["Analysis/SpecialFunctions/Log/PosLog.lean",148,"\u03b1 : Type u_1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u211d\nhs : \u00acs = \u2205\nt_max : \u03b1\nht_max : t_max \u2208 s \u2227 \u2200 x' \u2208 s, |f x'| \u2264 |f t_max|\n\u22a2 0 \u2264 \u2191s.card * |f t_max|",["positivity"]],["Topology/IndicatorConstPointwise.lean",115,"\u03b1 : Type u_1\nA : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : TopologicalSpace \u03b2\n\u03b9 : Type u_3\nL : Filter \u03b9\nAs : \u03b9 \u2192 Set \u03b1\nb : \u03b2\nnhd_b : {0}\u1d9c \u2208 \ud835\udcdd b\nnhd_o : {b}\u1d9c \u2208 \ud835\udcdd 0\n\u22a2 (\u2200 (x : \u03b1), \u2200\u1da0 (i : \u03b9) in L, x \u2208 As i \u2194 x \u2208 A) \u2194 \u2200 (i : \u03b1), \u2200\u1da0 (x : \u03b9) in L, As x i = (i \u2208 A)",["aesop","omega","infer_instance"]],["Probability/Distributions/Pareto.lean",75,"t r x : \u211d\nht : 0 < t\nhr : 0 < r\nhx : t \u2264 x\n\u22a2 0 < x",["linarith"]],["Probability/Distributions/Pareto.lean",108,"t r : \u211d\nht : 0 < t\nhr : 0 < r\nleftSide : \u222b\u207b (x : \u211d) in Iio t, paretoPDF t r x = 0\nrightSide : \u222b\u207b (x : \u211d) in Ici t, paretoPDF t r x = \u222b\u207b (x : \u211d) in Ici t, ENNReal.ofReal (r * t ^ r * x ^ (-(r + 1)))\n\u22a2 -(r + 1) < -1",["linarith","aesop"]],["Probability/Distributions/Pareto.lean",76,"t r x : \u211d\nht : 0 < t\nhr : 0 < r\nhx : t \u2264 x\nx\u271d : 0 < x\n\u22a2 0 < r * t ^ r * x ^ (-(r + 1))",["positivity"]],["Probability/Distributions/Pareto.lean",86,"case pos.inl\nt r : \u211d\nht : 0 \u2264 t\nhr : 0 \u2264 r\nx : \u211d\nh : 0 \u2264 x\nht0 : 0 = t\n\u22a2 0 \u2264 r * t ^ r * x ^ (-(r + 1))",["positivity"]],["Probability/Distributions/Pareto.lean",89,"case pos.inr\nt r : \u211d\nht : 0 \u2264 t\nhr : 0 \u2264 r\nx : \u211d\nh : t \u2264 x\nhtp : 0 < t\nthis : 0 < x\n\u22a2 0 \u2264 r * t ^ r * x ^ (-(r + 1))",["positivity"]],["Probability/Distributions/Pareto.lean",112,"case hf\nt r : \u211d\nht : 0 < t\nhr : 0 < r\nleftSide : \u222b\u207b (x : \u211d) in Iio t, paretoPDF t r x = 0\nrightSide : \u222b\u207b (x : \u211d) in Ici t, paretoPDF t r x = \u222b\u207b (x : \u211d) in Ici t, ENNReal.ofReal (r * t ^ r * x ^ (-(r + 1)))\nx : \u211d\nhx : t \u2264 x\nthis : 0 < x\n\u22a2 0 x \u2264 r * t ^ r * x ^ (-(r + 1))",["positivity"]],["Analysis/Convex/Uniform.lean",98,"E : Type u_1\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : UniformConvexSpace E\n\u03b5 : \u211d\ninst\u271d : NormedSpace \u211d E\nh\u03b5 : 0 < \u03b5\nh\u03b5' : 0 < \u03b5 / 3\n\u03b4 : \u211d\nh\u03b4 : 0 < \u03b4\nh : \u2200 \u2983x : E\u2984, \u2016x\u2016 = 1 \u2192 \u2200 \u2983y : E\u2984, \u2016y\u2016 = 1 \u2192 \u03b5 / 3 \u2264 \u2016x - y\u2016 \u2192 \u2016x + y\u2016 \u2264 2 - \u03b4\n\u03b4' : \u211d := 1 / 2 \u2293 (\u03b5 / 3 \u2293 \u03b4 / 3)\nx : E\nhx : \u2016x\u2016 \u2264 1\ny : E\nhy : \u2016y\u2016 \u2264 1\nhxy : \u03b5 \u2264 \u2016x - y\u2016\nhx' : 1 - \u03b4' < \u2016x\u2016\nhy' : 1 - \u03b4' < \u2016y\u2016\nh\u03b4' : 0 < 1 - \u03b4'\nh\u2081 : \u2200 (z : E), 1 - \u03b4' < \u2016z\u2016 \u2192 \u2016\u2016z\u2016\u207b\u00b9 \u2022 z\u2016 = 1\nh\u2082 : \u2200 (z : E), \u2016z\u2016 \u2264 1 \u2192 1 - \u03b4' \u2264 \u2016z\u2016 \u2192 \u2016\u2016z\u2016\u207b\u00b9 \u2022 z - z\u2016 \u2264 \u03b4'\nx' : E := \u2016x\u2016\u207b\u00b9 \u2022 x\ny' : E := \u2016y\u2016\u207b\u00b9 \u2022 y\nhxy' : \u03b5 / 3 \u2264 \u2016x' - y'\u2016\nthis : \u03b4' \u2264 \u03b4 / 3\n\u22a2 2 - \u03b4 + \u03b4' + \u03b4' \u2264 2 - \u03b4'",["linarith"]],["Algebra/GCDMonoid/Nat.lean",86,"case neg\nz : \u2124\nhz : -z = z\nh : \u00ac0 \u2264 z\n\u22a2 0 \u2264 z",["omega"]],["Data/Nat/Choose/Central.lean",86,"n : \u2115\nIH : \u2200 m < n + 1, 4 \u2264 m \u2192 4 ^ m < m * m.centralBinom\nn_big : 4 \u2264 n + 1\nhn : 4 < n + 1\n\u22a2 4 * n * n.centralBinom \u2264 2 * (2 * n + 1) * n.centralBinom",["linarith"]],["AlgebraicTopology/DoldKan/Decomposition.lean",78,"case pos.intro.e_a.e_s.h.mk\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nn q : \u2115\nhq : (Q q).f (n + 1) = \u2211 i \u2208 Finset.filter (fun i \u21a6 \u2191i < q) Finset.univ, (P \u2191i).f (n + 1) \u226b X.\u03b4 i.rev.succ \u226b X.\u03c3 i.rev\nhqn : q + 1 \u2264 n + 1\na : \u2115\nha : q + a = n\nq' : Fin (n + 1) := \u27e8q, \u22ef\u27e9\ni : \u2115\nhi : i < n + 1\n\u22a2 \u00aci = q \u2227 (i < q \u2228 i = q) \u2194 i < q",["aesop","omega"]],["AlgebraicTopology/DoldKan/Decomposition.lean",62,"case neg.e_s.h.mk\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nn q : \u2115\nhq : (Q q).f (n + 1) = \u2211 i \u2208 Finset.filter (fun i \u21a6 \u2191i < q) Finset.univ, (P \u2191i).f (n + 1) \u226b X.\u03b4 i.rev.succ \u226b X.\u03c3 i.rev\nhqn : \u00acq + 1 \u2264 n + 1\nx : \u2115\nhx : x < n + 1\n\u22a2 x < q \u2194 x < q + 1",["omega"]],["AlgebraicTopology/DoldKan/Decomposition.lean",70,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nn q : \u2115\nhq : (Q q).f (n + 1) = \u2211 i \u2208 Finset.filter (fun i \u21a6 \u2191i < q) Finset.univ, (P \u2191i).f (n + 1) \u226b X.\u03b4 i.rev.succ \u226b X.\u03c3 i.rev\nhqn : q + 1 \u2264 n + 1\na : \u2115\nha : q + a = n\nq' : Fin (n + 1) := \u27e8q, \u22ef\u27e9\n\u22a2 n = a + q",["omega"]],["Algebra/Order/Group/Unbundled/Int.lean",80,"a : \u2124\nn : \u2115\n\u22a2 n = 0 \u2194 -\u2191n - 1 = 1 \u2228 -\u2191n - 1 = -1",["omega"]],["Algebra/Order/Group/Unbundled/Int.lean",89,"m x : \u2124\nh1 : m \u2223 x\nh2 : \u2191x.natAbs < m\nh : \u00acx = 0\nthis : m.natAbs \u2264 x.natAbs\n\u22a2 False",["omega"]],["Algebra/Order/Group/Unbundled/Int.lean",92,"m a b : \u2115\nha : a < m\nhb : b < m\n\u22a2 -\u2191m < \u2191b - \u2191a \u2227 \u2191b - \u2191a < \u2191m",["omega"]],["Analysis/SpecialFunctions/Gamma/Deriv.lean",63,"case zero\ns : \u2102\nh1 : 1 - s.re < 0\nh2 : \u2200 (m : \u2115), s \u2260 -\u2191m\n\u22a2 0 < s.re",["linarith"]],["Analysis/SpecialFunctions/Gamma/Deriv.lean",67,"n : \u2115\ns : \u2102\nh1 : 1 - s.re < \u2191n + 1\nh2 : \u2200 (m : \u2115), s \u2260 -\u2191m\nhn : 1 - (s + 1).re < \u2191n \u2192 (\u2200 (m : \u2115), s + 1 \u2260 -\u2191m) \u2192 DifferentiableAt \u2102 (GammaAux n) (s + 1)\n\u22a2 1 - (s.re + 1) < \u2191n",["linarith"]],["Analysis/SpecialFunctions/Gamma/Deriv.lean",92,"case h1\ns : \u2102\nhs : \u2200 (m : \u2115), s \u2260 -\u2191m\nn : \u2115 := \u230a1 - s.re\u230b\u208a + 1\nhn : 1 - s.re < \u2191n\nS : Set \u2102 := {t | 1 - t.re < \u2191n}\nthis : S \u2208 \ud835\udcdd s\nt : \u2102\nht : 1 - t.re < \u2191n\n\u22a2 -t.re < \u2191n",["linarith"]],["Analysis/Convex/StoneSeparation.lean",42,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np q x y : E\naz bz : \ud835\udd5c\nhaz : 0 \u2264 az\nhbz : 0 \u2264 bz\nhabz : az + bz = 1\nhaz' : 0 < az\nav bv : \ud835\udd5c\nhav : 0 \u2264 av\nhbv : 0 \u2264 bv\nhabv : av + bv = 1\nhav' : 0 < av\nau bu : \ud835\udd5c\nhau : 0 \u2264 au\nhbu : 0 \u2264 bu\nhabu : au + bu = 1\n\u22a2 0 < az * av + bz * au",["positivity"]],["Analysis/Convex/StoneSeparation.lean",47,"case intro.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.refine_3\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np q x y : E\naz bz : \ud835\udd5c\nhaz : 0 \u2264 az\nhbz : 0 \u2264 bz\nhabz : az + bz = 1\nhaz' : 0 < az\nav bv : \ud835\udd5c\nhav : 0 \u2264 av\nhbv : 0 \u2264 bv\nhabv : av + bv = 1\nhav' : 0 < av\nau bu : \ud835\udd5c\nhau : 0 \u2264 au\nhbu : 0 \u2264 bu\nhabu : au + bu = 1\nhab : 0 < az * av + bz * au\n\u22a2 az * av + bz * au \u2260 0",["positivity"]],["Tactic/Positivity/Finset.lean",95,"\u03b1 : Type u_1\ns : Finset \u03b1\nhs : s.Nonempty\n\u22a2 0 < #s",["positivity","aesop"]],["Tactic/Positivity/Finset.lean",101,"\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\nhs : s.Nonempty\n\u22a2 0 < s.dens",["positivity","aesop"]],["Tactic/Positivity/Finset.lean",102,"\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d : Fintype \u03b1\nhs : s.Nonempty\n\u22a2 s.dens \u2260 0",["positivity","aesop"]],["Tactic/Positivity/Finset.lean",103,"\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 0 < #univ",["positivity"]],["Tactic/Positivity/Finset.lean",104,"\u03b1 : Type u_1\ns : Finset \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Nonempty \u03b1\n\u22a2 0 < Fintype.card \u03b1",["positivity"]],["Algebra/ContinuedFractions/Computation/ApproximationCorollaries.lean",98,"K : Type u_1\nv : K\ninst\u271d\u00b2 : LinearOrderedField K\ninst\u271d\u00b9 : FloorRing K\ninst\u271d : Archimedean K\n\u03b5 : K\n\u03b5_pos : \u03b5 > 0\nN' : \u2115\none_div_\u03b5_lt_N' : 1 / \u03b5 < \u2191N'\nN : \u2115 := N' \u2294 5\nn : \u2115\nn_ge_N : n \u2265 N\ng : GenContFract K := of v\nnot_terminatedAt_n : \u00acg.TerminatedAt n\nB : K := g.dens n\nnB : K := g.dens (n + 1)\nabs_v_sub_conv_le : |v - g.convs n| \u2264 1 / (B * nB)\nnB_ineq : \u2191(fib (n + 2)) \u2264 nB\nB_ineq : \u2191(fib (n + 1)) \u2264 B\nzero_lt_B : 0 < B\nnB_pos : 0 < nB\n\u22a2 0 < B * nB",["positivity","aesop"]],["Logic/Godel/GodelBetaFunction.lean",83,"m\u271d m : \u2115\na : Fin m \u2192 \u2115\ni j : Fin m\nhij : i \u2260 j\nltij : i < j\nhja : \u2191j < Nat.supOfSeq a\n\u22a2 0 < \u2191j + 1 - (\u2191i + 1)",["omega"]],["Data/Int/Basic.lean",43,"C : \u2124 \u2192 Sort u_1\nz b : \u2124\nH0 : C b\nHs : (k : \u2124) \u2192 b \u2264 k \u2192 C k \u2192 C (k + 1)\nHp : (k : \u2124) \u2192 k \u2264 b \u2192 C k \u2192 C (k - 1)\nhz : b \u2264 z\nzb : \u2115\nhzb : \u2191zb = z - b\n\u22a2 b + \u2191zb = z",["omega"]],["Analysis/Normed/Group/Tannery.lean",61,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\n\ud835\udcd5 : Filter \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : CompleteSpace G\nf : \u03b1 \u2192 \u03b2 \u2192 G\ng : \u03b2 \u2192 G\nbound : \u03b2 \u2192 \u211d\nh_sum : Summable bound\nhab : \u2200 (k : \u03b2), Tendsto (fun x \u21a6 f x k) \ud835\udcd5 (\ud835\udcdd (g k))\nh_bound : \u2200\u1da0 (n : \u03b1) in \ud835\udcd5, \u2200 (k : \u03b2), \u2016f n k\u2016 \u2264 bound k\nh\u271d\u00b9 : Nonempty \u03b2\nh\u271d : \ud835\udcd5.NeBot\nh_g_le : \u2200 (k : \u03b2), \u2016g k\u2016 \u2264 bound k\nh_sumg : Summable fun x \u21a6 \u2016g x\u2016\nh_suma : \u2200\u1da0 (n : \u03b1) in \ud835\udcd5, Summable fun x \u21a6 \u2016f n x\u2016\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nS : \u211d\nhS : \u2200 \u03b5 > 0, \u2200\u1da0 (x : Finset \u03b2) in atTop, dist (\u2211 b \u2208 x, bound b) S < \u03b5\n\u22a2 \u03b5 / 3 > 0",["positivity","aesop","linarith"]],["Algebra/Order/Module/Algebra.lean",103,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : OrderedCommSemiring \u03b1\ninst\u271d\u00b2 : OrderedSemiring \u03b2\ninst\u271d\u00b9 : Algebra \u03b1 \u03b2\ninst\u271d : SMulPosMono \u03b1 \u03b2\na : \u03b1\nha : 0 \u2264 a\n\u22a2 0 \u2264 (algebraMap \u03b1 \u03b2) a",["positivity","infer_instance"]],["Algebra/Order/Module/Algebra.lean",106,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : OrderedCommSemiring \u03b1\ninst\u271d\u00b2 : OrderedSemiring \u03b2\ninst\u271d\u00b9 : Algebra \u03b1 \u03b2\ninst\u271d : SMulPosMono \u03b1 \u03b2\na : \u03b1\nha : 0 < a\n\u22a2 0 \u2264 (algebraMap \u03b1 \u03b2) a",["positivity"]],["Algebra/Order/Module/Algebra.lean",109,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : OrderedCommSemiring \u03b1\ninst\u271d\u00b2 : StrictOrderedSemiring \u03b2\ninst\u271d\u00b9 : Algebra \u03b1 \u03b2\ninst\u271d : SMulPosStrictMono \u03b1 \u03b2\na : \u03b1\nha : 0 < a\n\u22a2 0 < (algebraMap \u03b1 \u03b2) a",["positivity"]],["Analysis/Hofer.lean",84,"X : Type u_1\ninst\u271d\u00b9 : MetricSpace X\ninst\u271d : CompleteSpace X\nx : X\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\n\u03d5 : X \u2192 \u211d\ncont : Continuous \u03d5\nreformulation : \u2200 (x' : X) (k : \u2115), \u03b5 * \u03d5 x \u2264 \u03b5 / 2 ^ k * \u03d5 x' \u2194 2 ^ k * \u03d5 x \u2264 \u03d5 x'\nthis : Nonempty X\nF : \u2115 \u2192 X \u2192 X\nhF : \u2200 (k : \u2115) (x' : X), d x' x \u2264 2 * \u03b5 \u2227 2 ^ k * \u03d5 x \u2264 \u03d5 x' \u2192 d x' (F k x') \u2264 \u03b5 / 2 ^ k \u2227 2 * \u03d5 x' < \u03d5 (F k x')\nu : \u2115 \u2192 X := fun n \u21a6 Nat.recOn n x F\nhu :\n  \u2200 (n : \u2115), d (u n) x \u2264 2 * \u03b5 \u2227 2 ^ n * \u03d5 x \u2264 \u03d5 (u n) \u2192 d (u n) (u (n + 1)) \u2264 \u03b5 / 2 ^ n \u2227 2 * \u03d5 (u n) < \u03d5 (u (n + 1))\nkey : \u2200 (n : \u2115), d (u n) (u (n + 1)) \u2264 \u03b5 / 2 ^ n \u2227 2 * \u03d5 (u n) < \u03d5 (u (n + 1))\nkey\u2081 : \u2200 (x : \u2115), d (u x) (u (x + 1)) \u2264 \u03b5 / 2 ^ x\nkey\u2082 : \u2200 (x : \u2115), 2 * \u03d5 (u x) < \u03d5 (u (x + 1))\ncauchy_u : CauchySeq u\ny : X\nlimy : Tendsto u atTop (\ud835\udcdd y)\nv : \u2115 \u2192 \u211d := fun n \u21a6 (\u03d5 \u2218 u) (n + 1)\nnonneg : 0 \u2264 \u03d5 x\n\u22a2 0 \u2264 2 * \u03d5 (u 0)",["positivity","aesop"]],["Analysis/SpecialFunctions/Pow/Integral.lean",52,"\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\n\u03bc : Measure \u03b1\nf_nn : 0 \u2264\u1da0[ae \u03bc] f\nf_mble : AEMeasurable f \u03bc\np : \u211d\np_pos : 0 < p\n\u22a2 -1 < p - 1",["linarith","aesop"]],["Analysis/Normed/Affine/Convex.lean",83,"E\u271d : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b3 : NormedSpace \u211d E\u271d\ns\u271d : Set E\u271d\nx : E\u271d\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Set E\nhs : s \u2208 \ud835\udcdd 0\nb : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E\nc : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E := -Finset.centroid \u211d Finset.univ \u21d1b +\u1d65 b\nhc\u2080 : 0 \u2208 interior ((convexHull \u211d) (range \u21d1c))\ncnorm : \u211d := Finset.univ.sup' \u22ef fun i \u21a6 \u2016c i\u2016\nhcnorm : range \u21d1c \u2286 closedBall 0 (cnorm + 1)\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh\u03b5s : ball 0 \u03b5 \u2286 s\n\u03b5' : \u211d := \u03b5 / 2 / (cnorm + 1)\nhc' : 0 < cnorm + 1\nh\u03b5' : 0 < \u03b5'\nd : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E := Units.mk0 \u03b5' \u22ef \u2022 c\nh\u03b5\u2080 : 0 < \u03b5 / 2\nhdnorm : range \u21d1d \u2286 closedBall 0 (\u03b5 / 2)\n\u22a2 \u03b5 / 2 < \u03b5",["linarith","aesop"]],["Analysis/Normed/Affine/Convex.lean",69,"E\u271d : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b3 : NormedSpace \u211d E\u271d\ns\u271d : Set E\u271d\nx : E\u271d\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Set E\nhs : s \u2208 \ud835\udcdd 0\nb : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E\nc : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E := -Finset.centroid \u211d Finset.univ \u21d1b +\u1d65 b\nhc\u2080 : 0 \u2208 interior ((convexHull \u211d) (range \u21d1c))\ncnorm : \u211d := Finset.univ.sup' \u22ef fun i \u21a6 \u2016c i\u2016\nhcnorm : range \u21d1c \u2286 closedBall 0 (cnorm + 1)\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh\u03b5s : ball 0 \u03b5 \u2286 s\n\u03b5' : \u211d := \u03b5 / 2 / (cnorm + 1)\nthis : 0 \u2264 cnorm\n\u22a2 0 < cnorm + 1",["positivity","linarith"]],["Analysis/Normed/Affine/Convex.lean",70,"E\u271d : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b3 : NormedSpace \u211d E\u271d\ns\u271d : Set E\u271d\nx : E\u271d\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Set E\nhs : s \u2208 \ud835\udcdd 0\nb : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E\nc : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E := -Finset.centroid \u211d Finset.univ \u21d1b +\u1d65 b\nhc\u2080 : 0 \u2208 interior ((convexHull \u211d) (range \u21d1c))\ncnorm : \u211d := Finset.univ.sup' \u22ef fun i \u21a6 \u2016c i\u2016\nhcnorm : range \u21d1c \u2286 closedBall 0 (cnorm + 1)\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh\u03b5s : ball 0 \u03b5 \u2286 s\n\u03b5' : \u211d := \u03b5 / 2 / (cnorm + 1)\nhc' : 0 < cnorm + 1\n\u22a2 0 < \u03b5'",["positivity","aesop"]],["Analysis/Normed/Affine/Convex.lean",72,"E\u271d : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b3 : NormedSpace \u211d E\u271d\ns\u271d : Set E\u271d\nx : E\u271d\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\ns : Set E\nhs : s \u2208 \ud835\udcdd 0\nb : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E\nc : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E := -Finset.centroid \u211d Finset.univ \u21d1b +\u1d65 b\nhc\u2080 : 0 \u2208 interior ((convexHull \u211d) (range \u21d1c))\ncnorm : \u211d := Finset.univ.sup' \u22ef fun i \u21a6 \u2016c i\u2016\nhcnorm : range \u21d1c \u2286 closedBall 0 (cnorm + 1)\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh\u03b5s : ball 0 \u03b5 \u2286 s\n\u03b5' : \u211d := \u03b5 / 2 / (cnorm + 1)\nhc' : 0 < cnorm + 1\nh\u03b5' : 0 < \u03b5'\nd : AffineBasis (Fin (finrank \u211d E + 1)) \u211d E := Units.mk0 \u03b5' \u22ef \u2022 c\n\u22a2 0 < \u03b5 / 2",["positivity","aesop","linarith"]],["Algebra/Group/Nat/Even.lean",93,"case intro.intro\nn m : \u2115\nhnm : n + n < m + m\n\u22a2 n + n + 1 < m + m",["omega","infer_instance"]],["Algebra/Vertex/VertexOperator.lean",74,"R : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module R V\nA : VertexOperator R V\nn : \u2124\nx : V\nh : n < ((HahnModule.of R).symm (A x)).order\n\u22a2 -(-n - 1) - 1 < ((HahnModule.of R).symm (A x)).order",["omega","aesop"]],["NumberTheory/Zsqrtd/QuadraticReciprocity.lean",38,"p : \u2115\nhp : Fact (Nat.Prime p)\nhpi : Prime \u2191p\nhp1 : p % 2 = 1\nhp3 : p % 4 \u2260 3\n\u22a2 p % 4 = 1",["omega"]],["AlgebraicTopology/Quasicategory/StrictSegal.lean",37,"X : SSet\ninst\u271d : X.StrictSegal\nn : \u2115\ni : Fin (n + 3)\n\u03c3\u2080 : Subpresheaf.toPresheaf \u039b[n + 2, i] \u27f6 X\nh\u2080 : 0 < i\nh\u2099 : i < Fin.last (n + 2)\nj : Fin (n + 3)\nhj : j \u2260 i\nk : Fin (n + 1)\nksucc : Fin (n + 1 + 1 + 1) := k.succ.castSucc\n\u22a2 ksucc < j \u2228 j < ksucc \u2228 j = ksucc",["omega"]],["AlgebraicTopology/Quasicategory/StrictSegal.lean",58,"X : SSet\ninst\u271d : X.StrictSegal\ni : Fin (0 + 3)\n\u03c3\u2080 : Subpresheaf.toPresheaf \u039b[0 + 2, i] \u27f6 X\nh\u2080 : 0 < i\nh\u2099 : i < Fin.last (0 + 2)\nj : Fin (0 + 3)\nhj : j \u2260 i\nk : Fin (0 + 1)\nksucc : Fin (0 + 1 + 1 + 1) := k.succ.castSucc\nheq : j = ksucc\n\u22a2 k = 0",["omega"]],["AlgebraicTopology/Quasicategory/StrictSegal.lean",64,"X : SSet\ninst\u271d : X.StrictSegal\nn : \u2115\ni : Fin (n + 1 + 3)\n\u03c3\u2080 : Subpresheaf.toPresheaf \u039b[n + 1 + 2, i] \u27f6 X\nh\u2080 : 0 < i\nh\u2099 : i < Fin.last (n + 1 + 2)\nj : Fin (n + 1 + 3)\nhj : j \u2260 i\nk : Fin (n + 1 + 1)\nksucc : Fin (n + 1 + 1 + 1 + 1) := k.succ.castSucc\nheq : j = ksucc\n\u22a2 \u2191k < n + 2",["omega"]],["Analysis/Complex/Positivity.lean",38,"f : \u2102 \u2192 \u2102\nc : \u2102\nr : \u211d\nhf : DifferentiableOn \u2102 f (Metric.ball c r)\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz\u2082 : z \u2208 Metric.ball c r\nH : \u2211' (n : \u2115), (\u2191n.factorial)\u207b\u00b9 * iteratedDeriv n f c * \u2191(z - c).re ^ n = f z\nhz' : z - c = \u2191(z - c).re\nn : \u2115\nhz\u2081 : 0 \u2264 (z - c).re\nthis : 0 \u2264 (iteratedDeriv n f c).re\n\u22a2 0 \u2264 (\u2191n.factorial)\u207b\u00b9 * (iteratedDeriv n f c).re * (z - c).re ^ n",["positivity"]],["Algebra/Ring/Rat.lean",60,"\u22a2 CommSemiring \u211a",["infer_instance","omega"]],["Data/List/Triplewise.lean",97,"case cons\n\u03b1 : Type u_1\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u03b1\nt : List \u03b1\nih :\n  Triplewise p (t ++ l\u2082) \u2194\n    Triplewise p t \u2227\n      Triplewise p l\u2082 \u2227 (\u2200 (a : \u03b1), a \u2208 t \u2192 Pairwise (p a) l\u2082) \u2227 \u2200 (a : \u03b1), a \u2208 l\u2082 \u2192 Pairwise (fun x y \u21a6 p x y a) t\n\u22a2 ((Pairwise (p h) t \u2227 Pairwise (p h) l\u2082 \u2227 \u2200 (a : \u03b1), a \u2208 t \u2192 \u2200 (b : \u03b1), b \u2208 l\u2082 \u2192 p h a b) \u2227\n      Triplewise p t \u2227\n        Triplewise p l\u2082 \u2227 (\u2200 (a : \u03b1), a \u2208 t \u2192 Pairwise (p a) l\u2082) \u2227 \u2200 (a : \u03b1), a \u2208 l\u2082 \u2192 Pairwise (fun x y \u21a6 p x y a) t) \u2194\n    (Pairwise (p h) t \u2227 Triplewise p t) \u2227\n      Triplewise p l\u2082 \u2227\n        (Pairwise (p h) l\u2082 \u2227 \u2200 (a : \u03b1), a \u2208 t \u2192 Pairwise (p a) l\u2082) \u2227\n          \u2200 (a : \u03b1), a \u2208 l\u2082 \u2192 (\u2200 (a' : \u03b1), a' \u2208 t \u2192 p h a' a) \u2227 Pairwise (fun x y \u21a6 p x y a) t",["aesop","omega"]],["Data/List/Triplewise.lean",83,"\u03b1 : Type u_1\nl : List \u03b1\np : \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop\nhead : \u03b1\ntail : List \u03b1\nih : Triplewise p tail \u2194 \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length), p tail[i] tail[j] tail[k]\nx\u271d :\n  (\u2200 (i j : Nat) (_hi : i < tail.length) (_hj : j < tail.length), i < j \u2192 p head tail[i] tail[j]) \u2227\n    \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length), p tail[i] tail[j] tail[k]\nhh : \u2200 (i j : Nat) (_hi : i < tail.length) (_hj : j < tail.length), i < j \u2192 p head tail[i] tail[j]\nht : \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length), p tail[i] tail[j] tail[k]\nj : Nat\nhij : 0 < j + 1\nk : Nat\nhk : k + 1 < tail.length + 1\nhjk : j + 1 < k + 1\n\u22a2 j < k",["omega","aesop"]],["Data/List/Triplewise.lean",87,"\u03b1 : Type u_1\nl : List \u03b1\np : \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop\nhead : \u03b1\ntail : List \u03b1\nih : Triplewise p tail \u2194 \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length), p tail[i] tail[j] tail[k]\nx\u271d :\n  (\u2200 (i j : Nat) (_hi : i < tail.length) (_hj : j < tail.length), i < j \u2192 p head tail[i] tail[j]) \u2227\n    \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length), p tail[i] tail[j] tail[k]\nhh : \u2200 (i j : Nat) (_hi : i < tail.length) (_hj : j < tail.length), i < j \u2192 p head tail[i] tail[j]\nht : \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length), p tail[i] tail[j] tail[k]\ni j : Nat\nhij : i + 1 < j + 1\nk : Nat\nhk : k + 1 < tail.length + 1\nhjk : j + 1 < k + 1\n\u22a2 k < tail.length",["omega"]],["Data/List/Triplewise.lean",88,"\u03b1 : Type u_1\nl : List \u03b1\np : \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop\nhead : \u03b1\ntail : List \u03b1\nih : Triplewise p tail \u2194 \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length), p tail[i] tail[j] tail[k]\nh :\n  \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length + 1),\n    p (head :: tail)[i] (head :: tail)[j] (head :: tail)[k]\ni j : Nat\nhi : i < tail.length\nhj : j < tail.length\nhij : i < j\n\u22a2 j + 1 < tail.length + 1",["omega"]],["Data/List/Triplewise.lean",89,"\u03b1 : Type u_1\nl : List \u03b1\np : \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop\nhead : \u03b1\ntail : List \u03b1\nih : Triplewise p tail \u2194 \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length), p tail[i] tail[j] tail[k]\nh :\n  \u2200 (i j k : Nat) (hij : i < j) (hjk : j < k) (hk : k < tail.length + 1),\n    p (head :: tail)[i] (head :: tail)[j] (head :: tail)[k]\ni j k : Nat\nhij : i < j\nhjk : j < k\nhk : k < tail.length\n\u22a2 k + 1 < tail.length + 1",["omega"]],["Algebra/Group/Int/Units.lean",84,"a b c d : \u2124\nha : a = 1 \u2228 a = -1\nhb : b = 1 \u2228 b = -1\nhc : c = 1 \u2228 c = -1\nhd : d = 1 \u2228 d = -1\n\u22a2 a + b = c + d \u2194 a = c \u2227 b = d \u2228 a = d \u2227 b = c",["aesop","omega"]],["AlgebraicTopology/SimplexCategory/MorphismProperty.lean",41,"d : \u2115\nW : MorphismProperty (Truncated d)\ninst\u271d : W.IsMultiplicative\n\u03b4_mem : \u2200 (n : \u2115) (hn : n < d) (i : Fin (n + 2)), W (\u03b4 i)\n\u03c3_mem : \u2200 (n : \u2115) (hn : n < d) (i : Fin (n + 1)), W (\u03c3 i)\na : \u2115\nha : a \u2264 d\nb : \u2115\nhb : b \u2264 d\nf : { obj := mk a, property := ha } \u27f6 { obj := mk b, property := hb }\nh : a + b = 0\n\u22a2 a = 0",["omega","aesop","linarith"]],["AlgebraicTopology/SimplexCategory/MorphismProperty.lean",42,"d : \u2115\nW : MorphismProperty (Truncated d)\ninst\u271d : W.IsMultiplicative\n\u03b4_mem : \u2200 (n : \u2115) (hn : n < d) (i : Fin (n + 2)), W (\u03b4 i)\n\u03c3_mem : \u2200 (n : \u2115) (hn : n < d) (i : Fin (n + 1)), W (\u03c3 i)\nb : \u2115\nhb : b \u2264 d\nha : 0 \u2264 d\nf : { obj := mk 0, property := ha } \u27f6 { obj := mk b, property := hb }\nh : 0 + b = 0\n\u22a2 b = 0",["omega"]],["NumberTheory/Transcendental/Liouville/Residual.lean",60,"case refine_2.intro.refine_1\nr : \u211a\nn : \u2115\nthis : 0 < r.den\n\u22a2 1 < \u2191r.den * 2",["omega","linarith"]],["Probability/Distributions/Geometric.lean",51,"p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_lt_one : p < 1\nthis : 0 < 1 - p\n\u22a2 0 < (1 - p) ^ n * p",["positivity","aesop"]],["Probability/Distributions/Geometric.lean",57,"p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_le_one : p \u2264 1\nthis : 0 \u2264 1 - p\n\u22a2 0 \u2264 (1 - p) ^ n * p",["positivity","aesop"]],["Probability/Distributions/Poisson.lean",50,"r : \u211d\u22650\nn : \u2115\nhr : 0 < r\n\u22a2 0 < rexp (-\u2191r) * \u2191r ^ n / \u2191n !",["positivity"]],["Probability/Distributions/Poisson.lean",54,"r : \u211d\u22650\nn : \u2115\n\u22a2 0 \u2264 rexp (-\u2191r) * \u2191r ^ n / \u2191n !",["positivity"]],["Data/Nat/Factorial/DoubleFactorial.lean",92,"n : \u2115\n\u22a2 0 < n\u203c",["positivity"]],["Analysis/SpecialFunctions/Log/Monotone.lean",54,"a : \u211d\nha : 0 < a\nx : \u211d\nhex : rexp (1 / a) \u2264 x\ny : \u211d\nx\u271d : rexp (1 / a) \u2264 y\nhxy : x \u2264 y\nx_pos : 0 < x\n\u22a2 0 < y",["linarith"]],["Analysis/SpecialFunctions/Log/Monotone.lean",66,"case refine_1\na : \u211d\nha : 0 < a\nx : \u211d\nhex : rexp (1 / a) \u2264 x\ny : \u211d\nx\u271d : rexp (1 / a) \u2264 y\nhxy : x \u2264 y\nx_pos : 0 < x\ny_pos : 0 < y\n\u22a2 0 \u2264 rexp (1 / a)",["positivity","omega","infer_instance"]],["Analysis/SpecialFunctions/Log/Monotone.lean",72,"case refine_2\na : \u211d\nha : 0 < a\nx : \u211d\nhex : rexp (1 / a) \u2264 x\ny : \u211d\nx\u271d : rexp (1 / a) \u2264 y\nhxy : x \u2264 y\nx_pos : 0 < x\ny_pos : 0 < y\n\u22a2 0 \u2264 rexp (1 / a)",["positivity"]],["RingTheory/RingHom/Integral.lean",59,"R S : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nf : R \u2192+* S\ns : Set R\nhs : Ideal.span s = \u22a4\nH : \u2200 (r : \u2191s), (fun {R S} [CommRing R] [CommRing S] x \u21a6 x.IsIntegral) (Localization.awayMap f \u2191r)\nr : S\nthis\u271d\u00b2 : Algebra R S := f.toAlgebra\nt : R\nht : t \u2208 s\nthis\u271d\u00b9 : Algebra (Localization.Away t) (Localization.Away (f t)) := (Localization.awayMap f t).toAlgebra\nthis\u271d : IsScalarTower R (Localization.Away t) (Localization.Away (f t))\nthis : _root_.IsIntegral (Localization.Away t) ((algebraMap S (Localization.Away (f t))) r)\nn : \u2115\np : R[X]\nhp : p.Monic\nm : \u2115\ne : \u2191\u27e8(algebraMap R S) t ^ m, \u22ef\u27e9 * eval\u2082 (algebraMap R S) ((algebraMap R S) \u2191\u27e8(fun x \u21a6 t ^ x) n, \u22ef\u27e9 * r) p = 0\nhp' : \u00ac1 \u2264 p.natDegree\n\u22a2 p.natDegree = 0",["omega","aesop","linarith"]],["Topology/Instances/Nat.lean",56,"x : \u2115\nr : \u211d\nhr : r < 0\n\u22a2 \u2191x + r \u2264 \u2191x",["linarith"]],["Topology/Instances/Nat.lean",59,"x : \u2115\nr : \u211d\nhr : r < 0\n\u22a2 \u2191x < \u2191x - r",["linarith"]],["Analysis/Complex/UpperHalfPlane/Exp.lean",36,"n : \u2115\ninst\u271d : NeZero n\n\u03c4 : \u210d\n\u22a2 0 < 2 * \u03c0 * \u03c4.im",["positivity"]],["NumberTheory/Harmonic/Int.lean",22,"n : \u2115\nHn : (Finset.range n).Nonempty\n\u22a2 0 < \u2211 i \u2208 Finset.range n, (\u2191(i + 1))\u207b\u00b9",["positivity"]],["MeasureTheory/Covering/OneDim.lean",26,"x y : \u211d\nhxy : x < y\n\u22a2 0 < (y - x) / 2",["linarith","aesop"]],["MeasureTheory/Covering/OneDim.lean",41,"x y : \u211d\nhxy : x < y\n\u22a2 0 < (y - x) / 2",["linarith","aesop"]],["Data/Nat/Factorial/BigOperators.lean",28,"\u03b1 : Type u_1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u2115\n\u22a2 0 < \u220f i \u2208 s, (f i)!",["positivity"]],["Analysis/CStarAlgebra/SpecialFunctions/PosPart.lean",33,"case inr.ha\nA : Type u_1\ninst\u271d\u00b2 : NonUnitalCStarAlgebra A\ninst\u271d\u00b9 : PartialOrder A\ninst\u271d : StarOrderedRing A\nr : \u211d\nhr : 0 < r\nx : A\nhx : x \u2208 {a | 0 \u2264 a}\nhx_pos : 0 < \u2016x\u2016\n\u22a2 \u00acr * \u2016x\u2016\u207b\u00b9 = 0",["positivity","aesop"]]]},{"tactics":["infer_instance","fun_prop","gcongr"],"cost":25,"goals":[["MeasureTheory/Integral/Lebesgue.lean",477,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u222b\u207b (x : \u03b1), f x \u2202\u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03b5\u2082 : \u211d\u22650\u221e\nh\u03b5\u20820 : 0 < \u03b5\u2082\nh\u03b5\u2082\u03b5 : \u03b5\u2082 < \u03b5\n\u03b5\u2081 : \u211d\u22650\u221e\nh\u03b5\u20810 : 0 < \u03b5\u2081\nh\u03b5\u2081\u2082 : \u03b5\u2081 < \u03b5\u2082\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nleft\u271d : \u2200 (x : \u03b1), \u2191(\u03c6 x) \u2264 f x\nh\u03c6 : \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u03c8 x) \u2264 f x) \u2192 (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)).lintegral \u03bc < \u03b5\u2081\nC : \u211d\u22650\nhC : \u2200 (x : \u03b1), \u03c6 x \u2264 C\ns : Set \u03b1\nhs : \u03bc s < (\u03b5\u2082 - \u03b5\u2081) / \u2191C\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u03c8 x) \u2264 f x\n\u22a2 \u2191C * \u03bc s + \u03b5\u2081 \u2264 \u2191C * ((\u03b5\u2082 - \u03b5\u2081) / \u2191C) + \u03b5\u2081",["gcongr"]],["SetTheory/Game/PGame.lean",1672,"xl xr : Type u\nn : \u2115\nthis : IsEmpty (\u2191n).RightMoves\n\u22a2 IsEmpty ((\u2191n).RightMoves \u2295 RightMoves 1)",["infer_instance"]],["MeasureTheory/Integral/SetToL1.lean",1427,"\u03b1 : Type u_1\nG : Type u_5\ninst\u271d : NormedAddCommGroup G\nm : MeasurableSpace \u03b1\n\u03bc \u03bc' : Measure \u03b1\nc' : \u211d\u22650\u221e\nhc' : c' \u2260 \u22a4\nh\u03bc'_le : \u03bc' \u2264 c' \u2022 \u03bc\nhc'0 : \u00acc' = 0\nf : \u21a5(Lp G 1 \u03bc)\n\u03b5 : \u211d\nh\u03b5_pos : \u03b5 > 0\ng : \u21a5(Lp G 1 \u03bc)\nhfg : (eLpNorm (\u2191\u2191g - \u2191\u2191f) 1 \u03bc).toReal < \u03b5 / 2 / c'.toReal\nh_int : \u2200 (f' : \u21a5(Lp G 1 \u03bc)), Integrable (\u2191\u2191f') \u03bc' :=\n  fun f' \u21a6 Integrable.of_measure_le_smul hc' h\u03bc'_le (L1.integrable_coeFn f')\nthis : eLpNorm (\u2191\u2191(Integrable.toL1 \u2191\u2191g \u22ef) - \u2191\u2191(Integrable.toL1 \u2191\u2191f \u22ef)) 1 \u03bc' = eLpNorm (\u2191\u2191g - \u2191\u2191f) 1 \u03bc'\nh_eLpNorm_ne_top : eLpNorm (\u2191\u2191g - \u2191\u2191f) 1 \u03bc \u2260 \u22a4\n\u22a2 c'.toReal * (eLpNorm (\u2191\u2191g - \u2191\u2191f) 1 \u03bc).toReal \u2264 c'.toReal * (\u03b5 / 2 / c'.toReal)",["gcongr"]],["Computability/AkraBazzi/AkraBazzi.lean",214,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nC c : \u211d\nhc_mem : c \u2208 Set.Ioo 0 1\nhc : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c * \u2191n \u2264 \u2191(r i n)\nn : \u2115\nhn\u2081 : \u2308C / c\u2309\u208a \u2264 n\nhn\u2082 : \u2200 (i : \u03b1), c * \u2191n \u2264 \u2191(r i n)\nh\u2081 : 0 < c\ni : \u03b1\n\u22a2 c * \u2191\u2308C / c\u2309\u208a \u2264 c * \u2191n",["gcongr","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1055,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 - \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nh_main_norm : (fun n \u21a6 \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n \u21a6 \u2016b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\u2016\nn : \u2115\nhn : \u2308(b i)\u207b\u00b9\u2309\u208a < n\nhn' : 1 < n\nh\u2081 : 0 < b i\n\u22a2 b i * \u2191\u2308(b i)\u207b\u00b9\u2309\u208a < b i * \u2191n",["gcongr","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1056,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 - \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nh_main_norm : (fun n \u21a6 \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n \u21a6 \u2016b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\u2016\nn : \u2115\nhn : \u2308(b i)\u207b\u00b9\u2309\u208a < n\nhn' : 1 < n\nh\u2081 : 0 < b i\nthis : b i < 1\n\u22a2 b i * \u2191n \u2264 1 * \u2191n",["gcongr"]],["Computability/AkraBazzi/AkraBazzi.lean",1151,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 + \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nh_main_norm : (fun n \u21a6 \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n \u21a6 \u2016b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\u2016\nn : \u2115\nhn : \u2308(b i)\u207b\u00b9\u2309\u208a < n\nhn' : 1 < n\nh\u2081 : 0 < b i\n\u22a2 b i * \u2191\u2308(b i)\u207b\u00b9\u2309\u208a < b i * \u2191n",["gcongr","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1152,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nq : \u211d \u2192 \u211d := fun x \u21a6 x ^ p a b * (1 + \u03b5 x)\nh_diff_q : DifferentiableOn \u211d q (Set.Ioi 1)\nh_deriv_q : deriv q =O[atTop] fun x \u21a6 x ^ (p a b - 1)\nh_main_norm : (fun n \u21a6 \u2016q \u2191(r i n) - q (b i * \u2191n)\u2016) \u2264\u1da0[atTop] fun n \u21a6 \u2016b i ^ p a b * \u2191n ^ p a b * (\u03b5 (b i * \u2191n) - \u03b5 \u2191n)\u2016\nn : \u2115\nhn : \u2308(b i)\u207b\u00b9\u2309\u208a < n\nhn' : 1 < n\nh\u2081 : 0 < b i\nthis : b i < 1\n\u22a2 b i * \u2191n \u2264 1 * \u2191n",["gcongr"]],["Computability/AkraBazzi/AkraBazzi.lean",1237,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), c\u2081 * g \u2191n \u2264 sumTransform (p a b) g (r i n) n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_smoothing_gt_half : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 1 / 2 < 1 - \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 - \u03b5 \u2191(r i y)\nbound1 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), \u2191(r i y) ^ p a b * (1 - \u03b5 \u2191(r i y)) \u2264 b i ^ p a b * \u2191y ^ p a b * (1 - \u03b5 \u2191y)\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 - \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), c\u2081 * g \u2191y \u2264 sumTransform (p a b) g (r i y) y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_max : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).sup' h_base_nonempty fun n \u21a6 T n / ((1 - \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := 2 * c\u2081\u207b\u00b9 \u2294 base_max\nhC : C = 2 * c\u2081\u207b\u00b9 \u2294 base_max\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, T n \u2264 C * ((1 - \u03b5 \u2191n) * asympBound g a b n)\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 - \u03b5 \u2191m \u2192 T m \u2264 C * ((1 - \u03b5 \u2191m) * asympBound g a b m)\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 - \u03b5 \u2191n\ni : \u03b1\n\u22a2 b' * \u2191n\u2080 \u2264 b' * \u2191n",["gcongr","aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",1386,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nc\u2081 : \u211d\nhc\u2081 : c\u2081 > 0\nh_sumTransform_aux : \u2200\u1da0 (n : \u2115) in atTop, \u2200 (i : \u03b1), sumTransform (p a b) g (r i n) n \u2264 c\u2081 * g \u2191n\nn\u2080 : \u2115\nn\u2080_ge_Rn\u2080 : R.n\u2080 \u2264 n\u2080\nh_b_floor : 0 < \u230ab' * \u2191n\u2080\u230b\u208a\nh_smoothing_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_smoothing_pos' : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_asympBound_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 0 < asympBound g a b y\nh_asympBound_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < asympBound g a b (r i y)\nh_asympBound_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < asympBound g a b y\nn\u2080_pos : 0 < n\u2080\nh_smoothing_r_pos : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), 0 < 1 + \u03b5 \u2191(r i y)\nbound2 : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b i ^ p a b * \u2191y ^ p a b * (1 + \u03b5 \u2191y) \u2264 \u2191(r i y) ^ p a b * (1 + \u03b5 \u2191(r i y))\nh_smoothingFn_floor : \u2200 (y : \u2115), \u230ab' * \u2191n\u2080\u230b\u208a \u2264 y \u2192 0 < 1 + \u03b5 \u2191y\nh_sumTransform : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), sumTransform (p a b) g (r i y) y \u2264 c\u2081 * g \u2191y\nh_bi_le_r : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2200 (i : \u03b1), b (min_bi b) / 2 * \u2191y \u2264 \u2191(r i y)\nh_exp : \u2200 (y : \u2115), n\u2080 \u2264 y \u2192 \u2308rexp 1\u2309\u208a \u2264 y\nh_base_nonempty : (Ico \u230ab (min_bi b) / 2 * \u2191n\u2080\u230b\u208a n\u2080).Nonempty\nbase_min : \u211d := (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nbase_min_def : base_min = (Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080).inf' h_base_nonempty fun n \u21a6 T n / ((1 + \u03b5 \u2191n) * asympBound g a b n)\nC : \u211d := (2 * c\u2081)\u207b\u00b9 \u2293 base_min\nhC_pos : 0 < C\nh_base : \u2200 n \u2208 Ico \u230ab' * \u2191n\u2080\u230b\u208a n\u2080, C * ((1 + \u03b5 \u2191n) * asympBound g a b n) \u2264 T n\nn : \u2115\nh_ind : \u2200 m < n, m \u2265 n\u2080 \u2192 0 < asympBound g a b m \u2192 0 < 1 + \u03b5 \u2191m \u2192 C * ((1 + \u03b5 \u2191m) * asympBound g a b m) \u2264 T m\nhn : n \u2265 n\u2080\nh_asympBound_pos' : 0 < asympBound g a b n\nh_one_sub_smoothingFn_pos' : 0 < 1 + \u03b5 \u2191n\ni : \u03b1\n\u22a2 b' * \u2191n\u2080 \u2264 b' * \u2191n",["gcongr","aesop"]],["MeasureTheory/Measure/Typeclasses.lean",876,"\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\nt : Set \u03b1\nm : \u2115 \u2192 Measure \u03b1\nhv : \u2200 (n : \u2115), (m n) t \u2260 \u22a4\nh\u03bc : \u03bc = sum m\nw : \u2115 \u2192 Set \u03b1 := fun n \u21a6 toMeasurable (m n) t\nT : t \u2286 \u22c2 n, w n\nM : MeasurableSet (\u22c2 n, w n)\nu : Set \u03b1\nhu : MeasurableSet u\n\u22a2 \u03bc (t \u2229 u) \u2264 \u03bc ((\u22c2 n, w n) \u2229 u)",["gcongr"]],["MeasureTheory/Measure/Typeclasses.lean",920,"\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\nt : Set \u03b1\nv : \u2115 \u2192 Set \u03b1\nhv : t \u2286 \u22c3 n, v n\nh'v : \u2200 (n : \u2115), \u03bc (t \u2229 v n) \u2260 \u22a4\nw : \u2115 \u2192 Set \u03b1 := fun n \u21a6 toMeasurable \u03bc (t \u2229 v n)\nhw : \u2200 (n : \u2115), \u03bc (w n) < \u22a4\nt' : Set \u03b1 := \u22c3 n, toMeasurable \u03bc (t \u2229 disjointed w n)\nht' : t' = \u22c3 n, toMeasurable \u03bc (t \u2229 disjointed w n)\ntt' : t \u2286 t'\nu : Set \u03b1\nhu : MeasurableSet u\n\u22a2 \u03bc (t \u2229 u) \u2264 \u03bc (t' \u2229 u)",["gcongr"]],["MeasureTheory/Measure/Typeclasses.lean",88,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns t : Set \u03b1\ninst\u271d : IsEmpty \u03b1\n\u22a2 IsFiniteMeasure 0",["infer_instance"]],["MeasureTheory/Measure/Typeclasses.lean",110,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns t : Set \u03b1\nR : Type u_5\ninst\u271d\u2074 : SMul R \u211d\u22650\ninst\u271d\u00b3 : SMul R \u211d\u22650\u221e\ninst\u271d\u00b2 : IsScalarTower R \u211d\u22650 \u211d\u22650\u221e\ninst\u271d\u00b9 : IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e\ninst\u271d : IsFiniteMeasure \u03bc\nr : R\n\u22a2 IsFiniteMeasure ((r \u2022 1) \u2022 \u03bc)",["infer_instance"]],["MeasureTheory/Measure/Typeclasses.lean",355,"case inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns t : Set \u03b1\nh\u271d : NeZero \u03bc\nh : \u03bc univ < \u22a4\nthis : IsFiniteMeasure \u03bc\n\u22a2 IsZeroOrProbabilityMeasure ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc)",["infer_instance"]],["MeasureTheory/Measure/Typeclasses.lean",607,"case intro.inr\n\u03b1 : Type u_1\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Countable \u03b9\nm : \u03b9 \u2192 Measure \u03b1\ninst\u271d : \u2200 (n : \u03b9), IsFiniteMeasure (m n)\nf : \u03b9 \u2192 \u2115\nhf : Injective f\nn : \u2115\nhn : n \u2209 range f\n\u22a2 IsFiniteMeasure 0",["infer_instance"]],["MeasureTheory/Integral/SetIntegral.lean",1473,"Y : Type u_2\nE : Type u_3\nF : Type u_4\nX : Type u_5\nG : Type u_6\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9\u00b9 : TopologicalSpace X\ninst\u271d\u00b9\u2070 : TopologicalSpace Y\ninst\u271d\u2079 : MeasurableSpace Y\ninst\u271d\u2078 : OpensMeasurableSpace Y\n\u03bc : Measure Y\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : NormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\ninst\u271d : NormedSpace \ud835\udd5c E\nL : F \u2192L[\ud835\udd5c] G \u2192L[\ud835\udd5c] E\nf : X \u2192 Y \u2192 G\ns : Set X\nk : Set Y\ng : Y \u2192 F\nhk : IsCompact k\nhf : ContinuousOn (uncurry f) (s \u00d7\u02e2 univ)\nhfs : \u2200 (p : X) (x : Y), p \u2208 s \u2192 x \u2209 k \u2192 f p x = 0\nhg : IntegrableOn g k \u03bc\nA : \u2200 p \u2208 s, Continuous (f p)\nq : X\nhq : q \u2208 s\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : \u222b (x : Y) in k, \u2016L\u2016 * \u2016g x\u2016 * \u03b4 \u2202\u03bc < \u03b5\nv : Set X\nv_mem : v \u2208 \ud835\udcdd[s] q\nI : \u2200 p \u2208 s, IntegrableOn (fun y \u21a6 (L (g y)) (f p y)) k \u03bc\np : X\nhp : p \u2208 v\nh'p : p \u2208 s\ny : Y\nhy : y \u2208 k\nhv : \u2016f p y - f q y\u2016 < \u03b4\n\u22a2 \u2016L\u2016 * \u2016g y\u2016 * \u2016f p y - f q y\u2016 \u2264 \u2016L\u2016 * \u2016g y\u2016 * \u03b4",["gcongr"]],["MeasureTheory/Integral/SetIntegral.lean",1401,"Y : Type u_2\nE : Type u_3\nX : Type u_5\ninst\u271d\u2079 : TopologicalSpace X\ninst\u271d\u2078 : TopologicalSpace Y\ninst\u271d\u2077 : MeasurableSpace Y\ninst\u271d\u2076 : OpensMeasurableSpace Y\n\u03bc : Measure Y\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FirstCountableTopology X\ninst\u271d\u00b2 : LocallyCompactSpace X\ninst\u271d\u00b9 : SecondCountableTopologyEither Y E\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : X \u2192 Y \u2192 E\nhf : Continuous (uncurry f)\ns : Set Y\nhs : IsCompact s\nx\u2080 : X\nU : Set X\nU_cpct : IsCompact U\nU_nhds : U \u2208 \ud835\udcdd x\u2080\nM : \u211d\nhM : M \u2208 upperBounds ((fun x \u21a6 \u2016uncurry f x\u2016) '' U \u00d7\u02e2 s)\nx : X\n\u22a2 Continuous (f x)",["fun_prop"]],["MeasureTheory/Integral/SetIntegral.lean",1407,"Y : Type u_2\nE : Type u_3\nX : Type u_5\ninst\u271d\u2079 : TopologicalSpace X\ninst\u271d\u2078 : TopologicalSpace Y\ninst\u271d\u2077 : MeasurableSpace Y\ninst\u271d\u2076 : OpensMeasurableSpace Y\n\u03bc : Measure Y\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FirstCountableTopology X\ninst\u271d\u00b2 : LocallyCompactSpace X\ninst\u271d\u00b9 : SecondCountableTopologyEither Y E\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : X \u2192 Y \u2192 E\nhf : Continuous (uncurry f)\ns : Set Y\nhs : IsCompact s\nx\u2080 : X\nU : Set X\nU_cpct : IsCompact U\nU_nhds : U \u2208 \ud835\udcdd x\u2080\nM : \u211d\nhM : M \u2208 upperBounds ((fun x \u21a6 \u2016uncurry f x\u2016) '' U \u00d7\u02e2 s)\n\u22a2 \u2200 (a : Y), ContinuousAt (fun x \u21a6 f x a) x\u2080",["fun_prop"]],["MeasureTheory/Integral/SetIntegral.lean",1433,"Y : Type u_2\nE : Type u_3\nF : Type u_4\nX : Type u_5\nG : Type u_6\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9\u00b9 : TopologicalSpace X\ninst\u271d\u00b9\u2070 : TopologicalSpace Y\ninst\u271d\u2079 : MeasurableSpace Y\ninst\u271d\u2078 : OpensMeasurableSpace Y\n\u03bc : Measure Y\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : NormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\ninst\u271d : NormedSpace \ud835\udd5c E\nL : F \u2192L[\ud835\udd5c] G \u2192L[\ud835\udd5c] E\nf : X \u2192 Y \u2192 G\ns : Set X\nk : Set Y\ng : Y \u2192 F\nhk : IsCompact k\nhf : ContinuousOn (uncurry f) (s \u00d7\u02e2 univ)\nhfs : \u2200 (p : X) (x : Y), p \u2208 s \u2192 x \u2209 k \u2192 f p x = 0\nhg : IntegrableOn g k \u03bc\nA : \u2200 p \u2208 s, Continuous (f p)\nq : X\nhq : q \u2208 s\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : \u222b (x : Y) in k, \u2016L\u2016 * \u2016g x\u2016 * \u03b4 \u2202\u03bc < \u03b5\nv : Set X\nv_mem : v \u2208 \ud835\udcdd[s] q\nhv : \u2200 p \u2208 v, \u2200 x \u2208 k, \u2016f p x - f q x\u2016 < \u03b4\np : X\nhp : p \u2208 s\n\u22a2 ContinuousOn (fun y \u21a6 (p, y)) k",["fun_prop"]],["Topology/Category/Profinite/Nobeling.lean",322,"I : Type u\nC : Set (I \u2192 Bool)\ninst\u271d\u00b9 : LinearOrder I\ninst\u271d : WellFoundedLT I\nthis : (fun x1 x2 \u21a6 x1 < x2) = fun l m \u21a6 List.Lex (fun x1 x2 \u21a6 x1 < x2) \u2191l \u2191m\n\u22a2 IsWellFounded { l // List.Chain' (flip fun x1 x2 \u21a6 x1 < x2) l } fun l m \u21a6 List.Lex (fun x1 x2 \u21a6 x1 < x2) \u2191l \u2191m",["infer_instance"]],["Topology/Instances/ENNReal/Lemmas.lean",446,"a : \u211d\u22650\u221e\n\u22a2 ContinuousOn (fun x \u21a6 (a, x)) {x | x \u2260 \u22a4}",["fun_prop"]],["Topology/Instances/ENNReal/Lemmas.lean",454,"a : \u211d\u22650\u221e\na_infty : \u00aca = \u22a4\n\u22a2 Continuous fun x \u21a6 (x, a)",["fun_prop"]],["Topology/Instances/ENNReal/Lemmas.lean",1358,"t : \u211d\u22650\u221e\nt_ne_top : t \u2260 \u22a4\n\u22a2 Continuous (min t)",["fun_prop"]],["MeasureTheory/Integral/FundThmCalculus.lean",200,"\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\na : \u211d\n\u22a2 FTCFilter a (Pure.pure a) \u22a5",["infer_instance"]],["MeasureTheory/Integral/FundThmCalculus.lean",210,"\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\na : \u211d\n\u22a2 FTCFilter a (\ud835\udcdd a) (\ud835\udcdd a)",["infer_instance"]],["Analysis/Calculus/MeanValue.lean",948,"f : \u211d \u2192 \u211d\na : \u211d\nf' : \u211d \u2192 \u211d := f \u2218 Neg.neg\nb : \u211d\nhb\u2081 : b < a\nhb\u2082 : \u2200 \u2983x : \u211d\u2984, x \u2208 Ioo b a \u2192 deriv f x \u2208 Iic (-1)\nx : \u211d\nhx : x \u2208 Ioo (-a) (-b)\n\u22a2 DifferentiableAt \u211d Neg.neg x",["fun_prop"]],["Analysis/Calculus/MeanValue.lean",437,"E : Type u_1\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \u211d F\n\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b3 : IsRCLikeNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nf g : E \u2192 G\nC : \u211d\ns : Set E\nx y : E\nf' g' : E \u2192 E \u2192L[\ud835\udd5c] G\n\u03c6 : E \u2192L[\ud835\udd5c] G\nthis : RCLike \ud835\udd5c := IsRCLikeNormedField.rclike \ud835\udd5c\n\u22a2 PathConnectedSpace \ud835\udd5c",["infer_instance"]],["MeasureTheory/Function/Jacobian.lean",171,"E : Type u_1\nF : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : SecondCountableTopology F\nf : E \u2192 F\ns : Set E\nf' : E \u2192 E \u2192L[\u211d] F\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\nr : (E \u2192L[\u211d] F) \u2192 \u211d\u22650\nrpos : \u2200 (A : E \u2192L[\u211d] F), r A \u2260 0\nhs : s.Nonempty\nT : Set \u2191s\nT_count : T.Countable\nhT : \u22c3 x \u2208 T, ball (f' \u2191x) \u2191(r (f' \u2191x)) = \u22c3 x, ball (f' \u2191x) \u2191(r (f' \u2191x))\nu : \u2115 \u2192 \u211d\nleft\u271d : StrictAnti u\nu_pos : \u2200 (n : \u2115), 0 < u n\nu_lim : Tendsto u atTop (\ud835\udcdd 0)\nM : \u2115 \u2192 \u2191T \u2192 Set E :=\n  fun n z \u21a6 {x | x \u2208 s \u2227 \u2200 y \u2208 s \u2229 ball x (u n), \u2016f y - f x - (f' \u2191\u2191z) (y - x)\u2016 \u2264 \u2191(r (f' \u2191\u2191z)) * \u2016y - x\u2016}\nx : E\nxs : x \u2208 s\nz : \u2191s\nzT : z \u2208 T\nhz : f' x \u2208 ball (f' \u2191z) \u2191(r (f' \u2191z))\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nh\u03b5 : \u2016f' x - f' \u2191z\u2016 + \u03b5 \u2264 \u2191(r (f' \u2191z))\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : ball x \u03b4 \u2229 s \u2286 {y | \u2016f y - f x - (f' x) (y - x)\u2016 \u2264 \u03b5 * \u2016y - x\u2016}\nn : \u2115\nhn : u n < \u03b4\ny : E\nhy : y \u2208 s \u2229 ball x (u n)\n\u22a2 (\u2016f' x - f' \u2191z\u2016 + \u03b5) * \u2016y - x\u2016 \u2264 \u2191(r (f' \u2191z)) * \u2016y - x\u2016",["gcongr"]],["MeasureTheory/Function/Jacobian.lean",333,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nA : E \u2192L[\u211d] E\nm : \u211d\u22650\nhm : ENNReal.ofReal |A.det| < \u2191m\nd : \u211d\u22650\u221e := ENNReal.ofReal |A.det|\n\u03b5 : \u211d\nh\u03b5 : \u03bc (closedBall 0 \u03b5 + \u21d1A '' closedBall 0 1) < \u2191m * \u03bc (closedBall 0 1)\n\u03b5pos : 0 < \u03b5\nthis : Iio \u27e8\u03b5, \u22ef\u27e9 \u2208 \ud835\udcdd 0\n\u03b4 : \u211d\u22650\ns : Set E\nf : E \u2192 E\nhf : ApproximatesLinearOn f A s \u03b4\nh\u03b4 : \u2191\u03b4 < \u03b5\nx : E\nr : \u211d\nxs : x \u2208 s\nr0 : 0 \u2264 r\nz : E\nzs : z \u2208 s\nzr : \u2016z - x\u2016 \u2264 r\n\u22a2 \u2191\u03b4 * \u2016z - x\u2016 \u2264 \u03b5 * r",["gcongr"]],["MeasureTheory/Function/Jacobian.lean",350,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nA : E \u2192L[\u211d] E\nm : \u211d\u22650\nhm : ENNReal.ofReal |A.det| < \u2191m\nd : \u211d\u22650\u221e := ENNReal.ofReal |A.det|\n\u03b5 : \u211d\nh\u03b5 : \u03bc (closedBall 0 \u03b5 + \u21d1A '' closedBall 0 1) < \u2191m * \u03bc (closedBall 0 1)\n\u03b5pos : 0 < \u03b5\nthis\u271d : Iio \u27e8\u03b5, \u22ef\u27e9 \u2208 \ud835\udcdd 0\n\u03b4 : \u211d\u22650\ns : Set E\nf : E \u2192 E\nhf : ApproximatesLinearOn f A s \u03b4\nh\u03b4 : \u2191\u03b4 < \u03b5\nx : E\nr : \u211d\nxs : x \u2208 s\nr0 : 0 \u2264 r\nK : f '' (s \u2229 closedBall x r) \u2286 {f x} + r \u2022 (\u21d1A '' closedBall 0 1 + closedBall 0 \u03b5)\nthis : \u21d1A '' closedBall 0 r + closedBall (f x) (\u03b5 * r) = {f x} + r \u2022 (\u21d1A '' closedBall 0 1 + closedBall 0 \u03b5)\n\u22a2 ENNReal.ofReal (r ^ finrank \u211d E) * \u03bc (closedBall 0 \u03b5 + \u21d1A '' closedBall 0 1) \u2264\n    ENNReal.ofReal (r ^ finrank \u211d E) * (\u2191m * \u03bc (closedBall 0 1))",["gcongr"]],["MeasureTheory/Function/Jacobian.lean",376,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nA : E \u2192L[\u211d] E\nm : \u211d\u22650\nhm : ENNReal.ofReal |A.det| < \u2191m\nd : \u211d\u22650\u221e := ENNReal.ofReal |A.det|\n\u03b5 : \u211d\nh\u03b5 : \u03bc (closedBall 0 \u03b5 + \u21d1A '' closedBall 0 1) < \u2191m * \u03bc (closedBall 0 1)\n\u03b5pos : 0 < \u03b5\nthis\u271d : Iio \u27e8\u03b5, \u22ef\u27e9 \u2208 \ud835\udcdd 0\n\u03b4 : \u211d\u22650\ns : Set E\nf : E \u2192 E\nhf : ApproximatesLinearOn f A s \u03b4\nh\u03b4 : \u2191\u03b4 < \u03b5\nI : \u2200 (x : E) (r : \u211d), x \u2208 s \u2192 0 \u2264 r \u2192 \u03bc (f '' (s \u2229 closedBall x r)) \u2264 \u2191m * \u03bc (closedBall x r)\na : \u211d\u22650\u221e\nha : 0 < a\nt : Set E\nr : E \u2192 \u211d\nt_count : t.Countable\nts : t \u2286 s\nrpos : \u2200 x \u2208 t, 0 < r x\nst : s \u2286 \u22c3 x \u2208 t, closedBall x (r x)\n\u03bct : \u2211' (x : \u2191t), \u03bc (closedBall (\u2191x) (r \u2191x)) \u2264 \u03bc s + a\nthis : Encodable \u2191t\n\u22a2 \u2191m * \u2211' (i : \u2191t), \u03bc (closedBall (\u2191i) (r \u2191i)) \u2264 \u2191m * (\u03bc s + a)",["gcongr"]],["MeasureTheory/Function/Jacobian.lean",528,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ns : Set E\nf : E \u2192 E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nA : E \u2192L[\u211d] E\n\u03b4 : \u211d\u22650\nhf : ApproximatesLinearOn f A s \u03b4\nhs : MeasurableSet s\nf' : E \u2192 E \u2192L[\u211d] E\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\nx : E\nhx : Tendsto (fun r \u21a6 \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd 1)\nxs : x \u2208 s\nz : E\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nB\u2081 : \u2200\u1da0 (r : \u211d) in \ud835\udcdd[>] 0, (s \u2229 ({x} + r \u2022 closedBall z \u03b5)).Nonempty\n\u03c1 : \u211d\n\u03c1pos : \u03c1 > 0\nh\u03c1 : ball x \u03c1 \u2229 s \u2286 {y | \u2016f y - f x - (f' x) (y - x)\u2016 \u2264 \u03b5 * \u2016y - x\u2016}\nB\u2082 : \u2200\u1da0 (r : \u211d) in \ud835\udcdd[>] 0, {x} + r \u2022 closedBall z \u03b5 \u2286 ball x \u03c1\nr : \u211d\ny : E\nys : y \u2208 s\nhy : y \u2208 {x} + r \u2022 closedBall z \u03b5\nr\u03c1 : {x} + r \u2022 closedBall z \u03b5 \u2286 ball x \u03c1\nrpos : 0 < r\na : E\naz : a \u2208 closedBall z \u03b5\nya : y = x + r \u2022 a\nnorm_a : \u2016a\u2016 \u2264 \u2016z\u2016 + \u03b5\n\u22a2 r * (\u2191\u03b4 + \u03b5) * \u2016a\u2016 \u2264 r * (\u2191\u03b4 + \u03b5) * (\u2016z\u2016 + \u03b5)",["gcongr"]],["MeasureTheory/Function/Jacobian.lean",541,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ns : Set E\nf : E \u2192 E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nA : E \u2192L[\u211d] E\n\u03b4 : \u211d\u22650\nhf : ApproximatesLinearOn f A s \u03b4\nhs : MeasurableSet s\nf' : E \u2192 E \u2192L[\u211d] E\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\nx : E\nhx : Tendsto (fun r \u21a6 \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd 1)\nxs : x \u2208 s\nz : E\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nB\u2081 : \u2200\u1da0 (r : \u211d) in \ud835\udcdd[>] 0, (s \u2229 ({x} + r \u2022 closedBall z \u03b5)).Nonempty\n\u03c1 : \u211d\n\u03c1pos : \u03c1 > 0\nh\u03c1 : ball x \u03c1 \u2229 s \u2286 {y | \u2016f y - f x - (f' x) (y - x)\u2016 \u2264 \u03b5 * \u2016y - x\u2016}\nB\u2082 : \u2200\u1da0 (r : \u211d) in \ud835\udcdd[>] 0, {x} + r \u2022 closedBall z \u03b5 \u2286 ball x \u03c1\nr : \u211d\ny : E\nys : y \u2208 s\nhy : y \u2208 {x} + r \u2022 closedBall z \u03b5\nr\u03c1 : {x} + r \u2022 closedBall z \u03b5 \u2286 ball x \u03c1\nrpos : 0 < r\na : E\naz : \u2016z - a\u2016 \u2264 \u03b5\nya : y = x + r \u2022 a\nnorm_a : \u2016a\u2016 \u2264 \u2016z\u2016 + \u03b5\nI : r * \u2016(f' x - A) a\u2016 \u2264 r * (\u2191\u03b4 + \u03b5) * (\u2016z\u2016 + \u03b5)\n\u22a2 (\u2191\u03b4 + \u03b5) * (\u2016z\u2016 + \u03b5) + \u2016f' x - A\u2016 * \u2016z - a\u2016 \u2264 (\u2191\u03b4 + \u03b5) * (\u2016z\u2016 + \u03b5) + \u2016f' x - A\u2016 * \u03b5",["gcongr"]],["MeasureTheory/Function/Jacobian.lean",633,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ns : Set E\nf : E \u2192 E\nf' : E \u2192 E \u2192L[\u211d] E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\nR : \u211d\nhs : s \u2286 closedBall 0 R\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nh'f' : \u2200 x \u2208 s, (f' x).det = 0\nh's : s.Nonempty\n\u03b4 : (E \u2192L[\u211d] E) \u2192 \u211d\u22650\nh\u03b4 :\n  \u2200 (A : E \u2192L[\u211d] E),\n    0 < \u03b4 A \u2227 \u2200 (t : Set E), ApproximatesLinearOn f A t (\u03b4 A) \u2192 \u03bc (f '' t) \u2264 \u2191(|A.det|.toNNReal + \u03b5) * \u03bc t\nt : \u2115 \u2192 Set E\nA : \u2115 \u2192 E \u2192L[\u211d] E\nt_disj : Pairwise (Disjoint on t)\nt_meas : \u2200 (n : \u2115), MeasurableSet (t n)\nt_cover : s \u2286 \u22c3 n, t n\nht : \u2200 (n : \u2115), ApproximatesLinearOn f (A n) (s \u2229 t n) (\u03b4 (A n))\nAf' : s.Nonempty \u2192 \u2200 (n : \u2115), \u2203 y \u2208 s, A n = f' y\n\u22a2 \u2191\u03b5 * \u2211' (i : \u2115), \u03bc (s \u2229 t i) \u2264 \u2191\u03b5 * \u2211' (n : \u2115), \u03bc (closedBall 0 R \u2229 t n)",["gcongr"]],["MeasureTheory/Function/Jacobian.lean",848,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ns : Set E\nf : E \u2192 E\nf' : E \u2192 E \u2192L[\u211d] E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\n\u03b4 : (E \u2192L[\u211d] E) \u2192 \u211d\u22650\nh\u03b4 :\n  \u2200 (A : E \u2192L[\u211d] E),\n    0 < \u03b4 A \u2227\n      (\u2200 (B : E \u2192L[\u211d] E), \u2016B - A\u2016 \u2264 \u2191(\u03b4 A) \u2192 |B.det - A.det| \u2264 \u2191\u03b5) \u2227\n        \u2200 (t : Set E) (g : E \u2192 E), ApproximatesLinearOn g A t (\u03b4 A) \u2192 \u03bc (g '' t) \u2264 (ENNReal.ofReal |A.det| + \u2191\u03b5) * \u03bc t\nt : \u2115 \u2192 Set E\nA : \u2115 \u2192 E \u2192L[\u211d] E\nt_disj : Pairwise (Disjoint on t)\nt_meas : \u2200 (n : \u2115), MeasurableSet (t n)\nt_cover : s \u2286 \u22c3 n, t n\nht : \u2200 (n : \u2115), ApproximatesLinearOn f (A n) (s \u2229 t n) (\u03b4 (A n))\nn : \u2115\nx : E\nhx : \u2016f' x - A n\u2016\u208a \u2264 \u03b4 (A n)\nI : |(A n).det| \u2264 |(f' x).det| + \u2191\u03b5\n\u22a2 ENNReal.ofReal |(A n).det| + \u2191\u03b5 \u2264 ENNReal.ofReal (|(f' x).det| + \u2191\u03b5) + \u2191\u03b5",["gcongr"]],["Analysis/Analytic/Basic.lean",100,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : AddCommMonoid E\ninst\u271d\u2078 : AddCommMonoid F\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c F\ninst\u271d\u2075 : TopologicalSpace E\ninst\u271d\u2074 : TopologicalSpace F\ninst\u271d\u00b3 : ContinuousAdd E\ninst\u271d\u00b2 : ContinuousAdd F\ninst\u271d\u00b9 : ContinuousConstSMul \ud835\udd5c E\ninst\u271d : ContinuousConstSMul \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\n\u22a2 Continuous fun x \u21a6 \u2211 k \u2208 Finset.range n, (p k) fun x_1 \u21a6 x",["fun_prop"]],["MeasureTheory/Integral/Bochner.lean",517,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf : 0 \u2264\u1da0[ae \u03bc] f\n\u22a2 CompleteSpace \u211d",["infer_instance"]],["MeasureTheory/Integral/Bochner.lean",778,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 \u211d\nhf : Integrable f \u03bc\nhg : Integrable g \u03bc\nh : f \u2264\u1da0[ae \u03bc] g\n\u22a2 CompleteSpace \u211d",["infer_instance"]],["Data/Ordmap/Ordset.lean",163,"\u03b1 : Type u_1\n\u22a2 Decidable True",["infer_instance"]],["Data/Ordmap/Ordset.lean",168,"\u03b1 : Type u_1\nsize\u271d : \u2115\nl : Ordnode \u03b1\nx\u271d : \u03b1\nr : Ordnode \u03b1\nthis\u271d : Decidable l.Balanced\nthis : Decidable r.Balanced\n\u22a2 Decidable (BalancedSz l.size r.size \u2227 l.Balanced \u2227 r.Balanced)",["infer_instance"]],["MeasureTheory/Function/LpSeminorm/Basic.lean",412,"case h\u2081\n\u03b1 : Type u_1\n\u03b5 : Type u_2\n\u03b5' : Type u_3\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : ENorm \u03b5\ninst\u271d : ENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nhq : 0 \u2264 q\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\nx : \u03b1\nhx : \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\n\u22a2 \u2016f x\u2016\u2091 ^ q \u2264 \u2016g x\u2016\u2091 ^ q",["gcongr"]],["MeasureTheory/Function/LpSeminorm/Basic.lean",420,"case h\u2081\n\u03b1 : Type u_1\nF : Type u_5\nG : Type u_6\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedAddCommGroup G\nf : \u03b1 \u2192 F\ng : \u03b1 \u2192 G\nhq : 0 \u2264 q\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u208a \u2264 \u2016g x\u2016\u208a\nx : \u03b1\nhx : \u2016f x\u2016\u208a \u2264 \u2016g x\u2016\u208a\n\u22a2 \u2191\u2016f x\u2016\u208a ^ q \u2264 \u2191\u2016g x\u2016\u208a ^ q",["gcongr"]],["Analysis/InnerProductSpace/Projection.lean",145,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nne : K.Nonempty\nh\u2081 : IsComplete K\nh\u2082 : Convex \u211d K\nu : F\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\nthis\u271d : Nonempty \u2191K := Set.Nonempty.to_subtype ne\nzero_le_\u03b4 : 0 \u2264 \u03b4\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nw : \u2115 \u2192 \u2191K\nhw : \u2200 (n : \u2115), \u2016u - \u2191(w n)\u2016 < \u03b4 + 1 / (\u2191n + 1)\nnorm_tendsto : Tendsto (fun n \u21a6 \u2016u - \u2191(w n)\u2016) atTop (\ud835\udcdd \u03b4)\nb\u271d : \u2115 \u2192 \u211d := fun n \u21a6 8 * \u03b4 * (1 / (\u2191n + 1)) + 4 * (1 / (\u2191n + 1)) * (1 / (\u2191n + 1))\np q N : \u2115\nhp : N \u2264 p\nhq : N \u2264 q\nwp : F := \u2191(w p)\nwq : F := \u2191(w q)\na : F := u - wq\nb : F := u - wp\nhalf : \u211d := 1 / 2\ndiv : \u211d := 1 / (\u2191N + 1)\nthis : 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016 + \u2016wp - wq\u2016 * \u2016wp - wq\u2016 = 2 * (\u2016a\u2016 * \u2016a\u2016 + \u2016b\u2016 * \u2016b\u2016)\neq : \u03b4 \u2264 \u2016u - half \u2022 (wq + wp)\u2016\n\u22a2 4 * (\u03b4 * \u03b4) \u2264 4 * (\u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016)",["gcongr"]],["Analysis/InnerProductSpace/Projection.lean",159,"F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nK : Set F\nne : K.Nonempty\nh\u2081 : IsComplete K\nh\u2082 : Convex \u211d K\nu : F\n\u03b4 : \u211d := \u2a05 w, \u2016u - \u2191w\u2016\nthis\u271d : Nonempty \u2191K := Set.Nonempty.to_subtype ne\nzero_le_\u03b4 : 0 \u2264 \u03b4\n\u03b4_le : \u2200 (w : \u2191K), \u03b4 \u2264 \u2016u - \u2191w\u2016\n\u03b4_le' : \u2200 w \u2208 K, \u03b4 \u2264 \u2016u - w\u2016\nw : \u2115 \u2192 \u2191K\nhw : \u2200 (n : \u2115), \u2016u - \u2191(w n)\u2016 < \u03b4 + 1 / (\u2191n + 1)\nnorm_tendsto : Tendsto (fun n \u21a6 \u2016u - \u2191(w n)\u2016) atTop (\ud835\udcdd \u03b4)\nb\u271d : \u2115 \u2192 \u211d := fun n \u21a6 8 * \u03b4 * (1 / (\u2191n + 1)) + 4 * (1 / (\u2191n + 1)) * (1 / (\u2191n + 1))\np q N : \u2115\nhp : N \u2264 p\nhq : N \u2264 q\nwp : F := \u2191(w p)\nwq : F := \u2191(w q)\na : F := u - wq\nb : F := u - wp\nhalf : \u211d := 1 / 2\ndiv : \u211d := 1 / (\u2191N + 1)\nthis : 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016 + \u2016wp - wq\u2016 * \u2016wp - wq\u2016 = 2 * (\u2016a\u2016 * \u2016a\u2016 + \u2016b\u2016 * \u2016b\u2016)\neq : \u03b4 \u2264 \u2016u - half \u2022 (wq + wp)\u2016\neq\u2081 : 4 * \u03b4 * \u03b4 \u2264 4 * \u2016u - half \u2022 (wq + wp)\u2016 * \u2016u - half \u2022 (wq + wp)\u2016\neq\u2082 : \u2016a\u2016 \u2264 \u03b4 + div\neq\u2082' : \u2016b\u2016 \u2264 \u03b4 + div\n\u22a2 2 * (\u2016a\u2016 * \u2016a\u2016 + \u2016b\u2016 * \u2016b\u2016) - 4 * \u03b4 * \u03b4 \u2264 2 * ((\u03b4 + div) * (\u03b4 + div) + (\u03b4 + div) * (\u03b4 + div)) - 4 * \u03b4 * \u03b4",["gcongr"]],["Analysis/InnerProductSpace/Projection.lean",895,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b9\nU : \u03b9 \u2192 Submodule \ud835\udd5c E\ninst\u271d : \u2200 (t : \u03b9), HasOrthogonalProjection (U t)\nhU : Monotone U\nx : E\nhU' : \u22a4 \u2264 (\u2a06 t, U t).topologicalClosure\n\u22a2 HasOrthogonalProjection \u22a4",["infer_instance"]],["MeasureTheory/Measure/MeasureSpace.lean",509,"case h\n\u03b1 : Type u_1\n\u03b9 : Type u_5\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\nh : \u2200 (i : \u03b9), NullMeasurableSet (s i) \u03bc\nhd : Directed (fun x1 x2 \u21a6 x1 \u2287 x2) s\nk : \u03b9\nhk : \u03bc (s k) \u2260 \u22a4\nthis : \u2200 t \u2286 s k, \u03bc t \u2260 \u22a4\ni j : \u03b9\nhji : s i \u2287 s j\nhjk : s k \u2287 s j\n\u22a2 \u03bc (s k \\ s i) \u2264 \u03bc (s k \\ s j)",["gcongr"]],["MeasureTheory/Measure/MeasureSpace.lean",588,"\u03b1 : Type u_8\n\u03b9 : Type u_9\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : atTop.IsCountablyGenerated\nx\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b9 \u2192 Set \u03b1\nh : atTop.NeBot\nthis : IsDirected \u03b9 fun x1 x2 \u21a6 x1 \u2264 x2\ni j : \u03b9\nhij : i \u2264 j\n\u22a2 \u03bc (Accumulate f i) \u2264 \u03bc (Accumulate f j)",["gcongr"]],["MeasureTheory/Measure/MeasureSpace.lean",728,"\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t u : Set \u03b1\nhs : MeasurableSet s\nh : \u03bc t = \u03bc u\nhtu : t \u2286 u\nht_ne_top : \u03bc u \u2260 \u22a4\n\u22a2 \u03bc (t \u2229 s) + \u03bc (t \\ s) \u2264 \u03bc (t \u2229 s) + \u03bc (u \\ s)",["gcongr"]],["MeasureTheory/Measure/MeasureSpace.lean",918,"\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ns t : Set \u03b1\nh : (\u03bc + \u03bd) t \u2260 \u22a4\nh' : s \u2286 t\nh'' : (\u03bc + \u03bd) s = (\u03bc + \u03bd) t\n\u22a2 \u03bc s + \u03bd s \u2264 \u03bc s + \u03bd t",["gcongr"]],["MeasureTheory/Measure/MeasureSpace.lean",652,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\n\u03b9 : Type u_8\ninst\u271d\u2074 : LinearOrder \u03b9\ninst\u271d\u00b3 : TopologicalSpace \u03b9\ninst\u271d\u00b2 : OrderTopology \u03b9\ninst\u271d\u00b9 : DenselyOrdered \u03b9\ninst\u271d : FirstCountableTopology \u03b9\ns : \u03b9 \u2192 Set \u03b1\na : \u03b9\nhs : \u2200 r > a, NullMeasurableSet (s r) \u03bc\nhm : \u2200 (i j : \u03b9), a < i \u2192 i \u2264 j \u2192 s i \u2286 s j\nhf : \u2203 r > a, \u03bc (s r) \u2260 \u22a4\n\u22a2 (comap Subtype.val (\ud835\udcdd[>] a)).IsCountablyGenerated",["infer_instance"]],["Analysis/NormedSpace/Multilinear/Basic.lean",296,"\ud835\udd5c : Type u\n\u03b9 : Type v\nE : \u03b9 \u2192 Type wE\nG : Type wG\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b2 : SeminormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\ninst\u271d : Fintype \u03b9\nf : MultilinearMap \ud835\udd5c E G\nC : \u211d\nD : \u211d := C \u2294 1\nD_pos : 0 \u2264 D\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 D * \u220f i : \u03b9, \u2016m i\u2016\nm m' : (i : \u03b9) \u2192 E i\nh' : dist m' m < 1\nthis : \u2016m'\u2016 \u2294 \u2016m\u2016 \u2264 \u2016m\u2016 + 1\n\u22a2 D * \u2191(Fintype.card \u03b9) * (\u2016m'\u2016 \u2294 \u2016m\u2016) ^ (Fintype.card \u03b9 - 1) * \u2016m' - m\u2016 \u2264\n    D * \u2191(Fintype.card \u03b9) * (\u2016m\u2016 + 1) ^ (Fintype.card \u03b9 - 1) * \u2016m' - m\u2016",["gcongr"]],["Analysis/NormedSpace/Multilinear/Basic.lean",484,"\ud835\udd5c : Type u\n\u03b9 : Type v\nE : \u03b9 \u2192 Type wE\nG : Type wG\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b2 : SeminormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\ninst\u271d : Fintype \u03b9\nx\u271d\u00b9 : Set ((i : \u03b9) \u2192 E i) \u00d7 \u211d\ns : Set ((i : \u03b9) \u2192 E i)\nr : \u211d\nx\u271d : Bornology.IsVonNBounded \ud835\udd5c (s, r).1 \u2227 0 < (s, r).2\nhs : Bornology.IsVonNBounded \ud835\udd5c (s, r).1\nhr : 0 < (s, r).2\n\u03b5 : \u211d\nh\u03b5 : \u2200 x \u2208 (s, r).1, \u2016x\u2016 \u2264 \u03b5\n\u03b4 : \u211d\nh\u03b4\u2080 : 0 < \u03b4\nh\u03b4 : \u03b5 ^ Fintype.card \u03b9 * \u03b4 < (s, r).2\nf : ContinuousMultilinearMap \ud835\udd5c E G\nx : (i : \u03b9) \u2192 E i\nhf : \u2016f\u2016 \u2264 \u03b4\nhx : \u2016x\u2016 \u2264 \u03b5\nthis : 0 \u2264 \u03b5\n\u22a2 \u2016f\u2016 * \u03b5 ^ Fintype.card \u03b9 \u2264 \u03b4 * \u03b5 ^ Fintype.card \u03b9",["gcongr"]],["Analysis/NormedSpace/Multilinear/Basic.lean",93,"\ud835\udd5c : Type u_1\n\u03b9 : Type u_2\nE : \u03b9 \u2192 Type u_3\nF : Type u_4\ninst\u271d\u00b9\u00b9 : NormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : Finite \u03b9\ninst\u271d\u2079 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : IsTopologicalAddGroup F\ninst\u271d\u2074 : Module \ud835\udd5c F\nG : Type u_5\ninst\u271d\u00b3 : AddCommGroup G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Module \ud835\udd5c G\ninst\u271d : ContinuousConstSMul \ud835\udd5c F\nf : G \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c E F\n\u22a2 Continuous fun p \u21a6 (f p.1) p.2",["fun_prop"]],["Probability/Independence/Kernel.lean",1108,"\u03b1 : Type u_1\n\u03a9 : Type u_2\n\u03b9 : Type u_3\n_m\u03b1 : MeasurableSpace \u03b1\n_m\u03a9 : MeasurableSpace \u03a9\n\u03ba : Kernel \u03b1 \u03a9\n\u03bc : Measure \u03b1\n\u03b2 : \u03b9 \u2192 Type u_8\nm : (i : \u03b9) \u2192 MeasurableSpace (\u03b2 i)\nf : (i : \u03b9) \u2192 \u03a9 \u2192 \u03b2 i\nhf_indep : iIndepFun f \u03ba \u03bc\nhf_meas : \u2200 (i : \u03b9), Measurable (f i)\ni\u271d j\u271d k l : \u03b9\nhik : i\u271d \u2260 k\nhil : i\u271d \u2260 l\nhjk : j\u271d \u2260 k\nhjl : j\u271d \u2260 l\ng : (i j : \u03b9) \u2192 ((x : { x // x \u2208 {i, j} }) \u2192 \u03b2 \u2191x) \u2192 \u03b2 i \u00d7 \u03b2 j := fun i j v \u21a6 (v \u27e8i, \u22ef\u27e9, v \u27e8j, \u22ef\u27e9)\ni j : \u03b9\n\u22a2 Measurable (g i j)",["fun_prop"]],["Analysis/Seminorm.lean",909,"case intro.intro\n\ud835\udd5c : Type u_3\nE : Type u_7\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nk : \ud835\udd5c\nr : \u211d\nx y : E\nhy : p y \u2264 r\nh : (fun x \u21a6 k \u2022 x) y = x\n\u22a2 \u2016k\u2016 * p y \u2264 \u2016k\u2016 * r",["gcongr"]],["Analysis/Seminorm.lean",927,"\ud835\udd5c : Type u_3\nE : Type u_7\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nhr\u2081 : 0 < r\u2081\nr : \u211d\nhr\u2080 : 0 < r\nhr : r\u2082 < r * r\u2081\na : \ud835\udd5c\nha : r \u2264 \u2016a\u2016\nx : E\nhx : p x < r\u2082\n\u22a2 r * r\u2081 \u2264 \u2016a\u2016 * r\u2081",["gcongr","aesop"]],["Topology/Algebra/Group/Basic.lean",165,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : Group \u03b2\ninst\u271d\u00b9 : MonoidHomClass F \u03b1 \u03b2\nt\u03b2 : TopologicalSpace \u03b2\ninst\u271d : ContinuousInv \u03b2\nf : F\n_t\u03b1 : TopologicalSpace \u03b1 := TopologicalSpace.induced (\u21d1f) t\u03b2\n\u22a2 Continuous fun x \u21a6 (f x)\u207b\u00b9",["fun_prop"]],["Topology/Algebra/Group/Basic.lean",629,"G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : IsTopologicalGroup G\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 G\ns : Set \u03b1\nx : \u03b1\n\u22a2 Continuous fun x \u21a6 (x.1, x.1 * x.2)",["fun_prop"]],["Topology/Algebra/Group/Basic.lean",630,"G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : IsTopologicalGroup G\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 G\ns : Set \u03b1\nx : \u03b1\n\u22a2 Continuous fun y \u21a6 (y.1, y.1\u207b\u00b9 * y.2)",["fun_prop"]],["Order/Interval/Set/Basic.lean",1611,"\u22a2 Ici False = univ",["aesop","infer_instance"]],["Topology/UniformSpace/Equicontinuity.lean",192,"\u03b9 : Type u_1\n\u03b1 : Type u_6\n\u03b2 : Type u_8\nu\u03b1 : UniformSpace \u03b1\nu\u03b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nS T : Set \u03b2\nH : UniformEquicontinuousOn F T\nhST : S \u2286 T\nU : Set (\u03b1 \u00d7 \u03b1)\nhU : U \u2208 \ud835\udce4 \u03b1\n\u22a2 \ud835\udce4 \u03b2 \u2293 \ud835\udcdf (S \u00d7\u02e2 S) \u2264 \ud835\udce4 \u03b2 \u2293 \ud835\udcdf (T \u00d7\u02e2 T)",["gcongr"]],["MeasureTheory/Measure/Regular.lean",541,"\u03b1 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : Set \u03b1 \u2192 Prop\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : \u03bc.OuterRegular\nH : \u03bc.InnerRegularWRT p IsOpen\nhd : \u2200 \u2983s U : Set \u03b1\u2984, p s \u2192 IsOpen U \u2192 p (s \\ U)\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nh0 : p \u2205\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh\u03b5s : \u03b5 + \u03b5 \u2264 \u03bc s\nhr : \u03bc s - (\u03b5 + \u03b5) < \u03bc s\nU : Set \u03b1\nhsU : U \u2287 s\nhUo : IsOpen U\nhUt : \u03bc U < \u22a4\nh\u03bcU : \u03bc (U \\ s) < \u03b5\nU' : Set \u03b1\nhU'o : IsOpen U'\nh\u03bcU' : \u03bc U' < \u03b5\nhsU' : U \\ U' \u2286 s\nK : Set \u03b1\nhKU : K \u2286 U\nhKc : p K\nhKr : \u03bc U < \u03bc K + \u03b5\n\u22a2 \u03bc (K \\ U') + \u03bc U' + \u03b5 \u2264 \u03bc (K \\ U') + \u03b5 + \u03b5",["gcongr"]],["MeasureTheory/Measure/Regular.lean",828,"\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : \u03bc.InnerRegularCompactLTTop\ninst\u271d\u00b2 : IsLocallyFiniteMeasure \u03bc\ninst\u271d\u00b9 : R1Space \u03b1\ninst\u271d : BorelSpace \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nthis : \u03b5 / 2 \u2260 0\nK : Set \u03b1\nhKs : K \u2286 s\nhKco : IsCompact K\nhKcl : IsClosed K\nh\u03bcK : \u03bc (s \\ K) < \u03b5 / 2\nU : Set \u03b1\nhKU : K \u2286 U\nhUo : IsOpen U\nh\u03bcU : \u03bc U < \u03bc K + \u03b5 / 2\n\u22a2 \u03bc (U \\ s) \u2264 \u03bc (U \\ K)",["gcongr"]],["MeasureTheory/Measure/Regular.lean",831,"\u03b1 : Type u_1\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : \u03bc.InnerRegularCompactLTTop\ninst\u271d\u00b2 : IsLocallyFiniteMeasure \u03bc\ninst\u271d\u00b9 : R1Space \u03b1\ninst\u271d : BorelSpace \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nthis : \u03b5 / 2 \u2260 0\nK : Set \u03b1\nhKs : K \u2286 s\nhKco : IsCompact K\nhKcl : IsClosed K\nh\u03bcK : \u03bc (s \\ K) < \u03b5 / 2\nU : Set \u03b1\nhKU : K \u2286 U\nhUo : IsOpen U\nh\u03bcU : \u03bc U < \u03bc K + \u03b5 / 2\n\u22a2 \u03bc K \u2264 \u03bc s",["gcongr"]],["MeasureTheory/Measure/Regular.lean",851,"case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : TopologicalSpace \u03b1\nh : \u03bc.InnerRegularCompactLTTop\nc : \u211d\u22650\u221e\nhc : c = 0\n\u22a2 InnerRegularCompactLTTop 0",["infer_instance"]],["Analysis/Asymptotics/Defs.lean",204,"\u03b1 : Type u_1\nE : Type u_3\nF' : Type u_7\ninst\u271d\u00b9 : Norm E\ninst\u271d : SeminormedAddCommGroup F'\nc c' : \u211d\nf : \u03b1 \u2192 E\ng' : \u03b1 \u2192 F'\nl : Filter \u03b1\nh : IsBigOWith c l f g'\nhc : c \u2264 c'\nx : \u03b1\nhx : x \u2208 {x | (fun x \u21a6 \u2016f x\u2016 \u2264 c * \u2016g' x\u2016) x}\n\u22a2 c * \u2016g' x\u2016 \u2264 c' * \u2016g' x\u2016",["gcongr"]],["Analysis/Asymptotics/Defs.lean",427,"\u03b1 : Type u_1\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : Norm F\ninst\u271d : Norm G\nc c' : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nl : Filter \u03b1\nhc : 0 \u2264 c\nhfg : \u2200\u1da0 (x : \u03b1) in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016\nhgk : \u2200\u1da0 (x : \u03b1) in l, \u2016g x\u2016 \u2264 c' * \u2016k x\u2016\nx : \u03b1\nhx : \u2016f x\u2016 \u2264 c * \u2016g x\u2016\nhx' : \u2016g x\u2016 \u2264 c' * \u2016k x\u2016\n\u22a2 c * \u2016g x\u2016 \u2264 c * (c' * \u2016k x\u2016)",["gcongr"]],["Analysis/Normed/Group/Basic.lean",900,"E : Type u_8\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ContinuousENorm E\nX : Type u_9\ninst\u271d : TopologicalSpace X\nf : X \u2192 E\na : X\nh : ContinuousAt f a\n\u22a2 ContinuousAt (fun x \u21a6 \u2016f x\u2016\u2091) a",["fun_prop"]],["MeasureTheory/Decomposition/Lebesgue.lean",157,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc\u271d \u03bd\u271d \u03bc \u03bd : Measure \u03b1\ninst\u271d : \u03bc.HaveLebesgueDecomposition \u03bd\nr : \u211d\u22650\n\u22a2 (\u2191r \u2022 \u03bc).HaveLebesgueDecomposition \u03bd",["infer_instance"]],["MeasureTheory/Decomposition/Lebesgue.lean",447,"case neg.hnc\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\nhr : \u00acr = 0\nhl : \u00ac\u03bc.HaveLebesgueDecomposition \u03bd\nhl' : (r \u2022 \u03bc).HaveLebesgueDecomposition \u03bd\n\u22a2 (r\u207b\u00b9 \u2022 r \u2022 \u03bc).HaveLebesgueDecomposition \u03bd",["infer_instance"]],["MeasureTheory/Decomposition/Lebesgue.lean",464,"case neg.hnc\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\nhr : r \u2260 0\nhl : \u00ac\u03bc.HaveLebesgueDecomposition \u03bd\nhl' : \u03bc.HaveLebesgueDecomposition (r \u2022 \u03bd)\n\u22a2 \u03bc.HaveLebesgueDecomposition (r\u207b\u00b9 \u2022 r \u2022 \u03bd)",["infer_instance"]],["AlgebraicGeometry/AffineScheme.lean",431,"X : Scheme\nU : X.Opens\nhU : IsAffineOpen U\n\u22a2 Continuous \u21d1(ConcreteCategory.hom hU.fromSpec.base)",["fun_prop"]],["AlgebraicGeometry/AffineScheme.lean",206,"\u22a2 PreservesLimits (equivCommRingCat.functor \u22d9 Scheme.Spec)",["infer_instance"]],["AlgebraicGeometry/AffineScheme.lean",366,"X Y : Scheme\nU : X.Opens\nhU : IsAffineOpen U\nf : \u2191\u0393(X, U)\n\u22a2 IsOpenImmersion (hU.isoSpec.inv \u226b U.\u03b9)",["infer_instance"]],["AlgebraicGeometry/AffineScheme.lean",381,"X : Scheme\nU : X.Opens\nhU : IsAffineOpen U\n\u22a2 Epi ((Spec.map (X.presheaf.map (eqToHom \u22ef).op)).base \u226b (\u2191U).isoSpec.inv.base)",["infer_instance"]],["Topology/MetricSpace/GromovHausdorff.lean",190,"X : Type u\ninst\u271d\u2076 : MetricSpace X\ninst\u271d\u2075 : CompactSpace X\ninst\u271d\u2074 : Nonempty X\nY : Type v\ninst\u271d\u00b3 : MetricSpace Y\ninst\u271d\u00b2 : CompactSpace Y\ninst\u271d\u00b9 : Nonempty Y\n\u03b3 : Type w\ninst\u271d : MetricSpace \u03b3\n\u03a6 : X \u2192 \u03b3\n\u03a8 : Y \u2192 \u03b3\nha : Isometry \u03a6\nhb : Isometry \u03a8\nxX : X\nh\u271d : xX \u2208 univ\ns : Set \u03b3 := range \u03a6 \u222a range \u03a8\n\u03a6' : X \u2192 Subtype s := fun y \u21a6 \u27e8\u03a6 y, \u22ef\u27e9\n\u03a8' : Y \u2192 Subtype s := fun y \u21a6 \u27e8\u03a8 y, \u22ef\u27e9\nI\u03a6' : Isometry \u03a6'\nI\u03a8' : Isometry \u03a8'\nthis : IsCompact s\n\u22a2 MetricSpace (Subtype s)",["infer_instance"]],["Topology/MetricSpace/GromovHausdorff.lean",965,"X : \u2115 \u2192 Type\ninst\u271d\u00b2 : (n : \u2115) \u2192 MetricSpace (X n)\ninst\u271d\u00b9 : \u2200 (n : \u2115), CompactSpace (X n)\ninst\u271d : \u2200 (n : \u2115), Nonempty (X n)\nn\u271d n : \u2115\nY : AuxGluingStruct (X n)\n\u22a2 MetricSpace (GlueSpace \u22ef \u22ef)",["infer_instance"]],["Data/Num/Lemmas.lean",560,"\u03b1 : Type u_1\n\u22a2 DecidableLT PosNum",["infer_instance"]],["Data/Num/Lemmas.lean",561,"\u03b1 : Type u_1\n\u22a2 DecidableLE PosNum",["infer_instance"]],["Data/Num/Lemmas.lean",562,"\u03b1 : Type u_1\n\u22a2 DecidableEq PosNum",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",144,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : PresheafedSpace C\nf : X \u27f6 Y\nH : IsOpenImmersion f\nU : Opens \u2191\u2191X\n\u22a2 IsIso (f.c.app (op ((opensFunctor f).obj U)))",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",178,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : PresheafedSpace C\nf : X \u27f6 Y\nH : IsOpenImmersion f\nU : Opens \u2191\u2191X\n\u22a2 IsIso (X.presheaf.map (eqToHom \u22ef) \u226b inv (f.c.app (op ((opensFunctor f).obj U))))",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",277,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y : PresheafedSpace C\nf : X \u27f6 Y\nH : IsOpenImmersion f\ninst\u271d : HasColimits C\nx : \u2191\u2191X\n\u22a2 IsIso\n    (Hom.stalkMap (Y.ofRestrict \u22ef) ((ConcreteCategory.hom (isoRestrict f).hom.base) x) \u226b\n      Hom.stalkMap (isoRestrict f).hom x)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",418,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : PresheafedSpace C\nf : X \u27f6 Z\nhf : IsOpenImmersion f\ng : Y \u27f6 Z\ns : PullbackCone f g\n\u22a2 IsOpenImmersion (Y.ofRestrict \u22ef)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",441,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : PresheafedSpace C\nf : X \u27f6 Z\nhf : IsOpenImmersion f\ng : Y \u27f6 Z\ns : PullbackCone f g\n\u22a2 IsOpenImmersion\n    ((limit.isoLimitCone { cone := pullbackConeOfLeft f g, isLimit := pullbackConeOfLeftIsLimit f g }).hom \u226b\n      { cone := pullbackConeOfLeft f g, isLimit := pullbackConeOfLeftIsLimit f g }.cone.\u03c0.app WalkingCospan.right)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",446,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : PresheafedSpace C\nf : X \u27f6 Z\nhf : IsOpenImmersion f\ng : Y \u27f6 Z\ns : PullbackCone f g\n\u22a2 IsOpenImmersion ((pullbackSymmetry g f).hom \u226b pullback.snd f g)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",451,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : PresheafedSpace C\nf : X \u27f6 Z\nhf : IsOpenImmersion f\ng : Y \u27f6 Z\ns : PullbackCone f g\ninst\u271d : IsOpenImmersion g\n\u22a2 IsOpenImmersion (limit.\u03c0 (cospan f g) WalkingCospan.left \u226b f)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",478,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : PresheafedSpace C\nf : X \u27f6 Z\nhf : IsOpenImmersion f\ng : Y \u27f6 Z\nH : Set.range \u21d1(ConcreteCategory.hom g.base) \u2286 Set.range \u21d1(ConcreteCategory.hom f.base)\nthis : IsIso (pullback.snd f.base g.base)\n\u22a2 IsIso\n    ((limit.isoLimitCone { cone := pullbackConeOfLeft f g, isLimit := pullbackConeOfLeftIsLimit f g }).hom.base \u226b\n      pullback.snd f.base g.base)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",621,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : SheafedSpace C\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 Mono f",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",630,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : SheafedSpace C\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 HasLimit (cospan (forget.map f) (forget.map g))",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",641,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : SheafedSpace C\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 HasLimit (cospan (forget.map g) (forget.map f))",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",670,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : SheafedSpace C\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 PreservesLimit (cospan f g) (PresheafedSpace.forget C)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",693,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : SheafedSpace C\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\nthis\u271d : (preservesLimitIso forget (cospan f g)).hom \u226b limit.\u03c0 (cospan f g \u22d9 forget) right = limit.\u03c0 (cospan f g) right\nthis :\n  (HasLimit.isoOfNatIso (diagramIsoCospan (cospan f g \u22d9 forget))).hom \u226b\n      limit.\u03c0 (cospan ((cospan f g \u22d9 forget).map Hom.inl) ((cospan f g \u22d9 forget).map Hom.inr)) right =\n    limit.\u03c0 (cospan f g \u22d9 forget) right\n\u22a2 IsOpenImmersion\n    ((preservesLimitIso forget (cospan f g)).hom \u226b\n      (HasLimit.isoOfNatIso (diagramIsoCospan (cospan f g \u22d9 forget))).hom \u226b limit.\u03c0 (cospan f g) right)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",704,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : SheafedSpace C\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\nthis\u271d : (preservesLimitIso forget (cospan g f)).hom \u226b limit.\u03c0 (cospan g f \u22d9 forget) left = limit.\u03c0 (cospan g f) left\nthis :\n  (HasLimit.isoOfNatIso (diagramIsoCospan (cospan g f \u22d9 forget))).hom \u226b\n      limit.\u03c0 (cospan ((cospan g f \u22d9 forget).map Hom.inl) ((cospan g f \u22d9 forget).map Hom.inr)) left =\n    limit.\u03c0 (cospan g f \u22d9 forget) left\n\u22a2 IsOpenImmersion\n    ((preservesLimitIso forget (cospan g f)).hom \u226b\n      (HasLimit.isoOfNatIso (diagramIsoCospan (cospan g f \u22d9 forget))).hom \u226b limit.\u03c0 (cospan g f) left)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",709,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : SheafedSpace C\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\ninst\u271d : IsOpenImmersion g\n\u22a2 IsOpenImmersion (limit.\u03c0 (cospan f g) left \u226b f)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",777,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : SheafedSpace C\nf : X \u27f6 Y\nH : IsOpenImmersion f\nU : Opens \u2191\u2191X.toPresheafedSpace\n\u22a2 IsIso (PresheafedSpace.IsOpenImmersion.invApp f U)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",929,"case intro.intro\nC : Type u\ninst\u271d\u2075 : Category.{v, u} C\ninst\u271d\u2074 : HasLimits C\n\u03b9\u271d : Type v\nF\u271d : Discrete \u03b9\u271d \u2964 SheafedSpace C\ninst\u271d\u00b3 : HasColimit F\u271d\ni\u271d : Discrete \u03b9\u271d\n\u03b9 : Type w\ninst\u271d\u00b2 : Small.{v, w} \u03b9\nF : Discrete \u03b9 \u2964 SheafedSpace C\ninst\u271d\u00b9 : HasColimit F\ni : Discrete \u03b9\ninst\u271d : HasStrictTerminalObjects C\n\u03b9' : Type v\ne : \u03b9 \u2243 \u03b9'\nf : Discrete \u03b9' \u224c Discrete \u03b9 := Discrete.equivalence e.symm\nthis :\n  colimit.\u03b9 F i =\n    (colimit.\u03b9 F i \u226b (HasColimit.isoOfEquivalence f (Iso.refl (f.functor \u22d9 F))).inv) \u226b\n      (HasColimit.isoOfEquivalence f (Iso.refl (f.functor \u22d9 F))).hom\n\u22a2 IsOpenImmersion\n    ((F.map (f.counitInv.app i) \u226b\n        (Iso.refl (f.functor \u22d9 F)).hom.app (f.inverse.obj i) \u226b colimit.\u03b9 (f.functor \u22d9 F) (f.inverse.obj i)) \u226b\n      (HasColimit.isoOfEquivalence f (Iso.refl (f.functor \u22d9 F))).hom)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",957,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : LocallyRingedSpace\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 Mono (Hom.toShHom f)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",974,"case prop\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : LocallyRingedSpace\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\nx : \u2191\u2191(Y.restrict \u22ef).toPresheafedSpace\nthis :\n  PresheafedSpace.Hom.stalkMap (PresheafedSpace.IsOpenImmersion.pullbackConeOfLeftFst f.toHom g.toHom) x =\n    inv\n        (f.stalkMap\n          ((ConcreteCategory.hom (PresheafedSpace.IsOpenImmersion.pullbackConeOfLeftFst f.toHom g.toHom).base) x)) \u226b\n      eqToHom \u22ef \u226b\n        g.stalkMap ((ConcreteCategory.hom (Y.ofRestrict \u22ef).base) x) \u226b PresheafedSpace.Hom.stalkMap (Y.ofRestrict \u22ef) x\n\u22a2 IsLocalHom\n    ((((CommRingCat.Hom.hom (PresheafedSpace.Hom.stalkMap (Y.ofRestrict \u22ef) x)).comp\n              (CommRingCat.Hom.hom (g.stalkMap ((ConcreteCategory.hom (pullback.snd f.base g.base)) x)))).comp\n          (CommRingCat.Hom.hom (eqToHom \u22ef))).comp\n      (CommRingCat.Hom.hom\n        (inv\n          (f.stalkMap\n            ((ConcreteCategory.hom (PresheafedSpace.IsOpenImmersion.pullbackConeOfLeftFst f.toHom g.toHom).base) x)))))",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",979,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : LocallyRingedSpace\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 PresheafedSpace.IsOpenImmersion (Y.ofRestrict \u22ef)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",1000,"case refine_1\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : LocallyRingedSpace\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\ns : PullbackCone f g\nx : \u2191\u2191s.pt.toPresheafedSpace\nthis :\n  PresheafedSpace.Hom.stalkMap\n      (PresheafedSpace.IsOpenImmersion.pullbackConeOfLeftLift f.toHom g.toHom (PullbackCone.mk s.fst.toHom s.snd.toHom \u22ef))\n      x =\n    inv\n        (PresheafedSpace.Hom.stalkMap (PresheafedSpace.IsOpenImmersion.pullbackConeOfLeft f.toHom g.toHom).snd\n          ((ConcreteCategory.hom\n              (PresheafedSpace.IsOpenImmersion.pullbackConeOfLeftLift f.toHom g.toHom\n                  (PullbackCone.mk s.fst.toHom s.snd.toHom \u22ef)).base)\n            x)) \u226b\n      eqToHom \u22ef \u226b s.snd.stalkMap x\n\u22a2 IsLocalHom\n    (CommRingCat.Hom.hom\n      (inv\n          (PresheafedSpace.Hom.stalkMap (PresheafedSpace.IsOpenImmersion.pullbackConeOfLeft f.toHom g.toHom).snd\n            ((ConcreteCategory.hom\n                (PresheafedSpace.IsOpenImmersion.pullbackConeOfLeftLift f.toHom g.toHom\n                    (PullbackCone.mk s.fst.toHom s.snd.toHom \u22ef)).base)\n              x)) \u226b\n        eqToHom \u22ef \u226b s.snd.stalkMap x))",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",1019,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : LocallyRingedSpace\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 IsOpenImmersion\n    ((limit.isoLimitCone { cone := pullbackConeOfLeft f g, isLimit := pullbackConeOfLeftIsLimit f g }).hom \u226b\n      { cone := pullbackConeOfLeft f g, isLimit := pullbackConeOfLeftIsLimit f g }.cone.\u03c0.app WalkingCospan.right)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",1025,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : LocallyRingedSpace\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 IsOpenImmersion ((pullbackSymmetry g f).hom \u226b pullback.snd f g)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",1030,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : LocallyRingedSpace\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\ninst\u271d : IsOpenImmersion g\n\u22a2 IsOpenImmersion (limit.\u03c0 (cospan f g) WalkingCospan.left \u226b f)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",1064,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : LocallyRingedSpace\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 PreservesLimit (cospan f.toHom g.toHom) (PresheafedSpace.forget CommRingCat)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",1141,"X Y Z : LocallyRingedSpace\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\nH' : Set.range \u21d1(ConcreteCategory.hom g.base) \u2286 Set.range \u21d1(ConcreteCategory.hom f.base)\nthis\u271d : IsIso (pullback.snd f g)\nthis :\n  (PreservesPullback.iso (forgetToSheafedSpace \u22d9 SheafedSpace.forget CommRingCat) f g).hom \u226b\n      pullback.fst ((forgetToSheafedSpace \u22d9 SheafedSpace.forget CommRingCat).map f)\n        ((forgetToSheafedSpace \u22d9 SheafedSpace.forget CommRingCat).map g) =\n    (pullback.fst f g).base\n\u22a2 Epi\n    (inv ((forgetToSheafedSpace \u22d9 SheafedSpace.forget CommRingCat).map (pullback.snd f g)) \u226b\n      (PreservesPullback.iso (forgetToSheafedSpace \u22d9 SheafedSpace.forget CommRingCat) f g).hom)",["infer_instance"]],["Geometry/RingedSpace/OpenImmersion.lean",1198,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y : LocallyRingedSpace\nf : X \u27f6 Y\nH : IsOpenImmersion f\nU : Opens \u2191X.toTopCat\n\u22a2 IsIso (PresheafedSpace.IsOpenImmersion.invApp f.toHom U)",["infer_instance"]],["Topology/Separation/Basic.lean",738,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : TopologicalSpace Y\ns : Set X\nhs : s.Finite\nf : X \u2192 Y\nthis : Finite \u2191s\n\u22a2 Continuous (s.restrict f)",["fun_prop"]],["Topology/Constructions.lean",1176,"X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nhf : Continuous f\n\u22a2 Continuous (ULift.up \u2218 f \u2218 ULift.down)",["fun_prop"]],["RingTheory/Ideal/Operations.lean",342,"R : Type u\ninst\u271d\u00b9 : Semiring R\nI J K L : Ideal R\ninst\u271d : I.IsTwoSided\nm n x\u271d\u00b9 : \u2115\nx\u271d : (I ^ x\u271d\u00b9).IsTwoSided\n\u22a2 IsTwoSided (I ^ x\u271d\u00b9 * I)",["infer_instance"]],["MeasureTheory/Measure/Hausdorff.lean",184,"X : Type u_2\ninst\u271d : EMetricSpace X\n\u03bc : OuterMeasure X\nhm : \u03bc.IsMetric\nt : Set X\nht : t \u2208 {s | IsClosed s}\ns : Set X\nS : \u2115 \u2192 Set X := fun n \u21a6 {x | x \u2208 s \u2227 (\u2191n)\u207b\u00b9 \u2264 infEdist x t}\nSsep : \u2200 (n : \u2115), Metric.AreSeparated (S n) t\nSsep' : \u2200 (n : \u2115), Metric.AreSeparated (S n) (s \u2229 t)\nS_sub : \u2200 (n : \u2115), S n \u2286 s \\ t\nhSs : \u2200 (n : \u2115), \u03bc (s \u2229 t) + \u03bc (S n) \u2264 \u03bc s\niUnion_S : \u22c3 n, S n = s \\ t\nhtop : \u00ac\u03bc (s \\ t) = \u22a4\nthis : \u03bc (\u22c3 n, S n) \u2264 \u2a06 n, \u03bc (S n)\n\u22a2 \u03bc (s \u2229 t) + \u03bc (\u22c3 n, S n) \u2264 \u03bc (s \u2229 t) + \u2a06 n, \u03bc (S n)",["gcongr"]],["Algebra/Order/Module/Defs.lean",809,"case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : StrictOrderedSemiring \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b2\ninst\u271d\u00b9 : Module \u03b1 \u03b2\ninst\u271d : PosSMulMono \u03b1 \u03b2\na\u2081 : \u03b1\nb\u2081 b\u2082 : \u03b2\nhb : b\u2081 \u2264 b\u2082\na : \u03b1\nha\u2080 : 0 \u2264 a\nha : a\u2081 \u2264 a\u2081 + a\n\u22a2 a\u2081 \u2022 b\u2081 + (a\u2081 \u2022 b\u2082 + a \u2022 b\u2081) \u2264 a\u2081 \u2022 b\u2081 + (a\u2081 \u2022 b\u2082 + a \u2022 b\u2082)",["gcongr"]],["Algebra/Order/Module/Defs.lean",826,"case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : StrictOrderedSemiring \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b2\ninst\u271d\u00b9 : Module \u03b1 \u03b2\ninst\u271d : PosSMulStrictMono \u03b1 \u03b2\na\u2081 : \u03b1\nb\u2081 b\u2082 : \u03b2\nhb : b\u2081 < b\u2082\na : \u03b1\nha\u2080 : 0 < a\nha : a\u2081 < a\u2081 + a\n\u22a2 a\u2081 \u2022 b\u2081 + (a\u2081 \u2022 b\u2082 + a \u2022 b\u2081) < a\u2081 \u2022 b\u2081 + (a\u2081 \u2022 b\u2082 + a \u2022 b\u2082)",["gcongr"]],["MeasureTheory/Covering/Differentiation.lean",839,"case h\u2082\n\u03b1 : Type u_1\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nv : VitaliFamily \u03bc\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : \u03b1 \u2192 E\nhf : Integrable f \u03bc\nh'f : StronglyMeasurable f\nA : \u03bc.FiniteSpanningSetsIn {K | IsOpen K} := \u03bc.finiteSpanningSetsInOpen'\nt : Set E\nt_count : t.Countable\nht : range f \u2286 closure t\nmain :\n  \u2200\u1d50 (x : \u03b1) \u2202\u03bc,\n    \u2200 (n : \u2115),\n      \u2200 c \u2208 t,\n        Tendsto (fun a \u21a6 (\u222b\u207b (y : \u03b1) in a, \u2016f y - (A.set n).indicator (fun x \u21a6 c) y\u2016\u2091 \u2202\u03bc) / \u03bc a) (v.filterAt x)\n          (\ud835\udcdd \u2016f x - (A.set n).indicator (fun x \u21a6 c) x\u2016\u2091)\nx : \u03b1\nhx :\n  \u2200 (n : \u2115),\n    \u2200 c \u2208 t,\n      Tendsto (fun a \u21a6 (\u222b\u207b (y : \u03b1) in a, \u2016f y - (A.set n).indicator (fun x \u21a6 c) y\u2016\u2091 \u2202\u03bc) / \u03bc a) (v.filterAt x)\n        (\ud835\udcdd \u2016f x - (A.set n).indicator (fun x \u21a6 c) x\u2016\u2091)\nh'x : \u2200\u1da0 (a : Set \u03b1) in v.filterAt x, 0 < \u03bc a\nM : \u2200 c \u2208 t, Tendsto (fun a \u21a6 (\u222b\u207b (y : \u03b1) in a, \u2016f y - c\u2016\u2091 \u2202\u03bc) / \u03bc a) (v.filterAt x) (\ud835\udcdd \u2016f x - c\u2016\u2091)\n\u03b5 : \u211d\u22650\u221e\n\u03b5pos : \u03b5 > 0\nc : E\nct : c \u2208 t\nxc : \u2016f x - c\u2016\u2091 < \u03b5 / 2\na : Set \u03b1\nha : (\u222b\u207b (y : \u03b1) in a, \u2016f y - c\u2016\u2091 \u2202\u03bc) / \u03bc a < \u03b5 / 2\nh'a : 0 < \u03bc a\nh''a : \u03bc a < \u22a4\n\u22a2 \u2016f x - c\u2016\u2091 * \u03bc a \u2264 \u03b5 / 2 * \u03bc a",["gcongr"]],["Algebra/Order/Floor.lean",495,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : FloorSemiring \u03b1\na b : \u03b1\nhb : 1 < b\nhba : \u2191\u2308(b - 1)\u207b\u00b9\u2309\u208a / b < a\nhab : a \u2264 (b - 1)\u207b\u00b9\n\u22a2 \u2191\u2308a\u2309\u208a \u2264 \u2191\u2308(b - 1)\u207b\u00b9\u2309\u208a",["gcongr"]],["Algebra/Order/Floor.lean",1242,"k : Type u_4\ninst\u271d\u00b9 : LinearOrderedField k\ninst\u271d : FloorRing k\na b : k\nhb : 1 < b\nhba : \u2191\u2308(b - 1)\u207b\u00b9\u2309 / b < a\nhab : a \u2264 (b - 1)\u207b\u00b9\n\u22a2 \u2191\u2308a\u2309 \u2264 \u2191\u2308(b - 1)\u207b\u00b9\u2309",["gcongr"]],["Topology/Bases.lean",504,"case intro.intro.intro.intro\n\u03b1 : Type u\nt\u271d : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nt : Set \u03b2\ncs : Set \u03b1\ncs_count : cs.Countable\nhcs : s \u2286 closure cs\nct : Set \u03b2\nct_count : ct.Countable\nhct : t \u2286 closure ct\n\u22a2 s \u00d7\u02e2 t \u2286 closure cs \u00d7\u02e2 closure ct",["gcongr"]],["MeasureTheory/Measure/Prod.lean",226,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d : SFinite \u03bd\ns : Set \u03b1\nt : Set \u03b2\nST : Set (\u03b1 \u00d7 \u03b2) := toMeasurable (\u03bc.prod \u03bd) (s \u00d7\u02e2 t)\nhSTm : MeasurableSet ST\nhST : s \u00d7\u02e2 t \u2286 ST\nf : \u03b1 \u2192 \u211d\u22650\u221e := fun x \u21a6 \u03bd (Prod.mk x \u207b\u00b9' ST)\nhfm : Measurable f\ns' : Set \u03b1 := {x | \u03bd t \u2264 f x}\nhss' : s \u2286 s'\n\u22a2 \u03bc s * \u03bd t \u2264 \u03bc s' * \u03bd t",["gcongr"]],["MeasureTheory/Measure/Prod.lean",458,"\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2075 : MeasurableSpace \u03b1\u271d\ninst\u271d\u2074 : MeasurableSpace \u03b2\u271d\ninst\u271d\u00b3 : MeasurableSpace \u03b3\n\u03bc\u271d \u03bc' : Measure \u03b1\u271d\n\u03bd\u271d \u03bd' : Measure \u03b2\u271d\n\u03c4 : Measure \u03b3\ninst\u271d\u00b2 : SFinite \u03bd\u271d\n\u03b1 : Type u_4\n\u03b2 : Type u_5\nx\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : SFinite \u03bc\nx\u271d : MeasurableSpace \u03b2\n\u03bd : Measure \u03b2\ninst\u271d : SFinite \u03bd\nthis : \u03bc.prod \u03bd = sum fun p \u21a6 (sfiniteSeq \u03bc p.1).prod (sfiniteSeq \u03bd p.2)\n\u22a2 SFinite (sum fun p \u21a6 (sfiniteSeq \u03bc p.1).prod (sfiniteSeq \u03bd p.2))",["infer_instance"]],["MeasureTheory/Measure/Prod.lean",690,"case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : MeasurableSpace \u03b4\n\u03bca : Measure \u03b1\n\u03bcb : Measure \u03b2\n\u03bcc : Measure \u03b3\n\u03bcd : Measure \u03b4\ninst\u271d\u00b9 : SFinite \u03bca\ninst\u271d : SFinite \u03bcc\nf : \u03b1 \u2192 \u03b2\nhf : MeasurePreserving f \u03bca \u03bcb\ng : \u03b1 \u2192 \u03b3 \u2192 \u03b4\nhgm : Measurable (uncurry g)\nhg : \u2200\u1d50 (a : \u03b1) \u2202\u03bca, map (g a) \u03bcc = \u03bcd\nthis : Measurable fun p \u21a6 (f p.1, g p.1 p.2)\nh\u271d : NeZero \u03bca\na : \u03b1\nha : map (g a) \u03bcc = \u03bcd\n\u22a2 SFinite (map (g a) \u03bcc)",["infer_instance"]],["MeasureTheory/Measure/Prod.lean",883,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b9 : SFinite \u03bd\n\u03c1 : Measure (\u03b1 \u00d7 \u03b2)\ninst\u271d : SFinite \u03c1\n\u22a2 SFinite (map Prod.fst \u03c1)",["infer_instance"]],["MeasureTheory/Measure/Prod.lean",887,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b9 : SFinite \u03bd\n\u03c1 : Measure (\u03b1 \u00d7 \u03b2)\ninst\u271d : IsFiniteMeasure \u03c1\n\u22a2 IsFiniteMeasure (map Prod.fst \u03c1)",["infer_instance"]],["MeasureTheory/Measure/Prod.lean",951,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b9 : SFinite \u03bd\n\u03c1 : Measure (\u03b1 \u00d7 \u03b2)\ninst\u271d : SFinite \u03c1\n\u22a2 SFinite (map Prod.snd \u03c1)",["infer_instance"]],["MeasureTheory/Measure/Prod.lean",955,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b9 : SFinite \u03bd\n\u03c1 : Measure (\u03b1 \u00d7 \u03b2)\ninst\u271d : IsFiniteMeasure \u03c1\n\u22a2 IsFiniteMeasure (map Prod.snd \u03c1)",["infer_instance"]],["Analysis/Calculus/FDeriv/Measurable.lean",168,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nx : E\nhx : DifferentiableAt \ud835\udd5c f x\n\u03b4 : \u211d := \u03b5 / 2 / 2\nR : \u211d\nR_pos : R > 0\nhR : \u2200 y \u2208 ball x R, \u2016f y - f x - (fderiv \ud835\udd5c f x) (y - x)\u2016 \u2264 \u03b4 * \u2016y - x\u2016\nr : \u211d\nhr : r \u2208 Ioo 0 R\nthis : r \u2208 Ioc (r / 2) r\ny : E\nhy : \u2016y - x\u2016 < r\nz : E\nhz : \u2016z - x\u2016 < r\n\u22a2 \u03b4 * \u2016z - x\u2016 + \u03b4 * \u2016y - x\u2016 \u2264 \u03b4 * r + \u03b4 * r",["gcongr"]],["Analysis/Calculus/FDeriv/Measurable.lean",190,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nr \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhr : 0 < r\nx : E\nL\u2081 L\u2082 : E \u2192L[\ud835\udd5c] F\nh\u2081 : x \u2208 A f L\u2081 r \u03b5\nh\u2082 : x \u2208 A f L\u2082 r \u03b5\ny : E\nley : r \u2264 2 * \u2016c\u2016 * \u2016y\u2016\nylt : \u2016y\u2016 < r / 2\n\u22a2 2 * \u03b5 * r \u2264 2 * \u03b5 * (2 * \u2016c\u2016 * \u2016y\u2016)",["gcongr","aesop"]],["Analysis/Calculus/FDeriv/Measurable.lean",276,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / (12 * \u2016c\u2016)\ne' : \u2115\nhe' : e' \u2265 e\n\u22a2 12 * \u2016c\u2016 * (1 / 2) ^ e < 12 * \u2016c\u2016 * (\u03b5 / (12 * \u2016c\u2016))",["gcongr"]],["Analysis/Calculus/FDeriv/Measurable.lean",332,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : E \u2192L[\ud835\udd5c] F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\npos : 0 < 4 + 12 * \u2016c\u2016\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / (4 + 12 * \u2016c\u2016)\ny : E\nhy : y \u2208 ball 0 ((1 / 2) ^ (n e + 1))\ny_pos : \u00acy = 0\nyzero : 0 < \u2016y\u2016\ny_lt : \u2016y\u2016 < (1 / 2) ^ (n e + 1)\nyone : \u2016y\u2016 \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : \u2016y\u2016 \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < \u2016y\u2016\nm_ge : n e \u2264 m\nkm : k = m + 1\nJ1 : \u2016f (x + y) - f x - (L e (n e) m) (x + y - x)\u2016 \u2264 (1 / 2) ^ e * (1 / 2) ^ m\n\u22a2 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) \u2264 4 * (1 / 2) ^ e * \u2016y\u2016",["gcongr"]],["Analysis/Calculus/FDeriv/Measurable.lean",340,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nK : Set (E \u2192L[\ud835\udd5c] F)\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 E \u2192L[\ud835\udd5c] F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115),\n    n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\nL0 : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : E \u2192L[\ud835\udd5c] F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * \u2016c\u2016 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\npos : 0 < 4 + 12 * \u2016c\u2016\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / (4 + 12 * \u2016c\u2016)\ny : E\nhy : y \u2208 ball 0 ((1 / 2) ^ (n e + 1))\ny_pos : \u00acy = 0\nyzero : 0 < \u2016y\u2016\ny_lt : \u2016y\u2016 < (1 / 2) ^ (n e + 1)\nyone : \u2016y\u2016 \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : \u2016y\u2016 \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < \u2016y\u2016\nm_ge : n e \u2264 m\nkm : k = m + 1\nJ1 : \u2016f (x + y) - f x - (L e (n e) m) (x + y - x)\u2016 \u2264 (1 / 2) ^ e * (1 / 2) ^ m\nJ2 : \u2016f (x + y) - f x - (L e (n e) m) y\u2016 \u2264 4 * (1 / 2) ^ e * \u2016y\u2016\n\u22a2 (4 + 12 * \u2016c\u2016) * \u2016y\u2016 * (1 / 2) ^ e \u2264 (4 + 12 * \u2016c\u2016) * \u2016y\u2016 * (\u03b5 / (4 + 12 * \u2016c\u2016))",["gcongr"]],["Analysis/Calculus/FDeriv/Measurable.lean",661,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / 16\ny : \u211d\nhy : y \u2208 Icc x (x + (1 / 2) ^ (n e + 1))\nxy : x < y\nyzero : 0 < y - x\ny_le : y - x \u2264 (1 / 2) ^ (n e + 1)\nyone : y - x \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : y - x \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < y - x\nm_ge : n e \u2264 m\nkm : k = m + 1\n\u22a2 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) \u2264 4 * (1 / 2) ^ e * (y - x)",["gcongr"]],["Analysis/Calculus/FDeriv/Measurable.lean",670,"F : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 F\nK : Set F\nhK : IsComplete K\nP : \u2200 {n : \u2115}, 0 < (1 / 2) ^ n\nx : \u211d\nhx : x \u2208 D f K\nn : \u2115 \u2192 \u2115\nL : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 F\nhn :\n  \u2200 (e p q : \u2115),\n    n e \u2264 p \u2192\n      n e \u2264 q \u2192 L e p q \u2208 K \u2227 x \u2208 A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) \u2229 A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)\nM :\n  \u2200 (e p q e' p' q' : \u2115), n e \u2264 p \u2192 n e \u2264 q \u2192 n e' \u2264 p' \u2192 n e' \u2264 q' \u2192 e \u2264 e' \u2192 \u2016L e p q - L e' p' q'\u2016 \u2264 12 * (1 / 2) ^ e\nL0 : \u2115 \u2192 F := fun e \u21a6 L e (n e) (n e)\nthis : CauchySeq L0\nf' : F\nf'K : f' \u2208 K\nhf' : Tendsto L0 atTop (\ud835\udcdd f')\nLf' : \u2200 (e p : \u2115), n e \u2264 p \u2192 \u2016L e (n e) p - f'\u2016 \u2264 12 * (1 / 2) ^ e\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\ne : \u2115\nhe : (1 / 2) ^ e < \u03b5 / 16\ny : \u211d\nhy : y \u2208 Icc x (x + (1 / 2) ^ (n e + 1))\nxy : x < y\nyzero : 0 < y - x\ny_le : y - x \u2264 (1 / 2) ^ (n e + 1)\nyone : y - x \u2264 1\nk : \u2115\nk_gt : n e < k\nm : \u2115 := k - 1\nh'k : y - x \u2264 (1 / 2) ^ (m + 1)\nhk : (1 / 2) ^ (m + 1 + 1) < y - x\nm_ge : n e \u2264 m\nkm : k = m + 1\nJ : \u2016f y - f x - (y - x) \u2022 L e (n e) m\u2016 \u2264 4 * (1 / 2) ^ e * \u2016y - x\u2016\n\u22a2 16 * \u2016y - x\u2016 * (1 / 2) ^ e \u2264 16 * \u2016y - x\u2016 * (\u03b5 / 16)",["gcongr"]],["Analysis/Calculus/FDeriv/Measurable.lean",803,"\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b3 : LocallyCompactSpace E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\n\u03b1 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 E \u2192 F\nr s : \u211d\nhf : Continuous (Function.uncurry f)\nL : E \u2192L[\ud835\udd5c] F\nthis : ProperSpace E\na : \u03b1\nx : E\nr' : \u211d\nhr :\n  \u2200 (y : E), dist y (a, x).2 < r' \u2192 \u2200 (z : E), dist z (a, x).2 < r' \u2192 \u2016f (a, x).1 z - f (a, x).1 y - (L z - L y)\u2016 < s * r\nIrr' : r / 2 < r'\nIr'r : r' \u2264 r\nha : Continuous (f a)\nt : \u211d\nhrt : r / 2 < t\nhtr' : t < r'\nt' : \u211d\nhrt' : r / 2 < t'\nht't : t' < t\n\u22a2 Continuous fun p \u21a6 \u2016f a p.2 - f a p.1 - (L p.2 - L p.1)\u2016",["fun_prop"]],["Analysis/Calculus/FDeriv/Measurable.lean",816,"\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b3 : LocallyCompactSpace E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\n\u03b1 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 E \u2192 F\nr s : \u211d\nhf : Continuous (Function.uncurry f)\nL : E \u2192L[\ud835\udd5c] F\nthis : ProperSpace E\na : \u03b1\nx : E\nr' : \u211d\nhr :\n  \u2200 (y : E), dist y (a, x).2 < r' \u2192 \u2200 (z : E), dist z (a, x).2 < r' \u2192 \u2016f (a, x).1 z - f (a, x).1 y - (L z - L y)\u2016 < s * r\nIrr' : r / 2 < r'\nIr'r : r' \u2264 r\nha : Continuous (f a)\nt : \u211d\nhrt : r / 2 < t\nhtr' : t < r'\nt' : \u211d\nhrt' : r / 2 < t'\nht't : t' < t\nb : \u211d\nb_lt : b < s * r\nhb : \u2200 y \u2208 closedBall x t, \u2200 z \u2208 closedBall x t, \u2016f a z - f a y - (L z - L y)\u2016 \u2264 b\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nh\u03b5 : b + 2 * \u03b5 < s * r\n\u22a2 Continuous fun p \u21a6 f a p.2",["fun_prop"]],["SetTheory/Ordinal/Notation.lean",263,"\u22a2 (\u21911).NF",["infer_instance"]],["SetTheory/Ordinal/Notation.lean",702,"x : ONote\ninst\u271d\u00b9 : x.NF\no : ONote\ninst\u271d : o.NF\n\u22a2 (x.oadd 1 0 * o).NF",["infer_instance"]],["SetTheory/Ordinal/Notation.lean",714,"case mk.intro\no : ONote\nm : \u2115\ninst\u271d : o.NF\na : ONote\ns\u2081 : a.NF\ne : o.split' = (a, m)\ns\u2082 : o.repr = \u03c9 * a.repr + \u2191m\n\u22a2 (scale 1 a).NF",["infer_instance"]],["SetTheory/Ordinal/Notation.lean",744,"case succ.succ\ne a0 a : ONote\ninst\u271d\u00b2 : e.NF\ninst\u271d\u00b9 : a0.NF\ninst\u271d : a.NF\nm k : \u2115\nthis : \u2200 (m : \u2115), (e.opowAux a0 a k m).NF\n\u22a2 ((e + a0 * \u2191k).scale a + e.opowAux a0 a k (m + 1)).NF",["infer_instance"]],["SetTheory/Ordinal/Notation.lean",758,"case neg\no\u2081 o\u2082 : ONote\ninst\u271d\u00b9 : o\u2081.NF\ninst\u271d : o\u2082.NF\nb' : ONote\nk : \u2115\ne\u2082 : o\u2082.split' = (b', k)\nthis : b'.NF\nna : zero.NF\nm : \u2115\ne\u2081 : o\u2081.split = (zero, m + 1)\nh\u271d : \u00acm = 0\n\u22a2 (b'.oadd (Monoid.npow k m.succPNat) 0).NF",["infer_instance"]],["SetTheory/Ordinal/Notation.lean",1147,"\u22a2 DecidableEq { o // o.NF }",["infer_instance"]],["MeasureTheory/Constructions/Polish/Basic.lean",965,"\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : StandardBorelSpace \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\nthis : UpgradedStandardBorel \u03b1 := upgradeStandardBorel \u03b1\nt : TopologicalSpace \u03b1\nhle : t \u2264 UpgradedStandardBorel.toTopologicalSpace\nht : PolishSpace \u03b1\ns_clopen : IsClosed s \u2227 IsOpen s\n\u22a2 PolishSpace \u03b1",["infer_instance"]],["MeasureTheory/Constructions/Polish/Basic.lean",972,"case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : StandardBorelSpace \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\nw\u271d : TopologicalSpace \u03b1\nleft\u271d\u00b9 : BorelSpace \u03b1\nleft\u271d : PolishSpace \u03b1\ns_closed : IsClosed s\nright\u271d : IsOpen s\nthis : PolishSpace \u2191s\n\u22a2 StandardBorelSpace \u2191s",["infer_instance"]],["Combinatorics/SimpleGraph/Path.lean",291,"V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu\u271d v\u271d w : V\ninst\u271d : DecidableEq V\nu v : V\np : G.Walk u v\n\u22a2 Decidable p.support.Nodup",["infer_instance"]],["Order/Atoms.lean",431,"\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\u271d\n\u03b1 : Type u_4\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PredOrder \u03b1\n\u22a2 IsStronglyAtomic \u03b1\u1d52\u1d48",["infer_instance"]],["Order/Atoms.lean",747,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : BoundedOrder \u03b1\ninst\u271d : IsSimpleOrder \u03b1\n\u22a2 IsAtomic \u03b1\u1d52\u1d48",["infer_instance"]],["Order/Atoms.lean",848,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : BoundedOrder \u03b1\ninst\u271d : IsSimpleOrder \u03b1\n\u22a2 IsAtomistic \u03b1\u1d52\u1d48",["infer_instance"]],["Analysis/Normed/Lp/lpSpace.lean",1130,"\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : \u211d\u22650\u221e\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u03b9 : Type u_5\nl : Filter \u03b9\ninst\u271d : l.NeBot\n_i : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\nC : \u211d\nF : \u03b9 \u2192 \u21a5(lp E p)\nhCF : \u2200\u1da0 (k : \u03b9) in l, \u2016F k\u2016 \u2264 C\nf : (a : \u03b1) \u2192 E a\nhf : Tendsto (id fun i \u21a6 \u2191(F i)) l (\ud835\udcdd f)\ns : Finset \u03b1\nhp' : p \u2260 0\nhp'' : 0 < p.toReal\nG : ((a : \u03b1) \u2192 E a) \u2192 \u211d := fun f \u21a6 \u2211 a \u2208 s, \u2016f a\u2016 ^ p.toReal\nhG : Continuous G\nk : \u03b9\nhCFk : \u2016F k\u2016 \u2264 C\n\u22a2 \u2016F k\u2016 ^ p.toReal \u2264 C ^ p.toReal",["gcongr"]],["Analysis/Normed/Lp/lpSpace.lean",286,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np q : \u211d\u22650\u221e\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u22a2 AddCommGroup ((i : \u03b1) \u2192 E i)",["infer_instance"]],["Analysis/Calculus/ContDiff/FaaDiBruno.lean",761,"\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\ns : Set E\nt : Set F\nq : F \u2192 FormalMultilinearSeries \ud835\udd5c F G\np\u271d : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nc : OrderedFinpartition n\nf : ContinuousMultilinearMap \ud835\udd5c (fun i \u21a6 F) G\np : (i : Fin c.length) \u2192 ContinuousMultilinearMap \ud835\udd5c (fun i \u21a6 E) F\n\u22a2 Continuous fun v m \u21a6 (p m) (v \u2218 c.emb m)",["fun_prop"]],["Analysis/Convex/Function.lean",255,"\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b2 : Type u_5\ninst\u271d\u2075 : OrderedSemiring \ud835\udd5c\ninst\u271d\u2074 : AddCommMonoid E\ninst\u271d\u00b3 : OrderedAddCommMonoid \u03b2\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : Module \ud835\udd5c \u03b2\ninst\u271d : OrderedSMul \ud835\udd5c \u03b2\ns : Set E\nf : E \u2192 \u03b2\nhf : ConvexOn \ud835\udd5c s f\nx : E\nr : \u03b2\nhx : (x, r).1 \u2208 s\nhr : f (x, r).1 \u2264 (x, r).2\ny : E\nt : \u03b2\nhy : (y, t).1 \u2208 s\nht : f (y, t).1 \u2264 (y, t).2\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 f x + b \u2022 f y \u2264 a \u2022 r + b \u2022 t",["gcongr"]],["Data/Set/Basic.lean",255,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 IsTrans (Set \u03b1) fun x1 x2 \u21a6 x1 \u2264 x2",["infer_instance"]],["Data/Set/Basic.lean",258,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 Trans (fun x1 x2 \u21a6 x1 \u2264 x2) (fun x1 x2 \u21a6 x1 \u2264 x2) fun x1 x2 \u21a6 x1 \u2264 x2",["infer_instance"]],["Data/Set/Basic.lean",261,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 IsAntisymm (Set \u03b1) fun x1 x2 \u21a6 x1 \u2264 x2",["infer_instance"]],["Data/Set/Basic.lean",264,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 IsIrrefl (Set \u03b1) fun x1 x2 \u21a6 x1 < x2",["infer_instance"]],["Data/Set/Basic.lean",267,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 IsTrans (Set \u03b1) fun x1 x2 \u21a6 x1 < x2",["infer_instance"]],["Data/Set/Basic.lean",270,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 Trans (fun x1 x2 \u21a6 x1 < x2) (fun x1 x2 \u21a6 x1 < x2) fun x1 x2 \u21a6 x1 < x2",["infer_instance"]],["Data/Set/Basic.lean",273,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 Trans (fun x1 x2 \u21a6 x1 < x2) (fun x1 x2 \u21a6 x1 \u2264 x2) fun x1 x2 \u21a6 x1 < x2",["infer_instance"]],["Data/Set/Basic.lean",276,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 Trans (fun x1 x2 \u21a6 x1 \u2264 x2) (fun x1 x2 \u21a6 x1 < x2) fun x1 x2 \u21a6 x1 < x2",["infer_instance"]],["Data/Set/Basic.lean",279,"\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\n\u22a2 IsAsymm (Set \u03b1) fun x1 x2 \u21a6 x1 < x2",["infer_instance"]],["MeasureTheory/Constructions/BorelSpace/Order.lean",132,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderClosedTopology \u03b1\na b x : \u03b1\n\u03bc : Measure \u03b1\n\u22a2 (\ud835\udcdd[Ici a] x \u2293 \ud835\udcdd[Iic b] x).IsMeasurablyGenerated",["infer_instance"]],["Data/Fin/Tuple/Basic.lean",90,"m n : \u2115\n\u03b1 : Fin 0 \u2192 Sort u\n\u22a2 Unique ((i : Fin 0) \u2192 \u03b1 i)",["infer_instance"]],["Geometry/Euclidean/Angle/Oriented/Basic.lean",790,"V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr : \u211d\nh : \u00ac(o.oangle x y = 0 \u2228 o.oangle x y = \u2191\u03c0)\nh' : \u2200 (r' : \u211d), o.oangle x (r' \u2022 x + y) \u2260 0 \u2227 o.oangle x (r' \u2022 x + y) \u2260 \u2191\u03c0\ns : Set (V \u00d7 V) := (fun r' \u21a6 (x, r' \u2022 x + y)) '' Set.univ\n\u22a2 ContinuousOn (fun r' \u21a6 (x, r' \u2022 x + y)) Set.univ",["fun_prop"]],["LinearAlgebra/Dual/Lemmas.lean",494,"K : Type u\nV : Type v\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\nW : Subspace K V\ninst\u271d : FiniteDimensional K V\n\u22a2 FiniteDimensional K (Dual K V)",["infer_instance"]],["Analysis/Fourier/FourierTransformDeriv.lean",224,"E : Type u_1\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u2102 E\nV : Type u_2\nW : Type u_3\ninst\u271d\u2076 : NormedAddCommGroup V\ninst\u271d\u2075 : NormedSpace \u211d V\ninst\u271d\u2074 : NormedAddCommGroup W\ninst\u271d\u00b3 : NormedSpace \u211d W\nL : V \u2192L[\u211d] W \u2192L[\u211d] \u211d\nf : V \u2192 E\ninst\u271d\u00b2 : MeasurableSpace V\ninst\u271d\u00b9 : BorelSpace V\ninst\u271d : SecondCountableTopology V\n\u03bc : Measure V\nhf : Integrable f \u03bc\nhf' : Integrable (fun v \u21a6 \u2016v\u2016 * \u2016f v\u2016) \u03bc\nw : W\nF : W \u2192 V \u2192 E := fun w' v \u21a6 \ud835\udc1e (-(L v) w') \u2022 f v\nF' : W \u2192 V \u2192 W \u2192L[\u211d] E := fun w' v \u21a6 \ud835\udc1e (-(L v) w') \u2022 fourierSMulRight L f v\nB : V \u2192 \u211d := fun v \u21a6 2 * \u03c0 * \u2016L\u2016 * \u2016v\u2016 * \u2016f v\u2016\nh0 : \u2200 (w' : W), Integrable (F w') \u03bc\nh1 : \u2200\u1da0 (w' : W) in \ud835\udcdd w, AEStronglyMeasurable (F w') \u03bc\n\u22a2 Continuous fun v \u21a6 -(L v) w",["fun_prop"]],["CategoryTheory/Preadditive/Biproducts.lean",762,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : Preadditive C\ninst\u271d\u00b2 : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\ninst\u271d\u00b9 : IsIso f\u2081\u2081\ninst\u271d : IsIso (ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082)\nL : X\u2081 \u229e X\u2082 \u2245 X\u2081 \u229e X\u2082\nR : Y\u2081 \u229e Y\u2082 \u2245 Y\u2081 \u229e Y\u2082\ng : X\u2082 \u27f6 Y\u2082\nw : L.hom \u226b ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082 \u226b R.hom = biprod.map f\u2081\u2081 g\n\u22a2 IsIso (L.hom \u226b ofComponents f\u2081\u2081 f\u2081\u2082 f\u2082\u2081 f\u2082\u2082 \u226b R.hom)",["infer_instance"]],["CategoryTheory/Preadditive/Biproducts.lean",775,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\ninst\u271d\u00b9 : HasBinaryBiproducts C\nX\u2081 X\u2082 Y\u2081 Y\u2082 : C\nf\u2081\u2081 : X\u2081 \u27f6 Y\u2081\nf\u2081\u2082 : X\u2081 \u27f6 Y\u2082\nf\u2082\u2081 : X\u2082 \u27f6 Y\u2081\nf\u2082\u2082 : X\u2082 \u27f6 Y\u2082\nf : X\u2081 \u229e X\u2082 \u2245 Y\u2081 \u229e Y\u2082\ninst\u271d : IsIso (biprod.inl \u226b f.hom \u226b biprod.fst)\n\u22a2 IsIso f.hom",["infer_instance"]],["CategoryTheory/Preadditive/Biproducts.lean",895,"C : Type u\ninst\u271d\u2078 : Category.{v, u} C\ninst\u271d\u2077 : Preadditive C\nD : Type u'\ninst\u271d\u2076 : Category.{v', u'} D\ninst\u271d\u2075 : Preadditive D\nF : C \u2964 D\ninst\u271d\u2074 : F.PreservesZeroMorphisms\nJ : Type\ninst\u271d\u00b3 : Fintype J\nf : J \u2192 C\ninst\u271d\u00b2 : HasBiproduct f\ninst\u271d\u00b9 : HasBiproduct (F.obj \u2218 f)\ninst\u271d : Mono (F.biproductComparison f)\n\u22a2 HasProduct (F.obj \u2218 f)",["infer_instance"]],["CategoryTheory/Preadditive/Biproducts.lean",904,"C : Type u\ninst\u271d\u2078 : Category.{v, u} C\ninst\u271d\u2077 : Preadditive C\nD : Type u'\ninst\u271d\u2076 : Category.{v', u'} D\ninst\u271d\u2075 : Preadditive D\nF : C \u2964 D\ninst\u271d\u2074 : F.PreservesZeroMorphisms\nJ : Type\ninst\u271d\u00b3 : Fintype J\nf : J \u2192 C\ninst\u271d\u00b2 : HasBiproduct f\ninst\u271d\u00b9 : HasBiproduct (F.obj \u2218 f)\ninst\u271d : Mono (F.biproductComparison f)\nthis\u271d : HasProduct fun b \u21a6 F.obj (f b)\nthat :\n  piComparison F f =\n    (F.mapIso (biproduct.isoProduct f)).inv \u226b F.biproductComparison f \u226b (biproduct.isoProduct (F.obj \u2218 f)).hom\nthis : IsIso (F.biproductComparison f)\n\u22a2 IsIso ((F.mapIso (biproduct.isoProduct f)).inv \u226b F.biproductComparison f \u226b (biproduct.isoProduct (F.obj \u2218 f)).hom)",["infer_instance"]],["CategoryTheory/Preadditive/Biproducts.lean",1012,"C : Type u\ninst\u271d\u2077 : Category.{v, u} C\ninst\u271d\u2076 : Preadditive C\nD : Type u'\ninst\u271d\u2075 : Category.{v', u'} D\ninst\u271d\u2074 : Preadditive D\nF : C \u2964 D\ninst\u271d\u00b3 : F.PreservesZeroMorphisms\nX Y : C\ninst\u271d\u00b2 : HasBinaryBiproduct X Y\ninst\u271d\u00b9 : HasBinaryBiproduct (F.obj X) (F.obj Y)\ninst\u271d : Mono (F.biprodComparison X Y)\nthat :\n  prodComparison F X Y =\n    (F.mapIso (biprod.isoProd X Y)).inv \u226b F.biprodComparison X Y \u226b (biprod.isoProd (F.obj X) (F.obj Y)).hom\nthis : IsIso (F.biprodComparison X Y)\n\u22a2 IsIso ((F.mapIso (biprod.isoProd X Y)).inv \u226b F.biprodComparison X Y \u226b (biprod.isoProd (F.obj X) (F.obj Y)).hom)",["infer_instance"]],["Analysis/Complex/PhragmenLindelof.lean",66,"E : Type u_1\ninst\u271d : NormedAddCommGroup E\na : \u211d\nf g : \u2102 \u2192 E\nl : Filter \u2102\nu : \u2102 \u2192 \u211d\nhBf : \u2203 c < a, \u2203 B, f =O[l] fun z \u21a6 expR (B * expR (c * |u z|))\nhBg : \u2203 c < a, \u2203 B, g =O[l] fun z \u21a6 expR (B * expR (c * |u z|))\nc\u2081\u271d c\u2082\u271d B\u2081\u271d B\u2082\u271d : \u211d\nhc : c\u2081\u271d \u2264 c\u2082\u271d\nhB\u2080 : 0 \u2264 B\u2082\u271d\nhB : B\u2081\u271d \u2264 B\u2082\u271d\nz : \u2102\n\u22a2 expR (B\u2081\u271d * expR (c\u2081\u271d * |u z|)) \u2264 expR (B\u2082\u271d * expR (c\u2082\u271d * |u z|))",["gcongr"]],["Data/ZMod/Basic.lean",677,"m n : \u2115\n\u22a2 Nontrivial\n    (match 0 with\n    | 0 => \u2124\n    | n.succ => Fin (n + 1))",["infer_instance"]],["Data/ZMod/Basic.lean",888,"case mpr\n\u22a2 Subsingleton (ZMod 1)",["infer_instance"]],["Combinatorics/SimpleGraph/Subgraph.lean",703,"case intro\n\u03b9 : Sort u_1\nV : Type u\nW : Type v\nG : SimpleGraph V\nG\u2081 G\u2082 : G.Subgraph\na b : V\ninst\u271d : Finite V\nval\u271d : Fintype V\n\u22a2 Finite G.Subgraph",["infer_instance"]],["Topology/Algebra/Monoid.lean",87,"\u03b1 : Type u_6\n\u03b2 : Type u_7\nF : Type u_8\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : MulOneClass \u03b2\ninst\u271d\u00b9 : MonoidHomClass F \u03b1 \u03b2\nt\u03b2 : TopologicalSpace \u03b2\ninst\u271d : ContinuousMul \u03b2\nf : F\nt\u03b1 : TopologicalSpace \u03b1 := TopologicalSpace.induced (\u21d1f) t\u03b2\n\u22a2 Continuous fun x \u21a6 f x.1 * f x.2",["fun_prop"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",53,"\u22a2 Continuous fun z \u21a6 (cexp (-z * I) - cexp (z * I)) * I / 2",["fun_prop"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",62,"\u22a2 Continuous fun z \u21a6 (cexp (z * I) + cexp (-z * I)) / 2",["fun_prop"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",71,"\u22a2 Continuous fun z \u21a6 (cexp z - cexp (-z)) / 2",["fun_prop"]],["Analysis/SpecialFunctions/Trigonometric/Basic.lean",76,"\u22a2 Continuous fun z \u21a6 (cexp z + cexp (-z)) / 2",["fun_prop"]],["CategoryTheory/Limits/Shapes/Biproducts.lean",600,"J\u271d : Type w\nC\u271d : Type uC\ninst\u271d\u2078 : Category.{uC', uC} C\u271d\ninst\u271d\u2077 : HasZeroMorphisms C\u271d\nD : Type uD\ninst\u271d\u2076 : Category.{uD', uD} D\ninst\u271d\u2075 : HasZeroMorphisms D\nF : J\u271d \u2192 C\u271d\nJ : Type w\nK : Type u_1\nC : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroMorphisms C\nf g : J \u2192 C\ninst\u271d\u00b2 : HasBiproduct f\ninst\u271d\u00b9 : HasBiproduct g\np : (j : J) \u2192 f j \u27f6 g j\ninst\u271d : \u2200 (j : J), Epi (p j)\nthis : map p = (isoCoproduct f).hom \u226b Sigma.map p \u226b (isoCoproduct g).inv\n\u22a2 Epi ((isoCoproduct f).hom \u226b Sigma.map p \u226b (isoCoproduct g).inv)",["infer_instance"]],["CategoryTheory/Limits/Shapes/Biproducts.lean",606,"J\u271d : Type w\nC\u271d : Type uC\ninst\u271d\u2078 : Category.{uC', uC} C\u271d\ninst\u271d\u2077 : HasZeroMorphisms C\u271d\nD : Type uD\ninst\u271d\u2076 : Category.{uD', uD} D\ninst\u271d\u2075 : HasZeroMorphisms D\nF : J\u271d \u2192 C\u271d\nJ : Type w\nK : Type u_1\nC : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroMorphisms C\nf g : J \u2192 C\ninst\u271d\u00b2 : HasBiproduct f\ninst\u271d\u00b9 : HasBiproduct g\np : (j : J) \u2192 f j \u27f6 g j\ninst\u271d : \u2200 (j : J), Epi (p j)\n\u22a2 Epi ((biproduct.isoProduct f).inv \u226b biproduct.map p \u226b (biproduct.isoProduct g).hom)",["infer_instance"]],["CategoryTheory/Limits/Shapes/Biproducts.lean",612,"J\u271d : Type w\nC\u271d : Type uC\ninst\u271d\u2078 : Category.{uC', uC} C\u271d\ninst\u271d\u2077 : HasZeroMorphisms C\u271d\nD : Type uD\ninst\u271d\u2076 : Category.{uD', uD} D\ninst\u271d\u2075 : HasZeroMorphisms D\nF : J\u271d \u2192 C\u271d\nJ : Type w\nK : Type u_1\nC : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroMorphisms C\nf g : J \u2192 C\ninst\u271d\u00b2 : HasBiproduct f\ninst\u271d\u00b9 : HasBiproduct g\np : (j : J) \u2192 f j \u27f6 g j\ninst\u271d : \u2200 (j : J), Mono (p j)\n\u22a2 Mono ((isoProduct f).hom \u226b Pi.map p \u226b (isoProduct g).inv)",["infer_instance"]],["CategoryTheory/Limits/Shapes/Biproducts.lean",618,"J\u271d : Type w\nC\u271d : Type uC\ninst\u271d\u2078 : Category.{uC', uC} C\u271d\ninst\u271d\u2077 : HasZeroMorphisms C\u271d\nD : Type uD\ninst\u271d\u2076 : Category.{uD', uD} D\ninst\u271d\u2075 : HasZeroMorphisms D\nF : J\u271d \u2192 C\u271d\nJ : Type w\nK : Type u_1\nC : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroMorphisms C\nf g : J \u2192 C\ninst\u271d\u00b2 : HasBiproduct f\ninst\u271d\u00b9 : HasBiproduct g\np : (j : J) \u2192 f j \u27f6 g j\ninst\u271d : \u2200 (j : J), Mono (p j)\n\u22a2 Mono ((biproduct.isoCoproduct f).inv \u226b biproduct.map p \u226b (biproduct.isoCoproduct g).hom)",["infer_instance"]],["Topology/Constructions/SumProd.lean",145,"X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\n\u22a2 Continuous fun y \u21a6 (x, y)",["fun_prop"]],["Topology/Constructions/SumProd.lean",151,"X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ny : Y\n\u22a2 Continuous fun x \u21a6 (x, y)",["fun_prop"]],["Topology/Constructions/SumProd.lean",888,"X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\n\u22a2 Continuous (Sum.inr \u2218 Sum.inr)",["fun_prop"]],["Topology/Constructions/SumProd.lean",892,"X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\n\u22a2 Continuous (Sum.elim (Sum.inl \u2218 Sum.inr) Sum.inr)",["fun_prop"]],["Topology/Constructions/SumProd.lean",910,"X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace W\ninst\u271d\u00b2 : TopologicalSpace Z\nX' : Type u_5\nY' : Type u_6\ninst\u271d\u00b9 : TopologicalSpace X'\ninst\u271d : TopologicalSpace Y'\nthis : Continuous (Sum.map (Sum.map id \u21d1(Equiv.sumComm Y W)) id)\n\u22a2 Continuous\n    (\u21d1(Equiv.sumAssoc (X \u2295 W) Y Z) \u2218\n      Sum.map (\u21d1(Equiv.sumAssoc X W Y).symm) id \u2218\n        Sum.map (Sum.map id \u21d1(Equiv.sumComm Y W)) id \u2218\n          Sum.map (\u21d1(Equiv.sumAssoc X Y W)) id \u2218 \u21d1(Equiv.sumAssoc (X \u2295 Y) W Z).symm)",["fun_prop"]],["Topology/Constructions/SumProd.lean",915,"X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace W\ninst\u271d\u00b2 : TopologicalSpace Z\nX' : Type u_5\nY' : Type u_6\ninst\u271d\u00b9 : TopologicalSpace X'\ninst\u271d : TopologicalSpace Y'\nthis : Continuous (Sum.map (Sum.map id \u21d1(Equiv.sumComm Y W).symm) id)\n\u22a2 Continuous\n    (\u21d1(Equiv.sumAssoc (X \u2295 Y) W Z) \u2218\n      Sum.map (\u21d1(Equiv.sumAssoc X Y W).symm) id \u2218\n        Sum.map (Sum.map id \u21d1(Equiv.sumComm Y W).symm) id \u2218\n          Sum.map (\u21d1(Equiv.sumAssoc X W Y)) id \u2218 \u21d1(Equiv.sumAssoc (X \u2295 W) Y Z).symm)",["fun_prop"]],["Topology/Constructions/SumProd.lean",952,"X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace W\ninst\u271d\u00b2 : TopologicalSpace Z\nX' : Type u_5\nY' : Type u_6\ninst\u271d\u00b9 : TopologicalSpace X'\ninst\u271d : TopologicalSpace Y'\n\u22a2 Continuous fun abcd \u21a6 ((abcd.1.1, abcd.2.1), abcd.1.2, abcd.2.2)",["fun_prop"]],["Topology/Constructions/SumProd.lean",956,"X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace W\ninst\u271d\u00b2 : TopologicalSpace Z\nX' : Type u_5\nY' : Type u_6\ninst\u271d\u00b9 : TopologicalSpace X'\ninst\u271d : TopologicalSpace Y'\n\u22a2 Continuous fun acbd \u21a6 ((acbd.1.1, acbd.2.1), acbd.1.2, acbd.2.2)",["fun_prop"]],["Topology/Constructions/SumProd.lean",979,"X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2076 : TopologicalSpace X\ninst\u271d\u2075 : TopologicalSpace Y\ninst\u271d\u2074 : TopologicalSpace W\ninst\u271d\u00b3 : TopologicalSpace Z\nX' : Type u_5\nY' : Type u_6\ninst\u271d\u00b2 : TopologicalSpace X'\ninst\u271d\u00b9 : TopologicalSpace Y'\ninst\u271d : IsEmpty Y\n\u22a2 Continuous fun a \u21a6 isEmptyElim a",["fun_prop","infer_instance"]],["MeasureTheory/Measure/Lebesgue/EqHaar.lean",607,"case h\nE : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : BorelSpace E\ninst\u271d\u00b9 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\ns : Set E\nx : E\nh : Tendsto (fun r \u21a6 \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd 0)\nt u : Set E\nh'u : \u03bc u \u2260 0\nt_bound : t \u2286 closedBall 0 1\nr : \u211d\nrpos : 0 < r\n\u22a2 \u03bc (s \u2229 (fun x_1 \u21a6 x + x_1) '' (r \u2022 t)) / \u03bc ((fun x_1 \u21a6 x +\u1d65 x_1) '' (r \u2022 closedBall 0 1)) \u2264\n    \u03bc (s \u2229 (fun x_1 \u21a6 x +\u1d65 x_1) '' (r \u2022 closedBall 0 1)) / \u03bc ((fun x_1 \u21a6 x +\u1d65 x_1) '' (r \u2022 closedBall 0 1))",["gcongr"]],["MeasureTheory/Measure/Lebesgue/EqHaar.lean",722,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : BorelSpace E\ninst\u271d\u00b9 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\ns : Set E\nx : E\nh : Tendsto (fun r \u21a6 \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd 0)\nt : Set E\nht : MeasurableSet t\nh''t : \u03bc t \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\n\u03b5pos : 0 < \u03b5\nh't : \u03bc t \u2260 0\nn : \u2115\nnpos : 0 < n\nhn : \u03bc (t \\ closedBall 0 \u2191n) < \u03b5 / 2 * \u03bc t\nL : Tendsto (fun r \u21a6 \u03bc (s \u2229 ({x} + r \u2022 (t \u2229 closedBall 0 \u2191n))) / \u03bc ({x} + r \u2022 t)) (\ud835\udcdd[>] 0) (\ud835\udcdd 0)\nr : \u211d\nhr : \u03bc (s \u2229 ({x} + r \u2022 (t \u2229 closedBall 0 \u2191n))) / \u03bc ({x} + r \u2022 t) < \u03b5 / 2\nrpos : 0 < r\nI : \u03bc (s \u2229 ({x} + r \u2022 t)) \u2264 \u03bc (s \u2229 ({x} + r \u2022 (t \u2229 closedBall 0 \u2191n))) + \u03bc ({x} + r \u2022 (t \\ closedBall 0 \u2191n))\n\u22a2 \u03bc (s \u2229 ({x} + r \u2022 t)) / \u03bc ({x} + r \u2022 t) \u2264\n    (\u03bc (s \u2229 ({x} + r \u2022 (t \u2229 closedBall 0 \u2191n))) + \u03bc ({x} + r \u2022 (t \\ closedBall 0 \u2191n))) / \u03bc ({x} + r \u2022 t)",["gcongr"]],["MeasureTheory/Measure/Lebesgue/EqHaar.lean",232,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : BorelSpace E\ninst\u271d\u00b9 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nf : E \u2192\u2097[\u211d] E\nhf : LinearMap.det f \u2260 0\n\u03b9 : Type := Fin (finrank \u211d E)\n\u22a2 FiniteDimensional \u211d (\u03b9 \u2192 \u211d)",["infer_instance"]],["MeasureTheory/Measure/Lebesgue/EqHaar.lean",565,"E : Type u_1\ninst\u271d\u00b9\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : NormedSpace \u211d E\ninst\u271d\u00b9\u2070 : MeasurableSpace E\ninst\u271d\u2079 : BorelSpace E\ninst\u271d\u2078 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u2077 : \u03bc.IsAddHaarMeasure\ns : Set E\n\u03b9 : Type u_2\nG : Type u_3\ninst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : NormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \u211d G\ninst\u271d\u00b2 : MeasurableSpace G\ninst\u271d\u00b9 : BorelSpace G\ninst\u271d : FiniteDimensional \u211d G\nn : \u2115\n_i : Fact (finrank \u211d G = n)\n\u03c9 : G [\u22c0^Fin n]\u2192\u2097[\u211d] \u211d\n\u22a2 (\u2016\u03c9 \u21d1(finBasisOfFinrankEq \u211d G \u22ef)\u2016\u208a \u2022 (finBasisOfFinrankEq \u211d G \u22ef).addHaar).IsAddLeftInvariant",["infer_instance"]],["MeasureTheory/Measure/Lebesgue/EqHaar.lean",568,"E : Type u_1\ninst\u271d\u00b9\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : NormedSpace \u211d E\ninst\u271d\u00b9\u2070 : MeasurableSpace E\ninst\u271d\u2079 : BorelSpace E\ninst\u271d\u2078 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u2077 : \u03bc.IsAddHaarMeasure\ns : Set E\n\u03b9 : Type u_2\nG : Type u_3\ninst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : NormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \u211d G\ninst\u271d\u00b2 : MeasurableSpace G\ninst\u271d\u00b9 : BorelSpace G\ninst\u271d : FiniteDimensional \u211d G\nn : \u2115\n_i : Fact (finrank \u211d G = n)\n\u03c9 : G [\u22c0^Fin n]\u2192\u2097[\u211d] \u211d\n\u22a2 IsLocallyFiniteMeasure (\u2016\u03c9 \u21d1(finBasisOfFinrankEq \u211d G \u22ef)\u2016\u208a \u2022 (finBasisOfFinrankEq \u211d G \u22ef).addHaar)",["infer_instance"]],["Geometry/Euclidean/Angle/Oriented/Affine.lean",615,"V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\nhd2 : Fact (finrank \u211d V = 2)\ninst\u271d : Oriented \u211d V (Fin 2)\np\u2081 p\u2082 p\u2083 p\u2084 p\u2085 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2083p\u2084 : p\u2083 \u2260 p\u2084\nhc : Collinear \u211d {p\u2081, p\u2082, p\u2083, p\u2084}\nhr : SameRay \u211d (p\u2082 -\u1d65 p\u2081) (p\u2084 -\u1d65 p\u2083)\nhc\u2085\u2081\u2082 : \u00acCollinear \u211d {p\u2085, p\u2081, p\u2082}\ns : Set (P \u00d7 P \u00d7 P) := (fun x \u21a6 (\u2191x.1, p\u2085, x.2 +\u1d65 \u2191x.1)) '' Set.univ \u00d7\u02e2 {v | SameRay \u211d (p\u2082 -\u1d65 p\u2081) v \u2227 v \u2260 0}\nthis : ConnectedSpace \u21a5(affineSpan \u211d {p\u2081, p\u2082})\n\u22a2 ContinuousOn (fun x \u21a6 (\u2191x.1, p\u2085, x.2 +\u1d65 \u2191x.1)) (Set.univ \u00d7\u02e2 {y | SameRay \u211d (p\u2082 -\u1d65 p\u2081) y \u2227 y \u2260 0})",["fun_prop"]],["Geometry/Euclidean/Angle/Oriented/Affine.lean",711,"V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : InnerProductSpace \u211d V\ninst\u271d\u00b2 : MetricSpace P\ninst\u271d\u00b9 : NormedAddTorsor V P\nhd2 : Fact (finrank \u211d V = 2)\ninst\u271d : Oriented \u211d V (Fin 2)\ns : AffineSubspace \u211d P\np\u2081 p\u2082 p\u2083 p\u2084 : P\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083p\u2084 : s.SSameSide p\u2083 p\u2084\nh : \u00acp\u2081 = p\u2082\nsp : Set (P \u00d7 P \u00d7 P) := (fun p \u21a6 (p\u2081, p, p\u2082)) '' {p | s.SSameSide p\u2083 p}\n\u22a2 ContinuousOn (fun p \u21a6 (p\u2081, p, p\u2082)) {y | s.SSameSide p\u2083 y}",["fun_prop"]],["SetTheory/Game/Basic.lean",962,"case refine_4\n\u22a2 IsEmpty (InvTy { i // 0 < i.elim } PEmpty.{?u.748178 + 1} true)",["infer_instance"]],["SetTheory/Game/Basic.lean",979,"\u22a2 IsEmpty { _i // False }",["infer_instance"]],["Analysis/Normed/Algebra/Spectrum.lean",632,"\ud835\udd5c : Type u_3\nA : Type u_4\nSA : Type u_5\ninst\u271d\u2075 : NormedRing A\ninst\u271d\u2074 : CompleteSpace A\ninst\u271d\u00b3 : SetLike SA A\ninst\u271d\u00b2 : SubringClass SA A\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : NormedAlgebra \ud835\udd5c A\ninstSMulMem : SMulMemClass SA \ud835\udd5c A\nS : SA\nhS : IsClosed \u2191S\nx : \u21a5S\nthis : CompleteSpace \u21a5S\n\u03bc : \ud835\udd5c\nh : IsUnit ((algebraMap \ud835\udd5c A) \u03bc - \u2191x)\nh\u03bc\u2081 : ClusterPt \u03bc (\ud835\udcdf (\u03c3 \ud835\udd5c x)\u1d9c)\nh\u03bc\u2082 : \u03bc \u2209 (\u03c3 \ud835\udd5c x)\u1d9c\n\u22a2 ContinuousAt (fun x_1 \u21a6 (algebraMap \ud835\udd5c \u21a5S) x_1 - x) \u03bc",["fun_prop"]],["Algebra/Polynomial/Basic.lean",1140,"R : Type u\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\n\u22a2 Nontrivial R[\u2115]",["infer_instance"]],["Analysis/InnerProductSpace/Basic.lean",787,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nx y : E\nhle : \u2016x\u2016 \u2264 \u2016y\u2016\nh : re \u27eax, y\u27eb_\ud835\udd5c = \u2016y\u2016 ^ 2\n\u22a2 \u2016x\u2016 ^ 2 \u2264 \u2016y\u2016 ^ 2",["gcongr"]],["Analysis/SpecificLimits/Normed.lean",813,"x : \u211d\nA : 0 < \u2191\u230a\u2016x\u2016\u230b\u208a + 1\nB : \u2016x\u2016 / (\u2191\u230a\u2016x\u2016\u230b\u208a + 1) < 1\nn : \u2115\nhn : n \u2265 \u230a\u2016x\u2016\u230b\u208a\n\u22a2 \u2016x\u2016 / (\u2191n + 1) * \u2016x ^ n / \u2191n !\u2016 \u2264 \u2016x\u2016 / (\u2191\u230a\u2016x\u2016\u230b\u208a + 1) * \u2016x ^ n / \u2191n !\u2016",["gcongr"]],["CategoryTheory/Limits/Shapes/BinaryBiproducts.lean",672,"J : Type w\nC : Type uC\ninst\u271d\u2077 : Category.{uC', uC} C\ninst\u271d\u2076 : HasZeroMorphisms C\nD : Type uD\ninst\u271d\u2075 : Category.{uD', uD} D\ninst\u271d\u2074 : HasZeroMorphisms D\nP Q W X Y Z : C\nf : W \u27f6 Y\ng : X \u27f6 Z\ninst\u271d\u00b3 : Epi f\ninst\u271d\u00b2 : Epi g\ninst\u271d\u00b9 : HasBinaryBiproduct W X\ninst\u271d : HasBinaryBiproduct Y Z\n\u22a2 Epi ((isoCoprod W X).hom \u226b coprod.map f g \u226b (isoCoprod Y Z).inv)",["infer_instance"]],["CategoryTheory/Limits/Shapes/BinaryBiproducts.lean",678,"J : Type w\nC : Type uC\ninst\u271d\u2077 : Category.{uC', uC} C\ninst\u271d\u2076 : HasZeroMorphisms C\nD : Type uD\ninst\u271d\u2075 : Category.{uD', uD} D\ninst\u271d\u2074 : HasZeroMorphisms D\nP Q W X Y Z : C\nf : W \u27f6 Y\ng : X \u27f6 Z\ninst\u271d\u00b3 : Epi f\ninst\u271d\u00b2 : Epi g\ninst\u271d\u00b9 : HasBinaryBiproduct W X\ninst\u271d : HasBinaryBiproduct Y Z\n\u22a2 Epi ((biprod.isoProd W X).inv \u226b biprod.map f g \u226b (biprod.isoProd Y Z).hom)",["infer_instance"]],["CategoryTheory/Limits/Shapes/BinaryBiproducts.lean",684,"J : Type w\nC : Type uC\ninst\u271d\u2077 : Category.{uC', uC} C\ninst\u271d\u2076 : HasZeroMorphisms C\nD : Type uD\ninst\u271d\u2075 : Category.{uD', uD} D\ninst\u271d\u2074 : HasZeroMorphisms D\nP Q W X Y Z : C\nf : W \u27f6 Y\ng : X \u27f6 Z\ninst\u271d\u00b3 : Mono f\ninst\u271d\u00b2 : Mono g\ninst\u271d\u00b9 : HasBinaryBiproduct W X\ninst\u271d : HasBinaryBiproduct Y Z\n\u22a2 Mono ((isoProd W X).hom \u226b prod.map f g \u226b (isoProd Y Z).inv)",["infer_instance"]],["CategoryTheory/Limits/Shapes/BinaryBiproducts.lean",690,"J : Type w\nC : Type uC\ninst\u271d\u2077 : Category.{uC', uC} C\ninst\u271d\u2076 : HasZeroMorphisms C\nD : Type uD\ninst\u271d\u2075 : Category.{uD', uD} D\ninst\u271d\u2074 : HasZeroMorphisms D\nP Q W X Y Z : C\nf : W \u27f6 Y\ng : X \u27f6 Z\ninst\u271d\u00b3 : Mono f\ninst\u271d\u00b2 : Mono g\ninst\u271d\u00b9 : HasBinaryBiproduct W X\ninst\u271d : HasBinaryBiproduct Y Z\n\u22a2 Mono ((biprod.isoCoprod W X).inv \u226b biprod.map f g \u226b (biprod.isoCoprod Y Z).hom)",["infer_instance"]],["Algebra/Lie/Nilpotent.lean",434,"case inl\nL : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : IsNilpotent L M\nh\u271d : nilpotencyLength L M \u2264 1\na\u271d : Nontrivial M\nh : Subsingleton M\n\u22a2 IsTrivial L M",["infer_instance"]],["NumberTheory/Padics/PadicNumbers.lean",453,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 Zero \u211a_[p]",["infer_instance"]],["NumberTheory/Padics/PadicNumbers.lean",455,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 One \u211a_[p]",["infer_instance"]],["NumberTheory/Padics/PadicNumbers.lean",467,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 AddCommGroup \u211a_[p]",["infer_instance"]],["GroupTheory/CoprodI.lean",98,"\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\n\u22a2 Monoid (conGen (Monoid.CoprodI.Rel M)).Quotient",["infer_instance"]],["AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean",811,"R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u2115 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\nf : A\nm : \u2115\nf_deg : f \u2208 \ud835\udc9c m\nhm : 0 < m\nthis : IsIso (toSpec \ud835\udc9c f).base\nx : \u2191(Proj.restrict \u22ef).toTopCat\n\u22a2 IsIso\n    ((specStalkEquiv \ud835\udc9c f x f_deg hm).hom \u226b (\u00abProj\u00bb.stalkIso' \ud835\udc9c \u2191x).toCommRingCatIso.inv \u226b (Proj.restrictStalkIso \u22ef x).inv)",["infer_instance"]],["Probability/Independence/Basic.lean",660,"\u03a9 : Type u_1\n\u03b9 : Type u_2\n_m\u03a9 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\n\u03b2 : \u03b9 \u2192 Type u_10\nm : (i : \u03b9) \u2192 MeasurableSpace (\u03b2 i)\nf : (i : \u03b9) \u2192 \u03a9 \u2192 \u03b2 i\nh_indep : iIndepFun f \u03bc\nhf : \u2200 (i : \u03b9), Measurable (f i)\ni\u271d j\u271d k l : \u03b9\nhik : i\u271d \u2260 k\nhil : i\u271d \u2260 l\nhjk : j\u271d \u2260 k\nhjl : j\u271d \u2260 l\ng : (i j : \u03b9) \u2192 ((x : { x // x \u2208 {i, j} }) \u2192 \u03b2 \u2191x) \u2192 \u03b2 i \u00d7 \u03b2 j := fun i j v \u21a6 (v \u27e8i, \u22ef\u27e9, v \u27e8j, \u22ef\u27e9)\ni j : \u03b9\n\u22a2 Measurable (g i j)",["fun_prop"]],["Order/KrullDimension.lean",289,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\nhab : a < b\nhfin : height a = \u22a4\n\u22a2 height a \u2264 height b",["gcongr"]],["Order/KrullDimension.lean",307,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\nhab : b < a\nhfin : coheight a = \u22a4\n\u22a2 coheight a \u2264 coheight b",["gcongr"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",635,"F : Type u_3\ninst\u271d\u2078 : NormedAddCommGroup F\ninst\u271d\u2077 : NormedSpace \u211d F\nE : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\ninst\u271d\u2074 : MeasurableSpace E\ninst\u271d\u00b3 : BorelSpace E\ninst\u271d\u00b2 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : FiniteDimensional \u211d F\nu : E \u2192 F\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\np p' : \u211d\u22650\nhp : 1 \u2264 p\nhn : 0 < finrank \u211d E\nhp' : (\u2191p')\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191(finrank \u211d E))\u207b\u00b9\nF' : Type := EuclideanSpace \u211d (Fin (finrank \u211d F))\ne : F \u2243L[\u211d] F' := toEuclidean\nC\u2081 : \u211d\u22650 := \u2016\u2191e.symm\u2016\u208a\nC : \u211d\u22650 := eLpNormLESNormFDerivOfEqInnerConst \u03bc \u2191p\nC\u2082 : \u211d\u22650 := \u2016\u2191e\u2016\u208a\nv : E \u2192 F' := \u21d1e \u2218 u\nhv : ContDiff \u211d 1 v\nh2v : HasCompactSupport v\nthis : eLpNorm v (\u2191p') \u03bc \u2264 \u2191(eLpNormLESNormFDerivOfEqInnerConst \u03bc \u2191p) * eLpNorm (fderiv \u211d v) (\u2191p) \u03bc\nh4v : \u2200 (x : E), \u2016fderiv \u211d v x\u2016 \u2264 \u2191C\u2082 * \u2016fderiv \u211d u x\u2016\n\u22a2 \u2191C\u2081 * eLpNorm v (\u2191p') \u03bc \u2264 \u2191C\u2081 * (\u2191C * eLpNorm (fderiv \u211d v) (\u2191p) \u03bc)",["gcongr"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",329,"\u03b9 : Type u_1\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : Fintype \u03b9\np : \u211d\nhp : (\u2191#\u03b9).IsConjExponent p\nu : (\u03b9 \u2192 \u211d) \u2192 F\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\nthis\u271d : 1 \u2264 \u2191#\u03b9 - 1\nthis : Continuous (fderiv \u211d u)\n\u22a2 Measurable fun x \u21a6 \u2016fderiv \u211d u x\u2016\u2091",["fun_prop"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",428,"F : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \u211d F\nE : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : BorelSpace E\ninst\u271d\u00b9 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nu : E \u2192 F\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\np : \u211d\nhp\u271d : (\u2191(finrank \u211d E)).IsConjExponent p\nC : \u211d\u22650 := lintegralPowLePowLIntegralFDerivConst \u03bc p\n\u03b9 : Type := Fin (finrank \u211d E)\nh\u03b9card : #\u03b9 = finrank \u211d E\nthis\u271d\u00b9 : finrank \u211d E = finrank \u211d (\u03b9 \u2192 \u211d)\ne : E \u2243L[\u211d] \u03b9 \u2192 \u211d := ContinuousLinearEquiv.ofFinrankEq this\u271d\u00b9\nthis\u271d : (Measure.map (\u21d1e.symm) volume).IsAddHaarMeasure\nhp : (\u2191#\u03b9).IsConjExponent p\nh0p : 0 \u2264 p\nc : \u211d\u22650 := \u03bc.addHaarScalarFactor (Measure.map (\u21d1e.symm) volume)\nhc : 0 < c\nh2c : \u03bc = c \u2022 Measure.map (\u21d1e.symm) volume\nh3c : \u2191c \u2260 0\nh0C : C = c * \u2016\u2191e.symm\u2016\u208a ^ p * (c ^ p)\u207b\u00b9\nhC : C * c ^ p = c * \u2016\u2191e.symm\u2016\u208a ^ p\nv : (\u03b9 \u2192 \u211d) \u2192 F := u \u2218 \u21d1e.symm\nhv : ContDiff \u211d 1 v\nh2v : HasCompactSupport v\nthis : Continuous (fderiv \u211d u)\n\u22a2 Measurable fun x \u21a6 \u2016fderiv \u211d u x\u2016\u2091",["fun_prop"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",560,"E : Type u_4\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : MeasurableSpace E\ninst\u271d\u2075 : BorelSpace E\ninst\u271d\u2074 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b3 : \u03bc.IsAddHaarMeasure\nF' : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup F'\ninst\u271d\u00b9 : InnerProductSpace \u211d F'\ninst\u271d : CompleteSpace F'\nu : E \u2192 F'\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\np p' : \u211d\u22650\nhp\u271d : 1 \u2264 p\nhp'0 : \u00acp' = 0\nn : \u2115 := finrank \u211d E\nhn\u271d : 0 < n\nhp' : (\u2191p')\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191n)\u207b\u00b9\nn' : \u211d\u22650 := (\u2191n).conjExponent\nh2p : \u2191p < \u2191n\nh0n : 2 \u2264 n\nhn : (\u2191n).IsConjExponent n'\nh1n : 1 \u2264 \u2191n\nh2n : 0 < \u2191n - 1\nhnp : 0 < \u2191n - \u2191p\nhp : 1 < p\nq : \u211d := (\u2191p).conjExponent\nhq : (\u2191p).IsConjExponent q\nh0p : p \u2260 0\nh1p : \u2191p \u2260 1\nh3p : \u2191p - 1 \u2260 0\nh0p' : p' \u2260 0\nh2q : 1 / \u2191n' - 1 / q = 1 / \u2191p'\n\u03b3 : \u211d\u22650 := \u27e8\u2191p * (\u2191n - 1) / (\u2191n - \u2191p), \u22ef\u27e9\nh0\u03b3 : \u2191\u03b3 = \u2191p * (\u2191n - 1) / (\u2191n - \u2191p)\nh1\u03b3 : 1 < \u2191\u03b3\nh2\u03b3 : \u03b3 * n' = p'\nh3\u03b3 : (\u2191\u03b3 - 1) * q = \u2191p'\nh4\u03b3 : \u2191\u03b3 \u2260 0\nh3u : \u00ac\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc = 0\nh4u : \u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc \u2260 \u22a4\nh5u : (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q) \u2260 0\nh6u : (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q) \u2260 \u22a4\nh7u : Continuous u\nh8u : Continuous (fderiv \u211d u)\nv : E \u2192 \u211d := fun x \u21a6 \u2016u x\u2016 ^ \u2191\u03b3\nhv : ContDiff \u211d 1 v\nh2v : HasCompactSupport v\nC : \u211d\u22650 := eLpNormLESNormFDerivOneConst \u03bc \u2191n'\n\u22a2 Measurable fun x \u21a6 \u2191\u2016u x\u2016\u208a ^ (\u2191\u03b3 - 1) * \u2191\u2016fderiv \u211d u x\u2016\u208a",["fun_prop"]],["Analysis/FunctionalSpaces/SobolevInequality.lean",568,"case bc.convert_3\nE : Type u_4\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : MeasurableSpace E\ninst\u271d\u2075 : BorelSpace E\ninst\u271d\u2074 : FiniteDimensional \u211d E\n\u03bc : Measure E\ninst\u271d\u00b3 : \u03bc.IsAddHaarMeasure\nF' : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup F'\ninst\u271d\u00b9 : InnerProductSpace \u211d F'\ninst\u271d : CompleteSpace F'\nu : E \u2192 F'\nhu : ContDiff \u211d 1 u\nh2u : HasCompactSupport u\np p' : \u211d\u22650\nhp\u271d : 1 \u2264 p\nhp'0 : \u00acp' = 0\nn : \u2115 := finrank \u211d E\nhn\u271d : 0 < n\nhp' : (\u2191p')\u207b\u00b9 = \u2191p\u207b\u00b9 - (\u2191n)\u207b\u00b9\nn' : \u211d\u22650 := (\u2191n).conjExponent\nh2p : \u2191p < \u2191n\nh0n : 2 \u2264 n\nhn : (\u2191n).IsConjExponent n'\nh1n : 1 \u2264 \u2191n\nh2n : 0 < \u2191n - 1\nhnp : 0 < \u2191n - \u2191p\nhp : 1 < p\nq : \u211d := (\u2191p).conjExponent\nhq : (\u2191p).IsConjExponent q\nh0p : p \u2260 0\nh1p : \u2191p \u2260 1\nh3p : \u2191p - 1 \u2260 0\nh0p' : p' \u2260 0\nh2q : 1 / \u2191n' - 1 / q = 1 / \u2191p'\n\u03b3 : \u211d\u22650 := \u27e8\u2191p * (\u2191n - 1) / (\u2191n - \u2191p), \u22ef\u27e9\nh0\u03b3 : \u2191\u03b3 = \u2191p * (\u2191n - 1) / (\u2191n - \u2191p)\nh1\u03b3 : 1 < \u2191\u03b3\nh2\u03b3 : \u03b3 * n' = p'\nh3\u03b3 : (\u2191\u03b3 - 1) * q = \u2191p'\nh4\u03b3 : \u2191\u03b3 \u2260 0\nh3u : \u00ac\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc = 0\nh4u : \u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc \u2260 \u22a4\nh5u : (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q) \u2260 0\nh6u : (\u222b\u207b (x : E), \u2016u x\u2016\u2091 ^ \u2191p' \u2202\u03bc) ^ (1 / q) \u2260 \u22a4\nh7u : Continuous u\nh8u : Continuous (fderiv \u211d u)\nv : E \u2192 \u211d := fun x \u21a6 \u2016u x\u2016 ^ \u2191\u03b3\nhv : ContDiff \u211d 1 v\nh2v : HasCompactSupport v\nC : \u211d\u22650 := eLpNormLESNormFDerivOneConst \u03bc \u2191n'\nthis\u271d\u00b9 : MeasurableSpace F' := borel F'\nthis\u271d : BorelSpace F'\n\u22a2 AEMeasurable (fun x \u21a6 \u2016u x\u2016\u2091 ^ (\u2191\u03b3 - 1)) \u03bc",["fun_prop"]],["Probability/Independence/Conditional.lean",738,"\u03a9 : Type u_1\n\u03b9 : Type u_2\nm' m\u03a9 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : StandardBorelSpace \u03a9\nhm' : m' \u2264 m\u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsFiniteMeasure \u03bc\n\u03b2 : \u03b9 \u2192 Type u_5\nm : (i : \u03b9) \u2192 MeasurableSpace (\u03b2 i)\nf : (i : \u03b9) \u2192 \u03a9 \u2192 \u03b2 i\nh_indep : iCondIndepFun m' hm' f \u03bc\nhf : \u2200 (i : \u03b9), Measurable (f i)\ni\u271d j\u271d k l : \u03b9\nhik : i\u271d \u2260 k\nhil : i\u271d \u2260 l\nhjk : j\u271d \u2260 k\nhjl : j\u271d \u2260 l\ng : (i j : \u03b9) \u2192 ((x : { x // x \u2208 {i, j} }) \u2192 \u03b2 \u2191x) \u2192 \u03b2 i \u00d7 \u03b2 j := fun i j v \u21a6 (v \u27e8i, \u22ef\u27e9, v \u27e8j, \u22ef\u27e9)\ni j : \u03b9\n\u22a2 Measurable (g i j)",["fun_prop"]],["MeasureTheory/Group/Arithmetic.lean",122,"M : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : MeasurableSpace M\ninst\u271d\u00b9 : Mul M\nm : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\ninst\u271d : MeasurableMul\u2082 M\nf g : \u03b1 \u2192 \u03b2 \u2192 M\nh : \u03b1 \u2192 \u03b2\nhf : Measurable \u21bff\nhg : Measurable \u21bfg\nhh : Measurable h\n\u22a2 Measurable fun a \u21a6 f a (h a) * g a (h a)",["fun_prop"]],["MeasureTheory/Group/Arithmetic.lean",273,"G : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : MeasurableSpace G\ninst\u271d\u00b9 : Div G\nm : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\ninst\u271d : MeasurableDiv\u2082 G\nf g : \u03b1 \u2192 \u03b2 \u2192 G\nh : \u03b1 \u2192 \u03b2\nhf : Measurable \u21bff\nhg : Measurable \u21bfg\nhh : Measurable h\n\u22a2 Measurable fun a \u21a6 f a (h a) / g a (h a)",["fun_prop"]],["MeasureTheory/Group/Arithmetic.lean",546,"M : Type u_2\nX : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b3 : MeasurableSpace M\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : SMul M X\nm : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\ninst\u271d : MeasurableSMul\u2082 M X\nf : \u03b1 \u2192 \u03b2 \u2192 M\ng : \u03b1 \u2192 \u03b2 \u2192 X\nh : \u03b1 \u2192 \u03b2\nhf : Measurable \u21bff\nhg : Measurable \u21bfg\nhh : Measurable h\n\u22a2 Measurable fun a \u21a6 f a (h a) \u2022 g a (h a)",["fun_prop"]],["MeasureTheory/Group/Arithmetic.lean",835,"M : Type u_2\n\u03b9 : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : MeasurableSpace M\ninst\u271d : MeasurableMul\u2082 M\nm : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2 \u2192 M\ng : \u03b1 \u2192 \u03b2\ns : Finset \u03b9\nhf : \u2200 (i : \u03b9), Measurable \u21bf(f i)\nhg : Measurable g\n\u22a2 Measurable fun a \u21a6 \u220f c \u2208 s, f c a (g a)",["fun_prop"]],["NumberTheory/LSeries/HurwitzZetaEven.lean",117,"a' x : \u211d\nhx : x \u2208 Ioi 0\n\u22a2 ContinuousAt (fun u \u21a6 (\u2191a' * I * \u2191u, I * \u2191u)) x",["fun_prop"]],["NumberTheory/LSeries/HurwitzZetaEven.lean",125,"a' x : \u211d\nhx : x \u2208 Ioi 0\n\u22a2 ContinuousAt (fun u \u21a6 (\u2191a', I * \u2191u)) x",["fun_prop"]],["Data/Set/Finite/Basic.lean",407,"case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t : Set \u03b1\ninst\u271d\u00b9 : Finite \u2191s\ninst\u271d : Finite \u2191t\nval\u271d\u00b9 : Fintype \u2191s\nval\u271d : Fintype \u2191t\n\u22a2 Finite \u2191(s \u222a t)",["infer_instance"]],["Data/Set/Finite/Basic.lean",412,"case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : Finite \u2191s\nval\u271d : Fintype \u2191s\n\u22a2 Finite \u2191{a | a \u2208 s \u2227 p a}",["infer_instance"]],["Data/Set/Finite/Basic.lean",416,"\u03b1 : Type u\ns t : Set \u03b1\ninst\u271d : Finite \u2191s\nh : t \u2286 s\n\u22a2 Finite \u2191{x | x \u2208 s \u2227 x \u2208 t}",["infer_instance"]],["Data/Set/Finite/Basic.lean",433,"case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Finite \u2191s\nval\u271d : Fintype \u2191s\n\u22a2 Finite \u2191(f '' s)",["infer_instance"]],["MeasureTheory/Measure/LevyProkhorovMetric.lean",463,"\u03a9 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : PseudoMetricSpace \u03a9\ninst\u271d : OpensMeasurableSpace \u03a9\n\u03bcs : \u2115 \u2192 LevyProkhorov (ProbabilityMeasure \u03a9)\n\u03bd : LevyProkhorov (ProbabilityMeasure \u03a9)\nh\u03bcs : Tendsto \u03bcs atTop (\ud835\udcdd \u03bd)\nP : ProbabilityMeasure \u03a9 := (equiv (ProbabilityMeasure \u03a9)) \u03bd\nPs : \u2115 \u2192 ProbabilityMeasure \u03a9 := fun n \u21a6 (equiv (ProbabilityMeasure \u03a9)) (\u03bcs n)\nf\u271d f : \u03a9 \u2192\u1d47 \u211d\nf_nn : 0 \u2264 f\nf_zero : \u00ac\u2016f\u2016 = 0\nnorm_f_pos : 0 < \u2016f\u2016\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\n\u03b5s : \u2115 \u2192 \u211d\nleft\u271d : StrictAnti \u03b5s\n\u03b5s_lim : Tendsto \u03b5s atTop (\ud835\udcdd 0)\n\u03b5_of_room : Tendsto (fun x \u21a6 dist (\u03bcs x) \u03bd + \u03b5s x) atTop (\ud835\udcdd 0)\n\u03b5_of_room' : Tendsto (fun n \u21a6 dist (\u03bcs n) \u03bd + \u03b5s n) atTop (\ud835\udcdd[>] 0)\nkey :\n  Tendsto ((fun \u03b5 \u21a6 \u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P (thickening \u03b5 {a | t \u2264 f a}))).toReal) \u2218 fun n \u21a6 dist (\u03bcs n) \u03bd + \u03b5s n)\n    atTop (\ud835\udcdd (\u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P {a | t \u2264 f a})).toReal))\naux : \u2200 (z : \u211d), Iio (z + \u03b4 / 2) \u2208 \ud835\udcdd z\nn : \u2115\nhn :\n  ((fun \u03b5 \u21a6 \u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P (thickening \u03b5 {a | t \u2264 f a}))).toReal) \u2218 fun n \u21a6 dist (\u03bcs n) \u03bd + \u03b5s n) n <\n    (\u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191(P {a | t \u2264 f a})).toReal) + \u03b4 / 2\nhn' : dist (\u03bcs n) \u03bd + \u03b5s n < \u2016f\u2016\u207b\u00b9 * \u03b4 / 2\n\u03b5s_pos : 0 < \u03b5s n\nbound :\n  \u222b (\u03c9 : \u03a9), f \u03c9 \u2202\u2191(Ps n) \u2264\n    (\u222b (t : \u211d) in Ioc 0 \u2016f\u2016, (\u2191P (thickening (dist (\u03bcs n) \u03bd + \u03b5s n) {a | t \u2264 f a})).toReal) + (dist (\u03bcs n) \u03bd + \u03b5s n) * \u2016f\u2016\n\u22a2 \u03b4 / 2 + \u2016f\u2016 * (dist (\u03bcs n) \u03bd + \u03b5s n) \u2264 \u03b4 / 2 + \u2016f\u2016 * (\u2016f\u2016\u207b\u00b9 * \u03b4 / 2)",["gcongr"]],["GroupTheory/SpecificGroups/Cyclic.lean",294,"\u03b1 : Type u_1\nG : Type u_2\nG' : Type u_3\na : \u03b1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : IsCyclic \u03b1\nthis : (a : Prop) \u2192 Decidable a\ng : \u03b1\nhg : \u2200 (x : \u03b1), x \u2208 zpowers g\nhx : \u00ac\u2203 x \u2208 \u22a5, x \u2260 1\n\u22a2 IsCyclic \u21a5\u22a5",["infer_instance"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/NonUnital.lean",607,"R : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u2078 : OrderedCommSemiring R\ninst\u271d\u00b9\u2077 : Nontrivial R\ninst\u271d\u00b9\u2076 : StarRing R\ninst\u271d\u00b9\u2075 : MetricSpace R\ninst\u271d\u00b9\u2074 : IsTopologicalSemiring R\ninst\u271d\u00b9\u00b3 : ContinuousStar R\ninst\u271d\u00b9\u00b2 : ContinuousSqrt R\ninst\u271d\u00b9\u00b9 : StarOrderedRing R\ninst\u271d\u00b9\u2070 : NoZeroDivisors R\ninst\u271d\u2079 : TopologicalSpace A\ninst\u271d\u2078 : NonUnitalRing A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : PartialOrder A\ninst\u271d\u2075 : StarOrderedRing A\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : IsScalarTower R A A\ninst\u271d\u00b2 : SMulCommClass R A A\ninst\u271d\u00b9 : NonUnitalContinuousFunctionalCalculus R p\ninst\u271d : NonnegSpectrumClass R A\na : A\nha : autoParam (p a) _auto\u271d\n\u22a2 ContinuousOn id (\u03c3\u2099 R a)",["fun_prop"]],["Analysis/SpecialFunctions/Integrals.lean",645,"case refine_1.hu\na b : \u211d\nn : \u2115\nC : \u211d := sin a ^ (n + 1) * cos a - sin b ^ (n + 1) * cos b\nh : \u2200 (\u03b1 \u03b2 \u03b3 : \u211d), \u03b2 * \u03b1 * \u03b3 * \u03b1 = \u03b2 * (\u03b1 * \u03b1 * \u03b3)\nhu : \u2200 x \u2208 [[a, b]], HasDerivAt (fun y \u21a6 sin y ^ (n + 1)) (\u2191(n + 1) * cos x * sin x ^ n) x\nhv : \u2200 x \u2208 [[a, b]], HasDerivAt (-cos) (sin x) x\n\u22a2 Continuous fun x \u21a6 \u2191(n + 1) * cos x * sin x ^ n\n```\n---\n```lean\ncase refine_2.hu\na b : \u211d\nn : \u2115\nC : \u211d := sin a ^ (n + 1) * cos a - sin b ^ (n + 1) * cos b\nh : \u2200 (\u03b1 \u03b2 \u03b3 : \u211d), \u03b2 * \u03b1 * \u03b3 * \u03b1 = \u03b2 * (\u03b1 * \u03b1 * \u03b3)\nhu : \u2200 x \u2208 [[a, b]], HasDerivAt (fun y \u21a6 sin y ^ (n + 1)) (\u2191(n + 1) * cos x * sin x ^ n) x\nhv : \u2200 x \u2208 [[a, b]], HasDerivAt (-cos) (sin x) x\n\u22a2 Continuous sin",["fun_prop"]],["Analysis/SpecialFunctions/Integrals.lean",712,"case refine_1.hu\na b : \u211d\nn : \u2115\nC : \u211d := cos b ^ (n + 1) * sin b - cos a ^ (n + 1) * sin a\nh : \u2200 (\u03b1 \u03b2 \u03b3 : \u211d), \u03b2 * \u03b1 * \u03b3 * \u03b1 = \u03b2 * (\u03b1 * \u03b1 * \u03b3)\nhu : \u2200 x \u2208 [[a, b]], HasDerivAt (fun y \u21a6 cos y ^ (n + 1)) (-\u2191(n + 1) * sin x * cos x ^ n) x\nhv : \u2200 x \u2208 [[a, b]], HasDerivAt sin (cos x) x\n\u22a2 Continuous fun x \u21a6 -\u2191(n + 1) * sin x * cos x ^ n\n```\n---\n```lean\ncase refine_2.hu\na b : \u211d\nn : \u2115\nC : \u211d := cos b ^ (n + 1) * sin b - cos a ^ (n + 1) * sin a\nh : \u2200 (\u03b1 \u03b2 \u03b3 : \u211d), \u03b2 * \u03b1 * \u03b3 * \u03b1 = \u03b2 * (\u03b1 * \u03b1 * \u03b3)\nhu : \u2200 x \u2208 [[a, b]], HasDerivAt (fun y \u21a6 cos y ^ (n + 1)) (-\u2191(n + 1) * sin x * cos x ^ n) x\nhv : \u2200 x \u2208 [[a, b]], HasDerivAt sin (cos x) x\n\u22a2 Continuous cos",["fun_prop"]],["Analysis/SpecialFunctions/Integrals.lean",733,"a b : \u211d\nm n : \u2115\n\u22a2 Continuous fun u \u21a6 u ^ m * (1 - u ^ 2) ^ n",["fun_prop"]],["Analysis/SpecialFunctions/Integrals.lean",765,"a b : \u211d\nm n : \u2115\n\u22a2 Continuous fun u \u21a6 u ^ n * (1 - u ^ 2) ^ m",["fun_prop"]],["Analysis/SpecialFunctions/Integrals.lean",806,"a b : \u211d\nh1 : \u2200 (c : \u211d), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4\n\u22a2 Continuous fun x \u21a6 cos (2 * x) ^ 2",["fun_prop"]],["Topology/UniformSpace/Defs.lean",514,"\u03b1 : Type ua\ninst\u271d : UniformSpace \u03b1\ns : Set (\u03b1 \u00d7 \u03b1)\nhs : s \u2208 \ud835\udce4 \u03b1\nw : Set (\u03b1 \u00d7 \u03b1)\nw_in : w \u2208 \ud835\udce4 \u03b1\nw_sub : w \u25cb w \u2286 s\nthis : symmetrizeRel w \u2286 w\n\u22a2 symmetrizeRel w \u25cb symmetrizeRel w \u2286 w \u25cb w",["gcongr"]],["Geometry/Euclidean/MongePoint.lean",351,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nn : \u2115\ns : Simplex \u211d P (n + 1)\ni : Fin (n + 2)\n\u22a2 FiniteDimensional \u211d \u21a5((vectorSpan \u211d (s.points '' \u2191(univ.erase i)))\u15ee \u2293 vectorSpan \u211d (Set.range s.points))",["infer_instance"]],["Geometry/Euclidean/MongePoint.lean",677,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\ns : Set P\np : Fin 3 \u2192 P\nhps : Set.range p \u2286 s\nhpi : Function.Injective p\nha : AffineIndependent \u211d p\nt : Triangle \u211d P\nleft\u271d : t.orthocenter \u2209 Set.range t.points\nhts : s = insert t.orthocenter (Set.range t.points)\nhs : affineSpan \u211d s = affineSpan \u211d (Set.range t.points)\n\u22a2 FiniteDimensional \u211d \u21a5(affineSpan \u211d (Set.range t.points)).direction",["infer_instance"]],["LinearAlgebra/AffineSpace/FiniteDimensional.lean",331,"case inr.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\n\u03b9 : Type u_4\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module k V\ninst\u271d\u00b9 : AffineSpace V P\ns : AffineSubspace k P\ninst\u271d : FiniteDimensional k \u21a5s.direction\np p\u2080 : P\nhp\u2080 : p\u2080 \u2208 \u2191s\n\u22a2 FiniteDimensional k \u21a5(Submodule.span k {p -\u1d65 p\u2080} \u2294 s.direction)",["infer_instance"]],["Probability/Kernel/IonescuTulcea/Traj.lean",522,"case h.h.hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\na b : \u2115\nx : (i : { x // x \u2208 Iic a }) \u2192 X \u2191i\ns\u271d : Set ((i : { x // x \u2208 Iic b }) \u2192 X \u2191i)\na\u271d : MeasurableSet s\u271d\n\u22a2 Measurable (frestrictLe b)",["fun_prop"]],["Probability/Kernel/IonescuTulcea/Traj.lean",634,"X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\na b : \u2115\nhab : a \u2264 b\nu : (i : { x // x \u2208 Iic a }) \u2192 X \u2191i\ns : Set (((i : { x // x \u2208 Iic b }) \u2192 X \u2191i) \u00d7 ((n : \u2115) \u2192 X n))\nms : MeasurableSet s\nx : (i : { x // x \u2208 Iic b }) \u2192 X \u2191i\n\u22a2 Measurable fun x \u21a6 (frestrictLe b x, x)\n```\n---\n```lean\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\na b : \u2115\nhab : a \u2264 b\nu : (i : { x // x \u2208 Iic a }) \u2192 X \u2191i\ns : Set (((i : { x // x \u2208 Iic b }) \u2192 X \u2191i) \u00d7 ((n : \u2115) \u2192 X n))\nms : MeasurableSet s\nx : (i : { x // x \u2208 Iic b }) \u2192 X \u2191i\n\u22a2 Measurable (Prod.mk x)",["fun_prop"]],["Probability/Kernel/IonescuTulcea/Traj.lean",636,"case h.hf\nX : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\na b : \u2115\nhab : a \u2264 b\nu : (i : { x // x \u2208 Iic a }) \u2192 X \u2191i\ns : Set (((i : { x // x \u2208 Iic b }) \u2192 X \u2191i) \u00d7 ((n : \u2115) \u2192 X n))\nms : MeasurableSet s\n\u22a2 Measurable fun x \u21a6 (frestrictLe b x, x)",["fun_prop"]],["Probability/Kernel/IonescuTulcea/Traj.lean",162,"X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc\u271d \u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\ninst\u271d : \u2200 (n : \u2115), SFinite (\u03bc n)\nI : Finset \u2115\n\u22a2 SFinite (Measure.map (restrict\u2082 \u22ef) (\u03bc (I.sup id)))",["infer_instance"]],["Probability/Kernel/IonescuTulcea/Traj.lean",165,"X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc\u271d \u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\ninst\u271d : \u2200 (n : \u2115), IsFiniteMeasure (\u03bc n)\nI : Finset \u2115\n\u22a2 IsFiniteMeasure (Measure.map (restrict\u2082 \u22ef) (\u03bc (I.sup id)))",["infer_instance"]],["Probability/Kernel/IonescuTulcea/Traj.lean",168,"X : \u2115 \u2192 Type u_1\ninst\u271d\u00b9 : (n : \u2115) \u2192 MeasurableSpace (X n)\n\u03bc\u271d \u03bc : (n : \u2115) \u2192 Measure ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i)\ninst\u271d : \u2200 (n : \u2115), IsZeroOrProbabilityMeasure (\u03bc n)\nI : Finset \u2115\n\u22a2 IsZeroOrProbabilityMeasure (Measure.map (restrict\u2082 \u22ef) (\u03bc (I.sup id)))",["infer_instance"]],["Algebra/Lie/Weights/Basic.lean",608,"case inl\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : LieRing L\ninst\u271d\u2077 : LieAlgebra R L\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : LieRingModule L M\ninst\u271d\u00b3 : LieModule R L M\ninst\u271d\u00b2 : LieRing.IsNilpotent L\ninst\u271d\u00b9 : IsNoetherian R M\ninst\u271d : IsArtinian R M\nh\u271d : \u2200 N < \u22a4, IsCompl (genWeightSpace (\u21a5N) 0) (posFittingComp R L \u21a5N)\nM\u2080 : LieSubmodule R L M := genWeightSpace M 0\nM\u2081 : LieSubmodule R L M := posFittingComp R L M\nh : M\u2080 = \u22a4\n\u22a2 IsNilpotent L \u21a5M\u2080",["infer_instance"]],["Analysis/Asymptotics/Lemmas.lean",431,"\u03b1 : Type u_1\nR : Type u_13\ninst\u271d : SeminormedRing R\nc : \u211d\nl : Filter \u03b1\nu v \u03c6 : \u03b1 \u2192 R\nh\u03c6 : \u2200\u1da0 (x : \u03b1) in l, \u2016\u03c6 x\u2016 \u2264 c\nh : u =\u1da0[l] \u03c6 * v\nx : \u03b1\nhx : \u2016\u03c6 x\u2016 \u2264 c\n\u22a2 \u2016\u03c6 x\u2016 * \u2016v x\u2016 \u2264 c * \u2016v x\u2016",["gcongr"]],["Analysis/Normed/Ring/Basic.lean",422,"\u03b1 : Type u_2\ninst\u271d : SeminormedRing \u03b1\na b c : \u03b1\nha : \u2016a\u2016 \u2264 1\n\u22a2 \u2016c - a\u2016 + \u2016a\u2016 * \u20161 - b\u2016 \u2264 \u2016c - a\u2016 + 1 * \u20161 - b\u2016",["gcongr"]],["Algebra/Homology/ShortComplex/Exact.lean",412,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nS : ShortComplex C\nhS : IsLimit (KernelFork.of\u03b9 S.f \u22ef)\ninst\u271d : S.HasHomology\nthis : IsSplitEpi S.toCycles\n\u22a2 Epi S.toCycles",["infer_instance"]],["Algebra/Homology/ShortComplex/Exact.lean",422,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} C\ninst\u271d\u00b9 : Preadditive C\nS : ShortComplex C\nhS : IsColimit (CokernelCofork.of\u03c0 S.g \u22ef)\ninst\u271d : S.HasHomology\nthis : IsSplitMono S.fromOpcycles\n\u22a2 Mono S.fromOpcycles",["infer_instance"]],["Algebra/Homology/ShortComplex/Exact.lean",500,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Preadditive C\nS : ShortComplex C\ns : S.Splitting\nthis : IsSplitMono S.f\n\u22a2 Mono S.f",["infer_instance"]],["Algebra/Homology/ShortComplex/Exact.lean",509,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Preadditive C\nS : ShortComplex C\ns : S.Splitting\nthis : IsSplitEpi S.g\n\u22a2 Epi S.g",["infer_instance"]],["Algebra/Homology/ShortComplex/Exact.lean",798,"C : Type u_1\ninst\u271d\u2076 : Category.{u_3, u_1} C\ninst\u271d\u2075 : Preadditive C\ninst\u271d\u2074 : Balanced C\nS\u2081 S\u2082 : ShortComplex C\n\u03c6 : S\u2081 \u27f6 S\u2082\nh\u2082 : S\u2082.Exact\ninst\u271d\u00b3 : Epi S\u2081.g\ninst\u271d\u00b2 : Epi S\u2082.g\ninst\u271d\u00b9 : Epi \u03c6.\u03c4\u2081\ninst\u271d : Epi \u03c6.\u03c4\u2083\n\u22a2 Mono S\u2081.g.op",["infer_instance"]],["Algebra/Homology/ShortComplex/Exact.lean",799,"C : Type u_1\ninst\u271d\u2076 : Category.{u_3, u_1} C\ninst\u271d\u2075 : Preadditive C\ninst\u271d\u2074 : Balanced C\nS\u2081 S\u2082 : ShortComplex C\n\u03c6 : S\u2081 \u27f6 S\u2082\nh\u2082 : S\u2082.Exact\ninst\u271d\u00b3 : Epi S\u2081.g\ninst\u271d\u00b2 : Epi S\u2082.g\ninst\u271d\u00b9 : Epi \u03c6.\u03c4\u2081\ninst\u271d : Epi \u03c6.\u03c4\u2083\nthis : Mono S\u2081.op.f\n\u22a2 Mono S\u2082.g.op",["infer_instance"]],["Algebra/Homology/ShortComplex/Exact.lean",800,"C : Type u_1\ninst\u271d\u2076 : Category.{u_3, u_1} C\ninst\u271d\u2075 : Preadditive C\ninst\u271d\u2074 : Balanced C\nS\u2081 S\u2082 : ShortComplex C\n\u03c6 : S\u2081 \u27f6 S\u2082\nh\u2082 : S\u2082.Exact\ninst\u271d\u00b3 : Epi S\u2081.g\ninst\u271d\u00b2 : Epi S\u2082.g\ninst\u271d\u00b9 : Epi \u03c6.\u03c4\u2081\ninst\u271d : Epi \u03c6.\u03c4\u2083\nthis\u271d : Mono S\u2081.op.f\nthis : Mono S\u2082.op.f\n\u22a2 Mono \u03c6.\u03c4\u2083.op",["infer_instance"]],["Algebra/Homology/ShortComplex/Exact.lean",801,"C : Type u_1\ninst\u271d\u2076 : Category.{u_3, u_1} C\ninst\u271d\u2075 : Preadditive C\ninst\u271d\u2074 : Balanced C\nS\u2081 S\u2082 : ShortComplex C\n\u03c6 : S\u2081 \u27f6 S\u2082\nh\u2082 : S\u2082.Exact\ninst\u271d\u00b3 : Epi S\u2081.g\ninst\u271d\u00b2 : Epi S\u2082.g\ninst\u271d\u00b9 : Epi \u03c6.\u03c4\u2081\ninst\u271d : Epi \u03c6.\u03c4\u2083\nthis\u271d\u00b9 : Mono S\u2081.op.f\nthis\u271d : Mono S\u2082.op.f\nthis : Mono (opMap \u03c6).\u03c4\u2081\n\u22a2 Mono \u03c6.\u03c4\u2081.op",["infer_instance"]],["Analysis/Analytic/Inverse.lean",518,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nhp : 0 < p.radius\nC r : \u211d\nCpos : 0 < C\nrpos : 0 < r\nple : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\na : \u211d\napos : 0 < a\nha1 : 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a \u2264 1\nha2 : r * (I + 1) * a \u2264 1 / 2\nS : \u2115 \u2192 \u211d := fun n \u21a6 \u2211 k \u2208 Ico 1 n, a ^ k * \u2016p.rightInv i x k\u2016\nn : \u2115\none_le_n : 1 \u2264 n\nhn : S n \u2264 (I + 1) * a\nIn : 2 \u2264 n + 1\n\u22a2 r * S n \u2264 r * ((I + 1) * a)",["gcongr","aesop"]],["Analysis/Analytic/Inverse.lean",531,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nhp : 0 < p.radius\nC r : \u211d\nCpos : 0 < C\nrpos : 0 < r\nple : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\na : \u211d\napos : 0 < a\nha1 : 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a \u2264 1\nha2 : r * (I + 1) * a \u2264 1 / 2\nS : \u2115 \u2192 \u211d := fun n \u21a6 \u2211 k \u2208 Ico 1 n, a ^ k * \u2016p.rightInv i x k\u2016\nn : \u2115\none_le_n : 1 \u2264 n\nhn : S n \u2264 (I + 1) * a\nIn : 2 \u2264 n + 1\nrSn : r * S n \u2264 1 / 2\n\u22a2 I * a + 2 * I * C * (r * S n) ^ 2 \u2264 I * a + 2 * I * C * (r * ((I + 1) * a)) ^ 2",["gcongr"]],["Analysis/Analytic/Inverse.lean",533,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\ni : E \u2243L[\ud835\udd5c] F\nx : E\nhp : 0 < p.radius\nC r : \u211d\nCpos : 0 < C\nrpos : 0 < r\nple : \u2200 (n : \u2115), \u2016p n\u2016 \u2264 C * r ^ n\nI : \u211d := \u2016\u2191i.symm\u2016\na : \u211d\napos : 0 < a\nha1 : 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a \u2264 1\nha2 : r * (I + 1) * a \u2264 1 / 2\nS : \u2115 \u2192 \u211d := fun n \u21a6 \u2211 k \u2208 Ico 1 n, a ^ k * \u2016p.rightInv i x k\u2016\nn : \u2115\none_le_n : 1 \u2264 n\nhn : S n \u2264 (I + 1) * a\nIn : 2 \u2264 n + 1\nrSn : r * S n \u2264 1 / 2\n\u22a2 (I + 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a) * a \u2264 (I + 1) * a",["gcongr","aesop"]],["Analysis/Analytic/Inverse.lean",670,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : PartialHomeomorph E F\na : E\ni : E \u2243L[\ud835\udd5c] F\nh0 : a \u2208 f.source\np : FormalMultilinearSeries \ud835\udd5c E F\nh : HasFPowerSeriesAt (\u2191f) p a\nhp : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm \u2191i\nA : HasFPowerSeriesAt (\u2191f.symm \u2218 \u2191f) ((p.leftInv i a).comp p) a\nB : \u2200\u1da0 (y : E) in \ud835\udcdd (a - a), HasSum (fun n \u21a6 (p.leftInv i a n) fun x \u21a6 \u2191f (a + y) - \u2191f a) (\u2191f.symm (\u2191f (a + y)))\n\u22a2 ContinuousAt (fun x \u21a6 x - a) a",["fun_prop"]],["MeasureTheory/MeasurableSpace/Embedding.lean",507,"\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3\u271d : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns t u : Set \u03b1\u271d\ninst\u271d\u2076 : MeasurableSpace \u03b1\u271d\ninst\u271d\u2075 : MeasurableSpace \u03b2\u271d\ninst\u271d\u2074 : MeasurableSpace \u03b3\u271d\n\u03c0 : \u03b4' \u2192 Type u_6\n\u03c0' : \u03b4' \u2192 Type u_7\ninst\u271d\u00b3 : (x : \u03b4') \u2192 MeasurableSpace (\u03c0 x)\ninst\u271d\u00b2 : (x : \u03b4') \u2192 MeasurableSpace (\u03c0' x)\n\u03b1 : Type u_8\n\u03b2 : Type u_9\n\u03b3 : Type u_10\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\n\u22a2 Measurable fun f \u21a6 (fun c \u21a6 (f c).1, fun c \u21a6 (f c).2)",["fun_prop"]],["MeasureTheory/MeasurableSpace/Embedding.lean",510,"\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3\u271d : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns t u : Set \u03b1\u271d\ninst\u271d\u2076 : MeasurableSpace \u03b1\u271d\ninst\u271d\u2075 : MeasurableSpace \u03b2\u271d\ninst\u271d\u2074 : MeasurableSpace \u03b3\u271d\n\u03c0 : \u03b4' \u2192 Type u_6\n\u03c0' : \u03b4' \u2192 Type u_7\ninst\u271d\u00b3 : (x : \u03b4') \u2192 MeasurableSpace (\u03c0 x)\ninst\u271d\u00b2 : (x : \u03b4') \u2192 MeasurableSpace (\u03c0' x)\n\u03b1 : Type u_8\n\u03b2 : Type u_9\n\u03b3 : Type u_10\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\n\u22a2 Measurable fun p c \u21a6 (p.1 c, p.2 c)",["fun_prop"]],["Data/Matroid/Map.lean",288,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nE\u271d I\u271d : Set \u03b1\nM : Matroid \u03b1\nN : Matroid \u03b2\nE B I : Set \u03b1\ninst\u271d : N.Finitary\n\u22a2 (N.comap f \u21be E).Finitary",["infer_instance"]],["Data/Matroid/Map.lean",291,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nE\u271d I\u271d : Set \u03b1\nM : Matroid \u03b1\nN : Matroid \u03b2\nE B I : Set \u03b1\ninst\u271d : N.RankFinite\n\u22a2 (N.comap f \u21be E).RankFinite",["infer_instance"]],["Data/Matroid/Map.lean",701,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nE\u271d I\u271d : Set \u03b1\nM\u271d : Matroid \u03b1\nN : Matroid \u03b2\nE X\u271d I : Set \u03b1\nM : Matroid \u03b1\ninst\u271d : M.Finitary\nX : Set \u03b1\n\u22a2 ((M \u21be X).comap Subtype.val).Finitary",["infer_instance"]],["Data/Matroid/Map.lean",704,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nE\u271d I\u271d : Set \u03b1\nM\u271d : Matroid \u03b1\nN : Matroid \u03b2\nE X\u271d I : Set \u03b1\nM : Matroid \u03b1\ninst\u271d : M.RankFinite\nX : Set \u03b1\n\u22a2 ((M \u21be X).comap Subtype.val).RankFinite",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",182,"d : \u2124\n\u22a2 AddMonoid (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",184,"d : \u2124\n\u22a2 Monoid (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",186,"d : \u2124\n\u22a2 CommMonoid (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",188,"d : \u2124\n\u22a2 CommSemigroup (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",190,"d : \u2124\n\u22a2 Semigroup (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",192,"d : \u2124\n\u22a2 AddCommSemigroup (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",194,"d : \u2124\n\u22a2 AddSemigroup (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",196,"d : \u2124\n\u22a2 CommSemiring (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",198,"d : \u2124\n\u22a2 Semiring (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",200,"d : \u2124\n\u22a2 Ring (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",202,"d : \u2124\n\u22a2 Distrib (\u2124\u221ad)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",850,"d : \u2115\ndnsq : Nonsquare d\n\u22a2 LinearOrderedRing (\u2124\u221a\u2191d)",["infer_instance"]],["NumberTheory/Zsqrtd/Basic.lean",852,"d : \u2115\ndnsq : Nonsquare d\n\u22a2 OrderedRing (\u2124\u221a\u2191d)",["infer_instance"]],["Algebra/Order/CauSeq/Basic.lean",60,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\n\u03b5 K\u2081 K\u2082 : \u03b1\n\u03b50 : 0 < \u03b5\na\u2081 a\u2082 b\u2081 b\u2082 : \u03b2\nM : \u03b1 := 1 \u2294 (K\u2081 \u2294 K\u2082)\nK0 : 0 < M\n\u03b5K : 0 < \u03b5 / 2 / M\nh\u2081 : abv (a\u2081 - b\u2081) < \u03b5 / 2 / M\nh\u2082 : abv (a\u2082 - b\u2082) < \u03b5 / 2 / M\nha\u2081 : abv a\u2081 < M\nhb\u2082 : abv b\u2082 < M\n\u22a2 abv (a\u2081 - b\u2081) * abv b\u2082 + abv (a\u2082 - b\u2082) * abv a\u2081 < \u03b5 / 2 / M * M + \u03b5 / 2 / M * M",["gcongr"]],["Algebra/Order/CauSeq/Basic.lean",76,"\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DivisionRing \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\n\u03b5 K : \u03b1\n\u03b50 : 0 < \u03b5\nK0 : 0 < K\na b : \u03b2\nha : K \u2264 abv a\nhb : K \u2264 abv b\nh : abv (a - b) < K * \u03b5 * K\na0 : 0 < abv a\nb0 : 0 < abv b\n\u22a2 K * \u03b5 * K \u2264 abv a * \u03b5 * abv b",["gcongr"]],["Algebra/Order/CauSeq/Basic.lean",483,"case intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nhf : \u00acf \u2248 0\nhg : \u00acg \u2248 0\nthis\u271d : (f * g - 0).LimZero\nhlz : (f * g).LimZero\nhf' : \u00acf.LimZero\nhg' : \u00acg.LimZero\na1 : \u03b1\nha1 : a1 > 0\nN1 : \u2115\nhN1 : \u2200 j \u2265 N1, a1 \u2264 abv (\u2191f j)\na2 : \u03b1\nha2 : a2 > 0\nN2 : \u2115\nhN2 : \u2200 j \u2265 N2, a2 \u2264 abv (\u2191g j)\nthis : 0 < a1 * a2\nN : \u2115\nhN : \u2200 j \u2265 N, abv (\u2191(f * g) j) < a1 * a2\ni : \u2115 := N \u2294 (N1 \u2294 N2)\nhN' : abv (\u2191(f * g) i) < a1 * a2\nhN1'\u271d : a1 \u2264 abv (\u2191f i)\nhN1' : a2 \u2264 abv (\u2191g i)\n\u22a2 a1 * a2 \u2264 abv (\u2191f i) * abv (\u2191g i)",["gcongr"]],["GroupTheory/FreeGroup/Basic.lean",429,"\u03b1 : Type u\nL L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)\ninst\u271d : IsEmpty \u03b1\n\u22a2 Unique (Quot Red.Step)",["infer_instance"]],["ModelTheory/Syntax.lean",834,"L : Language\n\u03b1 : Type u'\ns t : Set \u03b1\nh : s \u2286 t\n\u22a2 (fun ab \u21a6 ((L.con ab.1).term.equal (L.con ab.2).term).not) '' (s \u00d7\u02e2 s \u2229 (diagonal \u03b1)\u1d9c) \u2286\n    (fun ab \u21a6 ((L.con ab.1).term.equal (L.con ab.2).term).not) '' (t \u00d7\u02e2 t \u2229 (diagonal \u03b1)\u1d9c)",["gcongr"]],["Topology/MetricSpace/Thickening.lean",655,"\u03b1 : Type u\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : PseudoEMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nK : Set \u03b1\nU : Set \u03b2\nhK : IsCompact K\nho : IsOpen U\nhf : \u2200 x \u2208 K, ContinuousAt f x\nhKU : MapsTo f K U\ns t : Set \u03b1\n\u03b5\u2081 : \u211d\nh\u03b5\u2081 : \u03b5\u2081 > 0\nV\u2081 : Set \u03b1\nhV\u2081 : V\u2081 \u2208 \ud835\udcdd\u02e2 s\nhV\u2081thickening : thickening \u03b5\u2081 (f '' V\u2081) \u2286 U\n\u03b5\u2082 : \u211d\nh\u03b5\u2082 : \u03b5\u2082 > 0\nV\u2082 : Set \u03b1\nhV\u2082 : V\u2082 \u2208 \ud835\udcdd\u02e2 t\nhV\u2082thickening : thickening \u03b5\u2082 (f '' V\u2082) \u2286 U\n\u22a2 thickening \u03b5\u2081 (f '' V\u2081) \u222a thickening \u03b5\u2082 (f '' V\u2082) \u2286 U \u222a U",["gcongr","aesop"]],["Probability/Kernel/Disintegration/CDFToKernel.lean",168,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u211d)\n\u03bd : Kernel \u03b1 \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 \u211a \u2192 \u211d\ninst\u271d : IsFiniteKernel \u03ba\nhf : IsRatCondKernelCDF f \u03ba \u03bd\na : \u03b1\nx : \u211d\ns : Set \u03b2\nhs : MeasurableSet s\nh\u03c1_zero : \u00ac(\u03bd a).restrict s = 0\nh :\n  \u222b\u207b (b : \u03b2) in s, ENNReal.ofReal (\u2191(stieltjesOfMeasurableRat f \u22ef (a, b)) x) \u2202\u03bd a =\n    \u222b\u207b (b : \u03b2) in s, \u2a05 r, ENNReal.ofReal (\u2191(stieltjesOfMeasurableRat f \u22ef (a, b)) \u2191\u2191r) \u2202\u03bd a\nh_nonempty : Nonempty { r' // x < \u2191r' }\ni j : { r' // x < \u2191r' }\nhij : i \u2264 j\n\u22a2 Iic \u2191\u2191i \u2286 Iic \u2191\u2191j",["gcongr","aesop"]],["Probability/Kernel/Disintegration/CDFToKernel.lean",343,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03c1 : Measure (\u03b1 \u00d7 \u211d)\ninst\u271d : IsFiniteMeasure \u03c1\ns : Set \u03b1\nhs : MeasurableSet s\nt : \u211a\nr r' : { r' // t < r' }\nhrr' : r \u2264 r'\n\u22a2 Iic \u2191\u2191r \u2286 Iic \u2191\u2191r'",["gcongr","aesop"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",67,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Linear R C\nF G K L : CochainComplex C \u2124\nn m : \u2124\n\u22a2 AddCommGroup ((T : Triplet n) \u2192 F.X T.p \u27f6 G.X T.q)",["infer_instance"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",71,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Linear R C\nF G K L : CochainComplex C \u2124\nn m : \u2124\n\u22a2 Module R ((T : Triplet n) \u2192 F.X T.p \u27f6 G.X T.q)",["infer_instance"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",583,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Linear R C\nF G K L : CochainComplex C \u2124\nn m : \u2124\n\u22a2 AddCommGroup \u21a5(cocycle F G n)",["infer_instance"]],["NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean",313,"case inl\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nw : InfinitePlace K\nhw : w.IsReal\n\u22a2 w \u2208 Finset.univ \u2192 Continuous fun a \u21a6 \u2191w.mult * \u2016a.1 \u27e8w, hw\u27e9\u2016\n```\n---\n```lean\ncase inr\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nw : InfinitePlace K\nhw : w.IsComplex\n\u22a2 w \u2208 Finset.univ \u2192 Continuous fun a \u21a6 \u2191w.mult * \u2016a.2 \u27e8w, hw\u27e9\u2016",["fun_prop"]],["NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean",486,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nf : InfinitePlace K \u2192 \u211d\u22650\nI : (FractionalIdeal (\ud835\udcde K)\u2070 K)\u02e3\nh : minkowskiBound K I < volume (convexBodyLT K f)\nh_fund :\n  IsAddFundamentalDomain (\u21a5(span \u2124 (Set.range \u21d1(fractionalIdealLatticeBasis K I))).toAddSubgroup)\n    (fundamentalDomain (fractionalIdealLatticeBasis K I)) volume\n\u22a2 Countable \u21a5(span \u2124 (Set.range \u21d1(fractionalIdealLatticeBasis K I)))",["infer_instance"]],["NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean",503,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nf : InfinitePlace K \u2192 \u211d\u22650\nI : (FractionalIdeal (\ud835\udcde K)\u2070 K)\u02e3\nw\u2080 : { w // w.IsComplex }\nh : minkowskiBound K I < volume (convexBodyLT' K f w\u2080)\nh_fund :\n  IsAddFundamentalDomain (\u21a5(span \u2124 (Set.range \u21d1(fractionalIdealLatticeBasis K I))).toAddSubgroup)\n    (fundamentalDomain (fractionalIdealLatticeBasis K I)) volume\n\u22a2 Countable \u21a5(span \u2124 (Set.range \u21d1(fractionalIdealLatticeBasis K I)))",["infer_instance"]],["NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean",596,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\nI : (FractionalIdeal (\ud835\udcde K)\u2070 K)\u02e3\nB : \u211d\nh : minkowskiBound K I \u2264 volume (convexBodySum K B)\nhB : 0 \u2264 B\nh1 : 0 < (\u2191(finrank \u211a K))\u207b\u00b9\nh2 : 0 \u2264 B / \u2191(finrank \u211a K)\nh_fund :\n  IsAddFundamentalDomain (\u21a5(span \u2124 (Set.range \u21d1(fractionalIdealLatticeBasis K I))).toAddSubgroup)\n    (fundamentalDomain (fractionalIdealLatticeBasis K I)) volume\n\u22a2 Countable \u21a5(span \u2124 (Set.range \u21d1(fractionalIdealLatticeBasis K I)))",["infer_instance"]],["Analysis/Calculus/FDeriv/Symmetric.lean",587,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ns : Set E\nf : E \u2192 F\nx : E\nn : WithTop \u2115\u221e\nhf : ContDiffWithinAt \ud835\udd5c n f s x\nhn : minSmoothness \ud835\udd5c 2 \u2264 n\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 closure (interior s)\nh'x : x \u2208 s\nm : WithTop \u2115\u221e\nhm : minSmoothness \ud835\udd5c \u21912 \u2264 m\nhmn : m \u2264 n\nm_ne : m \u2260 \u221e\nu : Set E\nu_open : IsOpen u\nxu : x \u2208 u\nhu : ContDiffOn \ud835\udd5c m f (s \u2229 u)\nh'u : UniqueDiffOn \ud835\udd5c (s \u2229 u)\ny : \u2115 \u2192 E\nhy : \u2200 (n : \u2115), y n \u2208 interior s\ny_lim : Tendsto y atTop (\ud835\udcdd x)\nL : \u2200\u1da0 (k : \u2115) in atTop, y k \u2208 u\nI : \u2200\u1da0 (k : \u2115) in atTop, IsSymmSndFDerivWithinAt \ud835\udd5c f s (y k)\nA : ContinuousOn (fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c f s) s) (s \u2229 u)\nB : Tendsto (fun k \u21a6 fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c f s) s (y k)) atTop (\ud835\udcdd (fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c f s) s x))\nv w : E\n\u22a2 Continuous fun A \u21a6 (A v) w",["fun_prop"]],["Computability/AkraBazzi/GrowsPolynomially.lean",415,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\n\u22a2 b * x \u2264 1 * x",["gcongr"]],["Computability/AkraBazzi/GrowsPolynomially.lean",441,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\nhx_lb : 1 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonneg : 0 \u2264 f u\nhfg\u2083 : \u2016g u\u2016 \u2264 1 / 2 * f u\n\u22a2 c\u2081 / 3 * (3 / 2 * f x) \u2265 c\u2081 / 3 * (f x + g x)",["gcongr","aesop"]],["Computability/AkraBazzi/GrowsPolynomially.lean",448,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, 0 \u2264 f x\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 0 \u2264 f y\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 1 / 2 * f x\nhx_ub : f x + g x \u2264 3 / 2 * f x\nhx_lb : 1 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonneg : 0 \u2264 f u\nhfg\u2083 : \u2016g u\u2016 \u2264 1 / 2 * f u\n\u22a2 3 * c\u2082 * (1 / 2 * f x) \u2264 3 * c\u2082 * (f x + g x)",["gcongr","aesop"]],["Computability/AkraBazzi/GrowsPolynomially.lean",458,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\n\u22a2 b * x \u2264 1 * x",["gcongr"]],["Computability/AkraBazzi/GrowsPolynomially.lean",494,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\nhx_ub : f x + g x \u2264 1 / 2 * f x\nhx_lb : 3 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonpos : f u \u2264 0\nhfg\u2083 : \u2016g u\u2016 \u2264 -1 / 2 * f u\n\u22a2 3 * c\u2081 * (1 / 2 * f x) \u2265 3 * c\u2081 * (f x + g x)",["gcongr","aesop"]],["Computability/AkraBazzi/GrowsPolynomially.lean",504,"f g : \u211d \u2192 \u211d\nhf\u271d : GrowsPolynomially f\nb : \u211d\nhb : b \u2208 Set.Ioo 0 1\nhb_ub : b < 1\nhf' : \u2200\u1da0 (x : \u211d) in atTop, f x \u2264 0\nc\u2081 : \u211d\nhc\u2081_mem : 0 < c\u2081\nc\u2082 : \u211d\nhc\u2082_mem : 0 < c\u2082\nhf : \u2200\u1da0 (x : \u211d) in atTop, \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg : \u2200\u1da0 (x : \u211d) in atTop, \u2016g x\u2016 \u2264 1 / 2 * \u2016f x\u2016\nx : \u211d\nhf\u2081 : \u2200 u \u2208 Set.Icc (b * x) x, f u \u2208 Set.Icc (c\u2081 * f x) (c\u2082 * f x)\nhfg' : \u2200 (y : \u211d), b * id x \u2264 y \u2192 \u2016g y\u2016 \u2264 1 / 2 * \u2016f y\u2016\nhf\u2082 : \u2200 (y : \u211d), b * id x \u2264 y \u2192 f y \u2264 0\nhx_nonneg : 0 \u2264 x\nhbx : b * x \u2264 x\nhfg\u2082 : \u2016g x\u2016 \u2264 -1 / 2 * f x\nhx_ub : f x + g x \u2264 1 / 2 * f x\nhx_lb : 3 / 2 * f x \u2264 f x + g x\nu : \u211d\nhu_lb : b * x \u2264 u\nhu_ub : u \u2264 x\nhfu_nonpos : f u \u2264 0\nhfg\u2083 : \u2016g u\u2016 \u2264 -1 / 2 * f u\n\u22a2 c\u2082 / 3 * (3 / 2 * f x) \u2264 c\u2082 / 3 * (f x + g x)",["gcongr","aesop"]],["Analysis/Normed/Group/Hom.lean",161,"V\u2081 : Type u_2\nV\u2082 : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2081\ninst\u271d : SeminormedAddCommGroup V\u2082\nf : NormedAddGroupHom V\u2081 V\u2082\nK : AddSubgroup V\u2082\nC C' : \u211d\nh : f.SurjectiveOnWith K C\nH : C \u2264 C'\ng : V\u2081\nk_in : f g \u2208 K\nhg : \u2016g\u2016 \u2264 C * \u2016f g\u2016\nHg : \u00ac\u2016f g\u2016 = 0\n\u22a2 C * \u2016f g\u2016 \u2264 C' * \u2016f g\u2016",["gcongr"]],["Analysis/Normed/Group/Hom.lean",216,"V\u2081 : Type u_2\nV\u2082 : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2081\ninst\u271d : SeminormedAddCommGroup V\u2082\nf : NormedAddGroupHom V\u2081 V\u2082\nc : \u211d\nh : \u2016f\u2016 \u2264 c\nx : V\u2081\n\u22a2 \u2016f\u2016 * \u2016x\u2016 \u2264 c * \u2016x\u2016",["gcongr"]],["CategoryTheory/Triangulated/Pretriangulated.lean",454,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : \u2200 (n : \u2124), (shiftFunctor C n).Additive\nhC : Pretriangulated C\nT T' : Triangle C\n\u03c6 : T \u27f6 T'\nhT : T \u2208 distinguishedTriangles\nhT' : T' \u2208 distinguishedTriangles\nh\u2081 : IsIso \u03c6.hom\u2081\nh\u2082 : IsIso \u03c6.hom\u2082\n\u22a2 IsIso ((shiftFunctor C 1).map \u03c6.hom\u2081)",["infer_instance"]],["CategoryTheory/Triangulated/Pretriangulated.lean",568,"C : Type u\ninst\u271d\u2078 : Category.{v, u} C\ninst\u271d\u2077 : HasZeroObject C\ninst\u271d\u2076 : HasShift C \u2124\ninst\u271d\u2075 : Preadditive C\ninst\u271d\u2074 : \u2200 (n : \u2124), (shiftFunctor C n).Additive\nhC : Pretriangulated C\nJ : Type u_1\nT : J \u2192 Triangle C\nhT : \u2200 (j : J), T j \u2208 distinguishedTriangles\ninst\u271d\u00b3 : HasProduct fun j \u21a6 (T j).obj\u2081\ninst\u271d\u00b2 : HasProduct fun j \u21a6 (T j).obj\u2082\ninst\u271d\u00b9 : HasProduct fun j \u21a6 (T j).obj\u2083\ninst\u271d : HasProduct fun j \u21a6 (shiftFunctor C 1).obj (T j).obj\u2081\nf\u2081 : (\u220f\u1d9c fun j \u21a6 (T j).obj\u2081) \u27f6 \u220f\u1d9c fun j \u21a6 (T j).obj\u2082 := Limits.Pi.map fun j \u21a6 (T j).mor\u2081\nZ : C\nf\u2082 : (\u220f\u1d9c fun j \u21a6 (T j).obj\u2082) \u27f6 Z\nf\u2083 : Z \u27f6 (shiftFunctor C 1).obj (\u220f\u1d9c fun j \u21a6 (T j).obj\u2081)\nT' : Triangle C := Triangle.mk f\u2081 f\u2082 f\u2083\nhT' : T' \u2208 distinguishedTriangles\n\u03c6 : (j : J) \u2192 T' \u27f6 T j :=\n  fun j \u21a6\n    completeDistinguishedTriangleMorphism T' (T j) hT' \u22ef (Pi.\u03c0 (fun j \u21a6 (T j).obj\u2081) j) (Pi.\u03c0 (fun j \u21a6 (T j).obj\u2082) j) \u22ef\n\u03c6' : T' \u27f6 productTriangle T := productTriangle.lift T \u03c6\nh\u2081 : \u03c6'.hom\u2081 = \ud835\udfd9 T'.obj\u2081\nh\u2082 : \u03c6'.hom\u2082 = \ud835\udfd9 T'.obj\u2082\n\u22a2 IsIso (\ud835\udfd9 T'.obj\u2081)",["infer_instance"]],["CategoryTheory/Triangulated/Pretriangulated.lean",569,"C : Type u\ninst\u271d\u2078 : Category.{v, u} C\ninst\u271d\u2077 : HasZeroObject C\ninst\u271d\u2076 : HasShift C \u2124\ninst\u271d\u2075 : Preadditive C\ninst\u271d\u2074 : \u2200 (n : \u2124), (shiftFunctor C n).Additive\nhC : Pretriangulated C\nJ : Type u_1\nT : J \u2192 Triangle C\nhT : \u2200 (j : J), T j \u2208 distinguishedTriangles\ninst\u271d\u00b3 : HasProduct fun j \u21a6 (T j).obj\u2081\ninst\u271d\u00b2 : HasProduct fun j \u21a6 (T j).obj\u2082\ninst\u271d\u00b9 : HasProduct fun j \u21a6 (T j).obj\u2083\ninst\u271d : HasProduct fun j \u21a6 (shiftFunctor C 1).obj (T j).obj\u2081\nf\u2081 : (\u220f\u1d9c fun j \u21a6 (T j).obj\u2081) \u27f6 \u220f\u1d9c fun j \u21a6 (T j).obj\u2082 := Limits.Pi.map fun j \u21a6 (T j).mor\u2081\nZ : C\nf\u2082 : (\u220f\u1d9c fun j \u21a6 (T j).obj\u2082) \u27f6 Z\nf\u2083 : Z \u27f6 (shiftFunctor C 1).obj (\u220f\u1d9c fun j \u21a6 (T j).obj\u2081)\nT' : Triangle C := Triangle.mk f\u2081 f\u2082 f\u2083\nhT' : T' \u2208 distinguishedTriangles\n\u03c6 : (j : J) \u2192 T' \u27f6 T j :=\n  fun j \u21a6\n    completeDistinguishedTriangleMorphism T' (T j) hT' \u22ef (Pi.\u03c0 (fun j \u21a6 (T j).obj\u2081) j) (Pi.\u03c0 (fun j \u21a6 (T j).obj\u2082) j) \u22ef\n\u03c6' : T' \u27f6 productTriangle T := productTriangle.lift T \u03c6\nh\u2081 : \u03c6'.hom\u2081 = \ud835\udfd9 T'.obj\u2081\nh\u2082 : \u03c6'.hom\u2082 = \ud835\udfd9 T'.obj\u2082\nthis : IsIso \u03c6'.hom\u2081\n\u22a2 IsIso (\ud835\udfd9 T'.obj\u2082)",["infer_instance"]],["CategoryTheory/Triangulated/Pretriangulated.lean",622,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : \u2200 (n : \u2124), (shiftFunctor C n).Additive\nhC : Pretriangulated C\nT\u2081 T\u2082 : Triangle C\nhT\u2081 : T\u2081 \u2208 distinguishedTriangles\nhT\u2082 : T\u2082 \u2208 distinguishedTriangles\ne : Arrow.mk T\u2081.mor\u2081 \u2245 Arrow.mk T\u2082.mor\u2081\n\u03c6 : T\u2081 \u27f6 T\u2082 := completeDistinguishedTriangleMorphism T\u2081 T\u2082 hT\u2081 hT\u2082 e.hom.left e.hom.right \u22ef\n\u22a2 IsIso e.hom.left",["infer_instance"]],["CategoryTheory/Triangulated/Pretriangulated.lean",623,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : HasZeroObject C\ninst\u271d\u00b2 : HasShift C \u2124\ninst\u271d\u00b9 : Preadditive C\ninst\u271d : \u2200 (n : \u2124), (shiftFunctor C n).Additive\nhC : Pretriangulated C\nT\u2081 T\u2082 : Triangle C\nhT\u2081 : T\u2081 \u2208 distinguishedTriangles\nhT\u2082 : T\u2082 \u2208 distinguishedTriangles\ne : Arrow.mk T\u2081.mor\u2081 \u2245 Arrow.mk T\u2082.mor\u2081\n\u03c6 : T\u2081 \u27f6 T\u2082 := completeDistinguishedTriangleMorphism T\u2081 T\u2082 hT\u2081 hT\u2082 e.hom.left e.hom.right \u22ef\nthis : IsIso \u03c6.hom\u2081\n\u22a2 IsIso e.hom.right",["infer_instance"]],["Probability/Kernel/RadonNikodym.lean",129,"\u03b1 : Type u_1\n\u03b3 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b3 : MeasurableSpace \u03b3\nh\u03b1\u03b3 : MeasurableSpace.CountableOrCountablyGenerated \u03b1 \u03b3\n\u03ba \u03b7 : Kernel \u03b1 \u03b3\na : \u03b1\n\u22a2 Measurable fun x \u21a6 \u03ba.rnDerivAux \u03b7 a x",["fun_prop"]],["Probability/Kernel/RadonNikodym.lean",218,"\u03b1 : Type u_1\n\u03b3 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b3 : MeasurableSpace \u03b3\nh\u03b1\u03b3 : MeasurableSpace.CountableOrCountablyGenerated \u03b1 \u03b3\n\u03ba \u03b7 : Kernel \u03b1 \u03b3\ninst\u271d\u00b9 : IsFiniteKernel \u03ba\ninst\u271d : IsFiniteKernel \u03b7\na : \u03b1\n\u22a2 Measurable fun x \u21a6 ENNReal.ofReal (1 - \u03ba.rnDerivAux (\u03ba + \u03b7) a x)",["fun_prop"]],["Probability/Kernel/RadonNikodym.lean",243,"\u03b1 : Type u_1\n\u03b3 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b3 : MeasurableSpace \u03b3\nh\u03b1\u03b3 : MeasurableSpace.CountableOrCountablyGenerated \u03b1 \u03b3\n\u03ba \u03b7 : Kernel \u03b1 \u03b3\na : \u03b1\n\u22a2 Measurable fun x \u21a6 \u03ba.rnDeriv \u03b7 a x",["fun_prop"]],["Probability/Kernel/RadonNikodym.lean",265,"\u03b1 : Type u_1\n\u03b3 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b3 : MeasurableSpace \u03b3\nh\u03b1\u03b3 : MeasurableSpace.CountableOrCountablyGenerated \u03b1 \u03b3\n\u03ba \u03b7 : Kernel \u03b1 \u03b3\n\u22a2 Measurable fun p \u21a6\n    \u2191(\u03ba.rnDerivAux (\u03ba + \u03b7) p.1 p.2).toNNReal - \u2191(1 - \u03ba.rnDerivAux (\u03ba + \u03b7) p.1 p.2).toNNReal * \u03ba.rnDeriv \u03b7 p.1 p.2",["fun_prop"]],["AlgebraicGeometry/OpenImmersion.lean",156,"X Y : Scheme\nf : X.Hom Y\nH : IsOpenImmersion f\nV : Y.Opens\nhV : V \u2264 f.opensRange\n\u22a2 IsIso (f.app (f ''\u1d41 f \u207b\u00b9\u1d41 V))",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",252,"R S : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nf : R\ninst\u271d : IsLocalization.Away f S\ne :\n  (\u2191\u2191(IsLocalization.algEquiv (Submonoid.powers f) S (Localization.Away f)).symm).comp\n      (algebraMap R (Localization.Away f)) =\n    algebraMap R S\nH : IsIso (CommRingCat.ofHom \u2191(IsLocalization.algEquiv (Submonoid.powers f) S (Localization.Away f)).symm)\n\u22a2 IsOpenImmersion\n    (Spec.map (CommRingCat.ofHom \u2191(IsLocalization.algEquiv (Submonoid.powers f) S (Localization.Away f)).symm) \u226b\n      Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away f))))",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",287,"case intro.intro.intro.intro.refine_2\nC : Type u\ninst\u271d : Category.{v, u} C\nX : PresheafedSpace CommRingCat\nY : Scheme\nf : X \u27f6 Y.toPresheafedSpace\nH : IsOpenImmersion f\nx : \u2191(toLocallyRingedSpace Y.toLocallyRingedSpace f).toTopCat\nR : CommRingCat\ni : Spec R \u27f6 Y\nleft\u271d : AlgebraicGeometry.IsOpenImmersion i\nh\u2081 : (ConcreteCategory.hom f.base) x \u2208 Set.range \u21d1(ConcreteCategory.hom i.base)\nh\u2082 : Set.range \u21d1(ConcreteCategory.hom i.base) \u2286 \u2191{ carrier := Set.range \u21d1(ConcreteCategory.hom f.base), is_open' := \u22ef }\n\u22a2 LocallyRingedSpace.IsOpenImmersion\n    (let_fun this := \u22ef;\n    inv (pullback.snd (toLocallyRingedSpaceHom Y.toLocallyRingedSpace f) i.toLRSHom') \u226b\n      pullback.fst (toLocallyRingedSpaceHom Y.toLocallyRingedSpace f) i.toLRSHom')",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",344,"C : Type u\ninst\u271d : Category.{v, u} C\nU : TopCat\nX : Scheme\nf : U \u27f6 TopCat.of \u2191\u2191X.toPresheafedSpace\nh : IsOpenEmbedding \u21d1(ConcreteCategory.hom f)\n\u22a2 PresheafedSpace.IsOpenImmersion (X.ofRestrict h)",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",395,"X Y Z : Scheme\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d\u00b9 : IsOpenImmersion g\ninst\u271d : IsOpenImmersion (f \u226b g)\nx : \u2191\u2191X.toPresheafedSpace\n\u22a2 IsIso (Scheme.Hom.stalkMap (f \u226b g) x)",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",420,"case refine_1.intro\nX Y : Scheme\nf : X \u27f6 Y\nh\u2081 : Epi f.base\nh\u2082 : IsOpenEmbedding \u21d1(ConcreteCategory.hom f.base)\n\u22a2 IsIso\n    (TopCat.isoOfHomeo\n        (Homeomorph.homeomorphOfContinuousOpen (Equiv.ofBijective \u21d1(ConcreteCategory.hom f.base) \u22ef) \u22ef \u22ef)).hom",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",432,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 Mono (Scheme.Hom.toLRSHom f)",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",483,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\nthis :\n  (PreservesPullback.iso\n          { obj := Scheme.toLocallyRingedSpace, map := fun {X Y} \u21a6 Scheme.Hom.toLRSHom,\n            map_id := Scheme.forgetToLocallyRingedSpace.proof_1, map_comp := @Scheme.forgetToLocallyRingedSpace.proof_2 }\n          f g).hom \u226b\n      pullback.snd (Scheme.Hom.toLRSHom f) (Scheme.Hom.toLRSHom g) =\n    Scheme.Hom.toLRSHom (pullback.snd f g)\n\u22a2 LocallyRingedSpace.IsOpenImmersion\n    ((PreservesPullback.iso\n          { obj := Scheme.toLocallyRingedSpace, map := fun {X Y} \u21a6 Scheme.Hom.toLRSHom,\n            map_id := Scheme.forgetToLocallyRingedSpace.proof_1, map_comp := @Scheme.forgetToLocallyRingedSpace.proof_2 }\n          f g).hom \u226b\n      pullback.snd (Scheme.Hom.toLRSHom f) (Scheme.Hom.toLRSHom g))",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",487,"C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 IsOpenImmersion ((pullbackSymmetry g f).hom \u226b pullback.snd f g)",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",493,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\ninst\u271d : IsOpenImmersion g\n\u22a2 IsOpenImmersion (limit.\u03c0 (cospan f g) left \u226b f)",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",502,"case refine_2\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 PreservesLimit (cospan (Scheme.Hom.toLRSHom f) (Scheme.Hom.toLRSHom g))\n    (LocallyRingedSpace.forgetToSheafedSpace \u22d9 SheafedSpace.forget CommRingCat)",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",517,"X Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 Epi (PreservesPullback.iso Scheme.forgetToTop f g).hom",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",534,"X Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\nH : IsOpenImmersion f\n\u22a2 Epi (PreservesPullback.iso Scheme.forgetToTop g f).hom",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",692,"case hP\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d : Scheme\nf : X\u271d \u27f6 Y\u271d\nhf this : IsIso f\n\u22a2 IsOpenImmersion f",["infer_instance"]],["AlgebraicGeometry/OpenImmersion.lean",701,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX Y Z : Scheme\nf : X \u27f6 Z\ng : Y \u27f6 Z\ninst\u271d : HasPullback f g\nH : IsOpenImmersion g\n\u22a2 IsOpenImmersion (pullback.fst f g)",["infer_instance"]],["Analysis/Complex/Hadamard.lean",325,"case intro\nl u : \u211d\nhul : l < u\nz : \u2102\nhz\u2081 : 0 \u2264 z.re\nhz\u2082 : z.re \u2264 1\nthis : 0 \u2264 u - l\n\u22a2 z.re * (u - l) \u2264 1 * (u - l)",["gcongr","aesop"]],["Analysis/Normed/Module/Basic.lean",675,"G : Type u_6\nH : Type u_7\ninst\u271d\u00b2 : SeminormedAddCommGroup G\ninst\u271d\u00b9 : SeminormedAddCommGroup H\ninst\u271d : NormedSpace \u211d H\ns : Set G\nf : G \u2192+ H\nhs : s \u2208 \ud835\udcdd 0\nhbounded : Bornology.IsBounded (\u21d1f '' s)\n\u03b4 : \u211d\nh\u03b4 : \u03b4 > 0\nhU\u03b5 : ball 0 \u03b4 \u2286 s\nC \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhC : \u2200 (a : G), \u2016a\u2016 < \u03b4 \u2192 \u2016f a\u2016 < C\nhC\u2080 : 0 < C\nn : \u2115\nhn : C / \u03b5 < \u2191n\nhnpos : 0 < \u2191n\nhn\u2080 : n \u2260 0\nx : G\nhx\u03b4 : \u2016x\u2016 < \u03b4 / \u2191n\n\u22a2 (\u2191n)\u207b\u00b9 * C < (C / \u03b5)\u207b\u00b9 * C",["gcongr"]],["RingTheory/Valuation/ValuationSubring.lean",81,"K : Type u\ninst\u271d : Field K\nA : ValuationSubring K\n\u22a2 CommRing \u21a5A.toSubring",["infer_instance"]],["RingTheory/Valuation/ValuationSubring.lean",124,"K : Type u\ninst\u271d : Field K\nA : ValuationSubring K\n\u22a2 Algebra (\u21a5A.toSubring) K",["infer_instance"]],["RingTheory/Valuation/ValuationSubring.lean",151,"K : Type u\ninst\u271d : Field K\nA : ValuationSubring K\n\u22a2 LinearOrderedCommGroupWithZero (ValuationRing.ValueGroup (\u21a5A) K)",["infer_instance"]],["MeasureTheory/Function/ConditionalExpectation/AEMeasurable.lean",413,"\u03b1 : Type u_1\nF : Type u_2\n\ud835\udd5c : Type u_3\np : \u211d\u22650\u221e\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nhm : Fact (m \u2264 m0)\ninst\u271d : CompleteSpace F\nhp : Fact (1 \u2264 p)\n\u22a2 CompleteSpace \u21a5(Lp F p (\u03bc.trim \u22ef))",["infer_instance"]],["MeasureTheory/Function/ConditionalExpectation/AEMeasurable.lean",421,"\u03b1 : Type u_1\nF : Type u_2\n\ud835\udd5c : Type u_3\np : \u211d\u22650\u221e\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nhm : Fact (m \u2264 m0)\ninst\u271d : CompleteSpace F\nhp : Fact (1 \u2264 p)\n\u22a2 CompleteSpace \u21a5(lpMeasSubgroup F m p \u03bc)",["infer_instance"]],["MeasureTheory/Function/ConditionalExpectation/AEMeasurable.lean",428,"\u03b1 : Type u_1\nF : Type u_2\np : \u211d\u22650\u221e\ninst\u271d\u00b9 : NormedAddCommGroup F\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nhp : Fact (1 \u2264 p)\ninst\u271d : CompleteSpace F\nhm : m \u2264 m0\nthis : Fact (m \u2264 m0)\n\u22a2 CompleteSpace \u21a5(lpMeasSubgroup F m p \u03bc)",["infer_instance"]],["Combinatorics/SimpleGraph/Basic.lean",535,"\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v w : V\ne : Sym2 V\nG\u2081 G\u2082 : SimpleGraph V\n\u22a2 Fintype \u2191\u2205",["infer_instance"]],["Combinatorics/SimpleGraph/Basic.lean",540,"\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v w : V\ne : Sym2 V\nG\u2081 G\u2082 : SimpleGraph V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype \u2191G\u2081.edgeSet\ninst\u271d : Fintype \u2191G\u2082.edgeSet\n\u22a2 Fintype \u2191(G\u2081.edgeSet \u222a G\u2082.edgeSet)",["infer_instance"]],["Combinatorics/SimpleGraph/Basic.lean",625,"\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v w : V\ne : Sym2 V\ns : Set (Sym2 V)\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191s\n\u22a2 Fintype \u2191(s \\ {e | e.IsDiag})",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",76,"R : Type u_1\ninst\u271d : Inhabited R\n\u22a2 Inhabited (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",80,"R : Type u_1\ninst\u271d : Zero R\n\u22a2 Zero (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",84,"R : Type u_1\ninst\u271d : AddMonoid R\n\u22a2 AddMonoid (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",88,"R : Type u_1\ninst\u271d : AddGroup R\n\u22a2 AddGroup (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",92,"R : Type u_1\ninst\u271d : AddCommMonoid R\n\u22a2 AddCommMonoid (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",96,"R : Type u_1\ninst\u271d : AddCommGroup R\n\u22a2 AddCommGroup (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",100,"R : Type u_1\ninst\u271d : Semiring R\n\u22a2 Semiring (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",104,"R : Type u_1\ninst\u271d : CommSemiring R\n\u22a2 CommSemiring (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",108,"R : Type u_1\ninst\u271d : Ring R\n\u22a2 Ring (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",112,"R : Type u_1\ninst\u271d : CommRing R\n\u22a2 CommRing (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",116,"R : Type u_1\ninst\u271d : Nontrivial R\n\u22a2 Nontrivial (MvPowerSeries Unit R)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",120,"R : Type u_1\nA : Type ?u.2150\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid A\ninst\u271d : Module R A\n\u22a2 Module R (MvPowerSeries Unit A)",["infer_instance"]],["RingTheory/PowerSeries/Basic.lean",128,"R : Type u_1\nA : Type ?u.6577\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Algebra R A\n\u22a2 Algebra R (MvPowerSeries Unit A)",["infer_instance"]],["CategoryTheory/Limits/Types.lean",654,"J : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : J \u2964 Type u\ninst\u271d : HasColimit F\n\u03b1 \u03b2 : Type u\nf : \u03b1 \u27f6 \u03b2\n\u22a2 \u2200 {X Y : Type u} (f : X \u27f6 Y), HasImage f",["infer_instance"]],["CategoryTheory/Limits/Types.lean",704,"case hf\nF : \u2115\u1d52\u1d56 \u2964 Type u\nc : Cone F\nhc : IsLimit c\nhF : \u2200 (n : \u2115), Function.Surjective (F.map (homOfLE \u22ef).op)\ni : c.pt \u2245 (limitCone F).pt := hc.conePointUniqueUpToIso (limitConeIsLimit F)\nthis : c.\u03c0.app (Opposite.op 0) = i.hom \u226b (limitCone F).\u03c0.app (Opposite.op 0)\n\u22a2 Epi i.hom",["infer_instance"]],["MeasureTheory/Decomposition/RadonNikodym.lean",491,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SigmaFinite \u03bc\nh : s.toJordanDecomposition.posPart \u226a \u03bc \u2227 s.toJordanDecomposition.negPart \u226a \u03bc\ni : Set \u03b1\nhi : MeasurableSet i\n\u22a2 Measurable fun x \u21a6 (s.toJordanDecomposition.posPart.rnDeriv \u03bc x).toReal\n```\n---\n```lean\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SigmaFinite \u03bc\nh : s.toJordanDecomposition.posPart \u226a \u03bc \u2227 s.toJordanDecomposition.negPart \u226a \u03bc\ni : Set \u03b1\nhi : MeasurableSet i\n\u22a2 Measurable fun x \u21a6 (s.toJordanDecomposition.negPart.rnDeriv \u03bc x).toReal",["fun_prop"]],["Geometry/RingedSpace/PresheafedSpace/Gluing.lean",137,"case h\nC : Type u\ninst\u271d : Category.{v, u} C\nD : GlueData C\ni j k : D.J\nS : Set \u2191\u2191(D.V (i, j))\neq\u2081 :\n  (PreservesPullback.iso (forget C) (D.f i j) (D.f i k)).hom \u226b\n      pullback.fst ((forget C).map (D.f i j)) ((forget C).map (D.f i k)) =\n    (pullback.fst (D.f i j) (D.f i k)).base\neq\u2082 :\n  (PreservesPullback.iso (forget C) (D.f i j) (D.f i k)).hom \u226b\n      pullback.snd ((forget C).map (D.f i j)) ((forget C).map (D.f i k)) =\n    (pullback.snd (D.f i j) (D.f i k)).base\n\u22a2 Epi (PreservesPullback.iso (forget C) (D.f i j) (D.f i k)).hom",["infer_instance"]],["Geometry/RingedSpace/PresheafedSpace/Gluing.lean",254,"case h.h\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : GlueData C\ninst\u271d : HasLimits C\ni j : D.J\nU : Opens \u2191\u2191(D.U i)\n\u22a2 Mono ((HasColimit.isoOfNatIso (D.diagramIso (forget C))).inv \u226b (preservesColimitIso (forget C) D.diagram.multispan).inv)",["infer_instance"]],["Geometry/RingedSpace/PresheafedSpace/Gluing.lean",407,"case h.e'_5.inj\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : GlueData C\ninst\u271d : HasLimits C\ni : D.J\nU : Opens \u2191\u2191(D.U i)\nx y : \u2191\u2191(D.U i)\nh1 : y \u2208 U\nh2 :\n  (ConcreteCategory.hom (colimit.\u03b9 D.diagram.multispan (WalkingMultispan.right i)).base) y =\n    (ConcreteCategory.hom (colimit.\u03b9 D.diagram.multispan (WalkingMultispan.right i)).base) x\nthis : (D.mapGlueData (forget C)).\u03b9 i \u226b (D.gluedIso (forget C)).inv = (D.\u03b9 i).base\n\u22a2 Mono (D.gluedIso (forget C)).inv",["infer_instance"]],["Geometry/RingedSpace/PresheafedSpace/Gluing.lean",419,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : GlueData C\ninst\u271d : HasLimits C\ni : D.J\nU : Opens \u2191\u2191(D.U i)\n\u22a2 Epi (D.f i i).base",["infer_instance"]],["Geometry/RingedSpace/PresheafedSpace/Gluing.lean",455,"case inst\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : GlueData C\ninst\u271d : HasLimits C\ni j : D.J\nU : Opens \u2191\u2191(D.U i)\n\u22a2 Mono\n    ((D.f j i).c.app\n      (op ((opensFunctor (D.f j i)).obj ((Opens.map (D.t j i).base).obj ((Opens.map (D.f i j).base).obj U)))))",["infer_instance"]],["Geometry/RingedSpace/PresheafedSpace/Gluing.lean",457,"case inst\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : GlueData C\ninst\u271d : HasLimits C\ni j : D.J\nU : Opens \u2191\u2191(D.U i)\nthis : IsIso (D.t i j).c\n\u22a2 Mono\n    ((D.t i j).c.app\n      (op\n        ((Opens.map (D.f j i).base).obj\n          (unop\n            (op\n              ((Opens.map\n                    (colimit.\u03b9 D.diagram.multispan\n                        (unop (op (WalkingMultispan.right ((MultispanShape.prod D.J).snd (i, j)))))).base).obj\n                (\u22ef.functor.obj U)))))))",["infer_instance"]],["Geometry/RingedSpace/PresheafedSpace/Gluing.lean",485,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : GlueData C\ninst\u271d : HasLimits C\ni : D.J\nU : Opens \u2191\u2191(D.U i)\n\u22a2 IsIso\n    ((colimitPresheafObjIsoComponentwiseLimit D.diagram.multispan (\u22ef.functor.obj U)).hom \u226b\n      limit.\u03c0 (componentwiseDiagram D.diagram.multispan (\u22ef.functor.obj U)) (op (WalkingMultispan.right i)))",["infer_instance"]],["Geometry/RingedSpace/PresheafedSpace/Gluing.lean",577,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : GlueData C\ninst\u271d : HasLimits C\ni : D.J\nthis : PresheafedSpace.IsOpenImmersion (D.toPresheafedSpaceGlueData.\u03b9 i)\n\u22a2 IsOpenImmersion (D.toPresheafedSpaceGlueData.\u03b9 i \u226b D.isoPresheafedSpace.inv)",["infer_instance"]],["Topology/Algebra/Module/ModuleTopology.lean",455,"case eq_moduleTopology'\nR : Type u_1\ninst\u271d\u2079 : TopologicalSpace R\ninst\u271d\u2078 : Semiring R\nM : Type u_2\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : IsModuleTopology R M\nN : Type u_3\ninst\u271d\u00b3 : AddCommMonoid N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : TopologicalSpace N\ninst\u271d : IsModuleTopology R N\nthis\u271d\u00b2 : ContinuousAdd M\nthis\u271d\u00b9 : ContinuousAdd N\nP : Type (max u_2 u_3) := M \u00d7 N\n\u03c4P : TopologicalSpace P := moduleTopology R P\nthis\u271d : IsModuleTopology R P\nthis : ContinuousAdd P\ni : M \u00d7 N \u2192 P := id\ni\u2081 : M \u2192\u2097[R] P := LinearMap.inl R M N\ni\u2082 : N \u2192\u2097[R] P := LinearMap.inr R M N\n\u22a2 Continuous ((fun abcd \u21a6 abcd.1 + abcd.2) \u2218 fun ab \u21a6 (i\u2081 ab.1, i\u2082 ab.2))",["fun_prop"]],["Topology/Algebra/Module/ModuleTopology.lean",531,"case intro\nR : Type u_1\ninst\u271d\u00b9\u2070 : TopologicalSpace R\ninst\u271d\u2079 : CommSemiring R\nB : Type u_2\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\ninst\u271d\u2076 : TopologicalSpace B\ninst\u271d\u2075 : IsModuleTopology R B\nC : Type u_3\ninst\u271d\u2074 : AddCommMonoid C\ninst\u271d\u00b3 : Module R C\ninst\u271d\u00b2 : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_4\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nval\u271d : Fintype \u03b9\nh : (fun fb \u21a6 (bil fb.1) fb.2) = fun fb \u21a6 \u2211 i : \u03b9, fb.1 i \u2022 (bil \u21d1(Finsupp.single i 1)) fb.2\nthis : ContinuousAdd C\n\u22a2 Continuous fun fb \u21a6 \u2211 i : \u03b9, fb.1 i \u2022 (bil \u21d1(Finsupp.single i 1)) fb.2",["fun_prop"]],["Topology/Algebra/Module/ModuleTopology.lean",571,"R : Type u_1\ninst\u271d\u00b9\u00b2 : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : IsTopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R B\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u22a2 Continuous ((fun ba \u21a6 (bil.flip ba.1) ba.2) \u2218 Prod.swap)",["fun_prop"]],["Topology/Algebra/Module/ModuleTopology.lean",476,"case h_empty\nR : Type u_1\ninst\u271d\u2076 : TopologicalSpace R\ninst\u271d\u2075 : Semiring R\n\u03b9 : Type u_2\ninst\u271d\u2074 : Finite \u03b9\nA : PEmpty.{u_2 + 1} \u2192 Type u_3\ninst\u271d\u00b3 : (i : PEmpty.{u_2 + 1}) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b2 : (i : PEmpty.{u_2 + 1}) \u2192 Module R (A i)\ninst\u271d\u00b9 : (i : PEmpty.{u_2 + 1}) \u2192 TopologicalSpace (A i)\ninst\u271d : \u2200 (i : PEmpty.{u_2 + 1}), IsModuleTopology R (A i)\n\u22a2 IsModuleTopology R ((i : PEmpty.{u_2 + 1}) \u2192 A i)",["infer_instance"]],["Topology/Algebra/Module/ModuleTopology.lean",492,"R : Type u_1\ninst\u271d\u2077 : TopologicalSpace R\ninst\u271d\u2076 : Semiring R\n\u03b9\u271d : Type u_2\ninst\u271d\u2075 : Finite \u03b9\u271d\n\u03b9 : Type u_2\ninst\u271d\u2074 : Fintype \u03b9\nhind :\n  \u2200 {A : \u03b9 \u2192 Type u_3} [inst : (i : \u03b9) \u2192 AddCommMonoid (A i)] [inst_1 : (i : \u03b9) \u2192 Module R (A i)]\n    [inst_2 : (i : \u03b9) \u2192 TopologicalSpace (A i)] [inst_3 : \u2200 (i : \u03b9), IsModuleTopology R (A i)],\n    IsModuleTopology R ((i : \u03b9) \u2192 A i)\nA : Option \u03b9 \u2192 Type u_3\ninst\u271d\u00b3 : (i : Option \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b2 : (i : Option \u03b9) \u2192 Module R (A i)\ninst\u271d\u00b9 : (i : Option \u03b9) \u2192 TopologicalSpace (A i)\ninst\u271d : \u2200 (i : Option \u03b9), IsModuleTopology R (A i)\ne : Option \u03b9 \u2243 \u03b9 \u2295 Unit := Equiv.optionEquivSumPUnit \u03b9\nthis : IsModuleTopology R ((t : Unit) \u2192 A (e.symm (Sum.inr t)))\n\u22a2 IsModuleTopology R (((s : \u03b9) \u2192 A (e.symm (Sum.inl s))) \u00d7 ((t : Unit) \u2192 A (e.symm (Sum.inr t))))",["infer_instance"]],["CategoryTheory/Monad/Limits.lean",245,"C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nT : Monad C\nJ : Type u\ninst\u271d\u00b9 : Category.{v, u} J\ninst\u271d : PreservesColimitsOfShape J T.toFunctor\n\u22a2 {K : J \u2964 T.Algebra} \u2192 CreatesColimit K T.forget",["infer_instance"]],["CategoryTheory/Monad/Limits.lean",248,"C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nT : Monad C\nJ : Type u\ninst\u271d\u00b9 : Category.{v, u} J\ninst\u271d : PreservesColimitsOfSize.{v, u, v\u2081, v\u2081, u\u2081, u\u2081} T.toFunctor\n\u22a2 {J : Type u} \u2192 [inst : Category.{v, u} J] \u2192 CreatesColimitsOfShape J T.forget",["infer_instance"]],["CategoryTheory/Monad/Limits.lean",573,"C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nJ : Type u\ninst\u271d\u00b9 : Category.{v, u} J\nT : Comonad C\ninst\u271d : PreservesLimitsOfShape J T.toFunctor\n\u22a2 {K : J \u2964 T.Coalgebra} \u2192 CreatesLimit K T.forget",["infer_instance"]],["CategoryTheory/Monad/Limits.lean",576,"C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nJ : Type u\ninst\u271d\u00b9 : Category.{v, u} J\nT : Comonad C\ninst\u271d : PreservesLimitsOfSize.{v, u, v\u2081, v\u2081, u\u2081, u\u2081} T.toFunctor\n\u22a2 {J : Type u} \u2192 [inst : Category.{v, u} J] \u2192 CreatesLimitsOfShape J T.forget",["infer_instance"]],["Probability/Kernel/Composition/CompProd.lean",99,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03ba : Kernel \u03b1 \u03b2\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\ninst\u271d : IsSFiniteKernel \u03b7\na : \u03b1\nf : \u2115 \u2192 Set (\u03b2 \u00d7 \u03b3)\nhf_meas : \u2200 (i : \u2115), MeasurableSet (f i)\nhf_disj : Pairwise (Disjoint on f)\nh_Union : (fun b \u21a6 (\u03b7 (a, b)) {c | (b, c) \u2208 \u22c3 i, f i}) = fun b \u21a6 (\u03b7 (a, b)) (\u22c3 i, {c | (b, c) \u2208 f i})\nh_tsum : (fun b \u21a6 (\u03b7 (a, b)) (\u22c3 i, {c | (b, c) \u2208 f i})) = fun b \u21a6 \u2211' (i : \u2115), (\u03b7 (a, b)) {c | (b, c) \u2208 f i}\ni : \u2115\n\u22a2 Measurable fun p \u21a6 (p.1.2, p.2)",["fun_prop"]],["Probability/Kernel/Composition/CompProd.lean",413,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d\u00b9 : IsSFiniteKernel \u03ba\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\ninst\u271d : IsSFiniteKernel \u03b7\na : \u03b1\nf : \u03b2 \u2192 \u03b3 \u2192 \u211d\u22650\u221e\nhf : Measurable (Function.uncurry f)\nF : \u2115 \u2192 SimpleFunc (\u03b2 \u00d7 \u03b3) \u211d\u22650\u221e := SimpleFunc.eapprox (Function.uncurry f)\nh : \u2200 (a : \u03b2) (b : \u03b3), \u2a06 n, (F n) (a, b) = f a b\nh_mono : Monotone F\nthis\u271d : \u2200 (b : \u03b2), \u222b\u207b (c : \u03b3), \u2a06 n, (F n) (b, c) \u2202\u03b7 (a, b) = \u2a06 n, \u222b\u207b (c : \u03b3), (F n) (b, c) \u2202\u03b7 (a, b)\nf' : SimpleFunc (\u03b2 \u00d7 \u03b3) \u211d\u22650\u221e\nthis : (fun b \u21a6 \u222b\u207b (c : \u03b3), f' (b, c) \u2202\u03b7 (a, b)) = (fun ab \u21a6 \u222b\u207b (c : \u03b3), f' (ab.2, c) \u2202\u03b7 ab) \u2218 fun b \u21a6 (a, b)\n\u22a2 Measurable ((fun ab \u21a6 \u222b\u207b (c : \u03b3), f' (ab.2, c) \u2202\u03b7 ab) \u2218 fun b \u21a6 (a, b))",["fun_prop"]],["Probability/Kernel/Composition/CompProd.lean",524,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ns : Set (\u03b2 \u00d7 \u03b3)\ninst\u271d\u00b9 : IsZeroOrMarkovKernel 0\ninst\u271d : IsZeroOrMarkovKernel 0\n\u22a2 IsZeroOrMarkovKernel 0\n```\n---\n```lean\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ns : Set (\u03b2 \u00d7 \u03b3)\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\ninst\u271d\u00b9 : IsZeroOrMarkovKernel \u03b7\ninst\u271d : IsZeroOrMarkovKernel 0\nh\u271d : IsMarkovKernel \u03b7\n\u22a2 IsZeroOrMarkovKernel 0\n```\n---\n```lean\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ns : Set (\u03b2 \u00d7 \u03b3)\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d\u00b9 : IsZeroOrMarkovKernel \u03ba\nh\u271d : IsMarkovKernel \u03ba\ninst\u271d : IsZeroOrMarkovKernel 0\n\u22a2 IsZeroOrMarkovKernel 0\n```\n---\n```lean\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ns : Set (\u03b2 \u00d7 \u03b3)\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d\u00b9 : IsZeroOrMarkovKernel \u03ba\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\ninst\u271d : IsZeroOrMarkovKernel \u03b7\nh\u271d\u00b9 : IsMarkovKernel \u03ba\nh\u271d : IsMarkovKernel \u03b7\n\u22a2 IsZeroOrMarkovKernel (\u03ba \u2297\u2096 \u03b7)",["infer_instance"]],["Probability/Kernel/Composition/CompProd.lean",554,"case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ns : Set (\u03b2 \u00d7 \u03b3)\n\u03ba : Kernel \u03b1 \u03b2\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\nh : \u00acIsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel 0",["infer_instance"]],["Probability/Kernel/Composition/CompProd.lean",558,"case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ns : Set (\u03b2 \u00d7 \u03b3)\n\u03ba : Kernel \u03b1 \u03b2\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\nh\u271d : IsSFiniteKernel \u03ba\nh : \u00acIsSFiniteKernel \u03b7\n\u22a2 IsSFiniteKernel 0",["infer_instance"]],["Probability/Kernel/Composition/CompProd.lean",560,"case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ns : Set (\u03b2 \u00d7 \u03b3)\n\u03ba : Kernel \u03b1 \u03b2\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\nh\u271d : IsSFiniteKernel \u03ba\nh : IsSFiniteKernel \u03b7\n\u22a2 IsSFiniteKernel (Kernel.sum fun n \u21a6 Kernel.sum fun m \u21a6 \u03ba.seq n \u2297\u2096 \u03b7.seq m)",["infer_instance"]],["Analysis/Calculus/UniformLimitsDeriv.lean",465,"case intro.intro\n\u03b9 : Type u_1\nl : Filter \u03b9\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nG : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nf' : \u03b9 \u2192 \ud835\udd5c \u2192 G\nl' : Filter \ud835\udd5c\nhf' : \u2200 \u03b5 > 0, \u2200\u1da0 (n : (\u03b9 \u00d7 \u03b9) \u00d7 \ud835\udd5c) in (l \u00d7\u02e2 l) \u00d7\u02e2 l', dist (0 n.2) (f' n.1.1 n.2 - f' n.1.2 n.2) < \u03b5\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nq : \u211d\nhq : 0 < q\nhq' : q < \u03b5\nn : (\u03b9 \u00d7 \u03b9) \u00d7 \ud835\udd5c\nhn : \u2016f' n.1.1 n.2 - f' n.1.2 n.2\u2016 < q\nz : \ud835\udd5c\n\u22a2 \u2016f' n.1.1 n.2 - f' n.1.2 n.2\u2016 * \u2016z\u2016 \u2264 q * \u2016z\u2016",["gcongr"]],["Analysis/Calculus/UniformLimitsDeriv.lean",512,"case intro.intro\n\u03b9 : Type u_1\nl : Filter \u03b9\n\ud835\udd5c : Type u_2\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nG : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nf : \u03b9 \u2192 \ud835\udd5c \u2192 G\ng : \ud835\udd5c \u2192 G\nf' : \u03b9 \u2192 \ud835\udd5c \u2192 G\ng' : \ud835\udd5c \u2192 G\nx : \ud835\udd5c\ninst\u271d\u00b9 : IsRCLikeNormedField \ud835\udd5c\ninst\u271d : l.NeBot\nhf' : \u2200 \u03b5 > 0, \u2200\u1da0 (n : \u03b9 \u00d7 \ud835\udd5c) in l \u00d7\u02e2 \ud835\udcdd x, dist (g' n.2) (f' n.1 n.2) < \u03b5\nhfg : \u2200\u1da0 (y : \ud835\udd5c) in \ud835\udcdd x, Tendsto (fun n \u21a6 f n y) l (\ud835\udcdd (g y))\nF' : \u03b9 \u2192 \ud835\udd5c \u2192 \ud835\udd5c \u2192L[\ud835\udd5c] G := fun n z \u21a6 ContinuousLinearMap.smulRight 1 (f' n z)\nG' : \ud835\udd5c \u2192 \ud835\udd5c \u2192L[\ud835\udd5c] G := fun z \u21a6 ContinuousLinearMap.smulRight 1 (g' z)\nhf : \u2200\u1da0 (n : \u03b9 \u00d7 \ud835\udd5c) in l \u00d7\u02e2 \ud835\udcdd x, HasFDerivAt (f n.1) (ContinuousLinearMap.smulRight 1 (f' n.1 n.2)) n.2\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nq : \u211d\nhq : 0 < q\nhq' : q < \u03b5\nn : \u03b9 \u00d7 \ud835\udd5c\nhn : \u2016g' n.2 - f' n.1 n.2\u2016 < q\nz : \ud835\udd5c\n\u22a2 \u2016g' n.2 - f' n.1 n.2\u2016 * \u2016z\u2016 \u2264 q * \u2016z\u2016",["gcongr"]],["NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean",374,"case intro.intro.intro.refine_1.h\nz \u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\nT : \u211d\nhT : 0 < T\nh\u03c4' : T < \u03c4.im\nS : \u211d\nhz : |z.im| < S\nV : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}\nhVo : IsOpen V\nu : \u2124 \u2192 \u211d := fun n \u21a6 2 * \u03c0 * \u2191|n| * rexp (-\u03c0 * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))\nhu : Summable u\nn : \u2124\n\u22a2 Continuous fun p \u21a6 2 * \u2191\u03c0 * I * \u2191n * cexp (2 * \u2191\u03c0 * I * \u2191n * p.1 + \u2191\u03c0 * I * \u2191n ^ 2 * p.2)",["fun_prop"]],["GroupTheory/HNNExtension.lean",55,"G : Type u_1\ninst\u271d\u00b2 : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nH : Type u_2\ninst\u271d\u00b9 : Group H\nM : Type u_3\ninst\u271d : Monoid M\n\u22a2 Group (HNNExtension.con G A B \u03c6).Quotient",["infer_instance"]],["Algebra/GroupWithZero/Associated.lean",704,"M : Type u_1\ninst\u271d : CancelCommMonoidWithZero M\n\u22a2 NoZeroDivisors (Associates M)",["infer_instance"]],["Analysis/Calculus/FDeriv/Prod.lean",472,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\n\u03b9 : Type u_6\ninst\u271d\u00b2 : Fintype \u03b9\nF' : \u03b9 \u2192 Type u_7\ninst\u271d\u00b9 : (i : \u03b9) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (F' i)\ni : \u03b9\nf : (i : \u03b9) \u2192 F' i\ns' : Set ((i : \u03b9) \u2192 F' i)\n\u22a2 HasFDerivWithinAt (fun f \u21a6 f i) ?f' s' f\n```\n---\n```lean\ncase f'\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\n\u03b9 : Type u_6\ninst\u271d\u00b2 : Fintype \u03b9\nF' : \u03b9 \u2192 Type u_7\ninst\u271d\u00b9 : (i : \u03b9) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (F' i)\ni : \u03b9\nf : (i : \u03b9) \u2192 F' i\ns' : Set ((i : \u03b9) \u2192 F' i)\n\u22a2 ((i : \u03b9) \u2192 F' i) \u2192L[\ud835\udd5c] F' i",["fun_prop"]],["GroupTheory/PushoutI.lean",70,"\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_2\nH : Type u_3\nK : Type u_4\ninst\u271d\u00b2 : Monoid K\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Monoid (G i)\ninst\u271d : Monoid H\n\u03c6 : (i : \u03b9) \u2192 H \u2192* G i\n\u22a2 One (con \u03c6).Quotient",["infer_instance"]],["Probability/Moments/IntegrableExpMul.lean",124,"\u03a9\u271d : Type u_1\nm\u271d : MeasurableSpace \u03a9\u271d\nX\u271d : \u03a9\u271d \u2192 \u211d\n\u03bc\u271d : Measure \u03a9\u271d\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt\u2081 : \u211d\nht\u2081 : t\u2081 \u2208 integrableExpSet X \u03bc\nt\u2082 : \u211d\nht\u2082 : t\u2082 \u2208 integrableExpSet X \u03bc\na b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\nh_le : t\u2081 \u2264 t\u2082\n\u22a2 a * t\u2081 + b * t\u2081 \u2264 a * t\u2081 + b * t\u2082",["gcongr"]],["Probability/Moments/IntegrableExpMul.lean",127,"\u03a9\u271d : Type u_1\nm\u271d : MeasurableSpace \u03a9\u271d\nX\u271d : \u03a9\u271d \u2192 \u211d\n\u03bc\u271d : Measure \u03a9\u271d\n\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt\u2081 : \u211d\nht\u2081 : t\u2081 \u2208 integrableExpSet X \u03bc\nt\u2082 : \u211d\nht\u2082 : t\u2082 \u2208 integrableExpSet X \u03bc\na b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\nh_le : t\u2081 \u2264 t\u2082\n\u22a2 a * t\u2081 + b * t\u2082 \u2264 a * t\u2082 + b * t\u2082",["gcongr"]],["Probability/Moments/IntegrableExpMul.lean",268,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt v x : \u211d\nh_int_pos : Integrable (fun \u03c9 \u21a6 rexp ((v + t) * X \u03c9)) \u03bc\nh_int_neg : Integrable (fun \u03c9 \u21a6 rexp ((v - t) * X \u03c9)) \u03bc\nh_nonneg : 0 \u2264 x\nhx : x < |t|\np : \u211d\nhp : 0 \u2264 p\nht : t \u2260 0\nhX : AEMeasurable X \u03bc\n\u22a2 AEMeasurable (fun a \u21a6 |X a| ^ p * rexp (v * X a + x * |X a|)) \u03bc",["fun_prop"]],["Probability/Moments/IntegrableExpMul.lean",555,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz : \u2102\nhX : AEMeasurable X \u03bc\nhz : z.re \u2208 integrableExpSet X \u03bc\n\u22a2 AEMeasurable (fun \u03c9 \u21a6 cexp (z * \u2191(X \u03c9))) \u03bc",["fun_prop"]],["Probability/Moments/IntegrableExpMul.lean",568,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz : \u2102\nhz : z.re \u2208 interior (integrableExpSet X \u03bc)\np : \u211d\nhp : 0 \u2264 p\nhX : AEMeasurable X \u03bc\n\u22a2 AEMeasurable (fun \u03c9 \u21a6 \u2191(|X \u03c9| ^ p) * cexp (z * \u2191(X \u03c9))) \u03bc",["fun_prop"]],["Probability/Moments/IntegrableExpMul.lean",583,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz : \u2102\nhz : z.re \u2208 interior (integrableExpSet X \u03bc)\np : \u211d\nhp : 0 \u2264 p\nhX : AEMeasurable X \u03bc\n\u22a2 AEMeasurable (fun \u03c9 \u21a6 \u2191(X \u03c9 ^ p) * cexp (z * \u2191(X \u03c9))) \u03bc",["fun_prop"]],["Probability/Moments/IntegrableExpMul.lean",587,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz : \u2102\nhz : z.re \u2208 interior (integrableExpSet X \u03bc)\np : \u211d\nhp : 0 \u2264 p\nhX : AEMeasurable X \u03bc\n\u22a2 AEMeasurable (fun a \u21a6 \u2016X a ^ p\u2016 * rexp (z.re * X a)) \u03bc",["fun_prop"]],["NumberTheory/LSeries/HurwitzZetaOdd.lean",161,"a x : \u211d\nhx : x \u2208 Ioi 0\n\u22a2 Continuous fun u \u21a6 (\u2191a * I * \u2191u, I * \u2191u)",["fun_prop"]],["NumberTheory/LSeries/HurwitzZetaOdd.lean",175,"a x : \u211d\nhx : x \u2208 Ioi 0\nh : ContinuousAt (fun p \u21a6 jacobiTheta\u2082' p.1 p.2) (\u2191a, I * \u2191x)\n\u22a2 ContinuousAt (fun x \u21a6 jacobiTheta\u2082' (\u2191a) (I * \u2191x)) x",["fun_prop"]],["Probability/Kernel/Composition/MapComap.lean",51,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\nf\u271d : \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b1\n\u03ba : Kernel \u03b1 \u03b2\nf : \u03b2 \u2192 \u03b3\nhf : Measurable f\n\u22a2 Measurable fun a \u21a6 Measure.map f (\u03ba a)",["fun_prop"]],["Probability/Kernel/Composition/MapComap.lean",122,"case pos.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\nf\u271d : \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b1\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsZeroOrMarkovKernel \u03ba\nf : \u03b2 \u2192 \u03b3\nhf : Measurable f\nh : IsMarkovKernel \u03ba\nthis : IsMarkovKernel (\u03ba.map f)\n\u22a2 IsZeroOrMarkovKernel (\u03ba.map f)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",190,"case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\nf : \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b1\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsZeroOrMarkovKernel \u03ba\nhg : Measurable g\nh : IsMarkovKernel \u03ba\nthis : IsMarkovKernel (\u03ba.comap g hg)\n\u22a2 IsZeroOrMarkovKernel (\u03ba.comap g hg)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",283,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsMarkovKernel \u03ba\n\u22a2 IsMarkovKernel (\u03ba.comap Prod.snd \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",286,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsMarkovKernel \u03ba\n\u22a2 IsMarkovKernel (\u03ba.comap Prod.fst \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",289,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsZeroOrMarkovKernel \u03ba\n\u22a2 IsZeroOrMarkovKernel (\u03ba.comap Prod.snd \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",292,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsZeroOrMarkovKernel \u03ba\n\u22a2 IsZeroOrMarkovKernel (\u03ba.comap Prod.fst \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",295,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsFiniteKernel (\u03ba.comap Prod.snd \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",298,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsFiniteKernel (\u03ba.comap Prod.fst \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",301,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel (\u03ba.comap Prod.snd \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",304,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel (\u03ba.comap Prod.fst \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",310,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\nx\u271d : IsSFiniteKernel (prodMkLeft Unit \u03ba)\n\u22a2 IsSFiniteKernel ((prodMkLeft Unit \u03ba).comap (fun a \u21a6 ((), a)) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",316,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\nx\u271d : IsSFiniteKernel (prodMkRight Unit \u03ba)\n\u22a2 IsSFiniteKernel ((prodMkRight Unit \u03ba).comap (fun a \u21a6 (a, ())) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",350,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\ninst\u271d : IsMarkovKernel \u03ba\n\u22a2 IsMarkovKernel (\u03ba.comap Prod.swap \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",353,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsFiniteKernel (\u03ba.comap Prod.swap \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",356,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\ninst\u271d : IsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel (\u03ba.comap Prod.swap \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",391,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)\ninst\u271d : IsZeroOrMarkovKernel \u03ba\n\u22a2 IsZeroOrMarkovKernel (\u03ba.map Prod.swap)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",394,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsFiniteKernel (\u03ba.map Prod.swap)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",397,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)\ninst\u271d : IsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel (\u03ba.map Prod.swap)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",424,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)\ninst\u271d : IsZeroOrMarkovKernel \u03ba\n\u22a2 IsZeroOrMarkovKernel (\u03ba.map Prod.fst)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",427,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsFiniteKernel (\u03ba.map Prod.fst)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",430,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)\ninst\u271d : IsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel (\u03ba.map Prod.fst)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",485,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)\ninst\u271d : IsZeroOrMarkovKernel \u03ba\n\u22a2 IsZeroOrMarkovKernel (\u03ba.map Prod.snd)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",488,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsFiniteKernel (\u03ba.map Prod.snd)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",491,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 (\u03b2 \u00d7 \u03b3)\ninst\u271d : IsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel (\u03ba.map Prod.snd)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",551,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\nb : \u03b2\ninst\u271d : IsMarkovKernel \u03ba\n\u22a2 IsMarkovKernel (\u03ba.comap (fun a \u21a6 (a, b)) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",555,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\nb : \u03b2\ninst\u271d : IsZeroOrMarkovKernel \u03ba\n\u22a2 IsZeroOrMarkovKernel (\u03ba.comap (fun a \u21a6 (a, b)) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",558,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\nb : \u03b2\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsFiniteKernel (\u03ba.comap (fun a \u21a6 (a, b)) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",561,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\nb : \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel (\u03ba.comap (fun a \u21a6 (a, b)) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",595,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\ninst\u271d : IsMarkovKernel \u03ba\n\u22a2 IsMarkovKernel (\u03ba.comap (fun b \u21a6 (a, b)) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",599,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\ninst\u271d : IsZeroOrMarkovKernel \u03ba\n\u22a2 IsZeroOrMarkovKernel (\u03ba.comap (fun b \u21a6 (a, b)) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",602,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsFiniteKernel (\u03ba.comap (fun b \u21a6 (a, b)) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",605,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\ninst\u271d : IsSFiniteKernel \u03ba\n\u22a2 IsSFiniteKernel (\u03ba.comap (fun b \u21a6 (a, b)) \u22ef)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",640,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d : Nonempty \u03b3\n\u03ba : Kernel \u03b1 \u03b2\ninhabited_h : Inhabited \u03b3\nh : IsSFiniteKernel (prodMkLeft \u03b3 \u03ba)\n\u22a2 IsSFiniteKernel ((prodMkLeft \u03b3 \u03ba).sectR default)",["infer_instance"]],["Probability/Kernel/Composition/MapComap.lean",647,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d : Nonempty \u03b3\n\u03ba : Kernel \u03b1 \u03b2\ninhabited_h : Inhabited \u03b3\nh : IsSFiniteKernel (prodMkRight \u03b3 \u03ba)\n\u22a2 IsSFiniteKernel ((prodMkRight \u03b3 \u03ba).sectL default)",["infer_instance"]],["MeasureTheory/Integral/PeakFunction.lean",431,"E : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : CompleteSpace E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \u211d F\ninst\u271d\u00b3 : FiniteDimensional \u211d F\ninst\u271d\u00b2 : MeasurableSpace F\ninst\u271d\u00b9 : BorelSpace F\n\u03bc : Measure F\ninst\u271d : \u03bc.IsAddHaarMeasure\n\u03c6 : F \u2192 \u211d\nh\u03c6 : \u2200 (x : F), 0 \u2264 \u03c6 x\nh'\u03c6 : \u222b (x : F), \u03c6 x \u2202\u03bc = 1\nh : Tendsto (fun x \u21a6 \u2016x\u2016 ^ finrank \u211d F * \u03c6 x) (cobounded F) (\ud835\udcdd 0)\ng : F \u2192 E\nhg : Integrable g \u03bc\nh'g : ContinuousAt g 0\nI : Integrable \u03c6 \u03bc\nu : Set F\nu_open : IsOpen u\nhu : 0 \u2208 u\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\n\u03b4 : \u211d\n\u03b4pos : \u03b4 > 0\nh'u : ball 0 \u03b4 \u2286 u\nM : \u211d\nMpos : M > 0\nhM : \u2200 \u2983x : F\u2984, x \u2208 (closedBall 0 M)\u1d9c \u2192 \u2016x\u2016 ^ finrank \u211d F * \u03c6 x < \u03b4 ^ finrank \u211d F * \u03b5\nc : \u211d\nhc : M < c * \u03b4\nx : F\nhx : x \u2208 u\u1d9c\ncpos : 0 < c\nh\u03b4x : \u03b4 \u2264 \u2016x\u2016\n\u22a2 c * \u03b4 \u2264 c * \u2016x\u2016",["gcongr","aesop"]],["MeasureTheory/Integral/PeakFunction.lean",461,"E : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : CompleteSpace E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \u211d F\ninst\u271d\u00b3 : FiniteDimensional \u211d F\ninst\u271d\u00b2 : MeasurableSpace F\ninst\u271d\u00b9 : BorelSpace F\n\u03bc : Measure F\ninst\u271d : \u03bc.IsAddHaarMeasure\n\u03c6 : F \u2192 \u211d\nh\u03c6 : \u2200 (x : F), 0 \u2264 \u03c6 x\nh'\u03c6 : \u222b (x : F), \u03c6 x \u2202\u03bc = 1\nh : Tendsto (fun x \u21a6 \u2016x\u2016 ^ finrank \u211d F * \u03c6 x) (cobounded F) (\ud835\udcdd 0)\ng : F \u2192 E\nx\u2080 : F\nhg : Integrable g \u03bc\nh'g : ContinuousAt g x\u2080\nf : F \u2192 E := fun x \u21a6 g (x\u2080 - x)\nIf : Integrable f \u03bc\nA : ContinuousAt g (x\u2080 - 0)\n\u22a2 ContinuousAt (HSub.hSub x\u2080) 0",["fun_prop"]],["Combinatorics/SimpleGraph/Regularity/Chunk.lean",238,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\nP : Finpartition univ\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nh\u03b5\u2081 : \u03b5 \u2264 1\nthis : 0 \u2264 \u03b5\n\u22a2 1 + \u03b5 ^ 5 * (50\u207b\u00b9 + \u03b5 ^ 5 / 10000) \u2264 1 + \u03b5 ^ 5 * (50\u207b\u00b9 + 1 ^ 5 / 10000)",["gcongr"]],["AlgebraicGeometry/Limits.lean",90,"\u22a2 IsEmpty PEmpty.{u + 1}",["infer_instance"]],["AlgebraicGeometry/Limits.lean",130,"A : Scheme\nf : A \u27f6 \u22a5_ Scheme\n\u22a2 IsIso f",["infer_instance"]],["AlgebraicGeometry/Limits.lean",133,"X : Scheme\ninst\u271d : IsEmpty \u2191\u2191X.toPresheafedSpace\n\u22a2 Subsingleton \u2191\u0393(X, \u22a5)",["infer_instance"]],["AlgebraicGeometry/Limits.lean",154,"\u03b9 : Type u\nf : \u03b9 \u2192 Scheme\nx\u271d\u00b9 x\u271d : \u03b9\n\u22a2 x\u271d\u00b9 \u2260 x\u271d \u2192 Mono (f x\u271d\u00b9).emptyTo",["infer_instance"]],["AlgebraicGeometry/Limits.lean",254,"\u03b9 : Type u\nf : \u03b9 \u2192 Scheme\n\u03c3 : Type v\ng : \u03c3 \u2192 Scheme\ni : \u03b9\n\u22a2 IsOpenImmersion ((disjointGlueData f).\u03b9 i \u226b (sigmaIsoGlued f).inv)",["infer_instance"]],["AlgebraicGeometry/Limits.lean",260,"case intro.intro.intro\n\u03b9\u271d : Type u\nf : \u03b9\u271d \u2192 Scheme\n\u03c3 : Type v\ng : \u03c3 \u2192 Scheme\ninst\u271d : Small.{u, v} \u03c3\n\u03b9 : Type u\ne : \u03c3 \u2243 \u03b9\ni : \u03b9\n\u22a2 IsOpenImmersion (Sigma.\u03b9 (g \u2218 \u21d1e.symm) i \u226b (Sigma.reindex e.symm g).hom)",["infer_instance"]],["AlgebraicGeometry/Limits.lean",405,"\u03b9 : Type u\nf : \u03b9 \u2192 Scheme\n\u03c3 : Type v\ng : \u03c3 \u2192 Scheme\nX Y : Scheme\n\u22a2 IsOpenImmersion\n    (Sigma.\u03b9 (fun i \u21a6 WalkingPair.casesOn i.down X Y) { down := WalkingPair.left } \u226b (coprodIsoSigma X Y).inv)",["infer_instance"]],["AlgebraicGeometry/Limits.lean",408,"\u03b9 : Type u\nf : \u03b9 \u2192 Scheme\n\u03c3 : Type v\ng : \u03c3 \u2192 Scheme\nX Y : Scheme\n\u22a2 IsOpenImmersion\n    (Sigma.\u03b9 (fun i \u21a6 WalkingPair.casesOn i.down X Y) { down := WalkingPair.right } \u226b (coprodIsoSigma X Y).inv)",["infer_instance"]],["AlgebraicGeometry/Limits.lean",529,"case intro.inl\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nx : \u2191\u2191(Spec (CommRingCat.of R)).toPresheafedSpace\nthis\u271d\u00b2 :\n  (((Spec (CommRingCat.of (R \u00d7 S))).presheaf.stalkCongr \u22ef).hom \u226b\n        Scheme.Hom.stalkMap (Spec.map (CommRingCat.ofHom (RingHom.fst R S))) x) \u226b\n      inv (Scheme.Hom.stalkMap coprod.inl x) =\n    Scheme.Hom.stalkMap (coprodSpec R S) ((ConcreteCategory.hom coprod.inl.base) x)\nthis\u271d\u00b9 : Algebra (R \u00d7 S) R := (RingHom.fst R S).toAlgebra\nthis\u271d : IsLocalization.Away (1, 0) R\nthis : IsOpenImmersion (Spec.map (CommRingCat.ofHom (RingHom.fst R S)))\n\u22a2 IsIso\n    ((((Spec (CommRingCat.of (R \u00d7 S))).presheaf.stalkCongr \u22ef).hom \u226b\n        Scheme.Hom.stalkMap (Spec.map (CommRingCat.ofHom (RingHom.fst R S))) x) \u226b\n      inv (Scheme.Hom.stalkMap coprod.inl x))",["infer_instance"]],["AlgebraicGeometry/Limits.lean",537,"case intro.inr\nR S : Type u\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nx : \u2191\u2191(Spec (CommRingCat.of S)).toPresheafedSpace\nthis\u271d\u00b2 :\n  (((Spec (CommRingCat.of (R \u00d7 S))).presheaf.stalkCongr \u22ef).hom \u226b\n        Scheme.Hom.stalkMap (Spec.map (CommRingCat.ofHom (RingHom.snd R S))) x) \u226b\n      inv (Scheme.Hom.stalkMap coprod.inr x) =\n    Scheme.Hom.stalkMap (coprodSpec R S) ((ConcreteCategory.hom coprod.inr.base) x)\nthis\u271d\u00b9 : Algebra (R \u00d7 S) S := (RingHom.snd R S).toAlgebra\nthis\u271d : IsLocalization.Away (0, 1) S\nthis : IsOpenImmersion (Spec.map (CommRingCat.ofHom (RingHom.snd R S)))\n\u22a2 IsIso\n    ((((Spec (CommRingCat.of (R \u00d7 S))).presheaf.stalkCongr \u22ef).hom \u226b\n        Scheme.Hom.stalkMap (Spec.map (CommRingCat.ofHom (RingHom.snd R S))) x) \u226b\n      inv (Scheme.Hom.stalkMap coprod.inr x))",["infer_instance"]],["AlgebraicGeometry/Limits.lean",562,"case op.op\n\u03b9 : Type u\nf : \u03b9 \u2192 Scheme\n\u03c3 : Type v\ng : \u03c3 \u2192 Scheme\nX Y : Scheme\nR\u271d S\u271d : Type u\ninst\u271d\u00b9 : CommRing R\u271d\ninst\u271d : CommRing S\u271d\nR S : CommRingCat\nthis :\n  coprodComparison Scheme.Spec (op R) (op S) \u226b\n      Spec.map\n        ((limit.isoLimitCone { cone := R.prodFan S, isLimit := R.prodFanIsLimit S }).inv \u226b\n          (opProdIsoCoprod R S).unop.inv) =\n    coprodSpec \u2191R \u2191S\n\u22a2 IsIso\n    (coprodSpec \u2191R \u2191S \u226b\n      inv\n        (Spec.map\n          ((limit.isoLimitCone { cone := R.prodFan S, isLimit := R.prodFanIsLimit S }).inv \u226b\n            (opProdIsoCoprod R S).unop.inv)))",["infer_instance"]],["AlgebraicGeometry/Limits.lean",626,"\u03b9 : Type u\nf : \u03b9 \u2192 Scheme\n\u03c3 : Type v\ng : \u03c3 \u2192 Scheme\nX Y : Scheme\nR\u271d S : Type u\ninst\u271d\u00b2 : CommRing R\u271d\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Finite \u03b9\nR : \u03b9 \u2192 CommRingCat\nthis :\n  sigmaSpec R =\n    (colimit.isoColimitCocone\n        {\n          cocone :=\n            (Cocones.precompose Discrete.natIsoFunctor.symm.hom).obj (Scheme.Spec.mapCocone (CommRingCat.piFan R).op),\n          isColimit :=\n            (IsColimit.precomposeHomEquiv Discrete.natIsoFunctor.symm\n                  (Scheme.Spec.mapCocone (CommRingCat.piFan R).op)).symm\n              (isColimitOfPreserves Scheme.Spec (Fan.IsLimit.op (CommRingCat.piFanIsLimit R))) }).hom\n\u22a2 IsIso\n    (colimit.isoColimitCocone\n        {\n          cocone :=\n            (Cocones.precompose Discrete.natIsoFunctor.symm.hom).obj (Scheme.Spec.mapCocone (CommRingCat.piFan R).op),\n          isColimit :=\n            (IsColimit.precomposeHomEquiv Discrete.natIsoFunctor.symm\n                  (Scheme.Spec.mapCocone (CommRingCat.piFan R).op)).symm\n              (isColimitOfPreserves Scheme.Spec (Fan.IsLimit.op (CommRingCat.piFanIsLimit R))) }).hom",["infer_instance"]],["MeasureTheory/Constructions/BorelSpace/Real.lean",450,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort y\ns t u : Set \u03b1\nm\u03b1 : MeasurableSpace \u03b1\n\u22a2 Measurable fun r \u21a6 \u2191r.1 * r.2",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",244,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : E \u2192 F\nf' : F\ns t : Set E\nx v : E\nh : HasLineDerivWithinAt \ud835\udd5c f f' t x v\nhst : t \u2208 \ud835\udcdd[s] x\n\u22a2 Continuous fun t \u21a6 x + t \u2022 v",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",287,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : E \u2192 F\ns : Set E\nx v : E\nh : s \u2208 \ud835\udcdd x\n\u22a2 Continuous fun t \u21a6 x + t \u2022 v",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",297,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF\u271d : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\u271d\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\u271d\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : E \u2192 F\u271d\nf' : F\u271d\ns t : Set E\nx v : E\nh : s =\u1da0[\ud835\udcdd x] t\nF : \ud835\udd5c \u2192 E := fun t \u21a6 x + t \u2022 v\n\u22a2 Continuous F",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",312,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF\u271d : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\u271d\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\u271d\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : E \u2192 F\u271d\ns t : Set E\nx v : E\nh : s =\u1da0[\ud835\udcdd x] t\nF : \ud835\udd5c \u2192 E := fun t \u21a6 x + t \u2022 v\n\u22a2 Continuous F",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",320,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF\u271d : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\u271d\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\u271d\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf\u2080 f\u2081 : E \u2192 F\u271d\nf' : F\u271d\nx v : E\nh : f\u2080 =\u1da0[\ud835\udcdd x] f\u2081\nF : \ud835\udd5c \u2192 E := fun t \u21a6 x + t \u2022 v\n\u22a2 Continuous F",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",332,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf\u2080 f\u2081 : E \u2192 F\nf' : F\ns : Set E\nx v : E\nh : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081\nhx : f\u2080 x = f\u2081 x\n\u22a2 Continuous fun t \u21a6 x + t \u2022 v",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",354,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2081 : E \u2192 F\nf' : F\ns : Set E\nx v : E\nhf : HasLineDerivWithinAt \ud835\udd5c f f' s x v\nh'f : f\u2081 =\u1da0[\ud835\udcdd[s] x] f\nhx : f\u2081 x = f x\n\u22a2 Continuous fun t \u21a6 x + t \u2022 v",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",379,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2081 : E \u2192 F\ns : Set E\nx v : E\nhs : f\u2081 =\u1da0[\ud835\udcdd[s] x] f\nhx : f\u2081 x = f x\n\u22a2 Continuous fun t \u21a6 x + t \u2022 v",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",398,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nv : E\nf : E \u2192 F\nf' : F\nx\u2080 : E\nhf : HasLineDerivAt \ud835\udd5c f f' x\u2080 v\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u22a2 Continuous fun t \u21a6 x\u2080 + t \u2022 v",["fun_prop"]],["Analysis/Calculus/LineDeriv/Basic.lean",433,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nv : E\nf : E \u2192 F\nx\u2080 : E\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u22a2 Continuous fun t \u21a6 x\u2080 + t \u2022 v",["fun_prop"]],["Topology/EMetricSpace/Lipschitz.lean",457,"\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\ns s' : Set \u03b1\nt : Set \u03b2\nhs' : s' \u2286 s\nhss' : s \u2286 closure s'\nK : \u211d\u22650\nha : \u2200 a \u2208 s', ContinuousOn (fun y \u21a6 f (a, y)) t\nhb : \u2200 b \u2208 t, LipschitzOnWith K (fun x \u21a6 f (x, b)) s\nx : \u03b1\ny : \u03b2\nhx : x \u2208 s\nhy : y \u2208 t\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : 0 < \u03b5 / 2\n\u03b4 : \u211d\u22650\n\u03b4pos : 0 < \u2191\u03b4\nh\u03b4 : \u2191\u03b4 * \u2191(3 * K) < \u03b5 / 2\nx' : \u03b1\nhx' : x' \u2208 s'\nhxx' : edist x x' < \u2191\u03b4\nA : s \u2229 EMetric.ball x \u2191\u03b4 \u2208 \ud835\udcdd[s] x\nB : t \u2229 {b | edist (f (x', b)) (f (x', y)) \u2264 \u03b5 / 2} \u2208 \ud835\udcdd[t] y\na : \u03b1\nb : \u03b2\nhas : (a, b).1 \u2208 s\nhax : (a, b).1 \u2208 EMetric.ball x \u2191\u03b4\nhbt : (a, b).2 \u2208 t\nhby : (a, b).2 \u2208 {b | edist (f (x', b)) (f (x', y)) \u2264 \u03b5 / 2}\n\u22a2 \u2191\u03b4 * \u2191(3 * K) + \u03b5 / 2 \u2264 \u03b5 / 2 + \u03b5 / 2",["gcongr"]],["CategoryTheory/ChosenFiniteProducts.lean",345,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : ChosenFiniteProducts C\nD : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} D\ninst\u271d\u00b9 : ChosenFiniteProducts D\nF : C \u2964 D\ninst\u271d : PreservesLimit (Functor.empty C) F\n\u22a2 IsIso (preservesTerminalIso F).hom",["infer_instance"]],["CategoryTheory/ChosenFiniteProducts.lean",513,"C : Type u\ninst\u271d\u2076 : Category.{v, u} C\ninst\u271d\u2075 : ChosenFiniteProducts C\nD : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} D\ninst\u271d\u00b3 : ChosenFiniteProducts D\nF : C \u2964 D\nA B A' B' : C\nE : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} E\ninst\u271d\u00b9 : ChosenFiniteProducts E\nG : D \u2964 E\ninst\u271d : PreservesLimit (pair A B) F\n\u22a2 IsIso (prodComparisonIso F A B).hom",["infer_instance"]],["Analysis/InnerProductSpace/l2Space.lean",431,"\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nb : HilbertBasis \u03b9 \ud835\udd5c E\nf : \u21a5(lp (fun i \u21a6 \ud835\udd5c) 2)\ni : \u03b9\n\u22a2 NormedSpace \ud835\udd5c \u21a5(lp (fun _i \u21a6 \ud835\udd5c) 2)",["infer_instance"]],["MeasureTheory/Measure/Stieltjes.lean",69,"f : StieltjesFunction\nx : \u211d\n\u22a2 (\ud835\udcdd[>] x).NeBot",["infer_instance"]],["MeasureTheory/Covering/Vitali.lean",148,"\u03b1 : Type u_1\n\u03b9 : Type u_2\nB : \u03b9 \u2192 Set \u03b1\nt : Set \u03b9\n\u03b4 : \u03b9 \u2192 \u211d\n\u03c4 : \u211d\nh\u03c4 : 1 < \u03c4\n\u03b4nonneg : \u2200 a \u2208 t, 0 \u2264 \u03b4 a\nR : \u211d\n\u03b4le : \u2200 a \u2208 t, \u03b4 a \u2264 R\nhne : \u2200 a \u2208 t, (B a).Nonempty\nT : Set (Set \u03b9) :=\n  {u |\n    u \u2286 t \u2227 u.PairwiseDisjoint B \u2227 \u2200 a \u2208 t, \u2200 b \u2208 u, (B a \u2229 B b).Nonempty \u2192 \u2203 c \u2208 u, (B a \u2229 B c).Nonempty \u2227 \u03b4 a \u2264 \u03c4 * \u03b4 c}\nu : Set \u03b9\nhu : Maximal (fun x \u21a6 x \u2208 T) u\nA : Set \u03b9 := {a' | a' \u2208 t \u2227 \u2200 c \u2208 u, Disjoint (B a') (B c)}\nAnonempty : A.Nonempty\nm : \u211d := sSup (\u03b4 '' A)\nbddA : BddAbove (\u03b4 '' A)\nc : \u03b9\nct : c \u2208 t\nb : \u03b9\nhcb : (B c \u2229 B b).Nonempty\nH : \u2200 d \u2208 u, Disjoint (B c) (B d)\na'A : b \u2208 A\nha' : m / \u03c4 \u2264 \u03b4 b\na'_ne_u : b \u2209 u\nba'u : b \u2208 insert b u\n\u22a2 \u03c4 * (m / \u03c4) \u2264 \u03c4 * \u03b4 b",["gcongr"]],["MeasureTheory/Covering/Vitali.lean",396,"\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2074 : PseudoMetricSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\ns : Set \u03b1\nt : Set \u03b9\nC : \u211d\u22650\nr : \u03b9 \u2192 \u211d\nc : \u03b9 \u2192 \u03b1\nB : \u03b9 \u2192 Set \u03b1\nhB : \u2200 a \u2208 t, B a \u2286 closedBall (c a) (r a)\n\u03bcB : \u2200 a \u2208 t, \u03bc (closedBall (c a) (3 * r a)) \u2264 \u2191C * \u03bc (B a)\nht : \u2200 a \u2208 t, (interior (B a)).Nonempty\nh't : \u2200 a \u2208 t, IsClosed (B a)\nhf : \u2200 x \u2208 s, \u2200 \u03b5 > 0, \u2203 a \u2208 t, r a \u2264 \u03b5 \u2227 c a = x\nR : \u03b1 \u2192 \u211d\nhR0 : \u2200 (x : \u03b1), 0 < R x\nhR1 : \u2200 (x : \u03b1), R x \u2264 1\nhR\u03bc : \u2200 (x : \u03b1), \u03bc (closedBall x (20 * R x)) < \u22a4\nt' : Set \u03b9 := {a | a \u2208 t \u2227 r a \u2264 R (c a)}\nu : Set \u03b9\nut' : u \u2286 t'\nu_disj : u.PairwiseDisjoint B\nhu : \u2200 a \u2208 t', \u2203 b \u2208 u, (B a \u2229 B b).Nonempty \u2227 r a \u2264 2 * r b\nut : u \u2286 t\nu_count : u.Countable\nx : \u03b1\nx\u271d : x \u2208 s \\ \u22c3 a \u2208 u, B a\nv : Set \u03b9 := {a | a \u2208 u \u2227 (B a \u2229 ball x (R x)).Nonempty}\nvu : v \u2286 u\nK : \u211d\n\u03bcK : \u03bc (closedBall x K) < \u22a4\nhK : \u2200 a \u2208 u, (B a \u2229 ball x (R x)).Nonempty \u2192 B a \u2286 closedBall x K\n\u03b5 : \u211d\u22650\u221e\n\u03b5pos : 0 < \u03b5\nI : \u2211' (a : \u2191v), \u03bc (B \u2191a) < \u22a4\nw : Finset \u2191v\nhw : \u2211' (a : { a // a \u2209 w }), \u03bc (B \u2191\u2191a) < \u03b5 / \u2191C\nM : (s \\ \u22c3 a \u2208 u, B a) \u2229 ball x (R x) \u2286 \u22c3 a, closedBall (c \u2191\u2191a) (3 * r \u2191\u2191a)\nthis : Countable \u2191v\n\u22a2 \u2191C * \u2211' (a : { a // a \u2209 w }), \u03bc (B \u2191\u2191a) \u2264 \u2191C * (\u03b5 / \u2191C)",["gcongr"]],["Algebra/MonoidAlgebra/Degree.lean",301,"R : Type u_7\nA : Type u_8\nB : Type u_9\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : AddCommMonoid B\ninst\u271d\u00b3 : SemilatticeSup B\ninst\u271d\u00b2 : OrderBot B\ninst\u271d\u00b9 : AddLeftMono B\ninst\u271d : AddRightMono B\nD : A \u2192 B\nhzero : D 0 = 0\nhadd : \u2200 (a1 a2 : A), D (a1 + a2) = D a1 + D a2\n\u03b9 : Type u_10\ns\u271d : Finset \u03b9\nf : \u03b9 \u2192 R[A]\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nih : supDegree D (\u220f i \u2208 s, f i) \u2264 \u2211 i \u2208 s, supDegree D (f i)\n\u22a2 supDegree D (f i) + supDegree D (\u220f x \u2208 s, f x) \u2264 supDegree D (f i) + \u2211 x \u2208 s, supDegree D (f x)",["gcongr"]],["Topology/Homeomorph/Lemmas.lean",220,"X : Type u_1\nY : Type u_2\nW : Type u_3\nZ : Type u_4\ninst\u271d\u2076 : TopologicalSpace X\ninst\u271d\u2075 : TopologicalSpace Y\ninst\u271d\u2074 : TopologicalSpace W\ninst\u271d\u00b3 : TopologicalSpace Z\nX' : Type u_5\nY' : Type u_6\ninst\u271d\u00b2 : TopologicalSpace X'\ninst\u271d\u00b9 : TopologicalSpace Y'\nS : Type u_7\nT : Type u_8\nA : S \u2295 T \u2192 Type u_9\ninst\u271d : (st : S \u2295 T) \u2192 TopologicalSpace (A st)\n\u22a2 Continuous fun x i' \u21a6 x (Sum.inr i')",["fun_prop"]],["Topology/Homeomorph/Lemmas.lean",282,"X : Type u_1\nY : Type u_2\nW : Type u_3\nZ : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace W\ninst\u271d\u00b2 : TopologicalSpace Z\nX' : Type u_5\nY' : Type u_6\ninst\u271d\u00b9 : TopologicalSpace X'\ninst\u271d : TopologicalSpace Y'\n\u03b9 : Type u_7\n\u03b9' : Type u_8\n\u22a2 Continuous fun f \u21a6 (f \u2218 Sum.inl, f \u2218 Sum.inr)",["fun_prop"]],["Analysis/Convex/Segment.lean",418,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b2 : OrderedAddCommMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nx y : E\nh : x \u2264 y\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 x \u2264 a \u2022 x + b \u2022 y",["gcongr"]],["Analysis/Convex/Segment.lean",420,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b2 : OrderedAddCommMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nx y : E\nh : x \u2264 y\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2264 a \u2022 y + b \u2022 y",["gcongr"]],["Analysis/Convex/Segment.lean",434,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nx y : E\nh : x < y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 x < a \u2022 x + b \u2022 y",["gcongr","aesop"]],["Analysis/Convex/Segment.lean",436,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nx y : E\nh : x < y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y < a \u2022 y + b \u2022 y",["gcongr"]],["RingTheory/Flat/FaithfullyFlat/Basic.lean",122,"R : Type u\nM : Type v\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : FaithfullyFlat R M\nN : Type u_1\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nh : Nontrivial N\n\u22a2 Nontrivial (N \u2297[R] M)",["infer_instance"]],["Topology/UrysohnsLemma.lean",281,"case h\nX : Type u_1\ninst\u271d : TopologicalSpace X\nP : Set X \u2192 Prop\nh0 : 0 < 2\u207b\u00b9\nh1234 : 2\u207b\u00b9 < 3 / 4\nh1 : 3 / 4 < 1\nx : X\nx\u271d : True\nn : \u2115\nihn : \u2200 (c : CU P), \u2200\u1da0 (x_1 : X) in \ud835\udcdd x, dist (c.lim x_1) (c.lim x) \u2264 (3 / 4) ^ n\nc : CU P\nhxl : x \u2208 c.left.U\na\u271d : X\nhyl : a\u271d \u2208 c.left.U\nhyd : dist (c.left.lim a\u271d) (c.left.lim x) \u2264 (3 / 4) ^ n\n\u22a2 2\u207b\u00b9 * dist (c.left.lim a\u271d) (c.left.lim x) \u2264 3 / 4 * (3 / 4) ^ n",["gcongr"]],["Analysis/MellinTransform.lean",239,"b : \u211d\nf : \u211d \u2192 \u211d\nhfc : AEStronglyMeasurable f (volume.restrict (Ioi 0))\nhf : f =O[\ud835\udcdd[>] 0] fun x \u21a6 x ^ (-b)\ns : \u211d\nhs : b < s\nd : \u211d\nleft\u271d : d > 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nt : \u211d\nht : t \u2208 Ioo 0 \u03b5\nh\u03b5' : \u2016f t\u2016 \u2264 d * \u2016t ^ (-b)\u2016\n\u22a2 \u2016f t\u2016 * \u2016t ^ (s - 1)\u2016 \u2264 d * \u2016t ^ (-b)\u2016 * \u2016t ^ (s - 1)\u2016",["gcongr"]],["Analysis/Normed/Operator/Banach.lean",134,"\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' F\nf : E \u2192SL[\u03c3] F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomIsometric \u03c3\ninst\u271d\u00b9 : RingHomIsometric \u03c3'\ninst\u271d : CompleteSpace F\nsurj : Surjective \u21d1f\nA : \u22c3 n, closure (\u21d1f '' ball 0 \u2191n) = Set.univ\nn : \u2115\na : F\n\u03b5 : \u211d\n\u03b5pos : \u03b5 > 0\nH : ball a \u03b5 \u2286 closure (\u21d1f '' ball 0 \u2191n)\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\ny : F\nhy : y \u2260 0\nhc' : 1 < \u2016\u03c3 c\u2016\nd : \ud835\udd5c'\nhd : d \u2260 0\nydlt : \u2016d \u2022 y\u2016 < \u03b5 / 2\ndinv : \u2016d\u2016\u207b\u00b9 \u2264 (\u03b5 / 2)\u207b\u00b9 * \u2016\u03c3 c\u2016 * \u2016y\u2016\n\u03b4 : \u211d := \u2016d\u2016 * \u2016y\u2016 / 4\n\u03b4pos : 0 < \u03b4\nthis\u271d : a + d \u2022 y \u2208 ball a \u03b5\nz\u2081 : F\nz\u2081im : z\u2081 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2081 : E\nh\u2081 : dist (a + d \u2022 y) (f x\u2081) < \u03b4\nhx\u2081 : \u2016x\u2081\u2016 < \u2191n\nxz\u2081 : f x\u2081 = z\u2081\nthis : a \u2208 ball a \u03b5\nz\u2082 : F\nz\u2082im : z\u2082 \u2208 \u21d1f '' ball 0 \u2191n\nx\u2082 : E\nh\u2082 : dist a (f x\u2082) < \u03b4\nhx\u2082 : \u2016x\u2082\u2016 < \u2191n\nxz\u2082 : f x\u2082 = z\u2082\nx : E := x\u2081 - x\u2082\nI : \u2016f x - d \u2022 y\u2016 \u2264 2 * \u03b4\n\u22a2 \u2016d\u2016\u207b\u00b9 * \u2016f x - d \u2022 y\u2016 \u2264 \u2016d\u2016\u207b\u00b9 * (2 * \u03b4)",["gcongr","aesop"]],["Topology/MetricSpace/GromovHausdorffRealized.lean",446,"X : Type u\nY : Type v\ninst\u271d\u2075 : MetricSpace X\ninst\u271d\u2074 : CompactSpace X\ninst\u271d\u00b3 : Nonempty X\ninst\u271d\u00b2 : MetricSpace Y\ninst\u271d\u00b9 : CompactSpace Y\ninst\u271d : Nonempty Y\n\u22a2 MetricSpace (SeparationQuotient (X \u2295 Y))",["infer_instance"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",319,"E : Type u_1\ninst\u271d : NormedAddCommGroup E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\nh\u03b42 : \u03b4 \u2264 1\ni j : Fin N.succ\ninej : i \u2260 j\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nD : 0 \u2264 1 - \u03b4 / 4\n\u03c4pos : 0 < \u03c4\n\u22a2 (1 - \u03b4 / 4) * \u03c4 \u2264 (1 - \u03b4 / 4) * (1 + \u03b4 / 4)",["gcongr"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",358,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastc : a.c (last N) = 0\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\nh\u03b42 : \u03b4 \u2264 1\ni j : Fin N.succ\ninej : i \u2260 j\nhi : \u2016a.c i\u2016 \u2264 2\nhj : 2 < \u2016a.c j\u2016\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nD : 0 \u2264 1 - \u03b4 / 4\nhcrj : \u2016a.c j\u2016 \u2264 a.r j + 1\nI : a.r i \u2264 2\n\u22a2 (1 - \u03b4 / 4) * \u03c4 \u2264 (1 - \u03b4 / 4) * (1 + \u03b4 / 4)",["gcongr"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",366,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastc : a.c (last N) = 0\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\nh\u03b42 : \u03b4 \u2264 1\ni j : Fin N.succ\ninej : i \u2260 j\nhi : \u2016a.c i\u2016 \u2264 2\nhj : 2 < \u2016a.c j\u2016\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nD : 0 \u2264 1 - \u03b4 / 4\nhcrj : \u2016a.c j\u2016 \u2264 a.r j + 1\nI : a.r i \u2264 2\nJ : (1 - \u03b4 / 4) * \u03c4 \u2264 1\nH : a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i\n\u22a2 \u03c4 * a.r i \u2264 \u03c4 * 2",["gcongr"]],["MeasureTheory/Covering/BesicovitchVectorSpace.lean",375,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : SatelliteConfig E N \u03c4\nlastc : a.c (last N) = 0\nlastr : a.r (last N) = 1\nh\u03c4 : 1 \u2264 \u03c4\n\u03b4 : \u211d\nh\u03b41 : \u03c4 \u2264 1 + \u03b4 / 4\nh\u03b42 : \u03b4 \u2264 1\ni j : Fin N.succ\ninej : i \u2260 j\nhi : \u2016a.c i\u2016 \u2264 2\nhj : 2 < \u2016a.c j\u2016\nah : Pairwise fun i j \u21a6 a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i \u2228 a.r j \u2264 \u2016a.c j - a.c i\u2016 \u2227 a.r i \u2264 \u03c4 * a.r j\n\u03b4nonneg : 0 \u2264 \u03b4\nD : 0 \u2264 1 - \u03b4 / 4\nhcrj : \u2016a.c j\u2016 \u2264 a.r j + 1\nI : a.r i \u2264 2\nJ : (1 - \u03b4 / 4) * \u03c4 \u2264 1\nH : a.r i \u2264 \u2016a.c i - a.c j\u2016 \u2227 a.r j \u2264 \u03c4 * a.r i\nC : a.r j \u2264 4\n\u22a2 (1 - \u03b4 / 4) * \u03c4 * a.r i \u2264 1 * a.r i",["gcongr"]],["MeasureTheory/Decomposition/SignedLebesgue.lean",178,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\n\u22a2 Measurable fun x \u21a6\n    (s.toJordanDecomposition.posPart.rnDeriv \u03bc x).toReal - (s.toJordanDecomposition.negPart.rnDeriv \u03bc x).toReal",["fun_prop"]],["MeasureTheory/Decomposition/SignedLebesgue.lean",184,"case refine_1.left.hf\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\n\u22a2 Measurable fun x \u21a6 (s.toJordanDecomposition.posPart.rnDeriv \u03bc x).toReal\n```\n---\n```lean\ncase refine_2.left.hf\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\n\u22a2 Measurable fun x \u21a6 (s.toJordanDecomposition.negPart.rnDeriv \u03bc x).toReal",["fun_prop"]],["MeasureTheory/Decomposition/SignedLebesgue.lean",84,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : s.HaveLebesgueDecomposition \u03bc\n\u22a2 s.toJordanDecomposition.negPart.HaveLebesgueDecomposition \u03bc",["infer_instance"]],["MeasureTheory/Decomposition/SignedLebesgue.lean",87,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : s.HaveLebesgueDecomposition \u03bc\n\u22a2 s.toJordanDecomposition.posPart.HaveLebesgueDecomposition \u03bc",["infer_instance"]],["MeasureTheory/Decomposition/SignedLebesgue.lean",93,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : s.HaveLebesgueDecomposition \u03bc\nr : \u211d\u22650\n\u22a2 (r \u2022 s.toJordanDecomposition.posPart).HaveLebesgueDecomposition \u03bc",["infer_instance"]],["MeasureTheory/Decomposition/SignedLebesgue.lean",96,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : s.HaveLebesgueDecomposition \u03bc\nr : \u211d\u22650\n\u22a2 (r \u2022 s.toJordanDecomposition.negPart).HaveLebesgueDecomposition \u03bc",["infer_instance"]],["MeasureTheory/Decomposition/SignedLebesgue.lean",107,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\ns : SignedMeasure \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : s.HaveLebesgueDecomposition \u03bc\nr : \u211d\nhr : r < 0\n\u22a2 ((-r).toNNReal \u2022 s.toJordanDecomposition.negPart).HaveLebesgueDecomposition \u03bc",["infer_instance"]],["MeasureTheory/Decomposition/SignedLebesgue.lean",236,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : SignedMeasure \u03b1\nf : \u03b1 \u2192 \u211d\nhf : Measurable f\nhfi : Integrable f \u03bc\nht\u03bc : t \u27c2\u1d65 \u03bc.toENNRealVectorMeasure\nhadd : s = t + \u03bc.withDensity\u1d65 f\nthis : IsFiniteMeasure (\u03bc.withDensity fun x \u21a6 ENNReal.ofReal (f x))\n\u22a2 IsFiniteMeasure (t.toJordanDecomposition.posPart + \u03bc.withDensity fun x \u21a6 ENNReal.ofReal (f x))",["infer_instance"]],["MeasureTheory/Decomposition/SignedLebesgue.lean",237,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : SignedMeasure \u03b1\nf : \u03b1 \u2192 \u211d\nhf : Measurable f\nhfi : Integrable f \u03bc\nht\u03bc : t \u27c2\u1d65 \u03bc.toENNRealVectorMeasure\nhadd : s = t + \u03bc.withDensity\u1d65 f\nthis : IsFiniteMeasure (\u03bc.withDensity fun x \u21a6 ENNReal.ofReal ((-f) x))\n\u22a2 IsFiniteMeasure (t.toJordanDecomposition.negPart + \u03bc.withDensity fun x \u21a6 ENNReal.ofReal (-f x))",["infer_instance"]],["Topology/UniformSpace/Completion.lean",342,"\u03b1\u271d : Type u_1\ninst\u271d\u00b3 : UniformSpace \u03b1\u271d\n\u03b2 : Type u_2\ninst\u271d\u00b2 : UniformSpace \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b3\n\u03b1 : Type u_4\ninst\u271d : UniformSpace \u03b1\n\u22a2 UniformSpace (Completion \u03b1)",["infer_instance"]],["Topology/UniformSpace/Completion.lean",343,"\u03b1\u271d : Type u_1\ninst\u271d\u00b3 : UniformSpace \u03b1\u271d\n\u03b2 : Type u_2\ninst\u271d\u00b2 : UniformSpace \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b3\n\u03b1 : Type u_4\ninst\u271d : UniformSpace \u03b1\n\u22a2 CompleteSpace (Completion \u03b1)",["infer_instance"]],["Topology/UniformSpace/Completion.lean",344,"\u03b1\u271d : Type u_1\ninst\u271d\u00b3 : UniformSpace \u03b1\u271d\n\u03b2 : Type u_2\ninst\u271d\u00b2 : UniformSpace \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b3\n\u03b1 : Type u_4\ninst\u271d : UniformSpace \u03b1\n\u22a2 T0Space (Completion \u03b1)",["infer_instance"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Basic.lean",190,"case refine_1\nA : Type u_2\ninst\u271d : NonUnitalCStarAlgebra A\na : A\nha : IsStarNormal a\nh : \u2200 (a : A), IsStarNormal \u2191a \u2194 IsStarNormal a\n\u22a2 Continuous fun f \u21a6 \u2191((cfc\u2099Hom ha) f)",["fun_prop"]],["Topology/Path.lean",66,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3 : Path x y\n\u22a2 Continuous \u21d1\u03b3.toContinuousMap",["fun_prop"]],["Topology/Path.lean",174,"X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nx y : X\nY : Type u_4\ninst\u271d : TopologicalSpace Y\nf : Y \u2192 Path x y\ng : Y \u2192 \u2191I\nhf : Continuous f\nhg : Continuous g\n\u22a2 Continuous fun y_1 \u21a6 (f y_1) (g y_1)",["fun_prop"]],["Topology/Path.lean",257,"case refine_1\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\n\u03b3' : Path y z\n\u22a2 Continuous fun t \u21a6 \u03b3.extend (2 * t)\n```\n---\n```lean\ncase refine_2\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\n\u03b3' : Path y z\n\u22a2 Continuous fun t \u21a6 \u03b3'.extend (2 * t - 1)",["fun_prop"]],["Topology/Path.lean",396,"X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 Continuous \u21bffun t \u21a6 t",["fun_prop"]],["Topology/Path.lean",435,"X : Type u_1\ninst\u271d : TopologicalSpace X\nx y z : X\n\u22a2 Continuous fun \u03c1 \u21a6 \u03c1.1.trans \u03c1.2",["fun_prop"]],["Topology/Path.lean",559,"X : Type u_1\ninst\u271d : TopologicalSpace X\na b : X\n\u03b3 : Path a b\nt : \u211d\n\u22a2 Continuous fun x \u21a6 (t, x)",["fun_prop"]],["Topology/Path.lean",595,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\nf : \u2191I \u2192 \u2191I\nhfcont : Continuous f\nhf\u2080 : f 0 = 0\nhf\u2081 : f 1 = 1\n\u22a2 Continuous (\u21d1\u03b3 \u2218 f)",["fun_prop"]],["Geometry/Euclidean/Angle/Unoriented/Affine.lean",51,"V : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\nx : P \u00d7 P \u00d7 P\nhx12 : x.1 \u2260 x.2.1\nhx32 : x.2.2 \u2260 x.2.1\nf : P \u00d7 P \u00d7 P \u2192 V \u00d7 V := fun y \u21a6 (y.1 -\u1d65 y.2.1, y.2.2 -\u1d65 y.2.1)\nhf1 : (f x).1 \u2260 0\nhf2 : (f x).2 \u2260 0\n\u22a2 ContinuousAt f x",["fun_prop"]],["AlgebraicGeometry/GammaSpecAdjunction.lean",414,"case inst\nR : CommRingCat\u1d52\u1d56\n\u22a2 IsIso (Scheme.\u0393SpecIso (unop R)).inv.op",["infer_instance"]],["Analysis/Convex/Topology.lean",102,"\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u2078 : LinearOrderedRing \ud835\udd5c\ninst\u271d\u2077 : DenselyOrdered \ud835\udd5c\ninst\u271d\u2076 : TopologicalSpace \ud835\udd5c\ninst\u271d\u2075 : OrderTopology \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : ContinuousAdd E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : ContinuousSMul \ud835\udd5c E\nx y : E\n\u22a2 Continuous fun \u03b8 \u21a6 (1 - \u03b8) \u2022 x + \u03b8 \u2022 y",["fun_prop"]],["Analysis/Convex/Topology.lean",410,"E : Type u_4\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \u211d E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ContinuousAdd E\ninst\u271d : ContinuousSMul \u211d E\nx y : E\ns : Set E\nh : [x -[\u211d] y] \u2286 s\n\u22a2 Continuous fun t \u21a6 (1 - t) \u2022 x + t \u2022 y",["fun_prop"]],["NumberTheory/NumberField/Units/DirichletTheorem.lean",429,"case refine_1\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u22a2 Module.Finite \u2124 (Additive ((\ud835\udcde K)\u02e3 \u29f8 torsion K))",["infer_instance"]],["NumberTheory/NumberField/Units/DirichletTheorem.lean",438,"K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u22a2 Module.Finite \u2124 (Additive (\ud835\udcde K)\u02e3)",["infer_instance"]],["CategoryTheory/Adjunction/Mates.lean",375,"C : Type u\u2081\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nL\u2081 L\u2082 : C \u2964 D\nR\u2081 R\u2082 : D \u2964 C\nadj\u2081 : L\u2081 \u22a3 R\u2081\nadj\u2082 : L\u2082 \u22a3 R\u2082\n\u03b1 : L\u2082 \u27f6 L\u2081\ninst\u271d : IsIso ((conjugateEquiv adj\u2081 adj\u2082) \u03b1)\n\u22a2 IsIso ((conjugateEquiv adj\u2081 adj\u2082).symm ((conjugateEquiv adj\u2081 adj\u2082) \u03b1))",["infer_instance"]],["CategoryTheory/Adjunction/Mates.lean",385,"C : Type u\u2081\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nL\u2081 L\u2082 : C \u2964 D\nR\u2081 R\u2082 : D \u2964 C\nadj\u2081 : L\u2081 \u22a3 R\u2081\nadj\u2082 : L\u2082 \u22a3 R\u2082\n\u03b1 : R\u2081 \u27f6 R\u2082\ninst\u271d : IsIso ((conjugateEquiv adj\u2081 adj\u2082).symm \u03b1)\n\u22a2 IsIso ((conjugateEquiv adj\u2081 adj\u2082) ((conjugateEquiv adj\u2081 adj\u2082).symm \u03b1))",["infer_instance"]],["NumberTheory/NumberField/CanonicalEmbedding/PolarCoord.lean",254,"K : Type u_1\ninst\u271d : Field K\n\u22a2 Continuous fun x w \u21a6 (x.2 w).2",["fun_prop"]],["NumberTheory/NumberField/CanonicalEmbedding/PolarCoord.lean",403,"K : Type u_1\ninst\u271d\u00b9 : Field K\nA : Set (mixedSpace K)\ninst\u271d : NumberField K\nhA : normAtComplexPlaces \u207b\u00b9' (normAtComplexPlaces '' A) = A\nhm : MeasurableSet A\nhA' : \u2200 {x : mixedSpace K}, A.indicator 1 x = (normAtComplexPlaces '' A).indicator 1 (normAtComplexPlaces x)\n\u22a2 Measurable fun x \u21a6 \u220f w : { w // w.IsComplex }, ENNReal.ofReal (x.1 \u2191w)",["fun_prop"]],["MeasureTheory/Function/AEEqOfIntegral.lean",417,"case h_mono\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : CompleteSpace E\n\u03b2 : Type u_3\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : SigmaCompactSpace \u03b2\ninst\u271d : R1Space \u03b2\n\u03bc : Measure \u03b2\nf : \u03b2 \u2192 E\nhf : Integrable f \u03bc\nh'f : \u2200 (s : Set \u03b2), IsCompact s \u2192 \u222b (x : \u03b2) in s, f x \u2202\u03bc = 0\ns : Set \u03b2\nhs : IsClosed s\nt : \u2115 \u2192 Set \u03b2 := fun n \u21a6 closure (compactCovering \u03b2 n) \u2229 s\nB : s = \u22c3 n, t n\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 closure (compactCovering \u03b2 m) \u2229 s \u2286 closure (compactCovering \u03b2 n) \u2229 s",["gcongr"]],["Analysis/Calculus/Rademacher.lean",313,"E : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\nC : \u211d\u22650\ninst\u271d : FiniteDimensional \u211d E\nf : E \u2192 F\nhf : LipschitzWith C f\ns : Set E\nhs : sphere 0 1 \u2286 closure s\nL : E \u2192L[\u211d] F\nx : E\nhL : \u2200 v \u2208 s, HasLineDerivAt \u211d f (L v) x v\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u03b4 : \u211d\n\u03b4pos : 0 < \u03b4\nh\u03b4 : (\u2191C + \u2016L\u2016 + 1) * \u03b4 = \u03b5\nq : Set E\nhqs : q \u2286 s\nq_fin : q.Finite\nhq : sphere 0 1 \u2286 \u22c3 y \u2208 q, ball y \u03b4\nI : \u2200\u1da0 (t : \u211d) in \ud835\udcdd 0, \u2200 v \u2208 q, \u2016f (x + t \u2022 v) - f x - t \u2022 L v\u2016 \u2264 \u03b4 * \u2016t\u2016\nr : \u211d\nr_pos : 0 < r\nhr : \u2200 (t : \u211d), \u2016t\u2016 < r \u2192 \u2200 v \u2208 q, \u2016f (x + t \u2022 v) - f x - t \u2022 L v\u2016 \u2264 \u03b4 * \u2016t\u2016\nv : E\nhv : v \u2208 ball 0 r\nv_ne : v \u2260 0\nw : E\n\u03c1 : \u211d\nw_mem : w \u2208 sphere 0 1\nhvw : v = \u03c1 \u2022 w\nh\u03c1 : \u03c1 = \u2016v\u2016\nnorm_rho : \u2016\u03c1\u2016 = \u03c1\nrho_pos : 0 \u2264 \u03c1\ny : E\nyq : y \u2208 q\nhy : \u2016w - y\u2016 < \u03b4\nthis : \u2016y - w\u2016 < \u03b4\n\u22a2 \u2191C * (\u03c1 * \u2016w - y\u2016) + \u03c1 * (\u2016L\u2016 * \u2016y - w\u2016) + \u03b4 * \u03c1 \u2264 \u2191C * (\u03c1 * \u03b4) + \u03c1 * (\u2016L\u2016 * \u03b4) + \u03b4 * \u03c1",["gcongr"]],["Data/Finmap.lean",573,"\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\nx y : Finmap \u03b2\n\u22a2 Decidable (\u2200 x_1 \u2208 x, x_1 \u2209 y)",["infer_instance"]],["Analysis/PSeries.lean",274,"case inl.h_mono\np : \u211d\nhp : 0 \u2264 p\nm n : \u2115\nhm : 0 < m\nhmn : m \u2264 n\n\u22a2 (\u2191n ^ p)\u207b\u00b9 \u2264 (\u2191m ^ p)\u207b\u00b9",["gcongr"]],["Data/Matroid/Restrict.lean",354,"case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\ninst\u271d : M.RankFinite\nR : Set \u03b1\n\u22a2 (M \u21be R).RankFinite",["infer_instance"]],["Data/Matroid/Restrict.lean",358,"case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\ninst\u271d : M.Finitary\nR : Set \u03b1\n\u22a2 (M \u21be R).Finitary",["infer_instance"]],["Combinatorics/Additive/AP/Three/Behrend.lean",314,"x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 rexp (1 - x) / (x + 1) \u2264 rexp (2 - \u2191\u2308x\u2309\u208a) / (x + 1)",["gcongr"]],["Combinatorics/Additive/AP/Three/Behrend.lean",315,"x : \u211d\nhx : 0 < x\nh\u2081 : \u2191\u2308x\u2309\u208a < x + 1\nh\u2082 : 1 - x \u2264 2 - \u2191\u2308x\u2309\u208a\n\u22a2 rexp (2 - \u2191\u2308x\u2309\u208a) / (x + 1) < rexp (2 - \u2191\u2308x\u2309\u208a) / \u2191\u2308x\u2309\u208a",["gcongr"]],["Data/PFunctor/Univariate/M.lean",181,"F : PFunctor.{u}\ninst\u271d : Inhabited F.A\n\u22a2 Inhabited F.M",["infer_instance"]],["Geometry/Manifold/Instances/Real.lean",505,"x y : \u211d\nhxy : Fact (x < y)\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nH : Type u_2\ninst\u271d\u00b2 : TopologicalSpace H\nI : ModelWithCorners \u211d E H\nM : Type u_3\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\n\u22a2 ChartedSpace (EuclideanHalfSpace 1) \u2191(Icc 0 1)",["infer_instance"]],["Geometry/Manifold/Instances/Real.lean",508,"x y : \u211d\nhxy : Fact (x < y)\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nH : Type u_2\ninst\u271d\u00b2 : TopologicalSpace H\nI : ModelWithCorners \u211d E H\nM : Type u_3\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\nn : WithTop \u2115\u221e\n\u22a2 IsManifold (\ud835\udce1\u2202 1) n \u2191(Icc 0 1)",["infer_instance"]],["Topology/Connected/PathConnected.lean",122,"X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n\u22a2 Continuous fun t \u21a6 \u27e8h.somePath t, \u22ef\u27e9",["fun_prop"]],["Analysis/SpecialFunctions/Pow/Continuity.lean",341,"x : \u211d\ny : \u2102\nh : 0 < y.re \u2228 x \u2260 0\nhx : 0 < x\n\u22a2 ContinuousAt (fun p \u21a6 (\u2191p.1, p.2)) (x, y)",["fun_prop"]],["Analysis/SpecialFunctions/Pow/Continuity.lean",349,"y : \u2102\nh : 0 < y.re \u2228 0 \u2260 0\nA : ContinuousAt (fun p \u21a6 p.1 ^ p.2) (\u21910, y)\n\u22a2 ContinuousAt (fun p \u21a6 (\u2191p.1, p.2)) (0, y)",["fun_prop"]],["Analysis/SpecialFunctions/Pow/Continuity.lean",355,"x : \u211d\ny : \u2102\nh : 0 < y.re \u2228 x \u2260 0\nhx : x < 0\n\u22a2 ContinuousAt (fun p \u21a6 (-\u2191p.1, p.2)) (x, y)",["fun_prop"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",146,"X : Type u_1\ninst\u271d\u2075 : TopologicalSpace X\nA : Type u_2\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : Algebra \u211d A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : IsTopologicalRing A\n\u03c6 : C(X, \u211d\u22650) \u2192\u22c6\u2090[\u211d\u22650] A\nh\u03c6 : Continuous \u21d1\u03c6\n\u22a2 Continuous fun f \u21a6 \u03c6 f.toNNReal - \u03c6 (-f).toNNReal",["fun_prop"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unique.lean",332,"X : Type u_1\ninst\u271d\u2076 : TopologicalSpace X\ninst\u271d\u2075 : Zero X\nA : Type u_2\ninst\u271d\u2074 : NonUnitalRing A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : Module \u211d A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : IsTopologicalRing A\n\u03c6 : C(X, \u211d\u22650)\u2080 \u2192\u22c6\u2099\u2090[\u211d\u22650] A\nh\u03c6 : Continuous \u21d1\u03c6\n\u22a2 Continuous fun f \u21a6 \u03c6 f.toNNReal - \u03c6 (-f).toNNReal",["fun_prop"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",161,"\u22a2 Continuous fun p \u21a6 p.negMulLog + (1 - p).negMulLog",["fun_prop"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",238,"q : \u2115\n\u22a2 Continuous fun p \u21a6 p * log \u2191(\u2191q - 1) + binEntropy p",["fun_prop"]],["Analysis/SpecialFunctions/BinaryEntropy.lean",336,"q\u271d : \u2115\np\u271d : \u211d\nxne0 : p\u271d \u2260 0\nxne1 : p\u271d \u2260 1\nthis : \u2200\u1da0 (y : \u211d) in \ud835\udcdd p\u271d, deriv (fun p \u21a6 qaryEntropy q\u271d p) y = log (\u2191q\u271d - 1) + log (1 - y) - log y\nq p : \u211d\n\u22a2 DifferentiableAt \u211d (fun p \u21a6 q - p) p",["fun_prop"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",362,"case h.inr.inr.hg\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\nhab\u271d : a \u2264 b\nhbc\u271d : b \u2264 c\nf : ((n : \u2115) \u2192 X n) \u2192 \u211d\u22650\u221e\nhf : Measurable f\nx\u2080 : (n : \u2115) \u2192 X n\nhab : a < b\nhbc : b < c\n\u22a2 Measurable fun z \u21a6 f (updateFinset x\u2080 (Iic c) z)",["fun_prop"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",383,"X : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na b : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\nc : \u2115\nf : ((n : \u2115) \u2192 X n) \u2192 \u211d\u22650\u221e\nmf : Measurable f\nhf : DependsOn f \u2191(Iic a)\nhab : a \u2264 b\nx : (n : \u2115) \u2192 X n\n\u22a2 Measurable (restrict\u2082 \u22ef)",["fun_prop"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",136,"case inl.base\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\na b : \u2115\n\u22a2 IsSFiniteKernel Kernel.id",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",137,"case inl.succ\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d\u00b9 b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\na b k : \u2115\nhak : a \u2264 k\na\u271d : IsSFiniteKernel (partialTraj \u03ba a k)\n\u22a2 IsSFiniteKernel ((Kernel.id \u00d7\u2096 (\u03ba k).map \u21d1(piSingleton k) \u2218\u2096 partialTraj \u03ba a k).map (_root_.IicProdIoc k (k + 1)))",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",138,"case inr\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\na b : \u2115\nhba : b \u2264 a\n\u22a2 IsSFiniteKernel (deterministic (frestrictLe\u2082 hba) \u22ef)",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",143,"case inl.base\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsFiniteKernel (\u03ba n)\na b : \u2115\n\u22a2 IsFiniteKernel Kernel.id",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",144,"case inl.succ\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d\u00b9 b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsFiniteKernel (\u03ba n)\na b k : \u2115\nhak : a \u2264 k\na\u271d : IsFiniteKernel (partialTraj \u03ba a k)\n\u22a2 IsFiniteKernel ((Kernel.id \u00d7\u2096 (\u03ba k).map \u21d1(piSingleton k) \u2218\u2096 partialTraj \u03ba a k).map (_root_.IicProdIoc k (k + 1)))",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",145,"case inr\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsFiniteKernel (\u03ba n)\na b : \u2115\nhba : b \u2264 a\n\u22a2 IsFiniteKernel (deterministic (frestrictLe\u2082 hba) \u22ef)",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",151,"case inl.base\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsZeroOrMarkovKernel (\u03ba n)\na b : \u2115\n\u22a2 IsZeroOrMarkovKernel Kernel.id",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",152,"case inl.succ\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d\u00b9 b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsZeroOrMarkovKernel (\u03ba n)\na b k : \u2115\nhak : a \u2264 k\na\u271d : IsZeroOrMarkovKernel (partialTraj \u03ba a k)\n\u22a2 IsZeroOrMarkovKernel ((Kernel.id \u00d7\u2096 (\u03ba k).map \u21d1(piSingleton k) \u2218\u2096 partialTraj \u03ba a k).map (_root_.IicProdIoc k (k + 1)))",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",153,"case inr\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsZeroOrMarkovKernel (\u03ba n)\na b : \u2115\nhba : b \u2264 a\n\u22a2 IsZeroOrMarkovKernel (deterministic (frestrictLe\u2082 hba) \u22ef)",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",159,"case inl.base\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\na b : \u2115\n\u22a2 IsMarkovKernel Kernel.id",["infer_instance"]],["Probability/Kernel/IonescuTulcea/PartialTraj.lean",164,"case inr\nX : \u2115 \u2192 Type u_1\nmX : (n : \u2115) \u2192 MeasurableSpace (X n)\na\u271d b\u271d c : \u2115\n\u03ba : (n : \u2115) \u2192 Kernel ((i : { x // x \u2208 Iic n }) \u2192 X \u2191i) (X (n + 1))\ninst\u271d : \u2200 (n : \u2115), IsMarkovKernel (\u03ba n)\na b : \u2115\nhba : b \u2264 a\n\u22a2 IsMarkovKernel (deterministic (frestrictLe\u2082 hba) \u22ef)",["infer_instance"]],["CategoryTheory/Preadditive/Mat.lean",149,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : Preadditive C\nM N : Mat_ C\n\u22a2 AddCommGroup (DMatrix M.\u03b9 N.\u03b9 fun i j \u21a6 M.X i \u27f6 N.X j)",["infer_instance"]],["CategoryTheory/Preadditive/Mat.lean",496,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : Preadditive C\nR : Type u\n\u22a2 Inhabited FintypeCat",["infer_instance"]],["CategoryTheory/Preadditive/Mat.lean",594,"C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : Preadditive C\nR : Type\ninst\u271d : Ring R\nX Y : Mat R\n\u22a2 AddCommGroup (Matrix X.carrier Y.carrier R)",["infer_instance"]],["Algebra/Category/ModuleCat/Basic.lean",516,"R : Type u\ninst\u271d : Ring R\nX\u2081 X\u2082 : Type v\nM N : ModuleCat R\nA : AddCommGrp\n\u03c6 : R \u2192+* End A\n\u22a2 AddCommGroup \u2191A",["infer_instance"]],["Algebra/Category/ModuleCat/Basic.lean",572,"R : Type u\ninst\u271d : Ring R\nX\u2081 X\u2082 : Type v\nM N A\u271d B\u271d : ModuleCat R\nf : A\u271d \u27f6 B\u271d\nx\u271d : IsIso ((forget\u2082 (ModuleCat R) AddCommGrp).map f)\n\u22a2 IsIso ((forget AddCommGrp).map ((forget\u2082 (ModuleCat R) AddCommGrp).map f))",["infer_instance"]],["NumberTheory/Harmonic/ZetaAsymp.lean",88,"n : \u2115\nhn : 0 < n\nhv : \u2200 x \u2208 uIcc (\u2191n) (\u2191n + 1), 0 < x\n\u22a2 ContinuousOn (fun x \u21a6 x) (uIcc (\u2191n) (\u2191n + 1))",["fun_prop"]],["Data/Set/Finite/Lattice.lean",97,"\u03b1 : Type u\n\u03b9 : Type u_1\ns : Set \u03b9\ninst\u271d : Finite \u2191s\nt : \u03b9 \u2192 Set \u03b1\nH : \u2200 i \u2208 s, Finite \u2191(t i)\nthis : \u2200 (i : \u2191s), Finite \u2191(t \u2191i)\n\u22a2 Finite \u2191(\u22c3 x, t \u2191x)",["infer_instance"]],["MeasureTheory/Measure/NullMeasurable.lean",262,"\u03b1 : Type u_2\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nt s : Set \u03b1\nht : NullMeasurableSet t \u03bc\ns' : Set \u03b1\nhsub : s \u2286 s'\nhs' : \u03bc s' = \u03bc s\nhs'm : NullMeasurableSet s' \u03bc\n\u22a2 \u03bc (s \u2229 t) + \u03bc (s \\ t) \u2264 \u03bc (s' \u2229 t) + \u03bc (s' \\ t)",["gcongr"]],["Probability/Moments/Basic.lean",237,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nt : \u211d\nY : \u03a9 \u2192 \u211d\nhXY : X \u2264\u1da0[ae \u03bc] Y\nht : 0 \u2264 t\nhtY : Integrable (fun \u03c9 \u21a6 rexp (t * Y \u03c9)) \u03bc\nhtX : Integrable (fun \u03c9 \u21a6 rexp (t * X \u03c9)) \u03bc\n\u03c9 : \u03a9\nh\u03c9 : X \u03c9 \u2264 Y \u03c9\n\u22a2 rexp (t * X \u03c9) \u2264 rexp (t * Y \u03c9)",["gcongr"]],["Probability/Moments/Basic.lean",90,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\ninst\u271d : IsZeroOrProbabilityMeasure \u03bc\nh : IsProbabilityMeasure \u03bc\nh_int : \u00acIntegrable X \u03bc\nh_sub : Integrable (fun x \u21a6 X x - integral \u03bc X) \u03bc\nh_add : X = (fun x \u21a6 X x - integral \u03bc X) + fun x \u21a6 integral \u03bc X\n\u22a2 Integrable ((fun x \u21a6 X x - integral \u03bc X) + fun x \u21a6 integral \u03bc X) \u03bc",["fun_prop"]],["Probability/Moments/Basic.lean",269,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nt : \u211d\nX Y : \u03a9 \u2192 \u211d\nh_indep : IndepFun X Y \u03bc\nhX : AEStronglyMeasurable X \u03bc\nhY : AEStronglyMeasurable Y \u03bc\n\u22a2 Continuous fun x \u21a6 rexp (t * x)",["fun_prop"]],["Probability/Moments/Basic.lean",425,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nx : \u211d\nhX : Measure.map X \u03bc = Measure.dirac x\nt : \u211d\n\u22a2 IsProbabilityMeasure (Measure.dirac x)",["infer_instance"]],["Probability/Kernel/Disintegration/StandardBorel.lean",139,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03a9 : Type u_4\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u2074 : CountablyGenerated \u03b3\ninst\u271d\u00b3 : MeasurableSpace \u03a9\ninst\u271d\u00b2 : StandardBorelSpace \u03a9\ninst\u271d\u00b9 : Nonempty \u03a9\n\u03ba : Kernel \u03b1 (\u03b3 \u00d7 \u211d)\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsMarkovKernel (IsCondKernelCDF.toKernel \u03ba.condKernelCDF \u22ef)",["infer_instance"]],["Probability/Kernel/Disintegration/StandardBorel.lean",155,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03a9 : Type u_4\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u2074 : CountablyGenerated \u03b3\ninst\u271d\u00b3 : MeasurableSpace \u03a9\ninst\u271d\u00b2 : StandardBorelSpace \u03a9\ninst\u271d\u00b9 : Nonempty \u03a9\n\u03ba : Kernel Unit (\u03b1 \u00d7 \u211d)\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsMarkovKernel (IsCondKernelCDF.toKernel (fun p \u21a6 condCDF (\u03ba ()) p.2) \u22ef)",["infer_instance"]],["Probability/Kernel/Disintegration/StandardBorel.lean",318,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03a9 : Type u_4\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u2074 : CountablyGenerated \u03b3\ninst\u271d\u00b3 : MeasurableSpace \u03a9\ninst\u271d\u00b2 : StandardBorelSpace \u03a9\ninst\u271d\u00b9 : Nonempty \u03a9\n\u03ba : Kernel \u03b1 (\u03b3 \u00d7 \u03a9)\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsMarkovKernel (borelMarkovFromReal \u03a9 (\u03ba.map (Prod.map id (embeddingReal \u03a9))).condKernelReal)",["infer_instance"]],["Probability/Kernel/Disintegration/StandardBorel.lean",340,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03a9 : Type u_4\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u2074 : CountablyGenerated \u03b3\ninst\u271d\u00b3 : MeasurableSpace \u03a9\ninst\u271d\u00b2 : StandardBorelSpace \u03a9\ninst\u271d\u00b9 : Nonempty \u03a9\n\u03ba : Kernel Unit (\u03b1 \u00d7 \u03a9)\ninst\u271d : IsFiniteKernel \u03ba\n\u22a2 IsMarkovKernel (borelMarkovFromReal \u03a9 (\u03ba.map (Prod.map id (embeddingReal \u03a9))).condKernelUnitReal)",["infer_instance"]],["Probability/Kernel/Disintegration/StandardBorel.lean",379,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03a9 : Type u_4\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u2075 : CountablyGenerated \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03a9\ninst\u271d\u00b3 : StandardBorelSpace \u03a9\ninst\u271d\u00b2 : Nonempty \u03a9\n\u03c1\u271d : Measure (\u03b1 \u00d7 \u03a9)\ninst\u271d\u00b9 : IsFiniteMeasure \u03c1\u271d\n\u03c1 : Measure (\u03b1 \u00d7 \u03a9)\ninst\u271d : IsFiniteMeasure \u03c1\n\u22a2 IsMarkovKernel ((const Unit \u03c1).condKernelUnitBorel.comap (fun a \u21a6 ((), a)) \u22ef)",["infer_instance"]],["Algebra/Order/Ring/Defs.lean",224,"\u03b1 : Type u\ninst\u271d : OrderedRing \u03b1\na b c : \u03b1\nh : a + b + b * c \u2264 c\n\u22a2 1 + (a + b + b * c) \u2264 1 + c",["gcongr","aesop"]],["Algebra/Order/Ring/Defs.lean",228,"\u03b1 : Type u\ninst\u271d : OrderedRing \u03b1\na b c : \u03b1\nh : a + c + b * c \u2264 b\n\u22a2 1 + (a + c + b * c) \u2264 1 + b",["gcongr","aesop"]],["Algebra/Order/Ring/Defs.lean",232,"\u03b1 : Type u\ninst\u271d : OrderedRing \u03b1\na b c : \u03b1\nh : b + b * c \u2264 a + c\n\u22a2 1 + (b + b * c) \u2264 1 + (a + c)",["gcongr","aesop"]],["Algebra/Order/Ring/Defs.lean",236,"\u03b1 : Type u\ninst\u271d : OrderedRing \u03b1\na b c : \u03b1\nh : c + b * c \u2264 a + b\n\u22a2 1 + (c + b * c) \u2264 1 + (a + b)",["gcongr","aesop"]],["Topology/Gluing.lean",319,"case refine_2\nD : GlueData\nh : MkCore\ni j k : h.J\n\u22a2 Continuous fun x \u21a6 \u27e8(\u27e8\u2191((ConcreteCategory.hom (h.t i j)) (\u2191x).1), \u22ef\u27e9, (ConcreteCategory.hom (h.t i j)) (\u2191x).1), \u22ef\u27e9",["fun_prop"]],["Topology/MetricSpace/Polish.lean",101,"\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\nthis : UpgradedPolishSpace \u03b1 := upgradePolishSpace \u03b1\n\u22a2 MetrizableSpace \u03b1",["infer_instance"]],["Topology/MetricSpace/Polish.lean",107,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : Countable \u03b9\nE : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 TopologicalSpace (E i)\ninst\u271d : \u2200 (i : \u03b9), PolishSpace (E i)\nthis : (i : \u03b9) \u2192 UpgradedPolishSpace (E i) := fun i \u21a6 upgradePolishSpace (E i)\n\u22a2 PolishSpace ((i : \u03b9) \u2192 E i)",["infer_instance"]],["Topology/MetricSpace/Polish.lean",146,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PolishSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : IsClosedEmbedding f\nthis\u271d\u00b2 : UpgradedPolishSpace \u03b2 := upgradePolishSpace \u03b2\nthis\u271d\u00b9 : MetricSpace \u03b1 := IsEmbedding.comapMetricSpace f \u22ef\nthis\u271d : SecondCountableTopology \u03b1\nthis : CompleteSpace \u03b1\n\u22a2 PolishSpace \u03b1",["infer_instance"]],["Topology/MetricSpace/Polish.lean",185,"\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : Countable \u03b9\nu : \u03b9 \u2192 UniformSpace \u03b1\nhcomp : \u2200 (i : \u03b9), CompleteSpace \u03b1\nhcount : \u2200 (i : \u03b9), (\ud835\udce4 \u03b1).IsCountablyGenerated\nht\u2080 : \u2203 t\u2080, T2Space \u03b1 \u2227 \u2200 (i : \u03b9), (fun i \u21a6 UniformSpace.toTopologicalSpace) i \u2264 t\u2080\nhut : \u2200 (i : \u03b9), UniformSpace.toTopologicalSpace = (fun i \u21a6 UniformSpace.toTopologicalSpace) i\n\u22a2 (\u2a05 i, \ud835\udce4 \u03b1).IsCountablyGenerated",["infer_instance"]],["Topology/MetricSpace/Polish.lean",199,"\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : Countable \u03b9\nt : \u03b9 \u2192 TopologicalSpace \u03b1\nht : \u2200 (i : \u03b9), PolishSpace \u03b1\ni\u2080 : \u03b9\nhi\u2080 : \u2200 (i : \u03b9), t i \u2264 t i\u2080\nu : UniformSpace \u03b1\nhcomp : CompleteSpace \u03b1\nhcount : (\ud835\udce4 \u03b1).IsCountablyGenerated\nhtop : UniformSpace.toTopologicalSpace = \u2a05 i, t i\nthis\u271d\u00b9 : SecondCountableTopology \u03b1\nthis\u271d : TopologicalSpace \u03b1 := t i\u2080\nthis : PolishSpace \u03b1\n\u22a2 T1Space \u03b1",["infer_instance"]],["Topology/MetricSpace/Polish.lean",200,"case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : Countable \u03b9\nt : \u03b9 \u2192 TopologicalSpace \u03b1\nht : \u2200 (i : \u03b9), PolishSpace \u03b1\ni\u2080 : \u03b9\nhi\u2080 : \u2200 (i : \u03b9), t i \u2264 t i\u2080\nu : UniformSpace \u03b1\nhcomp : CompleteSpace \u03b1\nhcount : (\ud835\udce4 \u03b1).IsCountablyGenerated\nhtop : UniformSpace.toTopologicalSpace = \u2a05 i, t i\nthis\u271d : SecondCountableTopology \u03b1\nthis : T1Space \u03b1\n\u22a2 PolishSpace \u03b1",["infer_instance"]],["Algebra/Module/Presentation/Basic.lean",67,"A : Type u\ninst\u271d : Ring A\nrelations : Relations A\n\u22a2 AddCommGroup ((relations.G \u2192\u2080 A) \u29f8 Submodule.span A (Set.range relations.relation))",["infer_instance"]],["Algebra/Module/Presentation/Basic.lean",70,"A : Type u\ninst\u271d : Ring A\nrelations : Relations A\n\u22a2 Module A ((relations.G \u2192\u2080 A) \u29f8 Submodule.span A (Set.range relations.relation))",["infer_instance"]],["Algebra/Module/Presentation/Basic.lean",329,"A : Type u\ninst\u271d\u2074 : Ring A\nrelations : Relations A\nM : Type v\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\ns : relations.Solution N\n\u22a2 h.desc s \u2218\u2097 solution.\u03c0 = s.\u03c0",["aesop","infer_instance"]],["Algebra/Module/Presentation/Basic.lean",338,"A : Type u\ninst\u271d\u2074 : Ring A\nrelations : Relations A\nM : Type v\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\ns : relations.Solution N\n\u22a2 solution.postcomp (h.desc s) = s",["aesop","infer_instance"]],["NumberTheory/Padics/MahlerBasis.lean",82,"p : \u2115\nhp : Fact (Nat.Prime p)\nk : \u2115\n\u22a2 Continuous (Subtype.val \u2218 fun x \u21a6 \u27e8\u2191(Polynomial.eval x (ascPochhammer \u2124_[p] k)) / \u2191k.factorial, \u22ef\u27e9)",["fun_prop"]],["NumberTheory/Padics/MahlerBasis.lean",87,"p : \u2115\nhp : Fact (Nat.Prime p)\nk : \u2115\n\u22a2 Continuous fun x \u21a6 Ring.multichoose (x - \u2191k + 1) k",["fun_prop"]],["Combinatorics/SimpleGraph/Regularity/Uniform.lean",241,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 \u03b5' : \ud835\udd5c\nhP : P.IsUniform G \u03b5\nh : \u03b5 \u2264 \u03b5'\n\u22a2 \u2191(#P.parts * (#P.parts - 1)) * \u03b5 \u2264 \u2191(#P.parts * (#P.parts - 1)) * \u03b5'",["gcongr"]],["Combinatorics/SimpleGraph/Regularity/Uniform.lean",63,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b9 : LinearOrderedField \ud835\udd5c\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \ud835\udd5c\ns t : Finset \u03b1\na b : \u03b1\n\u22a2 DecidableRel fun s t \u21a6\n    \u2200 \u2983s' : Finset \u03b1\u2984,\n      s' \u2286 s \u2192\n        \u2200 \u2983t' : Finset \u03b1\u2984,\n          t' \u2286 t \u2192 \u2191(#s) * \u03b5 \u2264 \u2191(#s') \u2192 \u2191(#t) * \u03b5 \u2264 \u2191(#t') \u2192 |\u2191(G.edgeDensity s' t') - \u2191(G.edgeDensity s t)| < \u03b5",["infer_instance"]],["Combinatorics/SimpleGraph/Regularity/Uniform.lean",387,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : DecidableEq \u03b1\nA : Finset \u03b1\nP : Finpartition A\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 \u03b4 : \ud835\udd5c\nu v : Finset \u03b1\n\u22a2 DecidableRel\n    {\n        Adj := fun a b \u21a6\n          G.Adj a b \u2227 \u2203 U \u2208 P.parts, \u2203 V \u2208 P.parts, a \u2208 U \u2227 b \u2208 V \u2227 U \u2260 V \u2227 G.IsUniform \u03b5 U V \u2227 \u03b4 \u2264 \u2191(G.edgeDensity U V),\n        symm := \u22ef, loopless := \u22ef }.Adj",["infer_instance"]],["MeasureTheory/OuterMeasure/Induced.lean",246,"case mpr\n\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nh :\n  \u2200 (t : Set \u03b1),\n    P t \u2192 (inducedOuterMeasure m P0 m0) (t \u2229 s) + (inducedOuterMeasure m P0 m0) (t \\ s) \u2264 (inducedOuterMeasure m P0 m0) t\nu t : Set \u03b1\nht : P t\nh2t : u \u2286 t\n\u22a2 (inducedOuterMeasure m P0 m0) (u \u2229 s) + (inducedOuterMeasure m P0 m0) (u \\ s) \u2264\n    (inducedOuterMeasure m P0 m0) (t \u2229 s) + (inducedOuterMeasure m P0 m0) (t \\ s)",["gcongr"]],["Analysis/ODE/PicardLindelof.lean",295,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : PicardLindelof E\nf\u2081 f\u2082 : v.FunSpace\nn : \u2115\nt : \u2191(Icc v.tMin v.tMax)\nthis : |\u2191t - \u2191v.t\u2080| \u2264 v.tDist\n\u22a2 (\u2191v.L * |\u2191t - \u2191v.t\u2080|) ^ n / \u2191n ! * dist f\u2081 f\u2082 \u2264 (\u2191v.L * v.tDist) ^ n / \u2191n ! * dist f\u2081 f\u2082",["gcongr"]],["MeasureTheory/Function/LpSeminorm/CompareExp.lean",52,"\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 E\nq : \u211d\nhq_pos : 0 < q\nh_nnnorm_le_eLpNorm_ess_sup : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 eLpNormEssSup f \u03bc\nx : \u03b1\nhx : \u2016f x\u2016\u2091 \u2264 eLpNormEssSup f \u03bc\n\u22a2 \u2016f x\u2016\u2091 ^ q \u2264 eLpNormEssSup f \u03bc ^ q",["gcongr"]],["CategoryTheory/Shift/CommShift.lean",318,"C : Type u_1\nD : Type u_2\ninst\u271d\u2078 : Category.{u_7, u_1} C\ninst\u271d\u2077 : Category.{u_6, u_2} D\nF\u2081 F\u2082 : C \u2964 D\n\u03c4 : F\u2081 \u27f6 F\u2082\nA : Type u_5\ninst\u271d\u2076 : AddMonoid A\ninst\u271d\u2075 : HasShift C A\ninst\u271d\u2074 : HasShift D A\ninst\u271d\u00b3 : F\u2081.CommShift A\ninst\u271d\u00b2 : F\u2082.CommShift A\ninst\u271d\u00b9 : IsIso \u03c4\ninst\u271d : CommShift \u03c4 A\nthis : CommShift (asIso \u03c4).hom A\n\u22a2 CommShift (asIso \u03c4).inv A",["infer_instance"]],["CategoryTheory/Shift/CommShift.lean",431,"C\u2081 : Type u_1\nC\u2082 : Type u_2\nC\u2083 : Type u_3\nD\u2081 : Type u_4\nD\u2082 : Type u_5\nD\u2083 : Type u_6\ninst\u271d\u00b2\u2075 : Category.{u_8, u_1} C\u2081\ninst\u271d\u00b2\u2074 : Category.{u_9, u_2} C\u2082\ninst\u271d\u00b2\u00b3 : Category.{u_10, u_3} C\u2083\ninst\u271d\u00b2\u00b2 : Category.{u_11, u_4} D\u2081\ninst\u271d\u00b2\u00b9 : Category.{u_12, u_5} D\u2082\ninst\u271d\u00b2\u2070 : Category.{u_13, u_6} D\u2083\nF\u2081\u2082 : C\u2081 \u2964 C\u2082\nF\u2082\u2083 : C\u2082 \u2964 C\u2083\nF\u2081\u2083 : C\u2081 \u2964 C\u2083\n\u03b1 : F\u2081\u2083 \u27f6 F\u2081\u2082 \u22d9 F\u2082\u2083\nG\u2081\u2082 : D\u2081 \u2964 D\u2082\nG\u2082\u2083 : D\u2082 \u2964 D\u2083\nG\u2081\u2083 : D\u2081 \u2964 D\u2083\n\u03b2 : G\u2081\u2082 \u22d9 G\u2082\u2083 \u27f6 G\u2081\u2083\nL\u2081 : C\u2081 \u2964 D\u2081\nL\u2082 : C\u2082 \u2964 D\u2082\nL\u2083 : C\u2083 \u2964 D\u2083\ne\u2081\u2082 : F\u2081\u2082 \u22d9 L\u2082 \u27f6 L\u2081 \u22d9 G\u2081\u2082\ne\u2082\u2083 : F\u2082\u2083 \u22d9 L\u2083 \u27f6 L\u2082 \u22d9 G\u2082\u2083\nA : Type u_7\ninst\u271d\u00b9\u2079 : AddMonoid A\ninst\u271d\u00b9\u2078 : HasShift C\u2081 A\ninst\u271d\u00b9\u2077 : HasShift C\u2082 A\ninst\u271d\u00b9\u2076 : HasShift C\u2083 A\ninst\u271d\u00b9\u2075 : HasShift D\u2081 A\ninst\u271d\u00b9\u2074 : HasShift D\u2082 A\ninst\u271d\u00b9\u00b3 : HasShift D\u2083 A\ninst\u271d\u00b9\u00b2 : F\u2081\u2082.CommShift A\ninst\u271d\u00b9\u00b9 : F\u2082\u2083.CommShift A\ninst\u271d\u00b9\u2070 : F\u2081\u2083.CommShift A\ninst\u271d\u2079 : CommShift \u03b1 A\ninst\u271d\u2078 : G\u2081\u2082.CommShift A\ninst\u271d\u2077 : G\u2082\u2083.CommShift A\ninst\u271d\u2076 : G\u2081\u2083.CommShift A\ninst\u271d\u2075 : CommShift \u03b2 A\ninst\u271d\u2074 : L\u2081.CommShift A\ninst\u271d\u00b3 : L\u2082.CommShift A\ninst\u271d\u00b2 : L\u2083.CommShift A\ninst\u271d\u00b9 : CommShift e\u2081\u2082 A\ninst\u271d : CommShift e\u2082\u2083 A\n\u22a2 CommShift\n    (CategoryTheory.whiskerRight \u03b1 L\u2083 \u226b\n      (F\u2081\u2082.associator F\u2082\u2083 L\u2083).hom \u226b\n        CategoryTheory.whiskerLeft F\u2081\u2082 e\u2082\u2083 \u226b\n          (F\u2081\u2082.associator L\u2082 G\u2082\u2083).inv \u226b\n            CategoryTheory.whiskerRight e\u2081\u2082 G\u2082\u2083 \u226b (L\u2081.associator G\u2081\u2082 G\u2082\u2083).hom \u226b CategoryTheory.whiskerLeft L\u2081 \u03b2)\n    A",["infer_instance"]],["NumberTheory/LSeries/DirichletContinuation.lean",136,"case refine_2\nM N : \u2115\ninst\u271d\u00b9 : NeZero M\ninst\u271d : NeZero N\nhMN : M \u2223 N\n\u03c7 : DirichletCharacter \u2102 M\ns\u271d : \u2102\nhs\u271d : s\u271d \u2260 1\nhpc : IsPreconnected {1}\u1d9c\nhne : 2 \u2208 {1}\u1d9c\ns : \u2102\nhs : s \u2208 {1}\u1d9c\ni : \u2115\nh : i \u2208 N.primeFactors\nthis : NeZero i\n\u22a2 DifferentiableAt \u2102 (fun s \u21a6 1 - \u03c7 \u2191i * \u2191i ^ (-s)) s",["fun_prop"]],["NumberTheory/LSeries/DirichletContinuation.lean",154,"M N : \u2115\ninst\u271d\u00b9 : NeZero M\ninst\u271d : NeZero N\nhMN : M \u2223 N\n\u03c7 : DirichletCharacter \u2102 M\ns : \u2102\nh : \u03c7 \u2260 1\nh\u03c7 : (changeLevel hMN) \u03c7 \u2260 1\np : \u2115\nhp : p \u2208 N.primeFactors\nthis : NeZero p\n\u22a2 Continuous fun s \u21a6 1 - \u03c7 \u2191p * \u2191p ^ (-s)",["fun_prop"]],["NumberTheory/LSeries/DirichletContinuation.lean",190,"N : \u2115\ninst\u271d : NeZero N\nH :\n  (fun s \u21a6 (s - 1) * LFunctionTrivChar N s) =\u1da0[\ud835\udcdd[\u2260] 1] fun s \u21a6\n    (\u220f p \u2208 N.primeFactors, (1 - \u2191p ^ (-s))) * ((s - 1) * riemannZeta s)\np : \u2115\nhp : p \u2208 N.primeFactors\nthis : NeZero p\n\u22a2 Continuous fun s \u21a6 1 - \u2191p ^ (-s)",["fun_prop"]],["Analysis/SpecialFunctions/Trigonometric/Inverse.lean",322,"x y : \u211d\nhlt : x \u2264 y\n\u22a2 \u03c0 / 2 - arcsin y \u2264 \u03c0 / 2 - arcsin x",["gcongr"]],["Topology/Category/TopCat/Limits/Pullbacks.lean",58,"J : Type v\ninst\u271d : Category.{w, v} J\nX Y Z : TopCat\nf : X \u27f6 Z\ng : Y \u27f6 Z\nS : PullbackCone f g\n\u22a2 Continuous fun x \u21a6 \u27e8((ConcreteCategory.hom S.fst) x, (ConcreteCategory.hom S.snd) x), \u22ef\u27e9",["fun_prop"]],["Topology/Category/TopCat/Limits/Pullbacks.lean",157,"J : Type v\ninst\u271d\u00b3 : Category.{w, v} J\nX\u271d Y\u271d Z\u271d : TopCat\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\nhf : Continuous f\ng : Y \u2192 Z\nhg : IsEmbedding g\n\u22a2 Continuous\n    { toFun := fun x \u21a6 \u27e8(\u2191x).1, \u22ef\u27e9, invFun := fun x \u21a6 \u27e8(\u2191x, Exists.choose \u22ef), \u22ef\u27e9, left_inv := \u22ef, right_inv := \u22ef }.toFun",["fun_prop"]],["NumberTheory/FermatPsp.lean",307,"b : \u2115\nb_ge_two : 2 \u2264 b\np : \u2115\np_prime : Prime p\np_gt_two : 2 < p\nA : \u2115 := (b ^ p - 1) / (b - 1)\nB : \u2115 := (b ^ p + 1) / (b + 1)\nAB_dvd : b ^ 2 - 1 \u2223 b ^ (2 * p) - 1\nh : p < (b ^ 2) ^ (p - 1)\n\u22a2 p * b ^ 2 < (b ^ 2) ^ (p - 1) * b ^ 2",["gcongr"]],["Topology/Algebra/LinearTopology.lean",201,"R : Type u_1\nR' : Type u_2\nM : Type u_3\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : Ring R'\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R' M\ninst\u271d\u00b3 : SMulCommClass R R' M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : IsLinearTopology R M\ninst\u271d : IsLinearTopology R' M\nI : Submodule R M\nhI : \u2191I \u2208 \ud835\udcdd 0\nJ : Submodule R' M\nhJ : \u2191J \u2208 \ud835\udcdd 0\nJ_sub_I : \u2191J \u2286 \u2191I\nuR : Set R := univ\nuR' : Set R' := univ\nhRR : uR * uR \u2286 uR\nhRI : uR \u2022 \u2191I \u2286 \u2191I\nhR'J : uR' \u2022 \u2191J \u2286 \u2191J\nhRJ : uR \u2022 \u2191J \u2286 \u2191I\nS : Set M := \u2191J \u222a uR \u2022 \u2191J\nS_sub_I : S \u2286 \u2191I\n\u22a2 uR \u2022 \u2191J \u222a (uR * uR) \u2022 \u2191J \u2286 uR \u2022 \u2191J \u222a uR \u2022 \u2191J",["gcongr","aesop"]],["Topology/Algebra/LinearTopology.lean",206,"R : Type u_1\nR' : Type u_2\nM : Type u_3\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : Ring R'\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R' M\ninst\u271d\u00b3 : SMulCommClass R R' M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : IsLinearTopology R M\ninst\u271d : IsLinearTopology R' M\nI : Submodule R M\nhI : \u2191I \u2208 \ud835\udcdd 0\nJ : Submodule R' M\nhJ : \u2191J \u2208 \ud835\udcdd 0\nJ_sub_I : \u2191J \u2286 \u2191I\nuR : Set R := univ\nuR' : Set R' := univ\nhRR : uR * uR \u2286 uR\nhRI : uR \u2022 \u2191I \u2286 \u2191I\nhR'J : uR' \u2022 \u2191J \u2286 \u2191J\nhRJ : uR \u2022 \u2191J \u2286 \u2191I\nS : Set M := \u2191J \u222a uR \u2022 \u2191J\nS_sub_I : S \u2286 \u2191I\nhRS : uR \u2022 S \u2286 S\n\u22a2 uR' \u2022 \u2191J \u222a uR \u2022 uR' \u2022 \u2191J \u2286 \u2191J \u222a uR \u2022 \u2191J",["gcongr"]],["Probability/Kernel/Condexp.lean",97,"case inr\n\u03a9 : Type u_1\nF : Type u_2\nm m\u03a9 : MeasurableSpace \u03a9\ninst\u271d\u00b9 : StandardBorelSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d : IsFiniteMeasure \u03bc\nh : Nonempty \u03a9\n\u22a2 IsMarkovKernel ((condDistrib id id \u03bc).comap id \u22ef)",["infer_instance"]],["Probability/Moments/SubGaussian.lean",214,"\u03a9 : Type u_1\n\u03a9' : Type u_2\nm\u03a9 : MeasurableSpace \u03a9\nm\u03a9' : MeasurableSpace \u03a9'\n\u03bd : Measure \u03a9'\n\u03ba : Kernel \u03a9' \u03a9\nX : \u03a9 \u2192 \u211d\nc : \u211d\u22650\nh_int\u271d\u00b9 : \u2200 (t : \u211d), Integrable (fun \u03c9 \u21a6 rexp (t * X \u03c9)) (\u21d1\u03ba \u2218\u2098 \u03bd)\nh_mgf\u271d : \u2200\u1d50 (a : \u03a9') \u2202\u03bd, \u2200 (i : \u211a), mgf X (\u03ba a) \u2191i \u2264 rexp (\u2191c * \u2191i ^ 2 / 2)\nh_int\u271d : \u2200\u1d50 (\u03c9' : \u03a9') \u2202\u03bd, \u2200 (t : \u211d), Integrable (fun \u03c9 \u21a6 rexp (t * X \u03c9)) (\u03ba \u03c9')\n\u03c9' : \u03a9'\nh_mgf : \u2200 (i : \u211a), mgf X (\u03ba \u03c9') \u2191i \u2264 rexp (\u2191c * \u2191i ^ 2 / 2)\nh_int : \u2200 (t : \u211d), Integrable (fun \u03c9 \u21a6 rexp (t * X \u03c9)) (\u03ba \u03c9')\nt : \u211d\n\u22a2 Continuous fun b \u21a6 rexp (\u2191c * b ^ 2 / 2)",["fun_prop"]],["Topology/MetricSpace/Lipschitz.lean",99,"\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b2\nx y : \u03b1\nr : \u211d\nhf : LipschitzWith K f\nhr : dist x y \u2264 r\n\u22a2 \u2191K * dist x y \u2264 \u2191K * r",["gcongr"]],["Analysis/Calculus/Taylor.lean",254,"f : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\n\u22a2 ContinuousOn (fun t \u21a6 (x - t) ^ (n + 1)) (Icc x\u2080 x)",["fun_prop"]],["Analysis/Calculus/Taylor.lean",283,"f : \u211d \u2192 \u211d\nx x\u2080 : \u211d\nn : \u2115\nhx : x\u2080 < x\nhf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)\nhf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)\n\u22a2 ContinuousOn id (Icc x\u2080 x)",["fun_prop"]],["Probability/Distributions/Gaussian.lean",319,"\u03bc : \u211d\nv : \u211d\u22650\n\u03a9 : Type\ninst\u271d : MeasureSpace \u03a9\nX : \u03a9 \u2192 \u211d\nhX : Measure.map X \u2119 = gaussianReal \u03bc v\ny : \u211d\n\u22a2 NeZero (gaussianReal \u03bc v)",["infer_instance"]],["Probability/Distributions/Gaussian.lean",335,"\u03bc : \u211d\nv : \u211d\u22650\n\u03a9 : Type\ninst\u271d : MeasureSpace \u03a9\nX : \u03a9 \u2192 \u211d\nhX : Measure.map X \u2119 = gaussianReal \u03bc v\nc : \u211d\n\u22a2 NeZero (gaussianReal \u03bc v)",["infer_instance"]],["Algebra/Homology/TotalComplexShift.lean",112,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK L : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\nf : K \u27f6 L\nx y : \u2124\ninst\u271d : K.HasTotal (up \u2124)\n\u22a2 ((shiftFunctor\u2081 C x).obj ((shiftFunctor\u2082 C y).obj K)).HasTotal (up \u2124)",["infer_instance"]],["Algebra/Homology/TotalComplexShift.lean",116,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nK L : HomologicalComplex\u2082 C (up \u2124) (up \u2124)\nf : K \u27f6 L\nx y : \u2124\ninst\u271d : K.HasTotal (up \u2124)\n\u22a2 ((shiftFunctor\u2082 C y).obj ((shiftFunctor\u2081 C x).obj K)).HasTotal (up \u2124)",["infer_instance"]],["Data/Real/Archimedean.lean",385,"a : \u211d\nha : 1 < a\nk : \u2115\nposk : 0 < k\nhk : 1 / \u2191k + 1 < a\n\u22a2 (1 / \u2191k + 1) ^ (2 * k ^ 2) < a ^ (2 * k ^ 2)",["gcongr"]],["Analysis/Normed/Group/Uniform.lean",75,"E : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\ns : Set E\na b : E\nr : \u211d\nf : E \u2192 F\nC : \u211d\u22650\nh : LipschitzOnWith C f s\nha : a \u2208 s\nhb : b \u2208 s\nhr : \u2016a / b\u2016 \u2264 r\n\u22a2 \u2191C * \u2016a / b\u2016 \u2264 \u2191C * r",["gcongr"]],["Analysis/Normed/Group/Uniform.lean",89,"E : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\na b : E\nr : \u211d\nf : E \u2192 F\nC : \u211d\u22650\nh : LipschitzWith C f\nhr : \u2016a / b\u2016 \u2264 r\n\u22a2 \u2191C * \u2016a / b\u2016 \u2264 \u2191C * r",["gcongr"]],["Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",82,"case h.a.hab.h.h.h\nb : \u2102\nhb : 0 < b.re\nc\u271d T\u271d : \u211d\nhT\u271d : 0 \u2264 T\u271d\nT : \u211d\nhT : 0 \u2264 T\nc y : \u211d\nhy : |y| \u2264 |c|\n\u22a2 |b.im| * |y| \u2264 |b.im| * |c|",["gcongr"]],["Algebra/Homology/Embedding/ExtendHomology.lean",281,"case pos.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nc : ComplexShape \u03b9\nc' : ComplexShape \u03b9'\nC : Type u_3\ninst\u271d\u00b3 : Category.{u_4, u_3} C\ninst\u271d\u00b2 : HasZeroMorphisms C\ninst\u271d\u00b9 : HasZeroObject C\nK L M : HomologicalComplex C c\n\u03c6 : K \u27f6 L\n\u03c6' : L \u27f6 M\ne : c.Embedding c'\ninst\u271d : \u2200 (j : \u03b9), K.HasHomology j\nj : \u03b9\n\u22a2 (K.extend e).HasHomology (e.f j)",["infer_instance"]],["CategoryTheory/GlueData.lean",175,"C : Type u\u2081\ninst\u271d\u00b3 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d\u00b2 : Category.{v, u\u2082} C'\nD : GlueData C\ninst\u271d\u00b9 : HasMulticoequalizer D.diagram\ninst\u271d : HasColimits C\n\u22a2 Epi (Multicoequalizer.sigma\u03c0 D.diagram)",["infer_instance"]],["CategoryTheory/GlueData.lean",384,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData' C\ni : D.J\n\u22a2 IsIso (eqToHom \u22ef)",["infer_instance"]],["CategoryTheory/GlueData.lean",391,"case inst\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData' C\ni j k : D.J\nhij : i = j\n\u22a2 IsIso (eqToHom \u22ef)",["infer_instance"]],["CategoryTheory/GlueData.lean",395,"case inst\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData' C\ni j k : D.J\nhij : \u00aci = j\nhik : i = k\n\u22a2 IsIso (eqToHom \u22ef)",["infer_instance"]],["CategoryTheory/GlueData.lean",410,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData' C\ni j : D.J\nhij : \u00aci = j\n\u22a2 IsIso (pullback.snd (D.f' j i) (D.f' j i))",["infer_instance"]],["CategoryTheory/GlueData.lean",417,"case inst\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData' C\ni j k : D.J\nhij : \u00aci = j\nhik : \u00aci = k\nhjk : j = k\n\u22a2 IsIso (eqToHom \u22ef)",["infer_instance"]],["CategoryTheory/GlueData.lean",438,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData' C\ni : D.J\n\u22a2 IsIso (eqToHom \u22ef)",["infer_instance"]],["FieldTheory/PolynomialGaloisGroup.lean",258,"F : Type u_1\ninst\u271d : Field F\np q : F[X]\nhpq : p * q = 0\n\u22a2 Unique (Gal 0)",["infer_instance"]],["Data/Rat/Defs.lean",301,"q a b c : \u211a\n\u22a2 AddGroup \u211a",["infer_instance"]],["Data/Rat/Defs.lean",303,"q a b c : \u211a\n\u22a2 AddCommMonoid \u211a",["infer_instance"]],["Data/Rat/Defs.lean",305,"q a b c : \u211a\n\u22a2 AddMonoid \u211a",["infer_instance"]],["Data/Rat/Defs.lean",307,"q a b c : \u211a\n\u22a2 AddLeftCancelSemigroup \u211a",["infer_instance"]],["Data/Rat/Defs.lean",309,"q a b c : \u211a\n\u22a2 AddRightCancelSemigroup \u211a",["infer_instance"]],["Data/Rat/Defs.lean",311,"q a b c : \u211a\n\u22a2 AddCommSemigroup \u211a",["infer_instance"]],["Data/Rat/Defs.lean",313,"q a b c : \u211a\n\u22a2 AddSemigroup \u211a",["infer_instance"]],["Data/Rat/Defs.lean",333,"q a b c : \u211a\n\u22a2 Monoid \u211a",["infer_instance"]],["Data/Rat/Defs.lean",335,"q a b c : \u211a\n\u22a2 CommSemigroup \u211a",["infer_instance"]],["Data/Rat/Defs.lean",337,"q a b c : \u211a\n\u22a2 Semigroup \u211a",["infer_instance"]],["CategoryTheory/Monad/Comonadicity.lean",226,"C : Type u\u2081\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b2 : Category.{v\u2081, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\ninst\u271d\u00b9 : ComonadicLeftAdjoint F\nA B : C\nf g : A \u27f6 B\ninst\u271d : F.IsCosplitPair f g\n\u22a2 PreservesLimit (parallelPair (F.map f) (F.map g)) (comonadicRightAdjoint F \u22d9 F)\n```\n---\n```lean\nC : Type u\u2081\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b2 : Category.{v\u2081, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\ninst\u271d\u00b9 : ComonadicLeftAdjoint F\nA B : C\nf g : A \u27f6 B\ninst\u271d : F.IsCosplitPair f g\n\u22a2 PreservesLimit\n    (parallelPair (F.map ((comonadicRightAdjoint F).map (F.map f))) (F.map ((comonadicRightAdjoint F).map (F.map g))))\n    (comonadicRightAdjoint F \u22d9 F)",["infer_instance"]],["CategoryTheory/Monad/Comonadicity.lean",294,"C : Type u\u2081\nD : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b3 : Category.{v\u2081, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\ninst\u271d\u00b2 : HasEqualizerOfIsCosplitPair F\ninst\u271d\u00b9 : PreservesLimitOfIsCosplitPair F\ninst\u271d : ReflectsLimitOfIsCosplitPair F\nthis : \u2200 (X : adj.toComonad.Coalgebra), IsIso ((comparisonAdjunction adj).counit.app X)\nY : C\nx\u271d : F.IsCosplitPair (G.map (F.map (adj.unit.app Y))) (adj.unit.app (G.obj (F.obj Y))) :=\n  main_pair_F_cosplit adj ((comparison adj).obj Y)\n\u22a2 ReflectsLimit (parallelPair (G.map (F.map (adj.unit.app Y))) (adj.unit.app (G.obj (F.obj Y)))) F",["infer_instance"]],["Analysis/Convex/Star.lean",365,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : OrderedRing \ud835\udd5c\ninst\u271d\u00b2 : OrderedAddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nx y : E\nh : x < y\nz : E\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhz : a \u2022 y + b \u2022 z \u2264 x\n\u22a2 a \u2022 x + b \u2022 x < a \u2022 y + b \u2022 x",["gcongr","aesop"]],["Analysis/Convex/Star.lean",424,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b2 : OrderedAddCommMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nx : E\ns : Set E\nhs : s.OrdConnected\nhx : x \u2208 s\nh : \u2200 y \u2208 s, x \u2264 y \u2228 y \u2264 x\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\nhxy : x \u2264 y\n\u22a2 a \u2022 x + b \u2022 x \u2264 a \u2022 x + b \u2022 y",["gcongr"]],["Analysis/Convex/Star.lean",426,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b2 : OrderedAddCommMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nx : E\ns : Set E\nhs : s.OrdConnected\nhx : x \u2208 s\nh : \u2200 y \u2208 s, x \u2264 y \u2228 y \u2264 x\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\nhxy : x \u2264 y\n\u22a2 a \u2022 x + b \u2022 y \u2264 a \u2022 y + b \u2022 y",["gcongr"]],["Analysis/Convex/Star.lean",431,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b2 : OrderedAddCommMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nx : E\ns : Set E\nhs : s.OrdConnected\nhx : x \u2208 s\nh : \u2200 y \u2208 s, x \u2264 y \u2228 y \u2264 x\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\nhyx : y \u2264 x\n\u22a2 a \u2022 y + b \u2022 y \u2264 a \u2022 x + b \u2022 y",["gcongr"]],["Analysis/Convex/Star.lean",433,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b2 : OrderedAddCommMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nx : E\ns : Set E\nhs : s.OrdConnected\nhx : x \u2208 s\nh : \u2200 y \u2208 s, x \u2264 y \u2228 y \u2264 x\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\nhyx : y \u2264 x\n\u22a2 a \u2022 x + b \u2022 y \u2264 a \u2022 x + b \u2022 x",["gcongr"]],["MeasureTheory/Measure/Tilted.lean",139,"case pos\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nh\u03bc : NeZero \u03bc\nhf : Integrable (fun x \u21a6 rexp (f x)) \u03bc\nthis : IsProbabilityMeasure (\u03bc.tilted f)\n\u22a2 IsZeroOrProbabilityMeasure (\u03bc.tilted f)",["infer_instance"]],["Topology/LocallyConstant/Algebra.lean",384,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\n\u03b1 : Type u_3\nR\u271d : Type u_4\nR : Type u_5\nZ : Type u_6\ninst\u271d\u00b9 : MulOneClass Y\ninst\u271d : MulOneClass Z\nf : Y \u2192* Z\n\u22a2 \u2200 (x y : LocallyConstant X Y),\n    { toFun := map \u21d1f, map_one' := \u22ef }.toFun (x * y) =\n      { toFun := map \u21d1f, map_one' := \u22ef }.toFun x * { toFun := map \u21d1f, map_one' := \u22ef }.toFun y",["aesop","infer_instance"]],["Topology/LocallyConstant/Algebra.lean",393,"X : Type u_1\nY : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\n\u03b1 : Type u_3\nR\u271d\u00b9 : Type u_4\nR\u271d : Type u_5\nZ : Type u_6\nR : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid Y\ninst\u271d\u00b2 : Module R Y\ninst\u271d\u00b9 : AddCommMonoid Z\ninst\u271d : Module R Z\nf : Y \u2192\u2097[R] Z\n\u22a2 \u2200 (m : R) (x : LocallyConstant X Y),\n    { toFun := map \u21d1f, map_add' := \u22ef }.toFun (m \u2022 x) = (RingHom.id R) m \u2022 { toFun := map \u21d1f, map_add' := \u22ef }.toFun x",["aesop","infer_instance"]],["Combinatorics/Additive/VerySmallDoubling.lean",184,"G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nA\u271d : Finset G\na : G\nA : Finset G\nh : \u2191(#(A * A)) < 3 / 2 * \u2191(#A)\n\u22a2 Fintype { x // x \u2208 A\u207b\u00b9 * A }",["infer_instance"]],["Probability/Kernel/Disintegration/CondCDF.lean",61,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03c1 : Measure (\u03b1 \u00d7 \u211d)\nr r' : \u211d\nh_le : r \u2264 r'\n\u22a2 (\u03c1.restrict (univ \u00d7\u02e2 Iic r)).fst \u2264 (\u03c1.restrict (univ \u00d7\u02e2 Iic r')).fst",["gcongr"]],["CategoryTheory/Functor/Flat.lean",165,"case has_limit\nC : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\ninst\u271d\u00b9 : HasFiniteLimits C\nF : C \u2964 D\ninst\u271d : PreservesFiniteLimits F\nX : D\nJ : Type v\u2081\nsJ : SmallCategory J\nfJ : FinCategory J\n\u22a2 autoParam (\u2200 (F_1 : J \u2964 StructuredArrow X F), HasLimit F_1) _auto\u271d",["infer_instance"]],["CategoryTheory/Functor/Flat.lean",342,"C D : Type u\u2081\ninst\u271d\u00b9\u2070 : SmallCategory C\ninst\u271d\u2079 : SmallCategory D\nE : Type u\u2082\ninst\u271d\u2078 : Category.{u\u2081, u\u2082} E\ninst\u271d\u2077 : HasForget E\ninst\u271d\u2076 : HasLimits E\ninst\u271d\u2075 : HasColimits E\ninst\u271d\u2074 : ReflectsLimits (forget E)\ninst\u271d\u00b3 : PreservesFilteredColimits (forget E)\ninst\u271d\u00b2 : PreservesLimits (forget E)\ninst\u271d\u00b9 : HasFiniteLimits C\nF : C \u2964 D\ninst\u271d : PreservesFiniteLimits F\nthis : RepresentablyFlat F\n\u22a2 PreservesFiniteLimits F.op.lan",["infer_instance"]],["Probability/Process/Filtration.lean",364,"\u03b9 : Type u_3\ninst\u271d\u00b2 : Preorder \u03b9\nX : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 MeasurableSpace (X i)\ninst\u271d : LocallyFiniteOrderBot \u03b9\ni : \u03b9\n\u22a2 Measurable \u21d1(MeasurableEquiv.piCongrLeft (fun i_1 \u21a6 X \u2191i_1) (Equiv.IicFinsetSet i))",["fun_prop"]],["Probability/Process/Filtration.lean",366,"\u03b9 : Type u_3\ninst\u271d\u00b2 : Preorder \u03b9\nX : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 MeasurableSpace (X i)\ninst\u271d : LocallyFiniteOrderBot \u03b9\ni : \u03b9\n\u22a2 Measurable \u21d1(MeasurableEquiv.piCongrLeft (fun i_1 \u21a6 X \u2191i_1) (Equiv.IicFinsetSet i).symm)",["fun_prop"]],["Data/List/AList.lean",63,"\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (a : \u03b1) \u2192 DecidableEq (\u03b2 a)\nxs ys : AList \u03b2\n\u22a2 Decidable (xs.entries = ys.entries)",["infer_instance"]],["Topology/FiberBundle/Constructions.lean",143,"B : Type u_1\ninst\u271d\u2074 : TopologicalSpace B\nF\u2081 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace F\u2081\nE\u2081 : B \u2192 Type u_3\ninst\u271d\u00b2 : TopologicalSpace (TotalSpace F\u2081 E\u2081)\nF\u2082 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace F\u2082\nE\u2082 : B \u2192 Type u_5\ninst\u271d : TopologicalSpace (TotalSpace F\u2082 E\u2082)\ne\u2081 : Trivialization F\u2081 TotalSpace.proj\ne\u2082 : Trivialization F\u2082 TotalSpace.proj\nf\u2081 : (TotalSpace (F\u2081 \u00d7 F\u2082) fun x \u21a6 E\u2081 x \u00d7 E\u2082 x) \u2192 TotalSpace F\u2081 E\u2081 \u00d7 TotalSpace F\u2082 E\u2082 :=\n  fun p \u21a6 ({ proj := p.proj, snd := p.snd.1 }, { proj := p.proj, snd := p.snd.2 })\nf\u2082 : TotalSpace F\u2081 E\u2081 \u00d7 TotalSpace F\u2082 E\u2082 \u2192 (B \u00d7 F\u2081) \u00d7 B \u00d7 F\u2082 := fun p \u21a6 (\u2191e\u2081 p.1, \u2191e\u2082 p.2)\nf\u2083 : (B \u00d7 F\u2081) \u00d7 B \u00d7 F\u2082 \u2192 B \u00d7 F\u2081 \u00d7 F\u2082 := fun p \u21a6 (p.1.1, p.1.2, p.2.2)\nhf\u2081 : Continuous f\u2081\nhf\u2082 : ContinuousOn f\u2082 (e\u2081.source \u00d7\u02e2 e\u2082.source)\n\u22a2 Continuous f\u2083",["fun_prop"]],["Topology/FiberBundle/Constructions.lean",180,"B : Type u_1\ninst\u271d\u2076 : TopologicalSpace B\nF\u2081 : Type u_2\ninst\u271d\u2075 : TopologicalSpace F\u2081\nE\u2081 : B \u2192 Type u_3\ninst\u271d\u2074 : TopologicalSpace (TotalSpace F\u2081 E\u2081)\nF\u2082 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace F\u2082\nE\u2082 : B \u2192 Type u_5\ninst\u271d\u00b2 : TopologicalSpace (TotalSpace F\u2082 E\u2082)\ne\u2081 : Trivialization F\u2081 TotalSpace.proj\ne\u2082 : Trivialization F\u2082 TotalSpace.proj\ninst\u271d\u00b9 : (x : B) \u2192 Zero (E\u2081 x)\ninst\u271d : (x : B) \u2192 Zero (E\u2082 x)\n\u22a2 Continuous fun p \u21a6 ((p.1, p.2.1), p.1, p.2.2)",["fun_prop"]],["Analysis/Asymptotics/AsymptoticEquivalent.lean",238,"\u03b1 : Type u_1\nE : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na b : \u03b1 \u2192 \ud835\udd5c\nu v : \u03b1 \u2192 E\nl : Filter \u03b1\nhab : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u03b1) in l, \u2016(a - b) x\u2016 \u2264 c * \u2016b x\u2016\n\u03c6 : \u03b1 \u2192 \ud835\udd5c\nhab\u03c6 : a =\u1da0[l] \u03c6 * b\nthis : ((fun x \u21a6 a x \u2022 u x) - fun x \u21a6 b x \u2022 v x) =\u1da0[l] fun x \u21a6 b x \u2022 (\u03c6 x \u2022 u x - v x)\nC : \u211d\nhC : C > 0\nhCuv : \u2200\u1da0 (x : \u03b1) in l, \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nc : \u211d\nhc : 0 < c\nh\u03c6 : \u2200\u1da0 (x : \u03b1) in l, \u2016\u03c6 x - 1\u2016 < c / 2 / C\nhuv : \u2200\u1da0 (x : \u03b1) in l, \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nx : \u03b1\nhCuvx : \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nhuvx : \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nh\u03c6x : \u2016\u03c6 x - 1\u2016 < c / 2 / C\n\u22a2 \u2016\u03c6 x - 1\u2016 * \u2016u x\u2016 \u2264 c / 2 / C * \u2016u x\u2016",["gcongr"]],["Analysis/Asymptotics/AsymptoticEquivalent.lean",239,"\u03b1 : Type u_1\nE : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na b : \u03b1 \u2192 \ud835\udd5c\nu v : \u03b1 \u2192 E\nl : Filter \u03b1\nhab : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u03b1) in l, \u2016(a - b) x\u2016 \u2264 c * \u2016b x\u2016\n\u03c6 : \u03b1 \u2192 \ud835\udd5c\nhab\u03c6 : a =\u1da0[l] \u03c6 * b\nthis : ((fun x \u21a6 a x \u2022 u x) - fun x \u21a6 b x \u2022 v x) =\u1da0[l] fun x \u21a6 b x \u2022 (\u03c6 x \u2022 u x - v x)\nC : \u211d\nhC : C > 0\nhCuv : \u2200\u1da0 (x : \u03b1) in l, \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nc : \u211d\nhc : 0 < c\nh\u03c6 : \u2200\u1da0 (x : \u03b1) in l, \u2016\u03c6 x - 1\u2016 < c / 2 / C\nhuv : \u2200\u1da0 (x : \u03b1) in l, \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nx : \u03b1\nhCuvx : \u2016u x\u2016 \u2264 C * \u2016v x\u2016\nhuvx : \u2016(u - v) x\u2016 \u2264 c / 2 * \u2016v x\u2016\nh\u03c6x : \u2016\u03c6 x - 1\u2016 < c / 2 / C\n\u22a2 c / 2 / C * \u2016u x\u2016 \u2264 c / 2 / C * (C * \u2016v x\u2016)",["gcongr","aesop"]],["Probability/Kernel/Posterior.lean",272,"\u03a9 : Type u_1\n\ud835\udce7 : Type u_2\nm\u03a9 : MeasurableSpace \u03a9\nm\ud835\udce7 : MeasurableSpace \ud835\udce7\n\u03ba : Kernel \u03a9 \ud835\udce7\n\u03bc : Measure \u03a9\ninst\u271d\u2074 : IsFiniteMeasure \u03bc\ninst\u271d\u00b3 : IsFiniteKernel \u03ba\ninst\u271d\u00b2 : StandardBorelSpace \u03a9\ninst\u271d\u00b9 : Nonempty \u03a9\ninst\u271d : MeasurableSpace.CountableOrCountablyGenerated \u03a9 \ud835\udce7\nh_ac : \u2200\u1d50 (\u03c9 : \u03a9) \u2202\u03bc, \u03ba \u03c9 \u226a \u21d1\u03ba \u2218\u2098 \u03bc\n\u22a2 Measurable fun x \u21a6 \u03ba.rnDeriv (Kernel.const \u03a9 (\u21d1\u03ba \u2218\u2098 \u03bc)) x.2 x.1",["fun_prop"]],["Probability/Kernel/Posterior.lean",72,"\u03a9 : Type u_1\n\ud835\udce7 : Type u_2\n\ud835\udce8 : Type u_3\n\ud835\udce9 : Type u_4\nm\u03a9 : MeasurableSpace \u03a9\nm\ud835\udce7 : MeasurableSpace \ud835\udce7\nm\ud835\udce8 : MeasurableSpace \ud835\udce8\nm\ud835\udce9 : MeasurableSpace \ud835\udce9\n\u03ba : Kernel \u03a9 \ud835\udce7\n\u03bc : Measure \u03a9\ninst\u271d\u00b3 : IsFiniteMeasure \u03bc\ninst\u271d\u00b2 : IsFiniteKernel \u03ba\ninst\u271d\u00b9 : StandardBorelSpace \u03a9\ninst\u271d : Nonempty \u03a9\n\u22a2 IsMarkovKernel (Measure.map Prod.swap (\u03bc \u2297\u2098 \u03ba)).condKernel",["infer_instance"]],["Geometry/RingedSpace/LocallyRingedSpace/HasColimits.lean",268,"X Y : RingedSpace\nf g : X \u27f6 Y\nH : f = g\nx : \u2191\u2191X.toPresheafedSpace\nh : IsLocalHom (CommRingCat.Hom.hom (PresheafedSpace.Hom.stalkMap f x))\n\u22a2 IsLocalHom (CommRingCat.Hom.hom (eqToHom \u22ef \u226b PresheafedSpace.Hom.stalkMap f x))",["infer_instance","aesop"]],["Geometry/RingedSpace/LocallyRingedSpace/HasColimits.lean",289,"case create.refine_1.intro\nX Y : LocallyRingedSpace\nf g : X \u27f6 Y\ns : Cofork f g\ne : Hom.toShHom f \u226b Hom.toShHom s.\u03c0 = Hom.toShHom g \u226b Hom.toShHom s.\u03c0\ny : \u2191\u2191Y.toPresheafedSpace\nh : \u2191(s.pt.presheaf.stalk\n      ((ConcreteCategory.hom (coequalizer.desc (Hom.toShHom s.\u03c0) e).base)\n        ((ConcreteCategory.hom (coequalizer.\u03c0 (Hom.toShHom f) (Hom.toShHom g)).base) y))) \u2192+*\n  \u2191((coequalizerCofork f g).pt.presheaf.stalk\n      ((ConcreteCategory.hom (coequalizer.\u03c0 (Hom.toShHom f) (Hom.toShHom g)).base) y)) :=\n  CommRingCat.Hom.hom\n    (PresheafedSpace.Hom.stalkMap (coequalizer.desc (Hom.toShHom s.\u03c0) e)\n      ((ConcreteCategory.hom (coequalizer.\u03c0 (Hom.toShHom f) (Hom.toShHom g)).base) y))\n\u22a2 IsLocalHom (CommRingCat.Hom.hom (PresheafedSpace.Hom.stalkMap (Hom.toShHom s.\u03c0) y))",["infer_instance"]],["Topology/ContinuousMap/ContinuousMapZero.lean",119,"X : Type u_4\nY : Type u_5\nZ : Type u_6\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : Zero X\ninst\u271d\u00b9 : Zero Y\ninst\u271d : Zero Z\nf : C(X, Y)\u2080\n\u22a2 Continuous fun g \u21a6 (\u2191g).comp \u2191f",["fun_prop"]],["Analysis/SpecificLimits/FloorPow.lean",95,"u : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nhlim :\n  \u2200 (a : \u211d),\n    1 < a \u2192\n      \u2203 c,\n        (\u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 a * \u2191(c n)) \u2227\n          Tendsto c atTop atTop \u2227 Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nlnonneg : 0 \u2264 l\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nc : \u2115 \u2192 \u2115\ncgrowth : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 (1 + \u03b5) * \u2191(c n)\nctop : Tendsto c atTop atTop\nclim : Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nL : \u2200\u1da0 (n : \u2115) in atTop, u (c n) - \u2191(c n) * l \u2264 \u03b5 * \u2191(c n)\na : \u2115\nha : \u2200 (b : \u2115), a \u2264 b \u2192 \u2191(c (b + 1)) \u2264 (1 + \u03b5) * \u2191(c b) \u2227 u (c b) - \u2191(c b) * l \u2264 \u03b5 * \u2191(c b)\nM : \u2115 := (image (fun i \u21a6 c i) (range (a + 1))).max' \u22ef\nn : \u2115\nhn : n \u2208 Set.Ici M\nexN : \u2203 N, n < c N\nN : \u2115 := Nat.find exN\nncN : n < c N\naN : a + 1 \u2264 N\nNpos : 0 < N\ncNn : c (N - 1) \u2264 n\nIcN : \u2191(c N) \u2264 (1 + \u03b5) * \u2191(c (N - 1))\n\u22a2 \u03b5 * \u2191(c N) + \u03b5 * \u2191(c (N - 1)) * l \u2264 \u03b5 * ((1 + \u03b5) * \u2191(c (N - 1))) + \u03b5 * \u2191(c (N - 1)) * l",["gcongr","aesop"]],["Analysis/SpecificLimits/FloorPow.lean",97,"u : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nhlim :\n  \u2200 (a : \u211d),\n    1 < a \u2192\n      \u2203 c,\n        (\u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 a * \u2191(c n)) \u2227\n          Tendsto c atTop atTop \u2227 Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nlnonneg : 0 \u2264 l\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nc : \u2115 \u2192 \u2115\ncgrowth : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 (1 + \u03b5) * \u2191(c n)\nctop : Tendsto c atTop atTop\nclim : Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nL : \u2200\u1da0 (n : \u2115) in atTop, u (c n) - \u2191(c n) * l \u2264 \u03b5 * \u2191(c n)\na : \u2115\nha : \u2200 (b : \u2115), a \u2264 b \u2192 \u2191(c (b + 1)) \u2264 (1 + \u03b5) * \u2191(c b) \u2227 u (c b) - \u2191(c b) * l \u2264 \u03b5 * \u2191(c b)\nM : \u2115 := (image (fun i \u21a6 c i) (range (a + 1))).max' \u22ef\nn : \u2115\nhn : n \u2208 Set.Ici M\nexN : \u2203 N, n < c N\nN : \u2115 := Nat.find exN\nncN : n < c N\naN : a + 1 \u2264 N\nNpos : 0 < N\ncNn : c (N - 1) \u2264 n\nIcN : \u2191(c N) \u2264 (1 + \u03b5) * \u2191(c (N - 1))\n\u22a2 \u03b5 * (1 + \u03b5 + l) * \u2191(c (N - 1)) \u2264 \u03b5 * (1 + \u03b5 + l) * \u2191n",["gcongr"]],["Analysis/SpecificLimits/FloorPow.lean",150,"u : \u2115 \u2192 \u211d\nl : \u211d\nhmono : Monotone u\nhlim :\n  \u2200 (a : \u211d),\n    1 < a \u2192\n      \u2203 c,\n        (\u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 a * \u2191(c n)) \u2227\n          Tendsto c atTop atTop \u2227 Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nlnonneg : 0 \u2264 l\nA : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2200\u1da0 (n : \u2115) in atTop, u n - \u2191n * l \u2264 \u03b5 * (1 + \u03b5 + l) * \u2191n\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nc : \u2115 \u2192 \u2115\ncgrowth : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c (n + 1)) \u2264 (1 + \u03b5) * \u2191(c n)\nctop : Tendsto c atTop atTop\nclim : Tendsto (fun n \u21a6 u (c n) / \u2191(c n)) atTop (\ud835\udcdd l)\nL : \u2200\u1da0 (n : \u2115) in atTop, \u2191(c n) * l - u (c n) \u2264 \u03b5 * \u2191(c n)\na : \u2115\nha : \u2200 (b : \u2115), a \u2264 b \u2192 \u2191(c (b + 1)) \u2264 (1 + \u03b5) * \u2191(c b) \u2227 \u2191(c b) * l - u (c b) \u2264 \u03b5 * \u2191(c b)\nM : \u2115 := (image (fun i \u21a6 c i) (range (a + 1))).max' \u22ef\nn : \u2115\nhn : n \u2208 Set.Ici M\nexN : \u2203 N, n < c N\nN : \u2115 := Nat.find exN\nncN : n < c N\naN : a + 1 \u2264 N\nNpos : 0 < N\naN' : a \u2264 N - 1\ncNn : c (N - 1) \u2264 n\n\u22a2 \u03b5 * (1 + l) * \u2191(c (N - 1)) \u2264 \u03b5 * (1 + l) * \u2191n",["gcongr"]],["Analysis/SpecificLimits/FloorPow.lean",262,"N : \u2115\nj : \u211d\nhj : 0 < j\nc : \u211d\nhc : 1 < c\ncpos : 0 < c\nA : 0 < c\u207b\u00b9 ^ 2\nB : c ^ 2 * (1 - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9\nC : c\u207b\u00b9 ^ 2 < 1\n\u22a2 c ^ 2 * (1 - c\u207b\u00b9 ^ 2)\u207b\u00b9 / j ^ 2 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2",["gcongr"]],["CategoryTheory/MorphismProperty/TransfiniteComposition.lean",186,"case hm\nC : Type u\ninst\u271d\u2079 : Category.{v, u} C\nD : Type u'\ninst\u271d\u2078 : Category.{v', u'} D\nW : MorphismProperty C\nJ : Type w\ninst\u271d\u2077 : LinearOrder J\ninst\u271d\u2076 : SuccOrder J\ninst\u271d\u2075 : OrderBot J\ninst\u271d\u2074 : WellFoundedLT J\nJ' : Type w'\ninst\u271d\u00b3 : LinearOrder J'\ninst\u271d\u00b2 : SuccOrder J'\ninst\u271d\u00b9 : OrderBot J'\ninst\u271d : WellFoundedLT J'\nX Y : C\nf : X \u27f6 Y\nh : (isomorphisms C).TransfiniteCompositionOfShape J f\nhj : IsMin \u22a5\n\u22a2 IsIso (h.F.map (\ud835\udfd9 \u22a5))",["infer_instance"]],["CategoryTheory/MorphismProperty/TransfiniteComposition.lean",190,"case hs\nC : Type u\ninst\u271d\u2079 : Category.{v, u} C\nD : Type u'\ninst\u271d\u2078 : Category.{v', u'} D\nW : MorphismProperty C\nJ : Type w\ninst\u271d\u2077 : LinearOrder J\ninst\u271d\u2076 : SuccOrder J\ninst\u271d\u2075 : OrderBot J\ninst\u271d\u2074 : WellFoundedLT J\nJ' : Type w'\ninst\u271d\u00b3 : LinearOrder J'\ninst\u271d\u00b2 : SuccOrder J'\ninst\u271d\u00b9 : OrderBot J'\ninst\u271d : WellFoundedLT J'\nX Y : C\nf : X \u27f6 Y\nh : (isomorphisms C).TransfiniteCompositionOfShape J f\nj : J\nhj : \u00acIsMax j\nhj' : IsIso (h.F.map (homOfLE \u22ef))\nthis : IsIso (h.F.map (homOfLE \u22ef))\n\u22a2 IsIso (h.F.map (homOfLE \u22ef) \u226b h.F.map (homOfLE \u22ef))",["infer_instance"]],["CategoryTheory/MorphismProperty/TransfiniteComposition.lean",209,"C : Type u\ninst\u271d\u2074 : Category.{v, u} C\nJ : Type w\ninst\u271d\u00b3 : LinearOrder J\ninst\u271d\u00b2 : SuccOrder J\ninst\u271d\u00b9 : OrderBot J\ninst\u271d : WellFoundedLT J\nX Y : C\nf : X \u27f6 Y\nh : (isomorphisms C).TransfiniteCompositionOfShape J f\n\u22a2 IsIso (h.isoBot.inv \u226b h.incl.app \u22a5)",["infer_instance"]],["CategoryTheory/MorphismProperty/TransfiniteComposition.lean",301,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nW : MorphismProperty C\ninst\u271d\u00b9 : W.IsStableUnderTransfiniteComposition\ninst\u271d : UnivLE.{w, w'}\nJ : Type w\nx\u271d\u00b3 : LinearOrder J\nx\u271d\u00b2 : SuccOrder J\nx\u271d\u00b9 : OrderBot J\nx\u271d : WellFoundedLT J\n\u22a2 W.IsStableUnderTransfiniteCompositionOfShape (Shrink.{w', w} J)",["infer_instance"]],["Analysis/NormedSpace/OperatorNorm/NormedSpace.lean",317,"\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\nE : Type u_4\nF : Type u_5\n\u03b9 : Type u_8\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u2074 : RingHomIsometric \u03c3\u2081\u2082\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : SeminormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \ud835\udd5c\u2082 F\nf : \u03b9 \u2192 E \u2192SL[\u03c3\u2081\u2082] F\ntfae_1_to_3 : EquicontinuousAt (DFunLike.coe \u2218 f) 0 \u2192 UniformEquicontinuous (DFunLike.coe \u2218 f)\ntfae_3_to_2 : UniformEquicontinuous (DFunLike.coe \u2218 f) \u2192 Equicontinuous (DFunLike.coe \u2218 f)\ntfae_2_to_1 : Equicontinuous (DFunLike.coe \u2218 f) \u2192 EquicontinuousAt (DFunLike.coe \u2218 f) 0\nC\u2081 C\u2082 : \u211d\nhC : C\u2081 \u2264 C\u2082\ni : \u03b9\nx : E\n\u22a2 C\u2081 * \u2016x\u2016 \u2264 C\u2082 * \u2016x\u2016",["gcongr"]],["Order/Antisymmetrization.lean",125,"\u03b1 : Type u_1\n\u03b2 : Type u_2\na b c d : \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : IsPreorder \u03b1 r\ninst\u271d : Inhabited \u03b1\n\u22a2 Inhabited (Quotient (AntisymmRel.setoid \u03b1 r))",["infer_instance"]],["Topology/Category/CompHausLike/Limits.lean",242,"P : TopCat \u2192 Prop\nX Y B : CompHausLike P\nf : X \u27f6 B\ng : Y \u27f6 B\ninst\u271d : HasExplicitPullback f g\nZ : CompHausLike P\na : Z \u27f6 X\nb : Z \u27f6 Y\nw : a \u226b f = b \u226b g\n\u22a2 Continuous fun z \u21a6 \u27e8((ConcreteCategory.hom a) z, (ConcreteCategory.hom b) z), \u22ef\u27e9",["fun_prop"]],["Analysis/Asymptotics/TVS.lean",148,"case refine_2\n\u03b1 : Type u_1\n\ud835\udd5c : Type u_3\nE : Type u_4\nF : Type u_5\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : TopologicalSpace F\ninst\u271d : Module \ud835\udd5c F\nl : Filter \u03b1\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\n\u03b9E : Sort u_7\n\u03b9F : Sort u_8\npE : \u03b9E \u2192 Prop\npF : \u03b9F \u2192 Prop\nsE : \u03b9E \u2192 Set E\nsF : \u03b9F \u2192 Set F\nhE : (\ud835\udcdd 0).HasBasis pE sE\nhF : (\ud835\udcdd 0).HasBasis pF sF\nx\u271d\u00b9 : \u03b9E\nx\u271d : pE x\u271d\u00b9\ns t : Set F\nhsub : s \u2286 t\nh : \u2200 (\u03b5 : \u211d\u22650), \u03b5 \u2260 0 \u2192 \u2200\u1da0 (x : \u03b1) in l, egauge \ud835\udd5c (sE x\u271d\u00b9) (f x) \u2264 \u2191\u03b5 * egauge \ud835\udd5c t (g x)\n\u03b5 : \u211d\u22650\nh\u03b5 : \u03b5 \u2260 0\nx : \u03b1\nhx : egauge \ud835\udd5c (sE x\u271d\u00b9) (f x) \u2264 \u2191\u03b5 * egauge \ud835\udd5c t (g x)\n\u22a2 \u2191\u03b5 * egauge \ud835\udd5c t (g x) \u2264 \u2191\u03b5 * egauge \ud835\udd5c s (g x)",["gcongr"]],["Analysis/Asymptotics/TVS.lean",154,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_3\nE : Type u_4\nF : Type u_5\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : TopologicalSpace F\ninst\u271d : Module \ud835\udd5c F\nl : Filter \u03b1\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nV\u2081 V\u2082 : Set F\nhV : V\u2081 \u2286 V\u2082\nhV\u2082 : \u2200 (\u03b5 : \u211d\u22650), \u03b5 \u2260 0 \u2192 \u2200\u1da0 (x : \u03b1) in l, egauge \ud835\udd5c U (f x) \u2264 \u2191\u03b5 * egauge \ud835\udd5c V\u2082 (g x)\n\u03b5 : \u211d\u22650\nh\u03b5 : \u03b5 \u2260 0\nx : \u03b1\nhx : egauge \ud835\udd5c U (f x) \u2264 \u2191\u03b5 * egauge \ud835\udd5c V\u2082 (g x)\n\u22a2 \u2191\u03b5 * egauge \ud835\udd5c V\u2082 (g x) \u2264 \u2191\u03b5 * egauge \ud835\udd5c V\u2081 (g x)",["gcongr"]],["Analysis/CStarAlgebra/Module/Defs.lean",272,"A : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NonUnitalCStarAlgebra A\ninst\u271d\u2076 : PartialOrder A\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u2102 E\ninst\u271d\u00b3 : SMul A\u1d50\u1d52\u1d56 E\ninst\u271d\u00b2 : Norm E\ninst\u271d\u00b9 : CStarModule A E\ninst\u271d : StarOrderedRing A\nv : E\ninstNACG : NormedAddCommGroup E := NormedAddCommGroup.ofCore \u22ef\ninstNS : NormedSpace \u2102 E := NormedSpace.ofCore \u22ef\nw : E\nhw : \u2016w\u2016 \u2264 1\n\u22a2 \u2016w\u2016 * \u2016v\u2016 \u2264 1 * \u2016v\u2016",["gcongr"]],["NumberTheory/Transcendental/Liouville/LiouvilleWith.lean",116,"p x : \u211d\nr : \u211a\nh : LiouvilleWith p x\nhr : r \u2260 0\nC : \u211d\n_hC\u2080 : 0 < C\nhC : \u2203\u1da0 (n : \u2115) in atTop, 1 \u2264 n \u2227 \u2203 m, x \u2260 \u2191m / \u2191n \u2227 |x - \u2191m / \u2191n| < C / \u2191n ^ p\nn : \u2115\n_hn : 1 \u2264 n\nm : \u2124\nhne : x \u2260 \u2191m / \u2191n\nhlt : |x - \u2191m / \u2191n| < C / \u2191n ^ p\nA : \u2191(r.num * m) / \u2191(r.den \u2022 id n) = \u2191m / \u2191n * \u2191r\n\u22a2 |x - \u2191m / \u2191n| * |\u2191r| < C / \u2191n ^ p * |\u2191r|",["gcongr","aesop"]],["Analysis/SpecialFunctions/PolarCoord.lean",76,"\u22a2 ContinuousOn\n    { toFun := fun q \u21a6 (\u221a(q.1 ^ 2 + q.2 ^ 2), (Complex.equivRealProd.symm q).arg),\n        invFun := fun p \u21a6 (p.1 * cos p.2, p.1 * sin p.2), source := {q | 0 < q.1} \u222a {q | q.2 \u2260 0},\n        target := Ioi 0 \u00d7\u02e2 Ioo (-\u03c0) \u03c0, map_source' := \u22ef, map_target' := \u22ef, left_inv' := \u22ef, right_inv' := \u22ef }.invFun\n    { toFun := fun q \u21a6 (\u221a(q.1 ^ 2 + q.2 ^ 2), (Complex.equivRealProd.symm q).arg),\n        invFun := fun p \u21a6 (p.1 * cos p.2, p.1 * sin p.2), source := {q | 0 < q.1} \u222a {q | q.2 \u2260 0},\n        target := Ioi 0 \u00d7\u02e2 Ioo (-\u03c0) \u03c0, map_source' := \u22ef, map_target' := \u22ef, left_inv' := \u22ef, right_inv' := \u22ef }.target",["fun_prop"]],["Analysis/SpecialFunctions/PolarCoord.lean",90,"\u22a2 Continuous fun x \u21a6 x.1 * sin x.2",["fun_prop"]],["Topology/UnitInterval.lean",162,"\u22a2 CompactSpace \u2191I",["infer_instance"]],["Data/Finset/Defs.lean",213,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Finset \u03b1\n\u22a2 IsTrans (Finset \u03b1) fun x1 x2 \u21a6 x1 \u2264 x2",["infer_instance"]],["Data/Finset/Defs.lean",216,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Finset \u03b1\n\u22a2 IsAntisymm (Finset \u03b1) fun x1 x2 \u21a6 x1 \u2264 x2",["infer_instance"]],["Data/Finset/Defs.lean",219,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Finset \u03b1\n\u22a2 IsIrrefl (Finset \u03b1) fun x1 x2 \u21a6 x1 < x2",["infer_instance"]],["Data/Finset/Defs.lean",222,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Finset \u03b1\n\u22a2 IsTrans (Finset \u03b1) fun x1 x2 \u21a6 x1 < x2",["infer_instance"]],["Data/Finset/Defs.lean",225,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Finset \u03b1\n\u22a2 IsAsymm (Finset \u03b1) fun x1 x2 \u21a6 x1 < x2",["infer_instance"]],["Data/Real/Pi/Irrational.lean",71,"\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\n\u22a2 Continuous f",["fun_prop"]],["Data/Real/Pi/Irrational.lean",72,"\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\n\u22a2 Continuous u\u2081'",["fun_prop"]],["Data/Real/Pi/Irrational.lean",73,"\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\nhu\u2081d : Continuous u\u2081'\n\u22a2 Continuous v\u2081'",["fun_prop"]],["Data/Real/Pi/Irrational.lean",74,"\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\nhu\u2081d : Continuous u\u2081'\nhv\u2081d : Continuous v\u2081'\n\u22a2 Continuous u\u2082'",["fun_prop"]],["Data/Real/Pi/Irrational.lean",75,"\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\nhu\u2081d : Continuous u\u2081'\nhv\u2081d : Continuous v\u2081'\nhu\u2082d : Continuous u\u2082'\n\u22a2 Continuous v\u2082'",["fun_prop"]],["Data/Real/Pi/Irrational.lean",110,"\u03b8 : \u211d\nn : \u2115\nf : \u211d \u2192 \u211d := fun x \u21a6 1 - x ^ 2\nu\u2081 : \u211d \u2192 \u211d := fun x \u21a6 f x ^ (n + 1)\nu\u2081' : \u211d \u2192 \u211d := fun x \u21a6 -(2 * (\u2191n + 1) * x * f x ^ n)\nv\u2081 : \u211d \u2192 \u211d := fun x \u21a6 sin (x * \u03b8)\nv\u2081' : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8) * \u03b8\nu\u2082 : \u211d \u2192 \u211d := fun x \u21a6 x * f x ^ n\nu\u2082' : \u211d \u2192 \u211d := fun x \u21a6 f x ^ n - 2 * \u2191n * x ^ 2 * f x ^ (n - 1)\nv\u2082 : \u211d \u2192 \u211d := fun x \u21a6 cos (x * \u03b8)\nv\u2082' : \u211d \u2192 \u211d := fun x \u21a6 -sin (x * \u03b8) * \u03b8\nhfd : Continuous f\nhu\u2081d : Continuous u\u2081'\nhv\u2081d : Continuous v\u2081'\nhu\u2082d : Continuous u\u2082'\nhv\u2082d : Continuous v\u2082'\nhu\u2081_eval_one : u\u2081 1 = 0\nhu\u2081_eval_neg_one : u\u2081 (-1) = 0\nt : u\u2082 1 * v\u2082 1 - u\u2082 (-1) * v\u2082 (-1) = 2 * (0 ^ n * cos \u03b8)\nhf : \u2200 (x : \u211d), HasDerivAt f (-2 * x) x\nhu\u2081 : \u2200 (x : \u211d), HasDerivAt u\u2081 (u\u2081' x) x\nhv\u2081 : \u2200 (x : \u211d), HasDerivAt v\u2081 (v\u2081' x) x\nhu\u2082 : \u2200 (x : \u211d), HasDerivAt u\u2082 (u\u2082' x) x\nhv\u2082 : \u2200 (x : \u211d), HasDerivAt v\u2082 (v\u2082' x) x\nthis : \u2200 (x : \u211d), u\u2082' x = (2 * \u2191n + 1) * f x ^ n - 2 * \u2191n * f x ^ (n - 1)\n\u22a2 Continuous v\u2082",["fun_prop"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",80,"X : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 : X\np : Path x\u2080 x\u2081\n\u22a2 Continuous fun x \u21a6 p \u27e8reflTransSymmAux x, \u22ef\u27e9",["fun_prop"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",138,"X : Type u\ninst\u271d : TopologicalSpace X\nx\u2080 x\u2081 : X\np : Path x\u2080 x\u2081\n\u22a2 Continuous fun t \u21a6 \u27e8transReflReparamAux t, \u22ef\u27e9",["fun_prop"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",192,"X : Type u\ninst\u271d : TopologicalSpace X\nx\u2080\u271d x\u2081\u271d x\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\n\u22a2 Continuous fun t \u21a6 \u27e8transAssocReparamAux t, \u22ef\u27e9",["fun_prop"]],["AlgebraicTopology/FundamentalGroupoid/Basic.lean",234,"X : Type u\ninst\u271d : TopologicalSpace X\nx\u2080\u271d x\u2081\u271d x\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nq : Path x\u2081 x\u2082\nr : Path x\u2082 x\u2083\n\u22a2 Continuous fun t \u21a6 \u27e8transAssocReparamAux t, \u22ef\u27e9",["fun_prop"]],["MeasureTheory/Measure/Map.lean",283,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm0 : MeasurableSpace \u03b1\nm1 : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : MeasurableEmbedding f\n\u03bc : Measure \u03b1\ns : Set \u03b2\nt : Set \u03b2 := f '' toMeasurable \u03bc (f \u207b\u00b9' s) \u222a (range f)\u1d9c\nhtm : MeasurableSet t\nhst : s \u2286 t\nhft : f \u207b\u00b9' t = toMeasurable \u03bc (f \u207b\u00b9' s)\n\u22a2 (map f \u03bc) s \u2264 (map f \u03bc) t",["gcongr"]],["CategoryTheory/Comma/Arrow.lean",209,"T : Type u\ninst\u271d\u00b2 : Category.{v, u} T\nX Y : T\nf : X \u27f6 Y\ng : Arrow T\nsq : mk f \u27f6 g\ninst\u271d\u00b9 : IsIso sq\ninst\u271d : IsIso f\n\u22a2 IsIso ((asIso sq).inv.left \u226b f \u226b (asIso sq).hom.right)",["infer_instance"]],["Combinatorics/SimpleGraph/Turan.lean",66,"V : Type u_1\ninst\u271d\u00b9 : Fintype V\nG : SimpleGraph V\ninst\u271d : DecidableRel G.Adj\nn r : \u2115\nH : SimpleGraph V\n\u22a2 DecidableRel fun v w \u21a6 \u2191v % r \u2260 \u2191w % r",["infer_instance"]],["Probability/Kernel/WithDensity.lean",168,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : Countable \u03b9\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e\nhf : \u2200 (i : \u03b9), Measurable (Function.uncurry (f i))\nh_sum_a : \u2200 (a : \u03b1), Summable fun n \u21a6 f n a\nh_sum : Summable fun n \u21a6 f n\na : \u03b1\ns : Set \u03b2\nhs : MeasurableSet s\nthis : Function.uncurry (\u2211' (n : \u03b9), f n) = \u2211' (n : \u03b9), Function.uncurry (f n)\n\u22a2 Measurable (\u2211' (n : \u03b9), Function.uncurry (f n))",["fun_prop"]],["Probability/Kernel/WithDensity.lean",190,"case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsFiniteKernel \u03ba\nB : \u211d\u22650\u221e\nhB_top : B \u2260 \u22a4\nhf_B : \u2200 (a : \u03b1) (b : \u03b2), f a b \u2264 B\nhf : \u00acMeasurable (Function.uncurry f)\n\u22a2 IsFiniteKernel 0",["infer_instance"]],["Probability/Kernel/WithDensity.lean",201,"case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsFiniteKernel \u03ba\nhf_ne_top : \u2200 (a : \u03b1) (b : \u03b2), f a b \u2260 \u22a4\nhf : \u00acMeasurable (Function.uncurry f)\n\u22a2 IsSFiniteKernel 0",["infer_instance"]],["Probability/Kernel/WithDensity.lean",242,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsFiniteKernel \u03ba\nhf_ne_top : \u2200 (a : \u03b1) (b : \u03b2), f a b \u2260 \u22a4\nhf : Measurable (Function.uncurry f)\nfs : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e := fun n a b \u21a6 f a b \u2293 (\u2191n + 1) - f a b \u2293 \u2191n\nh_le : \u2200 (a : \u03b1) (b : \u03b2) (n : \u2115), \u2308(f a b).toReal\u2309\u208a \u2264 n \u2192 f a b \u2264 \u2191n\nh_zero : \u2200 (a : \u03b1) (b : \u03b2) (n : \u2115), \u2308(f a b).toReal\u2309\u208a \u2264 n \u2192 fs n a b = 0\nhf_eq_tsum : f = \u2211' (n : \u2115), fs n\nn : \u2115\nthis\u271d this : IsFiniteKernel (\u03ba.withDensity (fs n))\n\u22a2 IsSFiniteKernel (\u03ba.withDensity (fs n))",["infer_instance"]],["Combinatorics/SimpleGraph/Triangle/Basic.lean",191,"\u03b1 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\nG : SimpleGraph \u03b1\n\u03b5 \u03b4 : \ud835\udd5c\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableRel G.Adj\nh\u03b5 : G.FarFromTriangleFree \u03b5\nh : \u03b4 \u2264 \u03b5\n\u22a2 \u03b4 * \u2191(Fintype.card \u03b1 ^ 2) \u2264 \u03b5 * \u2191(Fintype.card \u03b1 ^ 2)",["gcongr"]],["Probability/Moments/ComplexMGF.lean",79,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nhX : AEMeasurable X \u03bc\nt : \u2102\n\u22a2 AEMeasurable (fun \u03c9 \u21a6 cexp (t * \u2191(id \u03c9))) (Measure.map X \u03bc)",["fun_prop"]],["Probability/Moments/ComplexMGF.lean",124,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz\u271d : \u2102\nhz : z\u271d.re \u2208 interior (integrableExpSet X \u03bc)\nn : \u2115\nhX : AEMeasurable X \u03bc\nl u : \u211d\nhlu : z\u271d.re \u2208 Set.Ioo l u\nh_subset : Set.Ioo l u \u2286 integrableExpSet X \u03bc\nt : \u211d := ((z\u271d.re - l) \u2293 (u - z\u271d.re)) / 2\nh_pos : 0 < (z\u271d.re - l) \u2293 (u - z\u271d.re)\nht : 0 < t\nz : \u2102\n\u22a2 AEMeasurable ((fun z \u03c9 \u21a6 \u2191(X \u03c9) ^ n * cexp (z * \u2191(X \u03c9))) z) \u03bc",["fun_prop"]],["Probability/Moments/ComplexMGF.lean",126,"\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\nz : \u2102\nhz : z.re \u2208 interior (integrableExpSet X \u03bc)\nn : \u2115\nhX : AEMeasurable X \u03bc\nl u : \u211d\nhlu : z.re \u2208 Set.Ioo l u\nh_subset : Set.Ioo l u \u2286 integrableExpSet X \u03bc\nt : \u211d := ((z.re - l) \u2293 (u - z.re)) / 2\nh_pos : 0 < (z.re - l) \u2293 (u - z.re)\nht : 0 < t\n\u22a2 AEMeasurable ((fun z \u03c9 \u21a6 \u2191(X \u03c9) ^ (n + 1) * cexp (z * \u2191(X \u03c9))) z) \u03bc",["fun_prop"]],["CategoryTheory/Monoidal/Center.lean",113,"C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b9 : MonoidalCategory C\nX Y : Center C\nf : X \u27f6 Y\ninst\u271d : IsIso f.f\n\u22a2 IsIso (isoMk f).hom",["infer_instance"]],["CategoryTheory/Monoidal/Center.lean",322,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : MonoidalCategory C\nA\u271d B\u271d : Center C\nf : A\u271d \u27f6 B\u271d\ni : IsIso f.f\n\u22a2 IsIso (isoMk f).hom",["infer_instance"]],["Analysis/Normed/Group/SemiNormedGrp/Kernels.lean",80,"\u22a2 HasCokernels SemiNormedGrp\u2081",["infer_instance"]],["Analysis/Normed/Group/SemiNormedGrp/Kernels.lean",167,"\u22a2 HasCokernels SemiNormedGrp",["infer_instance"]],["Order/Filter/CountableInter.lean",235,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\ninst\u271d : CountableInterFilter l\ng : Set (Set \u03b1)\n\u22a2 CountableInterFilter (ofCountableInter (CountableGenerateSets g) \u22ef \u22ef)",["infer_instance"]],["Combinatorics/Additive/PluenneckeRuzsa.lean",226,"G : Type u_1\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : CommGroup G\nA B : Finset G\nhAB : \u2200 A' \u2286 A, #(A * B) * #A' \u2264 #(A' * B) * #A\nhA : A.Nonempty\nn : \u2115\nih : \u2191(#(A * B ^ n)) \u2264 (\u2191(#(A * B)) / \u2191(#A)) ^ n * \u2191(#A)\n\u22a2 \u2191(#(A * B)) * \u2191(#(A * B ^ n)) \u2264 \u2191(#(A * B)) * ((\u2191(#(A * B)) / \u2191(#A)) ^ n * \u2191(#A))",["gcongr"]],["Analysis/Complex/AbelLimit.lean",77,"s x y : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x < 1 / (1 + s ^ 2)\nhy : |y| < s * x\n\u22a2 (1 - x) ^ 2 + |y| ^ 2 \u2264 (1 - x) ^ 2 + (s * x) ^ 2",["gcongr"]],["Analysis/Complex/AbelLimit.lean",79,"s x y : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x < 1 / (1 + s ^ 2)\nhy : |y| < s * x\n\u22a2 1 - 2 * x + (1 + s ^ 2) * x * x \u2264 1 - 2 * x + (1 + s ^ 2) * (1 / (1 + s ^ 2)) * x",["gcongr"]],["Analysis/Complex/AbelLimit.lean",87,"s x y : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x < 1 / (1 + s ^ 2)\nhy : |y| < s * x\nH : \u221a((1 - x) ^ 2 + y ^ 2) \u2264 1 - x / 2\n\u22a2 x ^ 2 + |y| ^ 2 \u2264 x ^ 2 + (s * x) ^ 2",["gcongr"]],["Analysis/Analytic/Uniqueness.lean",79,"\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ny : E\nc : \u211d\nc_pos : c > 0\nt : Set E\nt_open : IsOpen t\n\u03b4 : \u211d\n\u03b4_pos : \u03b4 > 0\n\u03b4\u03b5 : Metric.ball 0 \u03b4 \u2286 t\nn : \u2115\np : ContinuousMultilinearMap \ud835\udd5c (fun i \u21a6 E) F\nht : \u2200 y \u2208 t, \u2016p fun x \u21a6 y\u2016 \u2264 c * \u2016\u2016y\u2016 ^ (n + 1 + 1)\u2016\nhy : 0 < \u2016y\u2016\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\nh\u2080 : 0 < c * \u2016y\u2016 ^ (n.succ + 1)\nk : \ud835\udd5c\nk_pos : 0 < \u2016k\u2016\nk_norm : \u2016k\u2016 < \u03b4 * \u2016y\u2016\u207b\u00b9 \u2293 \u03b5 * (c * \u2016y\u2016 ^ (n.succ + 1))\u207b\u00b9\nh\u2081 : \u2016k \u2022 y\u2016 < \u03b4\nh\u2082 : \u2016p fun x \u21a6 k \u2022 y\u2016 \u2264 \u2016k\u2016 ^ n.succ * (\u2016k\u2016 * (c * \u2016y\u2016 ^ (n.succ + 1)))\nh\u2083 : \u2016k\u2016 * (c * \u2016y\u2016 ^ (n.succ + 1)) < \u03b5\n\u22a2 \u2016k\u207b\u00b9 ^ n.succ\u2016 * \u2016p fun x \u21a6 k \u2022 y\u2016 \u2264 \u2016k\u207b\u00b9 ^ n.succ\u2016 * (\u2016k\u2016 ^ n.succ * (\u2016k\u2016 * (c * \u2016y\u2016 ^ (n.succ + 1))))",["gcongr"]],["CategoryTheory/Sites/Equivalence.lean",69,"C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nK : GrothendieckTopology D\ne : C \u224c D\nG : D \u2964 C\nA : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} A\nthis : J = e.functor.inducedTopology (e.inverse.inducedTopology J)\n\u22a2 IsDenseSubsite (e.functor.inducedTopology (e.inverse.inducedTopology J)) (e.inverse.inducedTopology J) e.functor",["infer_instance"]],["CategoryTheory/Sites/Equivalence.lean",80,"C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nK : GrothendieckTopology D\ne : C \u224c D\nG : D \u2964 C\nA : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} A\ninst\u271d : IsDenseSubsite K J e.inverse\n\u22a2 IsDenseSubsite J (e.inverse.inducedTopology J) e.functor",["infer_instance"]],["Analysis/SpecialFunctions/Complex/LogBounds.lean",32,"z : \u2102\nhz : 1 + z \u2208 slitPlane\n\u22a2 ContinuousOn (fun t \u21a6 1 + t \u2022 z) (Set.Icc 0 1)",["fun_prop"]],["Analysis/SpecialFunctions/Complex/LogBounds.lean",127,"n : \u2115\nz : \u2102\nhz : \u2016z\u2016 < 1\nthis : ContinuousOn (fun t \u21a6 (1 + t \u2022 z)\u207b\u00b9) (Set.uIcc 0 1)\n\u22a2 ContinuousOn (fun t \u21a6 t ^ n * \u2016(1 + \u2191t * z)\u207b\u00b9\u2016) (Set.uIcc 0 1)",["fun_prop"]],["Analysis/Normed/Unbundled/SeminormFromConst.lean",134,"R : Type ?u.20102\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx y : R\nn : \u2115\nh_add : f ((x + y) * c ^ n) \u2264 f (x * c ^ n) + f (y * c ^ n)\n\u22a2 f ((x + y) * c ^ n) / f c ^ n \u2264 (f (x * c ^ n) + f (y * c ^ n)) / f c ^ n",["gcongr"]],["CategoryTheory/Galois/EssSurj.lean",89,"G : Type u_1\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : IsTopologicalGroup G\ninst\u271d\u00b3 : CompactSpace G\nX : Action FintypeCat G\ninst\u271d\u00b2 : TopologicalSpace X.V.carrier\ninst\u271d\u00b9 : DiscreteTopology X.V.carrier\ninst\u271d : ContinuousSMul G X.V.carrier\n\u03b9 : Type\nhf : Finite \u03b9\nf : \u03b9 \u2192 Action FintypeCat G\nu : \u2210 f \u2245 X\nhc : \u2200 (i : \u03b9), IsConnected (f i)\nthis\u271d\u00b9 : (i : \u03b9) \u2192 TopologicalSpace (f i).V.carrier := fun i \u21a6 \u22a5\nthis\u271d : \u2200 (i : \u03b9), DiscreteTopology (f i).V.carrier\ni : \u03b9\nr : f i \u27f6 X := Sigma.\u03b9 f i \u226b u.hom\nr'' : G \u00d7 (f i).V.carrier \u2192 G \u00d7 X.V.carrier := fun p \u21a6 (p.1, r.hom p.2)\nq : G \u00d7 X.V.carrier \u2192 X.V.carrier := fun p \u21a6 X.\u03c1 p.1 p.2\nq' : G \u00d7 (f i).V.carrier \u2192 (f i).V.carrier := fun p \u21a6 (f i).\u03c1 p.1 p.2\nheq : q \u2218 r'' = r.hom \u2218 q'\nhrinj : Function.Injective r.hom\nt\u2081 : TopologicalSpace (G \u00d7 (f i).V.carrier) := inferInstance\nthis : TopologicalSpace.induced r.hom inferInstance = \u22a5\n\u22a2 Continuous r''",["fun_prop"]],["Topology/MetricSpace/Holder.lean",101,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace X\ninst\u271d : PseudoEMetricSpace Y\nC r : \u211d\u22650\nf : X \u2192 Y\ns : Set X\nh : HolderOnWith C r f s\nx y : X\nhx : x \u2208 s\nhy : y \u2208 s\nd : \u211d\u22650\u221e\nhd : edist x y \u2264 d\n\u22a2 \u2191C * edist x y ^ \u2191r \u2264 \u2191C * d ^ \u2191r",["gcongr"]],["NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean",169,"p q : \u2115\nhp0 : \u00acp = 0\nx : \u2115\nhx : x \u2208 Ico 1 (p / 2).succ\nthis : x \u2264 p / 2\n\u22a2 x * q / p \u2264 p / 2 * q / p",["gcongr"]],["MeasureTheory/Integral/TorusIntegral.lean",130,"case refine_1\nn : \u2115\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : (Fin n \u2192 \u2102) \u2192 E\nc : Fin n \u2192 \u2102\nR : Fin n \u2192 \u211d\ninst\u271d : NormedSpace \u2102 E\nhf : TorusIntegrable f c R\n\u22a2 Continuous fun \u03b8 \u21a6 \u220f i : Fin n, \u2191(R i) * cexp (\u2191(\u03b8 i) * I) * I",["fun_prop"]],["Topology/Homotopy/Path.lean",190,"X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np : Path x\u2080 x\u2081\nf : \u2191I \u2192 \u2191I\nhf : Continuous f\nhf\u2080 : f 0 = 0\nhf\u2081 : f 1 = 1\n\u22a2 Continuous fun x \u21a6 p \u27e8\u2191(\u03c3 x.1) * \u2191x.2 + \u2191x.1 * \u2191(f x.2), \u22ef\u27e9",["fun_prop"]],["NumberTheory/FLT/Polynomial.lean",64,"p q r a b c : \u2115\nhp : 0 < p\nhq : 0 < q\nhr : 0 < r\nhineq : q * r + r * p + p * q \u2264 p * q * r\nhpa : p * a < a + b + c\nhqb : q * b < a + b + c\nhrc : r * c < a + b + c\n\u22a2 p * a * (q * r) + q * b * (r * p) + r * c * (p * q) <\n    (a + b + c) * (q * r) + (a + b + c) * (r * p) + (a + b + c) * (p * q)",["gcongr"]],["NumberTheory/FLT/Polynomial.lean",66,"p q r a b c : \u2115\nhp : 0 < p\nhq : 0 < q\nhr : 0 < r\nhineq : q * r + r * p + p * q \u2264 p * q * r\nhpa : p * a < a + b + c\nhqb : q * b < a + b + c\nhrc : r * c < a + b + c\n\u22a2 (q * r + r * p + p * q) * (a + b + c) \u2264 p * q * r * (a + b + c)",["gcongr"]],["Topology/Algebra/MulAction.lean",89,"R : Type u_5\n\u03b1 : Type u_6\n\u03b2 : Type u_7\nF : Type u_8\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b2\ninst\u271d\u2074 : Module R \u03b1\ninst\u271d\u00b3 : Module R \u03b2\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : LinearMapClass F R \u03b1 \u03b2\nt\u03b2 : TopologicalSpace \u03b2\ninst\u271d : ContinuousSMul R \u03b2\nf : F\nt\u03b1 : TopologicalSpace \u03b1 := TopologicalSpace.induced (\u21d1f) t\u03b2\n\u22a2 Continuous fun x \u21a6 x.1 \u2022 f x.2",["fun_prop"]],["Probability/Kernel/Composition/Prod.lean",182,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\n\u03b7 : Kernel \u03b3 \u03b4\ninst\u271d\u00b9 : IsSFiniteKernel \u03ba\ninst\u271d : IsSFiniteKernel \u03b7\nx : \u03b1 \u00d7 \u03b3\nf : \u03b4 \u00d7 \u03b2 \u2192 \u211d\u22650\u221e\nhf : Measurable f\n\u22a2 AEMeasurable (Function.uncurry fun c b \u21a6 f (b, c)) ((\u03ba x.1).prod (\u03b7 x.2))",["fun_prop"]],["Probability/Kernel/Composition/Prod.lean",191,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03b3 : Type u_4\nm\u03b3 : MeasurableSpace \u03b3\n\u03ba : Kernel \u03b1 \u03b2\n\u03b7 : Kernel \u03b1 \u03b3\ninst\u271d\u00b9 : IsSFiniteKernel \u03ba\ninst\u271d : IsSFiniteKernel \u03b7\nx : \u03b1\nf : \u03b3 \u00d7 \u03b2 \u2192 \u211d\u22650\u221e\nhf : Measurable f\n\u22a2 AEMeasurable (Function.uncurry fun c b \u21a6 f (b, c).swap) ((\u03b7 x).prod (\u03ba x))",["fun_prop"]],["Probability/Kernel/Composition/Prod.lean",130,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d\u00b9 : IsMarkovKernel \u03ba\n\u03b7 : Kernel \u03b1 \u03b3\ninst\u271d : IsMarkovKernel \u03b7\n\u22a2 IsMarkovKernel (\u03ba \u2297\u2096 (Kernel.prodMkLeft \u03b2 \u03b7).swapLeft)",["infer_instance"]],["Probability/Kernel/Composition/Prod.lean",138,"case inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\nh\u271d : IsZeroOrMarkovKernel \u03ba\n\u03b7 : Kernel \u03b1 \u03b3\ninst\u271d : IsZeroOrMarkovKernel \u03b7\nh : IsMarkovKernel \u03ba\nh' : IsMarkovKernel \u03b7\n\u22a2 IsZeroOrMarkovKernel (\u03ba \u00d7\u2096 \u03b7)",["infer_instance"]],["Probability/Kernel/Composition/Prod.lean",141,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d\u00b9 : IsFiniteKernel \u03ba\n\u03b7 : Kernel \u03b1 \u03b3\ninst\u271d : IsFiniteKernel \u03b7\n\u22a2 IsFiniteKernel (\u03ba \u2297\u2096 (Kernel.prodMkLeft \u03b2 \u03b7).swapLeft)",["infer_instance"]],["Probability/Kernel/Composition/Prod.lean",144,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3\u271d : MeasurableSpace \u03b3\u271d\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nm\u03b3 : MeasurableSpace \u03b3\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\n\u03b7 : Kernel \u03b1 \u03b3\n\u22a2 IsSFiniteKernel (\u03ba \u2297\u2096 (Kernel.prodMkLeft \u03b2 \u03b7).swapLeft)",["infer_instance"]],["RingTheory/Polynomial/Dickson.lean",209,"p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nK : Type := FractionRing (ZMod p)[X]\nf : ZMod p \u2192+* K := (algebraMap (ZMod p)[X] (FractionRing (ZMod p)[X])).comp C\n\u22a2 CharP (ZMod p) p",["infer_instance"]],["Topology/Category/TopCat/Limits/Basic.lean",148,"J\u271d : Type v\ninst\u271d\u00b2 : Category.{w, v} J\u271d\nF\u271d : J\u271d \u2964 TopCat\nJ : Type v\ninst\u271d\u00b9 : Category.{u_1, v} J\ninst\u271d : Small.{u, v} J\nF : J \u2964 TopCat\n\u22a2 Small.{u, max u v} \u2191(F \u22d9 forget).sections",["infer_instance"]],["Topology/Category/TopCat/Limits/Basic.lean",273,"J\u271d : Type v\ninst\u271d\u00b2 : Category.{w, v} J\u271d\nF\u271d : J\u271d \u2964 TopCat\nJ : Type v\ninst\u271d\u00b9 : Category.{u_1, v} J\ninst\u271d : Small.{u, v} J\nF : J \u2964 TopCat\n\u22a2 Small.{u, max u v} (Types.Quot (F \u22d9 forget))",["infer_instance"]],["Analysis/InnerProductSpace/OfNorm.lean",104,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf g : \u211d \u2192 E\nhf : Continuous f\nhg : Continuous g\n\u22a2 Continuous fun x \u21a6\n    4\u207b\u00b9 *\n      (\ud835\udcda \u2016f x + g x\u2016 * \ud835\udcda \u2016f x + g x\u2016 - \ud835\udcda \u2016f x - g x\u2016 * \ud835\udcda \u2016f x - g x\u2016 + I * \ud835\udcda \u2016I \u2022 f x + g x\u2016 * \ud835\udcda \u2016I \u2022 f x + g x\u2016 -\n        I * \ud835\udcda \u2016I \u2022 f x - g x\u2016 * \ud835\udcda \u2016I \u2022 f x - g x\u2016)",["fun_prop"]],["Analysis/InnerProductSpace/OfNorm.lean",256,"case intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : InnerProductSpaceable E\ninst\u271d : NormedSpace \u211d E\nval\u271d : InnerProductSpace \u211d E\n\u22a2 UniformConvexSpace E",["infer_instance"]],["RingTheory/PiTensorProduct.lean",206,"\u03b9 : Type u_1\nR' : Type u_2\nR : Type u_3\nA : \u03b9 \u2192 Type u_4\ninst\u271d\u2078 : CommSemiring R'\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : (i : \u03b9) \u2192 Semiring (A i)\ninst\u271d\u2075 : Algebra R' R\ninst\u271d\u2074 : (i : \u03b9) \u2192 Algebra R (A i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Algebra R' (A i)\ninst\u271d\u00b2 : \u2200 (i : \u03b9), IsScalarTower R' R (A i)\nS : Type u_5\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Algebra R S\nf : MultilinearMap R A S\none : f 1 = 1\nmul : \u2200 (x y : (i : \u03b9) \u2192 A i), f (x * y) = f x * f y\n\u22a2 (LinearMap.mul R (\u2a02[R] (i : \u03b9), A i)).compr\u2082 (lift f) = (LinearMap.mul R S \u2218\u2097 lift f).compl\u2082 (lift f)",["aesop","infer_instance"]],["Analysis/Normed/Field/Lemmas.lean",127,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d : NormedDivisionRing \u03b1\na r : \u03b1\nr0 : r \u2260 0\nr0' : 0 < \u2016r\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\n\u03b5r : \u03b5 < \u2016r\u2016\ne : \u03b1\nhe : \u03b5 < \u2016e\u2016\ne0 : e \u2260 0\n\u22a2 \u2016r - e\u2016 / \u2016r\u2016 / \u2016e\u2016 \u2264 \u2016r - e\u2016 / \u2016r\u2016 / \u03b5",["gcongr"]],["Topology/Category/Stonean/Basic.lean",244,"case mp\nX : CompHaus\nh : Projective X\n\u22a2 ExtremallyDisconnected \u2191X.toStonean.toTop",["infer_instance"]],["CategoryTheory/FiberedCategory/BasedCategory.lean",158,"\ud835\udcae : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} \ud835\udcae\n\ud835\udcb3 : BasedCategory \ud835\udcae\n\ud835\udcb4 : BasedCategory \ud835\udcae\nF G : \ud835\udcb3 \u2964\u1d47 \ud835\udcb4\n\u03b1 : BasedNatTrans F G\na : \ud835\udcb3.obj\n\u22a2 \ud835\udcb4.p.IsHomLift (\ud835\udfd9 (\ud835\udcb3.p.obj a)) (\u03b1.app a)",["infer_instance"]],["CategoryTheory/FiberedCategory/BasedCategory.lean",176,"\ud835\udcae : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} \ud835\udcae\n\ud835\udcb3 : BasedCategory \ud835\udcae\n\ud835\udcb4 : BasedCategory \ud835\udcae\nF G H : \ud835\udcb3 \u2964\u1d47 \ud835\udcb4\n\u03b1 : BasedNatTrans F G\n\u03b2 : BasedNatTrans G H\na : \ud835\udcb3.obj\n\u22a2 \ud835\udcb4.p.IsHomLift (\ud835\udfd9 (\ud835\udcb3.p.obj a)) (\u03b1.app a \u226b \u03b2.app a)",["infer_instance"]],["CategoryTheory/FiberedCategory/BasedCategory.lean",206,"\ud835\udcae : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} \ud835\udcae\n\ud835\udcb3 : BasedCategory \ud835\udcae\n\ud835\udcb4 : BasedCategory \ud835\udcae\nF G : \ud835\udcb3 \u2964\u1d47 \ud835\udcb4\n\u03b1 : F \u27f6 G\ninst\u271d : IsIso \u03b1\n\u22a2 IsIso ((forgetful \ud835\udcb3 \ud835\udcb4).map \u03b1)",["infer_instance"]],["Order/Filter/AtTopBot/Archimedean.lean",147,"\u03b1 : Type u_1\nR : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 R\nr : R\ninst\u271d\u00b9 : LinearOrderedSemiring R\ninst\u271d : Archimedean R\nhr : 0 < r\nhf : Tendsto f l atTop\nb : R\nn : \u2115\nhn : 1 \u2264 r * \u2191n\nx : \u03b1\nhx : \u2191n * (b \u2294 0) \u2264 f x\n\u22a2 1 * (b \u2294 0) \u2264 r * \u2191n * (b \u2294 0)",["gcongr"]],["Order/Filter/AtTopBot/Archimedean.lean",149,"\u03b1 : Type u_1\nR : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 R\nr : R\ninst\u271d\u00b9 : LinearOrderedSemiring R\ninst\u271d : Archimedean R\nhr : 0 < r\nhf : Tendsto f l atTop\nb : R\nn : \u2115\nhn : 1 \u2264 r * \u2191n\nx : \u03b1\nhx : \u2191n * (b \u2294 0) \u2264 f x\n\u22a2 r * (\u2191n * (b \u2294 0)) \u2264 r * f x",["gcongr"]],["Order/Filter/AtTopBot/Archimedean.lean",165,"\u03b1 : Type u_1\nR : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 R\nr : R\ninst\u271d\u00b9 : LinearOrderedSemiring R\ninst\u271d : Archimedean R\nhr : 0 < r\nhf : Tendsto f l atTop\nb : R\nn : \u2115\nhn : 1 \u2264 n \u2022 r\nhn' : 1 \u2264 \u2191n * r\nx : \u03b1\nhx : (b \u2294 0) * \u2191n \u2264 f x\n\u22a2 (b \u2294 0) * 1 \u2264 (b \u2294 0) * (\u2191n * r)",["gcongr"]],["Order/Filter/AtTopBot/Archimedean.lean",167,"\u03b1 : Type u_1\nR : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 R\nr : R\ninst\u271d\u00b9 : LinearOrderedSemiring R\ninst\u271d : Archimedean R\nhr : 0 < r\nhf : Tendsto f l atTop\nb : R\nn : \u2115\nhn : 1 \u2264 n \u2022 r\nhn' : 1 \u2264 \u2191n * r\nx : \u03b1\nhx : (b \u2294 0) * \u2191n \u2264 f x\n\u22a2 (b \u2294 0) * \u2191n * r \u2264 f x * r",["gcongr"]],["AlgebraicTopology/SimplicialSet/Coskeletal.lean",235,"C : Type u\ninst\u271d : Category.{v, u} C\n\u22a2 SimplicialObject.IsCoskeletal (nerve C) 2",["infer_instance"]],["Topology/MetricSpace/Algebra.lean",147,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : PseudoMetricSpace \u03b2\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : Zero \u03b2\ninst\u271d\u00b9 : SMul \u03b1 \u03b2\ninst\u271d : IsBoundedSMul \u03b1 \u03b2\na : \u03b1\nb : \u03b2\n\u03b5 : \u211d\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\n\u03b40 : \u03b4 > 0\nh\u03b4\u03b5 : \u03b4 * (\u03b4 + dist b 0) + dist a 0 * \u03b4 < \u03b5\nx\u271d : \u03b1 \u00d7 \u03b2\na' : \u03b1\nb' : \u03b2\nhab' : dist (a', b') (a, b) < \u03b4\nha : dist (a', b').1 (a, b).1 < \u03b4\nhb : dist (a', b').2 (a, b).2 < \u03b4\nthis : dist b' 0 \u2264 \u03b4 + dist b 0\n\u22a2 dist a' a * dist b' 0 + dist a 0 * dist b' b \u2264 \u03b4 * (\u03b4 + dist b 0) + dist a 0 * \u03b4",["gcongr"]],["Topology/MetricSpace/Algebra.lean",136,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : PseudoMetricSpace \u03b1\ninst\u271d\u2074 : PseudoMetricSpace \u03b2\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : Zero \u03b2\ninst\u271d\u00b9 : SMul \u03b1 \u03b2\ninst\u271d : IsBoundedSMul \u03b1 \u03b2\na : \u03b1\nb : \u03b2\n\u03b5 : \u211d\n\u03b50 : \u03b5 > 0\n\u22a2 Continuous fun \u03b4 \u21a6 \u03b4 * (\u03b4 + dist b 0) + dist a 0 * \u03b4",["fun_prop"]],["InformationTheory/KullbackLeibler/Basic.lean",119,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nh\u03bc\u03bd : \u03bc \u226a \u03bd\n\u22a2 Measurable fun x \u21a6 klFun (\u03bc.rnDeriv \u03bd x).toReal",["fun_prop"]],["Analysis/Normed/Order/UpperLower.lean",212,"\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nhs : IsClosed s\nhs' : BddAbove s\nval\u271d : Fintype \u03b9\nf : \u2115 \u2192 \u03b9 \u2192 \u211d\nx : \u03b9 \u2192 \u211d\nhx : Filter.Tendsto f Filter.atTop (nhds x)\ng : \u2115 \u2192 \u03b9 \u2192 \u211d\nhg : \u2200 (n : \u2115), g n \u2208 s\nhfg : \u2200 (n : \u2115), f n \u2264 g n\n\u22a2 BoundedGENhdsClass \u211d",["infer_instance"]],["Analysis/Meromorphic/NormalFormAt.lean",57,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nn : \u2124\ng : \ud835\udd5c \u2192 E\nh\u2081g : AnalyticAt \ud835\udd5c g x\nh\u2082g : g x \u2260 0\nh\u2083g : f =\u1da0[\ud835\udcdd x] (fun x_1 \u21a6 x_1 - x) ^ n \u2022 g\n\u22a2 MeromorphicAt ((fun x_1 \u21a6 x_1 - x) ^ n \u2022 g) x",["fun_prop"]],["Analysis/Meromorphic/NormalFormAt.lean",200,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nhf : MeromorphicAt f x\nn : \u2124\nhn : \u2191n = hf.order\ng : \ud835\udd5c \u2192 E\nh\u2081g : AnalyticAt \ud835\udd5c g x\nh\u2082g : g x \u2260 0\nh\u2083g : \u2200\u1da0 (z : \ud835\udd5c) in \ud835\udcdd[\u2260] x, f z = (z - x) ^ n \u2022 g z\nh\u2083f : n = 0\nh\u2081G : AnalyticAt \ud835\udd5c (Classical.choose \u22ef) x\nleft\u271d : Classical.choose \u22ef x \u2260 0\nh\u2083G : \u2200\u1da0 (z : \ud835\udd5c) in \ud835\udcdd[\u2260] x, f z = (z - x) ^ 0 \u2022 Classical.choose \u22ef z\n\u22a2 AnalyticAt \ud835\udd5c (fun {x} \u21a6 0 ^ n \u2022 g x) x",["fun_prop","aesop"]],["SetTheory/Game/Short.lean",213,"x : PGame\ninst\u271d : x.Short\n\u22a2 (x + x).Short",["infer_instance"]],["SetTheory/Game/Short.lean",258,"\u22a2 Short 0",["infer_instance"]],["SetTheory/Game/Short.lean",260,"\u22a2 Short 1",["infer_instance"]],["SetTheory/Game/Short.lean",262,"\u22a2 Short 2",["infer_instance"]],["SetTheory/Game/Short.lean",264,"\u22a2 (-2).Short",["infer_instance"]],["SetTheory/Game/Short.lean",266,"\u22a2 (ofLists [0] [1]).Short",["infer_instance"]],["SetTheory/Game/Short.lean",268,"\u22a2 (ofLists [-2, -1] [1]).Short",["infer_instance"]],["SetTheory/Game/Short.lean",270,"\u22a2 (0 + 0).Short",["infer_instance"]],["SetTheory/Game/Short.lean",272,"\u22a2 Decidable (1 \u2264 1)",["infer_instance"]],["Topology/Homotopy/HSpaces.lean",83,"X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : HSpace X\ninst\u271d : HSpace Y\nG : \u2191I \u00d7 X \u00d7 Y \u2192 X \u00d7 Y := fun p \u21a6 (eHmul (p.1, p.2.1), eHmul (p.1, p.2.2))\n\u22a2 Continuous G",["fun_prop"]],["Topology/Homotopy/HSpaces.lean",94,"X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : HSpace X\ninst\u271d : HSpace Y\nG : \u2191I \u00d7 X \u00d7 Y \u2192 X \u00d7 Y := fun p \u21a6 (hmulE (p.1, p.2.1), hmulE (p.1, p.2.2))\n\u22a2 Continuous G",["fun_prop"]],["Topology/Homotopy/HSpaces.lean",191,"X : Type u\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b8 : \u2191I\n\u03b3 : Path x y\n\u22a2 Continuous fun t \u21a6 \u03b3 (qRight (t, \u03b8))",["fun_prop"]],["Data/PFunctor/Multivariate/W.lean",113,"n : \u2115\nP : MvPFunctor.{u} (n + 1)\n\u22a2 MvFunctor fun \u03b1 \u21a6 \u2191P.wp \u03b1",["infer_instance"]],["Algebra/Order/CauSeq/BigOperators.lean",120,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nha : IsCauSeq abs fun m \u21a6 \u2211 n \u2208 range m, abv (f n)\nhb : IsCauSeq abv fun m \u21a6 \u2211 n \u2208 range m, g n\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\nP : \u03b1\nhP : \u2200 (i : \u2115), |\u2211 n \u2208 range i, abv (f n)| < P\nQ : \u03b1\nhQ : \u2200 (i : \u2115), abv (\u2211 n \u2208 range i, g n) < Q\nhP0 : 0 < P\nhP\u03b50 : 0 < \u03b5 / (2 * P)\nN : \u2115\nhN : \u2200 j \u2265 N, \u2200 k \u2265 N, abv (\u2211 n \u2208 range j, g n - \u2211 n \u2208 range k, g n) < \u03b5 / (2 * P)\nhQ\u03b50 : 0 < \u03b5 / (4 * Q)\nM : \u2115\nhM : \u2200 j \u2265 M, \u2200 k \u2265 M, |\u2211 n \u2208 range j, abv (f n) - \u2211 n \u2208 range k, abv (f n)| < \u03b5 / (4 * Q)\nK : \u2115\nhK : K \u2265 2 * (N \u2294 M + 1)\nh\u2081 : \u2211 m \u2208 range K, \u2211 k \u2208 range (m + 1), f k * g (m - k) = \u2211 m \u2208 range K, \u2211 n \u2208 range (K - m), f m * g n\nh\u2082 : (fun i \u21a6 \u2211 k \u2208 range (K - i), f i * g k) = fun i \u21a6 f i * \u2211 k \u2208 range (K - i), g k\nh\u2083 :\n  \u2211 i \u2208 range K, f i * \u2211 k \u2208 range (K - i), g k =\n    \u2211 i \u2208 range K, f i * (\u2211 k \u2208 range (K - i), g k - \u2211 k \u2208 range K, g k) + \u2211 i \u2208 range K, f i * \u2211 k \u2208 range K, g k\ntwo_mul_two : 4 = 2 * 2\nhQ0 : Q \u2260 0\nh2Q0 : 2 * Q \u2260 0\nh\u03b5 : \u03b5 / (2 * P) * P + \u03b5 / (4 * Q) * (2 * Q) = \u03b5\nhNMK : N \u2294 M + 1 < K\nhKN : N < K\nhsumlesum :\n  \u2211 i \u2208 range (N \u2294 M + 1), abv (f i) * abv (\u2211 k \u2208 range (K - i), g k - \u2211 k \u2208 range K, g k) \u2264\n    \u2211 i \u2208 range (N \u2294 M + 1), abv (f i) * (\u03b5 / (2 * P))\nhsumltP : \u2211 n \u2208 range (N \u2294 M + 1), abv (f n) < P\n\u22a2 \u03b5 / (2 * P) * \u2211 i \u2208 range (N \u2294 M + 1), abv (f i) < \u03b5 / (2 * P) * P",["gcongr","aesop"]],["Algebra/Order/CauSeq/BigOperators.lean",193,"case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 (1 - 1 * abv x ^ n) / (1 - abv x) \u2264 (1 - abv x * abv x ^ n) / (1 - abv x)",["gcongr"]],["Analysis/NormedSpace/HahnBanach/SeparatingDual.lean",169,"\ud835\udd5c : Type u_3\nE : Type u_4\nF : Type u_5\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : SeparatingDual \ud835\udd5c E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : CompleteSpace (E \u2192L[\ud835\udd5c] F)\nf : \u2115 \u2192 F\nhf : CauchySeq f\nv : E\nhv : v \u2260 0\n\u03c6 : E \u2192L[\ud835\udd5c] \ud835\udd5c\nh\u03c6 : \u03c6 v = 1\ng : \u2115 \u2192 E \u2192L[\ud835\udd5c] F := fun n \u21a6 ((ContinuousLinearMap.smulRightL \ud835\udd5c E F) \u03c6) (f n)\nthis : CauchySeq g\na : E \u2192L[\ud835\udd5c] F\nha : Tendsto g atTop (\ud835\udcdd a)\n\u22a2 Continuous fun i \u21a6 i v",["fun_prop"]],["CategoryTheory/Idempotents/FunctorExtension.lean",200,"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Category.{u_5, u_1} C\ninst\u271d\u00b2 : Category.{u_4, u_2} D\ninst\u271d\u00b9 : Category.{?u.93349, u_3} E\ninst\u271d : IsIdempotentComplete D\n\u22a2 (karoubiUniversal\u2082 C D).functor.IsEquivalence",["infer_instance"]],["CategoryTheory/Idempotents/FunctorExtension.lean",219,"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Category.{u_5, u_1} C\ninst\u271d\u00b2 : Category.{u_4, u_2} D\ninst\u271d\u00b9 : Category.{?u.97160, u_3} E\ninst\u271d : IsIdempotentComplete D\n\u22a2 (karoubiUniversal C D).functor.IsEquivalence",["infer_instance"]],["CategoryTheory/Idempotents/FunctorExtension.lean",226,"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Category.{u_4, u_1} C\ninst\u271d\u00b2 : Category.{u_5, u_2} D\ninst\u271d\u00b9 : Category.{?u.97473, u_3} E\ninst\u271d : IsIdempotentComplete D\n\u22a2 (karoubiUniversal C D).inverse.IsEquivalence",["infer_instance"]],["NumberTheory/Transcendental/Lindemann/Init/AnalyticalPart.lean",124,"f : \u2124[X]\ns : \u2102\nh :\n  (fun x \u21a6 (x * \u2016s\u2016 \u2294 1) * \u2016(aeval (\u2191x * s)) f\u2016) '' Set.Ioc 0 1 \u2286\n    (fun x \u21a6 (x * \u2016s\u2016 \u2294 1) * \u2016(aeval (\u2191x * s)) f\u2016) '' Set.Icc 0 1\n\u22a2 Continuous fun x \u21a6 (x * \u2016s\u2016 \u2294 1) * \u2016(aeval (\u2191x * s)) f\u2016",["fun_prop"]],["Probability/Kernel/MeasurableLIntegral.lean",164,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b1 \u00d7 \u03b2 \u2192 \u211d\u22650\u221e\nhf : Measurable f\n\u22a2 Measurable fun a \u21a6 \u222b\u207b (b : \u03b2), f (a, b) \u2202\u03ba a",["fun_prop"]],["Probability/Kernel/MeasurableLIntegral.lean",176,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\na : \u03b1\ninst\u271d : IsSFiniteKernel \u03b7\nf : \u03b2 \u00d7 \u03b3 \u2192 \u211d\u22650\u221e\nhf : Measurable f\n\u22a2 Measurable fun u \u21a6 f (u.1.2, u.2)",["fun_prop"]],["Probability/Kernel/MeasurableLIntegral.lean",181,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e\nhf : Measurable (uncurry f)\ns : Set \u03b2\nhs : MeasurableSet s\n\u22a2 Measurable fun a \u21a6 \u222b\u207b (b : \u03b2), f a b \u2202(\u03ba.restrict hs) a",["fun_prop"]],["Probability/Kernel/MeasurableLIntegral.lean",185,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b2 \u00d7 \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\n\u22a2 Measurable fun y \u21a6 \u222b\u207b (x : \u03b2), f (x, y) \u2202\u03ba y",["fun_prop"]],["Probability/Kernel/MeasurableLIntegral.lean",189,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable (uncurry f)\n\u22a2 Measurable fun y \u21a6 \u222b\u207b (x : \u03b2), f x y \u2202\u03ba y",["fun_prop"]],["Probability/Kernel/MeasurableLIntegral.lean",194,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable (uncurry f)\ns : Set \u03b2\nhs : MeasurableSet s\n\u22a2 Measurable fun b \u21a6 \u222b\u207b (a : \u03b2), f a b \u2202(\u03ba.restrict hs) b",["fun_prop"]],["Probability/Kernel/MeasurableLIntegral.lean",198,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\nf : \u03b2 \u2192 \u211d\u22650\u221e\nhf : Measurable f\n\u22a2 Measurable fun a \u21a6 \u222b\u207b (b : \u03b2), f b \u2202\u03ba a",["fun_prop"]],["Probability/Kernel/MeasurableLIntegral.lean",204,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d : IsSFiniteKernel \u03ba\nf : \u03b2 \u2192 \u211d\u22650\u221e\nhf : Measurable f\ns : Set \u03b2\nhs : MeasurableSet s\n\u22a2 Measurable (uncurry fun a \u21a6 f)",["fun_prop"]],["NumberTheory/Cyclotomic/Three.lean",60,"case h.e_s\nK : Type u_1\ninst\u271d\u00b2 : Field K\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 \u21913\nu : (\ud835\udcde K)\u02e3\ninst\u271d\u00b9 : NumberField K\ninst\u271d : IsCyclotomicExtension {3} \u211a K\nhrank : rank K = 0\nx : \u21a5(torsion K)\ne : Fin (rank K) \u2192 \u2124\nhxu : u = \u2191(x, e).1 * \u220f i : Fin (rank K), fundSystem K i ^ (x, e).2 i\n\u22a2 IsEmpty (Fin 0)",["infer_instance"]],["Combinatorics/Additive/ApproximateSubgroup.lean",91,"G : Type u_1\ninst\u271d\u00b9 : Group G\nK : \u211d\ninst\u271d : DecidableEq G\nA : Finset G\nhA : IsApproximateSubgroup K \u2191A\nn : \u2115\nF : Finset G\nhF : \u2191(#F) \u2264 K\nhSF : \u2191A ^ 2 \u2286 \u2191F \u2022 \u2191A\n\u22a2 \u2191(#F) ^ (n + 1) * \u2191(#A) \u2264 K ^ (n + 1) * \u2191(#A)",["gcongr"]],["Combinatorics/Additive/ApproximateSubgroup.lean",110,"case intro.intro.refine_2\nG : Type u_1\ninst\u271d\u00b3 : Group G\nA : Set G\nK : \u211d\nF\u271d : Type u_2\nH : Type u_3\ninst\u271d\u00b2 : Group H\ninst\u271d\u00b9 : FunLike F\u271d G H\ninst\u271d : MonoidHomClass F\u271d G H\nf : F\u271d\nhA : IsApproximateSubgroup K A\nF : Finset G\nhF : \u2191(#F) \u2264 K\nhAF : A ^ 2 \u2286 \u2191F * A\n\u22a2 \u21d1f '' (A ^ 2) \u2286 \u21d1f '' (\u2191F * A)",["gcongr"]],["Combinatorics/Additive/ApproximateSubgroup.lean",148,"G : Type u_1\ninst\u271d : Group G\nA B : Set G\nK L : \u211d\nm n : \u2115\nhA : IsApproximateSubgroup K A\nhB : IsApproximateSubgroup L B\nhm : 2 \u2264 m\nhn : 2 \u2264 n\nF\u2081 : Finset G\nhF\u2081 : \u2191(#F\u2081) \u2264 K\nhAF\u2081 : A ^ 2 \u2286 \u2191F\u2081 \u2022 A\nF\u2082 : Finset G\nhF\u2082 : \u2191(#F\u2082) \u2264 L\nhBF\u2082 : B ^ 2 \u2286 \u2191F\u2082 \u2022 B\nthis : 1 \u2264 K\nf : G \u2192 G \u2192 G\nhf : \u2200 (a b : G), a \u2022 A \u2229 b \u2022 B \u2286 f a b \u2022 (A\u207b\u00b9 * A \u2229 (B\u207b\u00b9 * B))\n\u22a2 \u2191(#F\u2081) ^ (m - 1) * \u2191(#F\u2082) ^ (n - 1) \u2264 K ^ (m - 1) * L ^ (n - 1)",["gcongr"]],["Data/Fintype/Pi.lean",177,"\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b2 : DecidableEq (\u03b9 \u2192 \u03b1)\ns : Finset \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\n\u22a2 filter (fun f \u21a6 \u2203 a \u2208 s, const \u03b9 a = f) (Fintype.piFinset fun x \u21a6 s) = s.piDiag \u03b9",["aesop","infer_instance"]],["Combinatorics/Additive/Corner/Roth.lean",147,"G : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Fintype G\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhG : cornersTheoremBound \u03b5 \u2264 Fintype.card G\nA : Finset G\nhA\u03b5 : \u03b5 * \u2191(Fintype.card G) \u2264 \u2191(#A)\nhA : ThreeAPFree \u2191A\nB : Finset (G \u00d7 G) :=\n  filter\n    (fun x \u21a6\n      match x with\n      | (x, y) => y - x \u2208 A)\n    univ\n\u22a2 \u2191(Fintype.card G) * (\u03b5 * \u2191(Fintype.card G)) \u2264 \u2191(Fintype.card G) * \u2191(#A)",["gcongr"]],["LinearAlgebra/Matrix/Determinant/TotallyUnimodular.lean",157,"m : Type u_1\nn : Type u_3\nR : Type u_5\ninst\u271d\u00b9 : CommRing R\ninst\u271d : DecidableEq n\nA : Matrix m n R\n\u22a2 fromRows 1 A = (reindex (Equiv.sumComm m n) (Equiv.refl n)) (A.fromRows 1)",["aesop","infer_instance"]],["Analysis/InnerProductSpace/LinearPMap.lean",157,"\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c F\nT : E \u2192\u2097.[\ud835\udd5c] F\ninst\u271d : CompleteSpace E\ny : F\nw : E\nhw : \u2200 (x : \u21a5T.domain), inner w \u2191x = inner y (\u2191T x)\n\u22a2 Continuous \u21d1(((innerSL \ud835\udd5c) w).comp T.domain.subtypeL)",["fun_prop"]],["Combinatorics/SetFamily/Shatter.lean",183,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\nh\ud835\udc9c\u212c : \ud835\udc9c \u2286 \u212c\n\u22a2 \ud835\udc9c.shatterer.sup card \u2264 \u212c.shatterer.sup card",["gcongr"]],["Probability/Martingale/Centering.lean",78,"\u03a9 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : CompleteSpace E\nf : \u2115 \u2192 \u03a9 \u2192 E\n\u2131 : Filtration \u2115 m0\nhf_int : \u2200 (n : \u2115), Integrable (f n) \u03bc\nn : \u2115\n\u22a2 Integrable ((fun n \u21a6 f 0 + \u2211 i \u2208 Finset.range n, (f (i + 1) - f i - \u03bc[f (i + 1) - f i|\u2191\u2131 i])) n) \u03bc",["fun_prop"]],["Analysis/Convex/Strong.lean",128,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\nf : E \u2192 \u211d\nm n : \u211d\nhmn : m \u2264 n\nhf : StrongConvexOn s n f\nr : \u211d\n\u22a2 m / 2 * r ^ 2 \u2264 n / 2 * r ^ 2",["gcongr"]],["Analysis/Convex/Strong.lean",131,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\nf : E \u2192 \u211d\nm n : \u211d\nhmn : m \u2264 n\nhf : StrongConcaveOn s n f\nr : \u211d\n\u22a2 m / 2 * r ^ 2 \u2264 n / 2 * r ^ 2",["gcongr"]],["Combinatorics/SimpleGraph/Triangle/Removal.lean",62,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nP : Finpartition univ\n\u03b5 : \u211d\nhP\u2081 : P.IsEquipartition\nhP\u2083 : #P.parts \u2264 bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a\nhX : s \u2208 P.parts\nh\u271d : Nonempty \u03b1\nthis : 0 < #P.parts\n\u22a2 \u2191(Fintype.card \u03b1) / (2 * \u2191(bound (\u03b5 / 8) \u23084 / \u03b5\u2309\u208a)) \u2264 \u2191(Fintype.card \u03b1) / (2 * \u2191(#P.parts))",["gcongr"]],["Combinatorics/SimpleGraph/Operations.lean",93,"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\n\u22a2 DecidableRel\n    { Adj := fun v w \u21a6 if v = t then if w = t then False else G.Adj s w else if w = t then G.Adj v s else G.Adj v w,\n        symm := \u22ef, loopless := \u22ef }.Adj",["infer_instance"]],["Combinatorics/SimpleGraph/Operations.lean",160,"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst\u271d : DecidableEq V\nx\u271d\u00b9 x\u271d : V\n\u22a2 Decidable ((x\u271d\u00b9 = s \u2227 x\u271d = t \u2228 x\u271d\u00b9 = t \u2227 x\u271d = s) \u2227 x\u271d\u00b9 \u2260 x\u271d)",["infer_instance"]],["Analysis/Normed/Group/HomCompletion.lean",166,"G : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup G\nH : Type u_2\ninst\u271d : SeminormedAddCommGroup H\nf : NormedAddGroupHom G H\nC : \u211d\nh : f.SurjectiveOnWith f.range C\nhatg : Completion G\nhatg_in : f.completion hatg = 0\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\nC' : \u211d\nC'_pos : C' > 0\nhC' : f.SurjectiveOnWith f.range C'\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\nh\u03b4 : (1 + C' * \u2016f\u2016) * \u03b4 < \u03b5\ng : G\nhg : \u2016hatg - \u2191g\u2016 < \u03b4\ng' : G\nhgg' : f g' = f g\nhfg : \u2016g'\u2016 \u2264 C' * \u2016f g\u2016\nmem_ker : g - g' \u2208 f.ker\n\u22a2 \u2016f\u2016 * \u2016hatg - \u2191g\u2016 \u2264 \u2016f\u2016 * \u03b4",["gcongr"]],["Analysis/Normed/Group/HomCompletion.lean",171,"G : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup G\nH : Type u_2\ninst\u271d : SeminormedAddCommGroup H\nf : NormedAddGroupHom G H\nC : \u211d\nh : f.SurjectiveOnWith f.range C\nhatg : Completion G\nhatg_in : f.completion hatg = 0\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\nC' : \u211d\nC'_pos : C' > 0\nhC' : f.SurjectiveOnWith f.range C'\n\u03b4 : \u211d\n\u03b4_pos : 0 < \u03b4\nh\u03b4 : (1 + C' * \u2016f\u2016) * \u03b4 < \u03b5\ng : G\nhg : \u2016hatg - \u2191g\u2016 < \u03b4\ng' : G\nhgg' : f g' = f g\nhfg : \u2016g'\u2016 \u2264 C' * \u2016f g\u2016\nmem_ker : g - g' \u2208 f.ker\nthis : \u2016f g\u2016 \u2264 \u2016f\u2016 * \u03b4\n\u22a2 \u03b4 + C' * \u2016f g\u2016 \u2264 \u03b4 + C' * (\u2016f\u2016 * \u03b4)",["gcongr","aesop"]],["Combinatorics/SimpleGraph/Regularity/Increment.lean",175,"\u03b1 : Type u_1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\nP : Finpartition univ\nG : SimpleGraph \u03b1\ninst\u271d\u00b9 : DecidableRel G.Adj\n\u03b5 : \u211d\ninst\u271d : Nonempty \u03b1\nhP : P.IsEquipartition\nhP\u2087 : 7 \u2264 #P.parts\nhP\u03b5 : 100 \u2264 4 ^ #P.parts * \u03b5 ^ 5\nhP\u03b1 : #P.parts * 16 ^ #P.parts \u2264 Fintype.card \u03b1\nhPG : \u2191(#P.parts.offDiag) * \u03b5 < \u2191(#(P.nonUniforms G \u03b5))\nh\u03b5\u2080 : 0 \u2264 \u03b5\nh\u03b5\u2081 : \u03b5 \u2264 1\n\u22a2 \u2191(#P.parts.offDiag) * \u03b5 * (\u03b5 ^ 4 / 3) - \u2191(#P.parts.offDiag) * (\u03b5 ^ 5 / 25) \u2264\n    \u2191(#(P.nonUniforms G \u03b5)) * (\u03b5 ^ 4 / 3) - \u2191(#P.parts.offDiag) * (\u03b5 ^ 5 / 25)",["gcongr"]],["Topology/Algebra/ProperAction/Basic.lean",132,"G : Type u_1\nX : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MulAction G X\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : TopologicalSpace X\nh_proper : ProperSMul G X\ninst\u271d : T2Space G\nf : X \u2192 G \u00d7 X := fun x \u21a6 (1, x)\ng : G \u00d7 X \u2192 X := fun gx \u21a6 gx.2\nthis : Function.LeftInverse g f\n\u22a2 Continuous f",["fun_prop"]],["MeasureTheory/Function/LpSeminorm/TriangleInequality.lean",115,"\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\n\u03bc : Measure \u03b1\np \u03b4 : \u211d\u22650\u221e\nh\u03b4 : \u03b4 \u2260 0\nthis : Tendsto (fun \u03b7 \u21a6 LpAddConst p * (\u03b7 + \u03b7)) (\ud835\udcdd[>] 0) (\ud835\udcdd 0)\n\u03b7 : \u211d\u22650\u221e\nh\u03b7 : LpAddConst p * (\u03b7 + \u03b7) < \u03b4\n\u03b7pos : 0 < \u03b7\nf g : \u03b1 \u2192 E\nhf : AEStronglyMeasurable f \u03bc\nhg : AEStronglyMeasurable g \u03bc\nHf : eLpNorm f p \u03bc \u2264 \u03b7\nHg : eLpNorm g p \u03bc \u2264 \u03b7\n\u22a2 LpAddConst p * (eLpNorm f p \u03bc + eLpNorm g p \u03bc) \u2264 LpAddConst p * (\u03b7 + \u03b7)",["gcongr"]],["Probability/Kernel/Composition/Comp.lean",187,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\ninst\u271d\u00b9 : IsZeroOrMarkovKernel 0\ninst\u271d : IsZeroOrMarkovKernel 0\n\u22a2 IsZeroOrMarkovKernel 0\n```\n---\n```lean\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b7 : Kernel \u03b2 \u03b3\ninst\u271d\u00b9 : IsZeroOrMarkovKernel \u03b7\ninst\u271d : IsZeroOrMarkovKernel 0\nh\u271d : IsMarkovKernel \u03b7\n\u22a2 IsZeroOrMarkovKernel 0\n```\n---\n```lean\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d\u00b9 : IsZeroOrMarkovKernel \u03ba\nh\u271d : IsMarkovKernel \u03ba\ninst\u271d : IsZeroOrMarkovKernel 0\n\u22a2 IsZeroOrMarkovKernel 0\n```\n---\n```lean\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d\u00b9 : IsZeroOrMarkovKernel \u03ba\n\u03b7 : Kernel \u03b2 \u03b3\ninst\u271d : IsZeroOrMarkovKernel \u03b7\nh\u271d\u00b9 : IsMarkovKernel \u03ba\nh\u271d : IsMarkovKernel \u03b7\n\u22a2 IsZeroOrMarkovKernel (\u03b7 \u2218\u2096 \u03ba)",["infer_instance"]],["Combinatorics/Additive/Energy.lean",75,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Mul \u03b1\ns\u2081 s\u2082 t\u2081 t\u2082 : Finset \u03b1\nhs : s\u2081 \u2286 s\u2082\nht : t\u2081 \u2286 t\u2082\n\u22a2 #(filter (fun x \u21a6 x.1.1 * x.2.1 = x.1.2 * x.2.2) ((s\u2081 \u00d7\u02e2 s\u2081) \u00d7\u02e2 t\u2081 \u00d7\u02e2 t\u2081)) \u2264\n    #(filter (fun x \u21a6 x.1.1 * x.2.1 = x.1.2 * x.2.2) ((s\u2082 \u00d7\u02e2 s\u2082) \u00d7\u02e2 t\u2082 \u00d7\u02e2 t\u2082))",["gcongr"]],["CategoryTheory/Presentable/IsCardinalFiltered.lean",137,"J : Type u\ninst\u271d\u00b3 : Category.{v, u} J\n\u03ba : Cardinal.{w}\nh\u03ba : Fact \u03ba.IsRegular\ninst\u271d\u00b2 : IsCardinalFiltered J \u03ba\nA : Type w\ninst\u271d\u00b9 : SmallCategory A\ninst\u271d : FinCategory A\nF : A \u2964 J\n\u22a2 Finite (Arrow A)",["infer_instance"]],["InformationTheory/KullbackLeibler/KLFun.lean",70,"\u22a2 Continuous fun x \u21a6 x * log x + 1 - x",["fun_prop"]],["InformationTheory/KullbackLeibler/KLFun.lean",170,"\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nh\u03bc\u03bd : \u03bc \u226a \u03bd\n\u22a2 Integrable (fun x \u21a6 1 - (\u03bc.rnDeriv \u03bd x).toReal) \u03bd",["fun_prop"]],["Analysis/SpecialFunctions/MulExpNegMulSq.lean",66,"\u03b5 : \u211d\n\u22a2 Continuous fun x \u21a6 rexp (-(\u03b5 * x * x))",["fun_prop"]],["Analysis/SpecialFunctions/MulExpNegMulSq.lean",75,"\u03b5 y : \u211d\n\u22a2 DifferentiableAt \u211d (fun y \u21a6 rexp (-(\u03b5 * y * y))) y",["fun_prop"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",174,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 Epi biprod.snd",["infer_instance"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",175,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 Mono biprod.inl",["infer_instance"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",202,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 Mono (kernel.map f (f \u226b g) (\ud835\udfd9 X) g \u22ef)",["infer_instance"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",206,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 Epi (cokernel.map (f \u226b g) g f (\ud835\udfd9 Z) \u22ef)",["infer_instance"]],["AlgebraicGeometry/FunctionField.lean",79,"X Y : Scheme\nf : X \u27f6 Y\nH : IsOpenImmersion f\nhX : IrreducibleSpace \u2191\u2191X.toPresheafedSpace\ninst\u271d : IrreducibleSpace \u2191\u2191Y.toPresheafedSpace\n\u22a2 Continuous \u21d1(ConcreteCategory.hom f.base)",["fun_prop"]],["Topology/Algebra/Group/GroupTopology.lean",101,"G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Group \u03b1\n_t : TopologicalSpace \u03b1 := \u22a5\nthis : DiscreteTopology \u03b1\n\u22a2 Continuous fun p \u21a6 p.1 * p.2",["fun_prop"]],["CategoryTheory/Galois/Topology.lean",113,"case continuous_smul\nC : Type u\u2081\ninst\u271d : Category.{u\u2082, u\u2081} C\nF : C \u2964 FintypeCat\nX : C\n\u22a2 Continuous fun p \u21a6 p.1 \u2022 p.2",["fun_prop"]],["CategoryTheory/Galois/Topology.lean",121,"C : Type u\u2081\ninst\u271d : Category.{u\u2082, u\u2081} C\nF : C \u2964 FintypeCat\nX : C\ng : Aut (F.obj X) \u00d7 (F.obj X).carrier \u2192 (F.obj X).carrier :=\n  fun x \u21a6\n    match x with\n    | (\u03c3, x) => \u03c3.hom x\nh : Aut F \u00d7 (F.obj X).carrier \u2192 Aut (F.obj X) \u00d7 (F.obj X).carrier :=\n  fun q \u21a6 (((fun p \u21a6 p X) \u2218 \u21d1(autEmbedding F)) q.1, q.2)\n\u22a2 Continuous (g \u2218 h)",["fun_prop"]],["Data/Matrix/Invertible.lean",70,"m : Type u_1\nn : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : StarRing \u03b1\nA : Matrix n n \u03b1\ninst\u271d : Invertible A\u1d34\n\u22a2 Invertible (star A\u1d34)",["infer_instance"]],["Data/String/Basic.lean",37,"\u22a2 DecidableRel fun s\u2081 s\u2082 \u21a6 ltb s\u2081.iter s\u2082.iter = true",["infer_instance"]],["Data/String/Basic.lean",106,"\u22a2 DecidableRel fun s\u2081 s\u2082 \u21a6 \u00acs\u2082 < s\u2081",["infer_instance"]],["Analysis/SpecialFunctions/JapaneseBracket.lean",94,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nr : \u211d\nhnr : \u2191(finrank \u211d E) < r\nhr : 0 < r\n\u22a2 Measurable fun \u03c9 \u21a6 (1 + \u2016\u03c9\u2016) ^ (-r)",["fun_prop"]],["Analysis/SpecialFunctions/JapaneseBracket.lean",132,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nr : \u211d\nhnr : \u2191(finrank \u211d E) < r\n\u22a2 Measurable fun x \u21a6 (1 + \u2016x\u2016) ^ (-r)",["fun_prop"]],["Analysis/SpecialFunctions/JapaneseBracket.lean",144,"E : Type u_1\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : FiniteDimensional \u211d E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\n\u03bc : Measure E\ninst\u271d : \u03bc.IsAddHaarMeasure\nr : \u211d\nhnr : \u2191(finrank \u211d E) < r\nhr : 0 < r\n\u22a2 Measurable fun x \u21a6 (1 + \u2016x\u2016 ^ 2) ^ (-r / 2)",["fun_prop"]],["Analysis/Normed/Affine/AddTorsorBases.lean",134,"V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : NormedSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\ns : Set V\nh : affineSpan \u211d s = \u22a4\nt : Set V\nhts : t \u2286 s\nb : AffineBasis \u2191t \u211d V\nhb : \u21d1b = Subtype.val\nthis : (interior ((convexHull \u211d) t)).Nonempty\n\u22a2 interior ((convexHull \u211d) t) \u2286 interior ((convexHull \u211d) s)",["gcongr"]],["Analysis/NormedSpace/HomeomorphBall.lean",65,"E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u22a2 Continuous fun x \u21a6 \u221a(1 + \u2016x\u2016 ^ 2)",["fun_prop"]],["Analysis/Complex/Circle.lean",105,"x y : Circle\n\u22a2 Continuous fun t \u21a6 cexp (\u2191t * I)",["fun_prop"]],["Analysis/Normed/Group/ControlledClosure.lean",86,"G : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup G\ninst\u271d\u00b9 : CompleteSpace G\nH : Type u_2\ninst\u271d : NormedAddCommGroup H\nf : NormedAddGroupHom G H\nK : AddSubgroup H\nC \u03b5 : \u211d\nhC : 0 < C\nh\u03b5 : 0 < \u03b5\nhyp : f.SurjectiveOnWith K C\nh : H\nh_in : h \u2208 K.topologicalClosure\nhyp_h : \u00ach = 0\nb : \u2115 \u2192 \u211d := fun i \u21a6 (1 / 2) ^ i * (\u03b5 * \u2016h\u2016 / 2) / C\nb_pos : \u2200 (i : \u2115), 0 < b i\nv : \u2115 \u2192 H\nlim_v : Tendsto (fun n \u21a6 \u2211 k \u2208 range (n + 1), v k) atTop (\ud835\udcdd h)\nv_in : \u2200 (n : \u2115), v n \u2208 K\nhv\u2080 : \u2016v 0 - h\u2016 < b 0\nhv : \u2200 n > 0, \u2016v n\u2016 < b n\nu : \u2115 \u2192 G\nhu : \u2200 (n : \u2115), f (u n) = v n\nhnorm_u : \u2200 (n : \u2115), \u2016u n\u2016 \u2264 C * \u2016v n\u2016\ns : \u2115 \u2192 G := fun n \u21a6 \u2211 k \u2208 range (n + 1), u k\nthis\u271d : CauchySeq s\ng : G\nhg : Tendsto s atTop (\ud835\udcdd g)\nn : \u2115\nthis : \u2016v 0\u2016 \u2264 \u2016h\u2016 + b 0\n\u22a2 C * \u2016v 0\u2016 \u2264 C * (\u2016h\u2016 + b 0)",["gcongr","aesop"]],["Analysis/LocallyConvex/WeakSpace.lean",49,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2078 : RCLike \ud835\udd5c\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : Module \u211d E\ninst\u271d\u2074 : IsScalarTower \u211d \ud835\udd5c E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : IsTopologicalAddGroup E\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c E\ninst\u271d : LocallyConvexSpace \u211d E\ns : Set E\nhs : Convex \u211d s\nx : E\nhx : (toWeakSpace \ud835\udd5c E).toEquiv x \u2208 (\u21d1(toWeakSpace \ud835\udd5c E) '' closure s)\u1d9c\nthis : ContinuousSMul \u211d E\nf : E \u2192L[\ud835\udd5c] \ud835\udd5c\nu : \u211d\nhus : \u2200 a \u2208 closure s, RCLike.re (f a) < u\nhux : u < RCLike.re (f x)\nf' : WeakSpace \ud835\udd5c E \u2192L[\ud835\udd5c] \ud835\udd5c := { toLinearMap := \u2191f \u2218\u2097 \u2191(toWeakSpace \ud835\udd5c E).symm, cont := \u22ef }\nhux' : u < (RCLike.reCLM.comp (ContinuousLinearMap.restrictScalars \u211d f')) ((toWeakSpace \ud835\udd5c E) x)\n\u22a2 Continuous fun y \u21a6 u",["fun_prop"]],["Probability/Kernel/IonescuTulcea/Maps.lean",103,"\u03b9 : Type u_1\ninst\u271d\u2074 : LinearOrder \u03b9\ninst\u271d\u00b3 : LocallyFiniteOrder \u03b9\ninst\u271d\u00b2 : DecidableLE \u03b9\nX : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : (i : \u03b9) \u2192 MeasurableSpace (X i)\na b : \u03b9\nhab : a \u2264 b\n\u22a2 Measurable fun x \u21a6 (fun i \u21a6 x \u27e8\u2191i, \u22ef\u27e9, fun i \u21a6 x \u27e8\u2191i, \u22ef\u27e9)",["fun_prop"]],["CategoryTheory/Subpresheaf/Image.lean",103,"case left\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\np : F' \u27f6 F\ninst\u271d : Mono p\nthis : Mono (toRange p)\ni : C\u1d52\u1d56\n\u22a2 Mono ((toRange p).app i)",["infer_instance"]],["CategoryTheory/Subpresheaf/Image.lean",105,"case right\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\np : F' \u27f6 F\ninst\u271d : Mono p\nthis : Mono (toRange p)\ni : C\u1d52\u1d56\n\u22a2 Epi ((toRange p).app i)",["infer_instance"]],["CategoryTheory/EffectiveEpi/Comp.lean",69,"C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\nB X : C\nf : X \u27f6 B\ninst\u271d : IsSplitEpi f\n\u22a2 CategoryTheory.EffectiveEpi (f \u226b \ud835\udfd9 B)",["infer_instance"]],["AlgebraicTopology/DoldKan/NReflectsIso.lean",111,"C : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preadditive C\nA\u271d B\u271d : Karoubi (SimplicialObject C)\nf : A\u271d \u27f6 B\u271d\ninst\u271d : IsIso (N\u2082.map f)\nF\u2081 : Karoubi (SimplexCategory\u1d52\u1d56 \u2964 C) \u2964 SimplexCategory\u1d52\u1d56 \u2964 Karoubi C :=\n  karoubiFunctorCategoryEmbedding SimplexCategory\u1d52\u1d56 C\nF\u2082 : SimplicialObject (Karoubi C) \u2964 Karoubi (ChainComplex (Karoubi C) \u2115) := N\u2081\nF\u2083 : Karoubi (ChainComplex (Karoubi C) \u2115) \u2964 ChainComplex (Karoubi (Karoubi C)) \u2115 :=\n  (karoubiChainComplexEquivalence (Karoubi C) \u2115).functor\nF\u2084 : HomologicalComplex (Karoubi (Karoubi C)) (ComplexShape.down \u2115) \u2964 HomologicalComplex (Karoubi C) (ComplexShape.down \u2115) :=\n  (KaroubiKaroubi.equivalence C).inverse.mapHomologicalComplex (ComplexShape.down \u2115)\nF : Karoubi (SimplexCategory\u1d52\u1d56 \u2964 C) \u2964 HomologicalComplex (Karoubi C) (ComplexShape.down \u2115) := F\u2081 \u22d9 F\u2082 \u22d9 F\u2083 \u22d9 F\u2084\nthis : F\u2081.ReflectsIsomorphisms\n\u22a2 F\u2082.ReflectsIsomorphisms",["infer_instance"]],["Algebra/Polynomial/CoeffMem.lean",59,"R : Type u_2\nS : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Algebra R S\np q : S[X]\nhq : q.Monic\ni : \u2115\nH\u2080 : \u2200 (i : \u2115), p.coeff i \u2208 spanCoeffs(q) ^ deg(p) * spanCoeffs(p)\nhpq : q.degree \u2264 p.degree \u2227 p \u2260 0\nr : S[X]\nhr : p - q * (C p.leadingCoeff * X ^ (deg(p) - deg(q))) = r\nhr' : \u00acr = 0\nH : span R coeffs(r) \u2264 span R coeffs(p) \u2294 span R coeffs(q) * span R coeffs(p)\ndeg_r_lt_deg_p : deg(r) < deg(p)\n\u22a2 spanCoeffs(q) ^ deg(r) * spanCoeffs(r) \u2264\n    spanCoeffs(q) ^ deg(r) * (1 \u2294 (span R coeffs(p) \u2294 span R coeffs(q) * span R coeffs(p)))",["gcongr"]],["Topology/Algebra/Group/SubmonoidClosure.lean",39,"G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx : G\nm : \u2124\ny : G\nhy : MapClusterPt y atTop fun x_1 \u21a6 x ^ x_1\n\u22a2 ContinuousAt (fun yz \u21a6 x ^ m * yz.2 / yz.1) (y, y)",["fun_prop"]],["Analysis/NormedSpace/RieszLemma.lean",96,"\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nR : \u211d\nhR : \u2016c\u2016 < R\nF : Subspace \ud835\udd5c E\nhFc : IsClosed \u2191F\nhF : \u2203 x, x \u2209 F\nRpos : 0 < R\nthis : \u2016c\u2016 / R < 1\nx : E\nxF : x \u2209 F\nhx : \u2200 y \u2208 F, \u2016c\u2016 / R * \u2016x\u2016 \u2264 \u2016x - y\u2016\nx0 : x \u2260 0\nd : \ud835\udd5c\nd0 : d \u2260 0\ndxlt : \u2016d \u2022 x\u2016 < R\nledx : R / \u2016c\u2016 \u2264 \u2016d \u2022 x\u2016\ny : E\nhy : y \u2208 F\ny' : E := d\u207b\u00b9 \u2022 y\nyy' : y = d \u2022 y'\n\u22a2 \u2016c\u2016 / R * (R / \u2016c\u2016) \u2264 \u2016c\u2016 / R * \u2016d \u2022 x\u2016",["gcongr"]],["Analysis/Calculus/LineDeriv/Measurable.lean",36,"\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2077 : LocallyCompactSpace \ud835\udd5c\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\ninst\u271d\u2074 : MeasurableSpace E\ninst\u271d\u00b3 : OpensMeasurableSpace E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : CompleteSpace F\nf : E \u2192 F\nv : E\nhf : Continuous f\nthis\u271d\u00b9 : MeasurableSpace \ud835\udd5c := borel \ud835\udd5c\nthis\u271d : BorelSpace \ud835\udd5c\ng : E \u2192 \ud835\udd5c \u2192 F := fun x t \u21a6 f (x + t \u2022 v)\n\u22a2 Continuous (Function.uncurry g)",["fun_prop"]],["Analysis/Calculus/LineDeriv/Measurable.lean",43,"\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2079 : LocallyCompactSpace \ud835\udd5c\nE : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\ninst\u271d\u2076 : MeasurableSpace E\ninst\u271d\u2075 : OpensMeasurableSpace E\nF : Type u_3\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : CompleteSpace F\nf : E \u2192 F\nv : E\ninst\u271d\u00b9 : MeasurableSpace F\ninst\u271d : BorelSpace F\nhf : Continuous f\nthis\u271d\u00b9 : MeasurableSpace \ud835\udd5c := borel \ud835\udd5c\nthis\u271d : BorelSpace \ud835\udd5c\ng : E \u2192 \ud835\udd5c \u2192 F := fun x t \u21a6 f (x + t \u2022 v)\n\u22a2 Continuous (Function.uncurry g)",["fun_prop"]],["Analysis/Calculus/LineDeriv/Measurable.lean",50,"\ud835\udd5c : Type u_1\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2078 : LocallyCompactSpace \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\ninst\u271d\u2075 : MeasurableSpace E\ninst\u271d\u2074 : OpensMeasurableSpace E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : CompleteSpace F\nf : E \u2192 F\nv : E\ninst\u271d : SecondCountableTopologyEither E F\nhf : Continuous f\nthis\u271d\u00b9 : MeasurableSpace \ud835\udd5c := borel \ud835\udd5c\nthis\u271d : BorelSpace \ud835\udd5c\ng : E \u2192 \ud835\udd5c \u2192 F := fun x t \u21a6 f (x + t \u2022 v)\n\u22a2 Continuous (Function.uncurry g)",["fun_prop"]],["Analysis/Polynomial/CauchyBound.lean",91,"K : Type u_1\ninst\u271d : NormedDivisionRing K\np : K[X]\nhp : p \u2260 0\na : K\nh : \u2016p.leadingCoeff\u2016\u208a * \u2016a\u2016\u208a ^ p.natDegree = \u2016\u2211 i \u2208 range p.natDegree, p.coeff i * a ^ i\u2016\u208a\nthis : \u2016a\u2016\u208a ^ p.natDegree \u2264 (p.cauchyBound - 1) * ((\u2016a\u2016\u208a ^ p.natDegree - 1) / (\u2016a\u2016\u208a - 1))\nha\u271d : \u2016a\u2016\u208a \u2260 1\nha : \u2016a\u2016\u208a > 1\n\u22a2 \u2016a\u2016\u208a ^ p.natDegree * (\u2016a\u2016\u208a - 1) / \u2016a\u2016\u208a ^ p.natDegree + 1 \u2264\n    (p.cauchyBound - 1) * ((\u2016a\u2016\u208a ^ p.natDegree - 1) / (\u2016a\u2016\u208a - 1)) * (\u2016a\u2016\u208a - 1) / \u2016a\u2016\u208a ^ p.natDegree + 1",["gcongr"]],["Analysis/Polynomial/CauchyBound.lean",111,"K : Type u_1\ninst\u271d : NormedDivisionRing K\np : K[X]\nhp : p \u2260 0\na : K\nh : \u2016p.leadingCoeff\u2016\u208a * \u2016a\u2016\u208a ^ p.natDegree \u2264 \u2016\u2211 i \u2208 range p.natDegree, p.coeff i * a ^ i\u2016\u208a\npld : \u2016p.leadingCoeff\u2016\u208a \u2260 0\n\u22a2 \u2016p.leadingCoeff\u2016\u208a * \u2016a\u2016\u208a ^ p.natDegree / \u2016p.leadingCoeff\u2016\u208a \u2264\n    \u2016\u2211 x \u2208 range p.natDegree, p.coeff x * a ^ x\u2016\u208a / \u2016p.leadingCoeff\u2016\u208a",["gcongr"]],["Algebra/ContinuedFractions/Computation/ApproximationCorollaries.lean",112,"K : Type u_1\nv : K\ninst\u271d\u00b2 : LinearOrderedField K\ninst\u271d\u00b9 : FloorRing K\ninst\u271d : Archimedean K\n\u03b5 : K\n\u03b5_pos : \u03b5 > 0\nN' : \u2115\none_div_\u03b5_lt_N' : 1 / \u03b5 < \u2191N'\nN : \u2115 := N' \u2294 5\nn : \u2115\nn_ge_N : n \u2265 N\ng : GenContFract K := of v\nnot_terminatedAt_n : \u00acg.TerminatedAt n\nB : K := g.dens n\nnB : K := g.dens (n + 1)\nabs_v_sub_conv_le : |v - g.convs n| \u2264 1 / (B * nB)\nnB_ineq : \u2191(fib (n + 2)) \u2264 nB\nB_ineq : \u2191(fib (n + 1)) \u2264 B\nzero_lt_B : 0 < B\nnB_pos : 0 < nB\nzero_lt_mul_conts : 0 < B * nB\n\u22a2 \u2191(fib (n + 1)) * \u2191(fib (n + 2)) \u2264 B * nB",["gcongr"]],["CategoryTheory/Subpresheaf/Equalizer.lean",73,"C : Type u\ninst\u271d : Category.{v, u} C\nF\u2081 F\u2082 : C\u1d52\u1d56 \u2964 Type w\nA : Subpresheaf F\u2081\nf g : A.toPresheaf \u27f6 F\u2082\n\u22a2 Mono (homOfLe \u22ef)",["infer_instance"]],["CategoryTheory/Sites/Coherent/Comparison.lean",49,"case intro.intro.intro.intro.refine_1\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : FinitaryPreExtensive C\ninst\u271d : Preregular C\nB\u2081 B\u2082 : C\nf : B\u2082 \u27f6 B\u2081\n\u03b1 : Type\nx\u271d\u00b9 : Finite \u03b1\nX\u2081 : \u03b1 \u2192 C\n\u03c0\u2081 : (a : \u03b1) \u2192 X\u2081 a \u27f6 B\u2081\nh : EffectiveEpiFamily X\u2081 \u03c0\u2081\nY : C\ng : Y \u27f6 B\u2082\nw\u271d : EffectiveEpi g\ng' : Y \u27f6 \u2210 X\u2081\nhg : g' \u226b Sigma.desc \u03c0\u2081 = g \u226b f\nX\u2082 : \u03b1 \u2192 C := fun a \u21a6 Limits.pullback g' (Sigma.\u03b9 X\u2081 a)\n\u03c0\u2082 : (a : \u03b1) \u2192 Limits.pullback g' (Sigma.\u03b9 X\u2081 a) \u27f6 B\u2082 := fun a \u21a6 pullback.fst g' (Sigma.\u03b9 X\u2081 a) \u226b g\n\u03c0' : (a : \u03b1) \u2192 Limits.pullback g' (Sigma.\u03b9 X\u2081 a) \u27f6 Y := fun a \u21a6 pullback.fst g' (Sigma.\u03b9 X\u2081 a)\nx\u271d : IsIso (Sigma.desc fun x \u21a6 pullback.fst g' (Sigma.\u03b9 X\u2081 x))\nthis : Sigma.desc \u03c0' \u226b g = Sigma.desc \u03c0\u2082\n\u22a2 EffectiveEpi (Sigma.desc \u03c0' \u226b g)",["infer_instance"]],["MeasureTheory/Group/Convolution.lean",45,"M : Type u_1\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MeasurableSpace M\ninst\u271d\u00b9 : MeasurableMul\u2082 M\n\u03bc : Measure M\ninst\u271d : SFinite \u03bc\n\u22a2 Measurable (Prod.mk 1)",["fun_prop"]],["MeasureTheory/Group/Convolution.lean",54,"M : Type u_1\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MeasurableSpace M\ninst\u271d\u00b9 : MeasurableMul\u2082 M\n\u03bc : Measure M\ninst\u271d : SFinite \u03bc\n\u22a2 Measurable fun x \u21a6 (x, 1)",["fun_prop"]],["MeasureTheory/Group/Convolution.lean",73,"case hf\nM : Type u_1\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : MeasurableSpace M\ninst\u271d\u00b3 : MeasurableMul\u2082 M\n\u03bc \u03bd \u03c1 : Measure M\ninst\u271d\u00b2 : SFinite \u03bc\ninst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03c1\n\u22a2 Measurable fun x \u21a6 x.1 * x.2",["fun_prop"]],["MeasureTheory/Group/Convolution.lean",80,"case hf\nM : Type u_1\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : MeasurableSpace M\ninst\u271d\u00b3 : MeasurableMul\u2082 M\n\u03bc \u03bd \u03c1 : Measure M\ninst\u271d\u00b2 : SFinite \u03bc\ninst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03c1\n\u22a2 Measurable fun x \u21a6 x.1 * x.2",["fun_prop"]],["MeasureTheory/Group/Convolution.lean",89,"M : Type u_2\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : MeasurableSpace M\ninst\u271d\u00b2 : MeasurableMul\u2082 M\n\u03bc \u03bd : Measure M\ninst\u271d\u00b9 : SFinite \u03bc\ninst\u271d : SFinite \u03bd\n\u22a2 Measurable Prod.swap",["fun_prop"]],["MeasureTheory/Group/Convolution.lean",108,"M : Type u_1\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : MeasurableSpace M\n\u03bc \u03bd : Measure M\ninst\u271d\u00b2 : MeasurableMul\u2082 M\ninst\u271d\u00b9 : IsProbabilityMeasure \u03bc\ninst\u271d : IsProbabilityMeasure \u03bd\n\u22a2 AEMeasurable (fun x \u21a6 x.1 * x.2) (\u03bc.prod \u03bd)",["fun_prop"]],["Algebra/Ring/Rat.lean",61,"\u22a2 Semiring \u211a",["infer_instance"]],["Combinatorics/Additive/RuzsaCovering.lean",38,"G : Type u_1\ninst\u271d\u00b9 : Group G\nK : \u211d\ninst\u271d : DecidableEq G\nA B : Finset G\nhB : B.Nonempty\nhK : \u2191(#(A * B)) \u2264 K * \u2191(#B)\nthis : (F : Set G) \u2192 Decidable (F.PairwiseDisjoint fun x \u21a6 x \u2022 B)\nC : Finset (Finset G) := filter (fun F \u21a6 (\u2191F).PairwiseDisjoint fun x \u21a6 x \u2022 B) A.powerset\nF : Finset G\nhFmax : \u2200 x \u2208 C, \u00acF < x\nhFA : F \u2286 A\nhF : (\u2191F).PairwiseDisjoint fun x \u21a6 x \u2022 B\n\u22a2 \u2191(#(F * B)) \u2264 \u2191(#(A * B))",["gcongr"]],["Probability/Kernel/CompProdEqIff.lean",65,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03ba \u03b7 : Kernel \u03b1 \u03b2\ninst\u271d\u00b3 : MeasurableSpace.CountableOrCountablyGenerated \u03b1 \u03b2\ninst\u271d\u00b2 : IsFiniteMeasure \u03bc\ninst\u271d\u00b9 : IsFiniteKernel \u03ba\ninst\u271d : IsFiniteKernel \u03b7\nh : \u03bc \u2297\u2098 \u03ba = \u03bc \u2297\u2098 \u03b7\nh_ac : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u03ba a \u226a \u03b7 a\nh\u03ba_eq : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u03ba a = (\u03b7.withDensity (\u03ba.rnDeriv \u03b7)) a\ns : Set (\u03b1 \u00d7 \u03b2)\nhs : MeasurableSet s\nx\u271d : (\u03bc \u2297\u2098 \u03b7) s < \u22a4\n\u22a2 Measurable (Function.uncurry (\u03ba.rnDeriv \u03b7))",["fun_prop"]],["Analysis/InnerProductSpace/Continuous.lean",87,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\n\u03b1 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b1 \u2192 E\nhf : Continuous f\nhg : Continuous g\n_x : \u03b1\n\u22a2 ContinuousAt (fun t \u21a6 Inner.inner (f t) (g t)) _x",["fun_prop"]],["Topology/Category/CompHausLike/EffectiveEpi.lean",76,"P : TopCat \u2192 Prop\ninst\u271d\u00b9 : HasExplicitPullbacks P\ninst\u271d : HasExplicitFiniteCoproducts P\nhs : \u2200 \u2983X Y : CompHausLike P\u2984 (f : X \u27f6 Y), EffectiveEpi f \u2192 Function.Surjective \u21d1(ConcreteCategory.hom f)\nthis : Preregular (CompHausLike P)\n\u22a2 Precoherent (CompHausLike P)",["infer_instance"]],["Combinatorics/Additive/CovBySMul.lean",54,"M : Type u_1\nN : Type u_2\nX : Type u_3\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : Monoid N\ninst\u271d\u00b3 : MulAction M X\ninst\u271d\u00b2 : MulAction N X\nK L : \u211d\nA B C : Set X\ninst\u271d\u00b9 : MulAction M N\ninst\u271d : IsScalarTower M N X\nthis : 0 \u2264 K\nF\u2081 : Finset M\nhF\u2081 : \u2191(#F\u2081) \u2264 K\nhFAB : A \u2286 \u2191F\u2081 \u2022 B\nF\u2082 : Finset N\nhF\u2082 : \u2191(#F\u2082) \u2264 L\nhFBC : B \u2286 \u2191F\u2082 \u2022 C\n\u22a2 \u2191(#F\u2081) * \u2191(#F\u2082) \u2264 K * L",["gcongr"]],["Combinatorics/Additive/CovBySMul.lean",57,"M : Type u_1\nN : Type u_2\nX : Type u_3\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : Monoid N\ninst\u271d\u00b3 : MulAction M X\ninst\u271d\u00b2 : MulAction N X\nK L : \u211d\nA B C : Set X\ninst\u271d\u00b9 : MulAction M N\ninst\u271d : IsScalarTower M N X\nthis : 0 \u2264 K\nF\u2081 : Finset M\nhF\u2081 : \u2191(#F\u2081) \u2264 K\nhFAB : A \u2286 \u2191F\u2081 \u2022 B\nF\u2082 : Finset N\nhF\u2082 : \u2191(#F\u2082) \u2264 L\nhFBC : B \u2286 \u2191F\u2082 \u2022 C\n\u22a2 \u2191F\u2081 \u2022 B \u2286 \u2191F\u2081 \u2022 \u2191F\u2082 \u2022 C",["gcongr"]],["Data/Real/Pi/Leibniz.lean",24,"x\u271d\u00b2 x\u271d\u00b9 : \u2115\nx\u271d : x\u271d\u00b2 < x\u271d\u00b9\n\u22a2 (2 * \u2191x\u271d\u00b9 + 1)\u207b\u00b9 \u2264 (2 * \u2191x\u271d\u00b2 + 1)\u207b\u00b9",["gcongr"]],["Topology/Algebra/Affine.lean",59,"R : Type u_1\nF : Type u_3\ninst\u271d\u2075 : AddCommGroup F\ninst\u271d\u2074 : TopologicalSpace F\ninst\u271d\u00b3 : IsTopologicalAddGroup F\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R F\ninst\u271d : ContinuousConstSMul R F\nx : F\nt : R\nthis : \u21d1(homothety x t) = fun y \u21a6 t \u2022 (y - x) + x\n\u22a2 Continuous fun y \u21a6 t \u2022 (y - x) + x",["fun_prop"]],["Analysis/NormedSpace/SphereNormEquiv.lean",46,"E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u22a2 Continuous fun x \u21a6 \u2191x.2 \u2022 \u2191x.1",["fun_prop"]],["Topology/ContinuousMap/ContinuousSqrt.lean",23,"\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\n\u22a2 ContinuousOn (ofReal \u2218 Real.sqrt \u2218 \u21d1re \u2218 fun z \u21a6 z.2 - z.1) {x | x.1 \u2264 x.2}",["fun_prop"]],["Topology/ContinuousMap/ContinuousSqrt.lean",40,"\u22a2 ContinuousOn (\u21d1NNReal.sqrt \u2218 fun x \u21a6 x.2 - x.1) {x | x.1 \u2264 x.2}",["fun_prop"]],["Algebra/Order/Ring/Rat.lean",34,"\u22a2 LinearOrderedRing \u211a",["infer_instance"]],["Algebra/Order/Ring/Rat.lean",36,"\u22a2 OrderedRing \u211a",["infer_instance"]],["Algebra/Order/Ring/Rat.lean",38,"\u22a2 LinearOrderedSemiring \u211a",["infer_instance"]],["Algebra/Order/Ring/Rat.lean",40,"\u22a2 OrderedSemiring \u211a",["infer_instance"]],["Algebra/Order/Ring/Rat.lean",42,"\u22a2 LinearOrderedAddCommGroup \u211a",["infer_instance"]],["Algebra/Order/Ring/Rat.lean",44,"\u22a2 OrderedAddCommGroup \u211a",["infer_instance"]],["Algebra/Order/Ring/Rat.lean",46,"\u22a2 OrderedCancelAddCommMonoid \u211a",["infer_instance"]],["Algebra/Order/Ring/Rat.lean",48,"\u22a2 OrderedAddCommMonoid \u211a",["infer_instance"]],["Topology/Algebra/Module/Compact.lean",27,"case intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : TopologicalSpace R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : ContinuousAdd M\ninst\u271d\u00b9 : ContinuousSMul R M\ninst\u271d : CompactSpace R\nN : Submodule R M\ns : Finset M\nhs : span R \u2191s = N\nthis : LinearMap.range (Fintype.linearCombination R Subtype.val) = N\n\u22a2 Continuous fun f \u21a6 \u2211 i \u2208 s.attach, f i \u2022 \u2191i",["fun_prop"]]]},{"tactics":["aesop"],"cost":30,"goals":[["MeasureTheory/Integral/Lebesgue.lean",850,"\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nhs : MeasurableSet s\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 a \u2208 s, a \u2208 t \u2192 f a \u2264 1\nhf' : \u2200 a \u2208 s, a \u2209 t \u2192 f a = 0\n\u22a2 \u2200 a \u2208 t\u1d9c, s.indicator f a = 0",["aesop"]],["Data/Real/EReal.lean",1276,"x y : EReal\nh : \u2200 (z : \u211d), x < \u2191z \u2192 y \u2264 \u2191z\n\u22a2 (x < \u2191\u22a4 \u2192 y \u2264 \u2191\u22a4) \u2227 \u2200 (x_1 : \u211d), x < \u2191\u2191x_1 \u2192 y \u2264 \u2191\u2191x_1",["aesop"]],["Data/Real/EReal.lean",1281,"x y : EReal\nh : \u2200 (z : \u211d), \u2191z < y \u2192 \u2191z \u2264 x\n\u22a2 (\u2191\u22a4 < y \u2192 \u2191\u22a4 \u2264 x) \u2227 \u2200 (x_1 : \u211d), \u2191\u2191x_1 < y \u2192 \u2191\u2191x_1 \u2264 x",["aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",187,"case h.h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ngt_zero : 0 < b (min_bi b)\nhlo : \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 c * \u2016\u2191x\u2016\nhlo' : \u2200\u1da0 (x : \u2115) in atTop, \u2016\u2191x / log \u2191x ^ 2\u2016 \u2264 b (min_bi b) / 2 * \u2016\u2191x\u2016\nn : \u2115\nhn' : \u2200 (i : \u03b1), b i * \u2191n - \u2191n / log \u2191n ^ 2 \u2264 \u2191(r i n)\ni : \u03b1\nhn : \u2016\u2191n / log \u2191n ^ 2\u2016 \u2264 b (min_bi b) / 2 * \u2191n\n\u22a2 b (min_bi b) \u2264 b i",["aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",275,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nn : \u2115\nh_ind : \u2200 m < n, 0 < T m\nhn : R.n\u2080 \u2264 n\nthis : \u2200 x \u2265 0, 0 \u2264 g x\n\u22a2 0 \u2264 g \u2191n",["aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",472,"\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\ni : \u03b1\nn : \u2115\nhn : 1 < n\nhn' : \u2200 (i : \u03b1), 0 < log (b i * \u2191n)\n\u22a2 1 < \u2191n",["aesop"]],["Computability/AkraBazzi/AkraBazzi.lean",951,"case hab\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\nT : \u2115 \u2192 \u211d\ng : \u211d \u2192 \u211d\na b : \u03b1 \u2192 \u211d\nr : \u03b1 \u2192 \u2115 \u2192 \u2115\ninst\u271d : Nonempty \u03b1\nR : AkraBazziRecurrence T g a b r\nq : \u211d \u2192 \u211d\nhq_diff : DifferentiableOn \u211d q (Set.Ioi 1)\nhq_poly : GrowsPolynomially fun x \u21a6 \u2016deriv q x\u2016\ni\u271d : \u03b1\nb' : \u211d := b (min_bi b) / 2\nhb_pos : 0 < b'\nhb_lt_one : b' < 1\nhb : b' \u2208 Set.Ioo 0 1\ni : \u03b1\n\u22a2 b (min_bi b) \u2264 b i",["aesop"]],["Data/Set/Lattice.lean",1269,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Set \u03b1\nS : Set (Set \u03b2)\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\n\u22a2 image2 f t (\u22c2\u2080 S) \u2286 \u22c2 s \u2208 S, image2 f t s",["aesop"]],["Data/Set/Lattice.lean",1273,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nS : Set (Set \u03b1)\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\n\u22a2 image2 f (\u22c2\u2080 S) t \u2286 \u22c2 s \u2208 S, image2 f s t",["aesop"]],["Data/Set/Lattice.lean",1609,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nS : Set (Set \u03b1)\nt : Set \u03b2\n\u22a2 image2 f (\u22c3\u2080 S) t = \u22c3 s \u2208 S, image2 f s t",["aesop"]],["Data/Set/Lattice.lean",1613,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nT : Set (Set \u03b2)\n\u22a2 image2 f s (\u22c3\u2080 T) = \u22c3 t \u2208 T, image2 f s t",["aesop"]],["Topology/Category/Profinite/Nobeling.lean",127,"case h.h\nI : Type u\nJ K : I \u2192 Prop\ninst\u271d\u00b9 : (i : I) \u2192 Decidable (J i)\ninst\u271d : (i : I) \u2192 Decidable (K i)\nh : \u2200 (i : I), J i \u2192 K i\nx : I \u2192 Bool\ni : I\n\u22a2 (if J i then if K i then x i else false else false) = if J i then x i else false",["aesop"]],["Topology/Category/Profinite/Nobeling.lean",164,"case h.a.h\nI : Type u\nC : Set (I \u2192 Bool)\nJ K L : I \u2192 Prop\ninst\u271d\u00b2 : (i : I) \u2192 Decidable (J i)\ninst\u271d\u00b9 : (i : I) \u2192 Decidable (K i)\ninst\u271d : (i : I) \u2192 Decidable (L i)\nhJK : \u2200 (i : I), J i \u2192 K i\nhKL : \u2200 (i : I), K i \u2192 L i\nx : \u2191(\u03c0 C L)\ni : I\n\u22a2 (if J i then if K i then \u2191x i else false else false) = if J i then \u2191x i else false",["aesop"]],["Topology/Category/Profinite/Nobeling.lean",170,"case h.a.h\nI : Type u\nC : Set (I \u2192 Bool)\nJ K : I \u2192 Prop\ninst\u271d\u00b9 : (i : I) \u2192 Decidable (J i)\ninst\u271d : (i : I) \u2192 Decidable (K i)\nh : \u2200 (i : I), J i \u2192 K i\nx : \u2191C\ni : I\n\u22a2 (if J i then if K i then \u2191x i else false else false) = if J i then \u2191x i else false",["aesop"]],["Data/Set/Function.lean",466,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\n\u22a2 (\u2200 \u2983x\u2081 : \u03b1\u2984, x\u2081 \u2208 {a, b} \u2192 \u2200 \u2983x\u2082 : \u03b1\u2984, x\u2082 \u2208 {a, b} \u2192 f x\u2081 = f x\u2082 \u2192 x\u2081 = x\u2082) \u2194 f a = f b \u2192 a = b",["aesop"]],["Data/Set/Function.lean",696,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\n\u22a2 graphOn f s \u00d7\u02e2 graphOn g t = \u21d1(prodProdProdComm \u03b1 \u03b3 \u03b2 \u03b4) \u207b\u00b9' graphOn (Prod.map f g) (s \u00d7\u02e2 t)",["aesop"]],["Data/Set/Function.lean",700,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\n\u22a2 graphOn (Prod.map f g) (s \u00d7\u02e2 t) = \u21d1(prodProdProdComm \u03b1 \u03b2 \u03b3 \u03b4) \u207b\u00b9' graphOn f s \u00d7\u02e2 graphOn g t",["aesop"]],["Analysis/Analytic/Composition.lean",648,"case h\nm n : \u2115 \u00d7 \u2115\nhmn : m \u2264 n\na : (n : \u2115) \u00d7 Composition n\nha : a \u2208 (fun p \u21a6 compPartialSumTarget 0 p.1 p.2) m\nthis\u271d : \u2200 i < m.1, i < n.1\nthis : \u2200 i < m.2, i < n.2\n\u22a2 a \u2208 (fun p \u21a6 compPartialSumTarget 0 p.1 p.2) n",["aesop"]],["Order/UpperLower/Basic.lean",152,"\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : Set \u03b1\nhs : IsUpperSet s\n\u22a2 IsLowerSet (Subtype.val \u207b\u00b9' t) \u2194 \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t",["aesop"]],["Order/UpperLower/Basic.lean",155,"\u03b1 : Type u_1\ninst\u271d : LE \u03b1\ns t : Set \u03b1\nhs : IsLowerSet s\n\u22a2 IsUpperSet (Subtype.val \u207b\u00b9' t) \u2194 \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t",["aesop"]],["Order/Interval/Set/Basic.lean",1609,"\u22a2 Iic False = {False}",["aesop"]],["Order/Interval/Set/Basic.lean",1610,"\u22a2 Iic True = univ",["aesop"]],["Order/Interval/Set/Basic.lean",1612,"\u22a2 Ici True = {True}",["aesop"]],["Order/Interval/Set/Basic.lean",1613,"\u22a2 Iio False = \u2205",["aesop"]],["Order/Interval/Set/Basic.lean",1616,"\u22a2 Ioi True = \u2205",["aesop"]],["Analysis/Distribution/SchwartzSpace.lean",1188,"\ud835\udd5c : Type u_1\nE : Type u_4\nF : Type u_5\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : NormedAddCommGroup F\ninst\u271d\u2077 : NormedSpace \u211d F\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\ninst\u271d\u2074 : SMulCommClass \u211d \ud835\udd5c F\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : BorelSpace E\ninst\u271d\u00b9 : SecondCountableTopology E\ninst\u271d : CompleteSpace F\nx : E\n\u22a2 integralCLM \ud835\udd5c (dirac x) = delta \ud835\udd5c F x",["aesop"]],["Geometry/Manifold/VectorField/LieBracket.lean",175,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nH : Type u_2\ninst\u271d\u2074 : TopologicalSpace H\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nI : ModelWithCorners \ud835\udd5c E H\nM : Type u_4\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\ns t : Set M\nx : M\nV W : (x : M) \u2192 TangentSpace I x\nht : t \u2208 \ud835\udcdd x\ny : M\nhy : y \u2208 t\n\u22a2 (y \u2208 s \u2229 t) = (y \u2208 s)",["aesop"]],["Algebra/Group/Pointwise/Set/Basic.lean",474,"case h\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Mul \u03b2\ns\u2081 s\u2082 : Set \u03b1\nt\u2081 t\u2082 : Set \u03b2\nx\u271d : \u03b1 \u00d7 \u03b2\n\u22a2 (\u2203 a b, (a \u2208 s\u2081 \u2227 b \u2208 t\u2081) \u2227 \u2203 a_1 b_1, (a_1 \u2208 s\u2082 \u2227 b_1 \u2208 t\u2082) \u2227 (a * a_1, b * b_1) = x\u271d) \u2194\n    (\u2203 x \u2208 s\u2081, \u2203 y \u2208 s\u2082, x * y = x\u271d.1) \u2227 \u2203 x \u2208 t\u2081, \u2203 y \u2208 t\u2082, x * y = x\u271d.2",["aesop"]],["Data/Set/Image.lean",206,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : \u2200 a \u2208 s, f a = g a\n\u22a2 f '' s = g '' s",["aesop"]],["Data/Set/Image.lean",216,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\ng : \u03b1 \u2192 \u03b2\na : Set \u03b1\n\u22a2 f \u2218 g '' a = f '' (g '' a)",["aesop"]],["Data/Set/Image.lean",343,"case mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nS S' : Set \u03b2\nx : \u03b1\nr : range f \u2229 S \u2286 S'\nhx : f x \u2208 S\n\u22a2 f x \u2208 S'\n```\n---\n```lean\ncase mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nS S' : Set \u03b2\nr : f \u207b\u00b9' S \u2286 f \u207b\u00b9' S'\nx : \u03b2\nhx : (\u2203 y, f y = x) \u2227 x \u2208 S\n\u22a2 x \u2208 S'",["aesop"]],["Data/Set/Image.lean",634,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_4\ng : \u03b1 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\n\u22a2 range (g \u2218 f) = g '' range f",["aesop"]],["Algebra/Order/Floor.lean",777,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na : \u03b1\n\u22a2 \u2191\u230aa\u230b = a \u2194 a \u2208 range Int.cast",["aesop"]],["Algebra/Order/Floor.lean",1175,"\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na : \u03b1\n\u22a2 \u2191\u2308a\u2309 = a \u2194 a \u2208 range Int.cast",["aesop"]],["Data/Set/Card.lean",321,"\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 (\u2200 (a b : \u03b1), a \u2208 s \u2192 b \u2208 s \u2192 a = b) \u2194 \u2200 (x : \u03b1), \u00ac\u2203 b, x \u2208 s \u2227 b \u2208 s \u2227 x \u2260 b",["aesop"]],["Topology/Bases.lean",243,"case h.e'_4.h.a\n\u03b1 : Type u\nt : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nT : Set (Set \u03b2)\nhf : IsInducing f\nh : IsTopologicalBasis T\na : \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 preimage f '' T \u2227 a \u2208 s \u2194 s \u2208 (preimage f \u2218 fun t \u21a6 t) '' {i | i \u2208 T \u2227 f a \u2208 i}",["aesop"]],["Topology/Bases.lean",259,"case h.e'_4.h.a\n\u03b2 : Type u_1\nt\u2081 t\u2082 : TopologicalSpace \u03b2\nB\u2081 B\u2082 : Set (Set \u03b2)\nh\u2081 : IsTopologicalBasis B\u2081\nh\u2082 : IsTopologicalBasis B\u2082\na : \u03b2\nx\u271d : Set \u03b2\n\u22a2 x\u271d \u2208 image2 (fun x1 x2 \u21a6 x1 \u2229 x2) B\u2081 B\u2082 \u2227 a \u2208 x\u271d \u2194\n    x\u271d \u2208 (fun i \u21a6 i.1 \u2229 i.2) '' {i | (i.1 \u2208 B\u2081 \u2227 a \u2208 i.1) \u2227 i.2 \u2208 B\u2082 \u2227 a \u2208 i.2}",["aesop"]],["Topology/Bases.lean",872,"case h.e'_4.h.a\n\u03b9 : Type u_1\nE : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (E i)\ns : (i : \u03b9) \u2192 Set (Set (E i))\nhs : \u2200 (i : \u03b9), IsTopologicalBasis (s i)\na : (i : \u03b9) \u00d7 E i\nx\u271d : Set ((i : \u03b9) \u00d7 E i)\n\u22a2 x\u271d \u2208 \u22c3 i, (fun u \u21a6 Sigma.mk i '' u) '' s i \u2227 a \u2208 x\u271d \u2194\n    x\u271d \u2208 (fun i \u21a6 Sigma.mk a.fst '' i) '' {i | i \u2208 s a.fst \u2227 a.snd \u2208 i}",["aesop"]],["Combinatorics/SimpleGraph/Path.lean",231,"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n\u22a2 h.toWalk.IsPath",["aesop"]],["Combinatorics/SimpleGraph/Path.lean",308,"V : Type u\nG : SimpleGraph V\nu\u271d v\u271d v w u : V\nh : G.Adj v w\np : G.Walk w u\nihp :\n  p.IsPath \u2192 \u2200 \u2983n : \u2115\u2984, n \u2208 {i | i \u2264 p.length} \u2192 \u2200 \u2983m : \u2115\u2984, m \u2208 {i | i \u2264 p.length} \u2192 p.getVert n = p.getVert m \u2192 n = m\nhp : (cons h p).IsPath\nn : \u2115\nhn : n \u2264 p.length + 1\nm : \u2115\nhm : m \u2264 p.length + 1\nhn0 : n = 0\nhm0 : \u00acm = 0\nhnm : v = p.getVert (m - 1)\n\u22a2 v \u2209 p.support",["aesop"]],["Combinatorics/SimpleGraph/Path.lean",311,"V : Type u\nG : SimpleGraph V\nu\u271d v\u271d v w u : V\nh : G.Adj v w\np : G.Walk w u\nihp :\n  p.IsPath \u2192 \u2200 \u2983n : \u2115\u2984, n \u2208 {i | i \u2264 p.length} \u2192 \u2200 \u2983m : \u2115\u2984, m \u2208 {i | i \u2264 p.length} \u2192 p.getVert n = p.getVert m \u2192 n = m\nhp : (cons h p).IsPath\nn : \u2115\nhn : n \u2264 p.length + 1\nm : \u2115\nhm : m \u2264 p.length + 1\nhn0 : \u00acn = 0\nhm0 : m = 0\nhnm : p.getVert (n - 1) = (cons h p).getVert 0\n\u22a2 v \u2209 p.support",["aesop"]],["Combinatorics/SimpleGraph/Path.lean",1171,"case pos\nV : Type u\nG : SimpleGraph V\nv w : V\nc : G.ConnectedComponent\nh : v \u2208 c.supp\nh' : v \u2208 c.supp \u2227 G.Adj v w\nthis : w \u2208 c.supp\n\u22a2 (induce c.supp G).spanningCoe.Adj v w",["aesop"]],["Data/DFinsupp/Defs.lean",842,"\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 f = mk f.support fun i \u21a6 f \u2191i",["aesop"]],["Data/Matroid/Closure.lean",120,"case h.e'_3.h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Matroid \u03b1\nF X Y : Set \u03b1\ne f : \u03b1\nM : Matroid \u03b1\ns : Set \u2191(Iic M.E)\nhs : \u2200 a \u2208 s, (fun F \u21a6 M.IsFlat \u2191F) a\nhne : s.Nonempty\nx\u271d\u00b9 : Nonempty \u2191s\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191(sInf s) \u2194 x\u271d \u2208 \u22c2 i, \u2191\u2191i",["aesop"]],["Order/Atoms.lean",564,"\u03b1 : Type u_2\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsAtomistic \u03b1\na b : \u03b1\nh : \u2200 (c : \u03b1), IsAtom c \u2192 (c \u2264 a \u2194 c \u2264 b)\n\u22a2 (\u2200 (c : \u03b1), IsAtom c \u2192 c \u2264 a \u2192 c \u2264 b) \u2227 \u2200 (c : \u03b1), IsAtom c \u2192 c \u2264 b \u2192 c \u2264 a",["aesop"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",741,"R : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u2070 : Semifield R\ninst\u271d\u2079 : StarRing R\ninst\u271d\u2078 : MetricSpace R\ninst\u271d\u2077 : IsTopologicalSemiring R\ninst\u271d\u2076 : ContinuousStar R\ninst\u271d\u2075 : TopologicalSpace A\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : ContinuousFunctionalCalculus R p\ninst\u271d : HasContinuousInv\u2080 R\nf : R \u2192 R\na : A\nhf' : \u2200 x \u2208 spectrum R a, f x \u2260 0\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto\u271d\nha : autoParam (p a) _auto\u271d\nx\u271d\u00b9 : R\nx\u271d : x\u271d\u00b9 \u2208 spectrum R a\n\u22a2 f x\u271d\u00b9 * (f x\u271d\u00b9)\u207b\u00b9 = 1 x\u271d\u00b9",["aesop"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Unital.lean",744,"R : Type u_1\nA : Type u_2\np : A \u2192 Prop\ninst\u271d\u00b9\u2070 : Semifield R\ninst\u271d\u2079 : StarRing R\ninst\u271d\u2078 : MetricSpace R\ninst\u271d\u2077 : IsTopologicalSemiring R\ninst\u271d\u2076 : ContinuousStar R\ninst\u271d\u2075 : TopologicalSpace A\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : ContinuousFunctionalCalculus R p\ninst\u271d : HasContinuousInv\u2080 R\nf : R \u2192 R\na : A\nhf' : \u2200 x \u2208 spectrum R a, f x \u2260 0\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto\u271d\nha : autoParam (p a) _auto\u271d\nx\u271d\u00b9 : R\nx\u271d : x\u271d\u00b9 \u2208 spectrum R a\n\u22a2 (f x\u271d\u00b9)\u207b\u00b9 * f x\u271d\u00b9 = 1 x\u271d\u00b9",["aesop"]],["Data/Set/Basic.lean",1005,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Sum.inl '' s\u1d9c \u222a Sum.inr '' t\u1d9c = (Sum.inl '' s)\u1d9c \u2229 (Sum.inr '' t)\u1d9c",["aesop"]],["Order/Hom/Basic.lean",469,"F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : Preorder \u03b3\ninst\u271d\u00b9 : Preorder \u03b4\n\u03b9 : Type u_6\n\u03c0 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 Preorder (\u03c0 i)\np q : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), p a \u2192 q a\n\u22a2 \u2200 {a b : { x // p x }}, __src\u271d a \u2264 __src\u271d b \u2194 a \u2264 b",["aesop"]],["LinearAlgebra/Dual/Lemmas.lean",752,"K : Type uK\ninst\u271d\u00b3 : Field K\nV\u2081 : Type uV\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2081\ninst\u271d\u00b9 : Module K V\u2081\ninst\u271d : FiniteDimensional K V\u2081\nf g : Dual K V\u2081\nx : V\u2081\nh : LinearMap.ker f = LinearMap.ker g\nh' : f x = g x\nhx : f x \u2260 0\np : Submodule K V\u2081 := span K {x}\n\u22a2 p \u2260 \u22a5",["aesop"]],["LinearAlgebra/Dual/Lemmas.lean",759,"K : Type uK\ninst\u271d\u00b3 : Field K\nV\u2081 : Type uV\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2081\ninst\u271d\u00b9 : Module K V\u2081\ninst\u271d : FiniteDimensional K V\u2081\nf g : Dual K V\u2081\nx : V\u2081\nh : LinearMap.ker f = LinearMap.ker g\nh' : f x = g x\nhx : f x \u2260 0\np : Submodule K V\u2081 := span K {x}\nhp : p \u2260 \u22a5\nhpf : Disjoint (LinearMap.ker f) p\n\u22a2 f \u2260 0",["aesop"]],["CategoryTheory/Preadditive/Biproducts.lean",457,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Preadditive C\nX Y : C\ninst\u271d : HasBinaryBiproduct X Y\nZ : C\nf g : Z \u27f6 X \u229e Y\n\u22a2 f = g \u2194 f \u226b fst = g \u226b fst \u2227 f \u226b snd = g \u226b snd",["aesop"]],["CategoryTheory/Preadditive/Biproducts.lean",465,"C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : Preadditive C\nX Y : C\ninst\u271d : HasBinaryBiproduct X Y\nZ : C\nf g : X \u229e Y \u27f6 Z\n\u22a2 f = g \u2194 inl \u226b f = inl \u226b g \u2227 inr \u226b f = inr \u226b g",["aesop"]],["Combinatorics/SimpleGraph/Subgraph.lean",177,"V : Type u\nv w : V\ns : Set V\nG : SimpleGraph \u2191s\nhadj : G.spanningCoe.Adj v w\n\u22a2 v \u2208 s",["aesop"]],["Combinatorics/SimpleGraph/Subgraph.lean",183,"case Adj.h.h.a\nV : Type u\nG : SimpleGraph V\nv\u271d w\u271d : V\nhadj : G.Adj v\u271d w\u271d\nv w : V\n\u22a2 (G.subgraphOfAdj hadj).spanningCoe.Adj v w \u2194 (fromEdgeSet {s(v\u271d, w\u271d)}).Adj v w",["aesop"]],["LinearAlgebra/Eigenspace/Basic.lean",274,"case h.e'_2.e_a\nR : Type v\nM : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherian R M\nf : End R M\n\u03bc : R\nthis :\n  iSup \u21d1((f.genEigenspace \u03bc).comp WithTop.coeOrderHom.toOrderHom) =\n    monotonicSequenceLimit ((f.genEigenspace \u03bc).comp WithTop.coeOrderHom.toOrderHom)\n\u22a2 (range fun l \u21a6 LinearMap.ker ((f - \u03bc \u2022 1) ^ l)) = range fun x \u21a6 LinearMap.ker ((f - \u03bc \u2022 1) ^ (\u2191x).2)",["aesop"]],["Analysis/RCLike/Basic.lean",765,"K : Type u_1\ninst\u271d : RCLike K\nz : K\n\u22a2 0 \u2264 re z \u2227 im z = 0 \u2194 \u2203 x \u2265 0, re \u2191x = re z \u2227 im \u2191x = im z",["aesop"]],["Analysis/RCLike/Basic.lean",768,"K : Type u_1\ninst\u271d : RCLike K\nz : K\n\u22a2 0 < re z \u2227 im z = 0 \u2194 \u2203 x > 0, re \u2191x = re z \u2227 im \u2191x = im z",["aesop"]],["Analysis/RCLike/Basic.lean",771,"K : Type u_1\ninst\u271d : RCLike K\nz : K\n\u22a2 re z \u2264 0 \u2227 im z = 0 \u2194 \u2203 x \u2264 0, re \u2191x = re z \u2227 im \u2191x = im z",["aesop"]],["Analysis/RCLike/Basic.lean",774,"K : Type u_1\ninst\u271d : RCLike K\nz : K\n\u22a2 re z < 0 \u2227 im z = 0 \u2194 \u2203 x < 0, re \u2191x = re z \u2227 im \u2191x = im z",["aesop"]],["GroupTheory/CoprodI.lean",352,"case pos\n\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Monoid (M i)\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (M i)\ni : \u03b9\nm : M i\nw : Word M\nh : w.fstIdx \u2260 some i\nm' : M i\nw' : Word M\nh' : w'.fstIdx \u2260 some i\nhm : m = 1\nhm' : m' = 1\nhe : w = w'\n\u22a2 { head := m, tail := w, fstIdx_ne := h } = { head := m', tail := w', fstIdx_ne := h' }",["aesop"]],["AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean",839,"R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Algebra R A\n\ud835\udc9c : \u2115 \u2192 Submodule R A\ninst\u271d : GradedAlgebra \ud835\udc9c\nx : \u2191Proj.T\nthis : \u2200 (f : A) (m : \u2115), f \u2208 \ud835\udc9c m \u2192 0 < m \u2192 f \u2208 x.asHomogeneousIdeal\nz : A\nhz : z \u2208 HomogeneousIdeal.irrelevant \ud835\udc9c\nk : \u2115\nhk : k \u2208 DFinsupp.support ((decompose \ud835\udc9c) z)\n\u22a2 \u00ac0 < k \u2192 False",["aesop"]],["Topology/Order/IntermediateValue.lean",606,"case pos.intro\n\u03b1 : Type u\ninst\u271d\u2077 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : OrderTopology \u03b1\ninst\u271d\u2074 : DenselyOrdered \u03b1\n\u03b4 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b4\ninst\u271d\u00b2 : TopologicalSpace \u03b4\ninst\u271d\u00b9 : OrderClosedTopology \u03b4\ninst\u271d : BoundedOrder \u03b1\nf : \u03b1 \u2192 \u03b4\nhf_c : Continuous f\nhf : f \u22a5 \u2264 f \u22a4\nhf_i : Injective f\na b : \u03b1\nhab : a < b\nh : f b \u2264 f a\nH : f b < f a\nha : f a \u2264 f \u22a5\nu : \u03b1\nhu : u \u2208 Ioc b \u22a4 \u2227 f u = f \u22a5\nthis : u = \u22a5\n\u22a2 False",["aesop"]],["Topology/Order/IntermediateValue.lean",615,"case neg.intro\n\u03b1 : Type u\ninst\u271d\u2077 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : OrderTopology \u03b1\ninst\u271d\u2074 : DenselyOrdered \u03b1\n\u03b4 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b4\ninst\u271d\u00b2 : TopologicalSpace \u03b4\ninst\u271d\u00b9 : OrderClosedTopology \u03b4\ninst\u271d : BoundedOrder \u03b1\nf : \u03b1 \u2192 \u03b4\nhf_c : Continuous f\nhf : f \u22a5 \u2264 f \u22a4\nhf_i : Injective f\na b : \u03b1\nhab : a < b\nh : f b \u2264 f a\nH : f b < f a\nha : f \u22a5 < f a\nhb : f b < f \u22a5\nu : \u03b1\nhu : u \u2208 Ioo a b \u2227 f u = f \u22a5\nthis : u = \u22a5\n\u22a2 False",["aesop"]],["LinearAlgebra/SesquilinearForm.lean",939,"R : Type u_1\nM : Type u_5\ninst\u271d\u00b2 : LinearOrderedCommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nB : LinearMap.BilinForm R M\nhs : \u2200 (x : M), 0 \u2264 (B x) x\nhB : IsSymm B\nx : M\n\u22a2 B x = 0 \u2192 x = 0 \u2194 (B x = 0 \u2194 x = 0)",["aesop"]],["CategoryTheory/Limits/Shapes/Types.lean",711,"X Y Z : Type u\nf : X \u27f6 Z\ng : Y \u27f6 Z\n\u22a2 (pullbackIsoPullback f g).inv \u226b pullback.fst f g = fun p \u21a6 (\u2191p).1",["aesop"]],["CategoryTheory/Limits/Shapes/Types.lean",715,"X Y Z : Type u\nf : X \u27f6 Z\ng : Y \u27f6 Z\n\u22a2 (pullbackIsoPullback f g).inv \u226b pullback.snd f g = fun p \u21a6 (\u2191p).2",["aesop"]],["Data/Matroid/Circuit.lean",321,"\u03b1 : Type u_1\nM : Matroid \u03b1\nI : Set \u03b1\n\u22a2 \u00ac((\u2203 C \u2286 I, M.IsCircuit C) \u2227 I \u2286 M.E) \u2227 I \u2286 M.E \u2194 (\u2200 C \u2286 I, \u00acM.IsCircuit C) \u2227 I \u2286 M.E",["aesop"]],["GroupTheory/SpecificGroups/Cyclic.lean",704,"\u03b1 : Type u_1\ninst\u271d : Group \u03b1\np : \u2115\nhp : Nat.Prime p\nh\u03b1 : Nat.card \u03b1 = p ^ 2\nthis\u271d : Finite \u03b1\nthis : Nontrivial \u03b1\nh_cyc : \u00acIsCyclic \u03b1\ng : \u03b1\nhg : g \u2260 1\na : \u2115\nha : 2 < 3\nha' : p ^ 2 = orderOf g\n\u22a2 orderOf g = Nat.card \u03b1",["aesop"]],["Data/Nat/Digits.lean",306,"case pos\nb : \u2115\nhb : 1 < b\nn : \u2115\nIH : \u2200 m < n, m \u2260 0 \u2192 (b.digits m).length = log b m + 1\nhn : n \u2260 0\nh : n / b = 0\n\u22a2 n < b \u2228 b \u2264 1",["aesop"]],["Data/Set/Prod.lean",156,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b3 \u2192 \u03b4\ns : Set \u03b1\nt : Set \u03b3\nx\u271d : \u03b2 \u00d7 \u03b4\n\u22a2 x\u271d \u2208 Prod.map f g '' s \u00d7\u02e2 t \u2194 x\u271d \u2208 (f '' s) \u00d7\u02e2 (g '' t)",["aesop"]],["Algebra/Lie/Weights/Basic.lean",228,"case mk.mk\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : LieAlgebra R L\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieModule R L M\ninst\u271d : LieRing.IsNilpotent L\nf\u2081 : L \u2192 R\ngenWeightSpace_ne_bot'\u271d\u00b9 : genWeightSpace M f\u2081 \u2260 \u22a5\nf\u2082 : L \u2192 R\ngenWeightSpace_ne_bot'\u271d : genWeightSpace M f\u2082 \u2260 \u22a5\nh :\n  \u2200 (x : L),\n    { toFun := f\u2081, genWeightSpace_ne_bot' := genWeightSpace_ne_bot'\u271d\u00b9 } x =\n      { toFun := f\u2082, genWeightSpace_ne_bot' := genWeightSpace_ne_bot'\u271d } x\n\u22a2 { toFun := f\u2081, genWeightSpace_ne_bot' := genWeightSpace_ne_bot'\u271d\u00b9 } =\n    { toFun := f\u2082, genWeightSpace_ne_bot' := genWeightSpace_ne_bot'\u271d }",["aesop"]],["RingTheory/HahnSeries/Multiplication.lean",506,"R : Type u_3\n\u0393 : Type u_6\ninst\u271d\u00b9 : LinearOrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nx y : HahnSeries \u0393 R\nh : x.leadingCoeff * y.leadingCoeff \u2260 0\n\u22a2 x.leadingCoeff \u2260 0",["aesop"]],["RingTheory/HahnSeries/Multiplication.lean",507,"R : Type u_3\n\u0393 : Type u_6\ninst\u271d\u00b9 : LinearOrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nx y : HahnSeries \u0393 R\nh : x.leadingCoeff * y.leadingCoeff \u2260 0\nhx : x.leadingCoeff \u2260 0\n\u22a2 y.leadingCoeff \u2260 0",["aesop"]],["Geometry/Manifold/LocalInvariantProperties.lean",345,"case e_s\nH : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nG : StructureGroupoid H\nG' : StructureGroupoid H'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\ng : M \u2192 M'\ns t : Set M\nx : M\nhG : G.LocalInvariantProp G' P\nhu : s =\u1da0[\ud835\udcdd x] t\n\u22a2 s \u2229 {x | (fun x \u21a6 s x = t x) x} = t \u2229 {x | (fun x \u21a6 s x = t x) x}",["aesop"]],["Combinatorics/SimpleGraph/Clique.lean",241,"\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ns : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nha : \u2200 w \u2208 s \\ {b}, G.Adj a w\nhb : b \u2208 s\nn\u271d : \u2115\nhs : G.IsNClique (n\u271d + 1) s\nw : \u03b1\nh : w \u2208 s.erase b\n\u22a2 G.Adj a w",["aesop"]],["AlgebraicTopology/SimplexCategory/Basic.lean",35,"\u22a2 \u298b0\u298c.const \u298b0\u298c 0 = \ud835\udfd9 \u298b0\u298c",["aesop"]],["AlgebraicTopology/SimplexCategory/Basic.lean",448,"case a.h.h.h.\u00ab_@\u00bb.Mathlib.AlgebraicTopology.SimplexCategory.Defs._hyg.913.\u00ab0\u00bb\nn : \u2115\ni : Fin n\n\u22a2 \u2191((Hom.toOrderHom (\u03b4 1 \u226b mkOfSucc i)) ((fun i \u21a6 i) \u27e80, \u22ef\u27e9)) =\n    \u2191((Hom.toOrderHom (\u298b0\u298c.const \u298bn\u298c \u2191\u2191i.castSucc)) ((fun i \u21a6 i) \u27e80, \u22ef\u27e9))",["aesop"]],["Data/Matroid/Map.lean",190,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nE : Set \u03b2\n\u22a2 ((loopyOn E).comap f).E = f \u207b\u00b9' E \u2227 \u2200 X \u2286 ((loopyOn E).comap f).E, ((loopyOn E).comap f).Indep X \u2192 X = \u2205",["aesop"]],["ModelTheory/Substructures.lean",769,"L : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst\u271d\u00b2 : L.Structure M\ninst\u271d\u00b9 : L.Structure N\ninst\u271d : L.Structure P\nS : L.Substructure M\np : L.Substructure N\nf\u271d : M \u2192[L] N\nh : \u2200 (c : M), f\u271d c \u2208 p\nn : \u2115\nf : L.Functions n\nx : Fin n \u2192 M\n\u22a2 (fun c \u21a6 \u27e8f\u271d c, \u22ef\u27e9) (funMap f x) = funMap f ((fun c \u21a6 \u27e8f\u271d c, \u22ef\u27e9) \u2218 x)",["aesop"]],["Analysis/SpecificLimits/Basic.lean",105,"case h\n\u03b1 : Type u_4\nG : Type u_5\ninst\u271d : GroupWithZero G\nf g : \u03b1 \u2192 G\nl : Filter \u03b1\nhg : Tendsto g l (\ud835\udcdf {0}\u1d9c)\nx : \u03b1\nhx : x \u2208 g \u207b\u00b9' {0}\u1d9c\n\u22a2 f x / g x * g x = f x",["aesop"]],["Order/BooleanAlgebra.lean",300,"\u03b1 : Type u\nx y : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 x \\ y = \u22a5 \u2227 y = \u22a5 \u2194 x = \u22a5 \u2227 y = \u22a5",["aesop"]],["Order/BooleanAlgebra.lean",695,"\u03b1 : Type u\nx y : \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x \u21e8 y = \u22a4 \u2227 x = \u22a4 \u2194 x = \u22a4 \u2227 y = \u22a4",["aesop"]],["Order/RelSeries.lean",360,"case h.e'_1\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\n\u03b2 : Type u_2\ns : Rel \u03b2 \u03b2\np : RelSeries r\ni : Fin p.length\na : \u03b1\nprev_connect : r (p.toFun i.castSucc) a\nconnect_next : r a (p.toFun i.succ)\nm : Fin (p.length + 1)\nx : \u03b1 := i.succ.castSucc.insertNth a p.toFun m.castSucc\ny : \u03b1 := i.succ.castSucc.insertNth a p.toFun m.succ\nhm : \u2191i + 1 < \u2191m\n\u22a2 Eq.recOn \u22ef (p.toFun (m.castSucc.pred \u22ef)) = p.toFun \u27e8\u2191m - 1, \u22ef\u27e9.castSucc",["aesop"]],["Order/RelSeries.lean",536,"case h.e'_3.e_a\n\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\n\u03b2 : Type u_2\ns : Rel \u03b2 \u03b2\np q : RelSeries r\nconnect : p.last = q.head\ni : Fin (p.length + q.length)\nh\u2082 : \u00ac\u2191i + 1 < p.length\nh\u2081 : \u2191i < p.length\nh\u2083 : p.length = \u2191i + 1\n\u22a2 \u27e8\u2191i, h\u2081\u27e9.succ = Fin.last p.length",["aesop"]],["Order/RelSeries.lean",593,"\u03b1 : Type u_1\nr : Rel \u03b1 \u03b1\np q : RelSeries r\nh : p.last = q.head\n\u22a2 { length := p.length + q.length,\n          toFun := fun i \u21a6 if H : \u2191i < p.length then p.toFun \u27e8\u2191i, \u22ef\u27e9 else q.toFun \u27e8\u2191i - p.length, \u22ef\u27e9, step := \u22ef }.toFun\n      (Fin.last\n        { length := p.length + q.length,\n            toFun := fun i \u21a6 if H : \u2191i < p.length then p.toFun \u27e8\u2191i, \u22ef\u27e9 else q.toFun \u27e8\u2191i - p.length, \u22ef\u27e9,\n            step := \u22ef }.length) =\n    q.toFun (Fin.last q.length)",["aesop"]],["GroupTheory/FreeGroup/Basic.lean",544,"\u03b1 : Type u\nx\u271d\u00b9 x\u271d : \u03b1\nH : of x\u271d\u00b9 = of x\u271d\nL\u2081 : List (\u03b1 \u00d7 Bool)\nhx : L\u2081 = [(x\u271d\u00b9, true)]\nhy : L\u2081 = [(x\u271d, true)]\n\u22a2 x\u271d\u00b9 = x\u271d",["aesop"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",635,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Linear R C\nF G K L : CochainComplex C \u2124\nn m : \u2124\nx\u271d : Cocycle F G n\n\u22a2 1 \u2022 x\u271d = x\u271d",["aesop"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",637,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Linear R C\nF G K L : CochainComplex C \u2124\nn m : \u2124\nx\u271d : R\n\u22a2 x\u271d \u2022 0 = 0",["aesop"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",638,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Linear R C\nF G K L : CochainComplex C \u2124\nn m : \u2124\nx\u271d\u00b2 : R\nx\u271d\u00b9 x\u271d : Cocycle F G n\n\u22a2 x\u271d\u00b2 \u2022 (x\u271d\u00b9 + x\u271d) = x\u271d\u00b2 \u2022 x\u271d\u00b9 + x\u271d\u00b2 \u2022 x\u271d",["aesop"]],["Algebra/Homology/HomotopyCategory/HomComplex.lean",640,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Preadditive C\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Linear R C\nF G K L : CochainComplex C \u2124\nn m : \u2124\n\u22a2 \u2200 (x : Cocycle F G n), 0 \u2022 x = 0",["aesop"]],["Analysis/Calculus/FDeriv/Symmetric.lean",578,"case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ns : Set E\nf : E \u2192 F\nx : E\nn : WithTop \u2115\u221e\nhf : ContDiffWithinAt \ud835\udd5c n f s x\nhn : minSmoothness \ud835\udd5c 2 \u2264 n\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 closure (interior s)\nh'x : x \u2208 s\nm : WithTop \u2115\u221e\nhm : minSmoothness \ud835\udd5c \u21912 \u2264 m\nhmn : m \u2264 n\nm_ne : m \u2260 \u221e\nu : Set E\nu_open : IsOpen u\nxu : x \u2208 u\nhu : ContDiffOn \ud835\udd5c m f (s \u2229 u)\nh'u : UniqueDiffOn \ud835\udd5c (s \u2229 u)\ny\u271d : \u2115 \u2192 E\nhy\u271d : \u2200 (n : \u2115), y\u271d n \u2208 interior s\ny_lim : Tendsto y\u271d atTop (\ud835\udcdd x)\nL : \u2200\u1da0 (k : \u2115) in atTop, y\u271d k \u2208 u\nI : \u2200\u1da0 (k : \u2115) in atTop, IsSymmSndFDerivWithinAt \ud835\udd5c f s (y\u271d k)\nthis : ContinuousOn (fderivWithin \ud835\udd5c (fderivWithin \ud835\udd5c f (s \u2229 u)) (s \u2229 u)) (s \u2229 u)\ny : E\nhy : y \u2208 s \u2229 u\nz : E\nhz : z \u2208 u\n\u22a2 (z \u2208 s) = (z \u2208 s \u2229 u)",["aesop"]],["Order/OmegaCompletePartialOrder.lean",138,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nc c' : Chain \u03b1\nf : \u03b1 \u2192o \u03b2\ng : \u03b2 \u2192o \u03b3\na b : \u03b1\nhab : a \u2264 b\nx\u271d\u00b2 x\u271d\u00b9 : \u2115\nx\u271d : x\u271d\u00b2 \u2264 x\u271d\u00b9\n\u22a2 (fun x \u21a6\n        match x with\n        | 0 => a\n        | x => b)\n      x\u271d\u00b2 \u2264\n    (fun x \u21a6\n        match x with\n        | 0 => a\n        | x => b)\n      x\u271d\u00b9",["aesop"]],["Order/OmegaCompletePartialOrder.lean",144,"\u03b1 : Type u_2\ninst\u271d : Preorder \u03b1\na b : \u03b1\nhab : a \u2264 b\nx\u271d : \u03b1\n\u22a2 ((pair a b hab) 0 = x\u271d \u2228 \u2203 n, (pair a b hab) (n + 1) = x\u271d) \u2194 x\u271d \u2208 {a, b}",["aesop"]],["GroupTheory/Perm/Cycle/Type.lean",155,"case e_s\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Perm \u03b1\n\u22a2 Finset.filter (Membership.mem (Function.fixedPoints \u21d1\u03c3)) Finset.univ = \u03c3.support\u1d9c",["aesop"]],["CategoryTheory/Limits/Types.lean",123,"J : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : J \u2964 Type u\ninst\u271d : Small.{u, max u v} \u2191F.sections\nx y : (limitCone F).pt\nw : (equivShrink \u2191F.sections).symm x = (equivShrink \u2191F.sections).symm y\n\u22a2 x = y",["aesop"]],["Algebra/Lie/Weights/Killing.lean",423,"K : Type u_2\nL : Type u_3\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : LieAlgebra K L\ninst\u271d\u2074 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b3 : H.IsCartanSubalgebra\ninst\u271d\u00b2 : IsKilling K L\ninst\u271d\u00b9 : IsTriangularizable K (\u21a5H) L\ninst\u271d : CharZero K\n\u03b1 : Weight K (\u21a5H) L\nh\u03b1 : \u00ac\u03b1.IsZero\n\u22a2 Weight.toLinear K (\u21a5H) L \u03b1 \u2260 0",["aesop"]],["LinearAlgebra/Matrix/SesquilinearForm.lean",78,"R\u2081 : Type u_2\nS\u2081 : Type u_3\nR\u2082 : Type u_4\nS\u2082 : Type u_5\nN\u2082 : Type u_10\nn : Type u_11\nm : Type u_12\ninst\u271d\u00b9\u00b9 : Semiring R\u2081\ninst\u271d\u00b9\u2070 : Semiring S\u2081\ninst\u271d\u2079 : Semiring R\u2082\ninst\u271d\u2078 : Semiring S\u2082\ninst\u271d\u2077 : AddCommMonoid N\u2082\ninst\u271d\u2076 : Module S\u2081 N\u2082\ninst\u271d\u2075 : Module S\u2082 N\u2082\ninst\u271d\u2074 : SMulCommClass S\u2082 S\u2081 N\u2082\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : Fintype m\n\u03c3\u2081 : R\u2081 \u2192+* S\u2081\n\u03c3\u2082 : R\u2082 \u2192+* S\u2082\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : DecidableEq m\nf : Matrix n m N\u2082\ni : n\nj : m\nthis : \u2211 i' : n, \u2211 j' : m, (if i = i' then 1 else 0) \u2022> (if j = j' then 1 else 0) \u2022> f i' j' = f i j\nx\u271d\u00b3 : n\nx\u271d\u00b2 : x\u271d\u00b3 \u2208 univ\nx\u271d\u00b9 : m\nx\u271d : x\u271d\u00b9 \u2208 univ\n\u22a2 \u03c3\u2082 (Pi.single j 1 x\u271d\u00b9) \u2022> \u03c3\u2081 (Pi.single i 1 x\u271d\u00b3) \u2022> f x\u271d\u00b3 x\u271d\u00b9 =\n    (if i = x\u271d\u00b3 then 1 else 0) \u2022> (if j = x\u271d\u00b9 then 1 else 0) \u2022> f x\u271d\u00b3 x\u271d\u00b9",["aesop"]],["Probability/Kernel/Composition/CompProd.lean",611,"case h.h.h.e_6.h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nm\u03b1 : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nm\u03b3 : MeasurableSpace \u03b3\n\u03b4 : Type u_4\nm\u03b4 : MeasurableSpace \u03b4\n\u03ba : Kernel \u03b1 \u03b2\ninst\u271d\u00b9 : IsSFiniteKernel \u03ba\n\u03b7 : Kernel (\u03b1 \u00d7 \u03b2) \u03b3\ninst\u271d : IsSFiniteKernel \u03b7\nf : \u03b4 \u2192 \u03b3\nhf : MeasurableEmbedding f\na : \u03b1\nt : Set (\u03b2 \u00d7 \u03b4)\nht : MeasurableSet t\nb : \u03b2\nx : \u03b3\n\u22a2 x \u2208 Prod.mk b \u207b\u00b9' (Prod.map id f '' t) \u2194 x \u2208 f '' (Prod.mk b \u207b\u00b9' t)",["aesop"]],["Data/Sym/Sym2.lean",364,"case mp.h\n\u03b1 : Type u_1\nx y : \u03b1\nhne : x \u2260 y\nx' y' : \u03b1\n\u22a2 (x = x' \u2228 x = y') \u2227 (y = x' \u2228 y = y') \u2192 s(x', y') = s(x, y)",["aesop"]],["Data/Sym/Sym2.lean",430,"case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nP : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 P a \u2192 \u03b2\nb : \u03b2\nx y : \u03b1\nh : \u2200 a \u2208 s(x, y), P a\n\u22a2 b \u2208 s(f x \u22ef, f y \u22ef) \u2194 \u2203 a, \u2203 (ha : a \u2208 s(x, y)), b = f a \u22ef",["aesop"]],["Data/Sym/Sym2.lean",561,"case h\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nsym : Symmetric r\nh : Irreflexive r\n\u22a2 \u2200 (x y : \u03b1), s(x, y) \u2208 fromRel sym \u2192 \u00acs(x, y).IsDiag",["aesop"]],["Algebra/GroupWithZero/Associated.lean",238,"M : Type u_1\ninst\u271d : CancelCommMonoidWithZero M\np : M\nn : \u2115\nhp : Prime (p ^ n)\nthis : n = 1\n\u22a2 Prime p \u2227 n = 1",["aesop"]],["Order/Minimal.lean",577,"case h.e'_3.h.e'_2.h.h.e'_3.h.a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\n\u03b2 : Type u_2\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2243o \u03b2\nP : \u03b1 \u2192 Prop\nx\u271d\u00b9 x\u271d : \u03b2\n\u22a2 P (f.symm x\u271d) \u2194 \u2203 x\u2080, P x\u2080 \u2227 f x\u2080 = x\u271d",["aesop"]],["Order/Minimal.lean",582,"case h.e'_3.h.e'_2.h.h.e'_3.h.a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\n\u03b2 : Type u_2\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2243o \u03b2\nP : \u03b1 \u2192 Prop\nx\u271d\u00b9 x\u271d : \u03b2\n\u22a2 P (f.symm x\u271d) \u2194 \u2203 x\u2080, P x\u2080 \u2227 f x\u2080 = x\u271d",["aesop"]],["Combinatorics/SimpleGraph/Matching.lean",142,"case h\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.Adj v w\nv\u271d : V\nh\u271d : v\u271d = v\n\u22a2 (fun w_1 \u21a6 (G.subgraphOfAdj h).Adj v\u271d w_1) w \u2227 \u2200 (y : V), (fun w_1 \u21a6 (G.subgraphOfAdj h).Adj v\u271d w_1) y \u2192 y = w",["aesop"]],["Combinatorics/SimpleGraph/Matching.lean",143,"case h\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.Adj v w\nv\u271d : V\nh\u271d : v\u271d = w\n\u22a2 (fun w_1 \u21a6 (G.subgraphOfAdj h).Adj v\u271d w_1) v \u2227 \u2200 (y : V), (fun w_1 \u21a6 (G.subgraphOfAdj h).Adj v\u271d w_1) y \u2192 y = v",["aesop"]],["Combinatorics/SimpleGraph/Matching.lean",168,"V : Type u_1\nG : SimpleGraph V\ns t : Set V\nh : Disjoint s t\nf : \u2191s \u2243 \u2191t\nhadj : \u2200 (v : \u2191s), G.Adj \u2191v \u2191(f v)\n\u22a2 \u2200 {v w : V}, (fun v w \u21a6 (\u2203 (h : v \u2208 s), \u2191(f \u27e8v, h\u27e9) = w) \u2228 \u2203 (h : w \u2208 s), \u2191(f \u27e8w, h\u27e9) = v) v w \u2192 v \u2208 s \u222a t",["aesop"]],["Combinatorics/SimpleGraph/Matching.lean",356,"case h.intro.intro\nV : Type u_1\nG : SimpleGraph V\nv w : V\nh : G.IsCycles\nw' : V\nhww : w \u2260 w'\ny : V\nhwy : w \u2260 y\nx y' : V\nhxy' : x \u2260 y' \u2227 G.neighborSet v = {x, y'}\nhadj : w \u2208 G.neighborSet v\nhww' : w' \u2208 G.neighborSet v\nhwy' : y \u2208 G.neighborSet v\n\u22a2 y = w'",["aesop"]],["Combinatorics/SimpleGraph/Matching.lean",381,"case Adj.h.h.a\nV : Type u_1\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nhp : p.IsPath\nh : u \u2260 v\nhs : s(v, u) \u2209 p.edges\nc : (completeGraph V).Walk v v := cons \u22ef (Walk.mapLe \u22ef p)\nw x : V\n\u22a2 p.toSubgraph.Adj w x \u2228 (w = v \u2227 x = u \u2228 w = u \u2227 x = v) \u2227 w \u2260 x \u2194 s(v, u) = s(w, x) \u2228 p.toSubgraph.Adj w x",["aesop"]],["Combinatorics/SimpleGraph/Matching.lean",411,"case h\nV : Type u_1\nG G' : SimpleGraph V\nM : G.Subgraph\nM' : G'.Subgraph\nhM : M.IsPerfectMatching\nhM' : M'.IsPerfectMatching\nv w : V\nhw : (fun w \u21a6 M.Adj v w) w \u2227 \u2200 (y : V), (fun w \u21a6 M.Adj v w) y \u2192 y = w\nw' : V\nhw' : (fun w \u21a6 M'.Adj v w) w' \u2227 \u2200 (y : V), (fun w \u21a6 M'.Adj v w) y \u2192 y = w'\nhww' : \u00acw = w'\n\u22a2 \u00acw = w' \u2227 (M.spanningCoe \\ M'.spanningCoe \u2294 M'.spanningCoe \\ M.spanningCoe).neighborSet v = {w, w'}",["aesop"]],["Combinatorics/SimpleGraph/Matching.lean",594,"case intro.intro.intro.intro\nV : Type u_1\nG G' : SimpleGraph V\nM : G.Subgraph\nM' : G'.Subgraph\nhM : M.IsPerfectMatching\nhM' : M'.IsPerfectMatching\nv w w' : V\nhww' : w \u2260 w'\nhvw : (M.spanningCoe \\ M'.spanningCoe \u2294 M'.spanningCoe \\ M.spanningCoe).Adj v w\nhvw' : (M.spanningCoe \\ M'.spanningCoe \u2294 M'.spanningCoe \\ M.spanningCoe).Adj v w'\nv1 : V\nhm1 : M.Adj v v1\nhv1 : \u2200 (y : V), M.Adj v y \u2192 y = v1\nv2 : V\nhm2 : M'.Adj v v2\nhv2 : \u2200 (y : V), M'.Adj v y \u2192 y = v2\n\u22a2 M.spanningCoe.Adj v w \u2194 \u00acM.spanningCoe.Adj v w'",["aesop"]],["CategoryTheory/ChosenFiniteProducts.lean",286,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : ChosenFiniteProducts C\nT X Y : C\nf : T \u27f6 X\ng : T \u27f6 Y\n\u22a2 lift f g \u226b (\u03b2_ X Y).hom = lift g f",["aesop"]],["CategoryTheory/ChosenFiniteProducts.lean",290,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : ChosenFiniteProducts C\nT X Y : C\nf : T \u27f6 X\ng : T \u27f6 Y\n\u22a2 lift f g \u226b (\u03b2_ Y X).inv = lift g f",["aesop"]],["Condensed/Discrete/Colimit.lean",104,"case w\nF G : Profinite\u1d52\u1d56 \u2964 Type (u + 1)\nS : Profinite\u1d52\u1d56\ni : toProfinite.op \u22d9 F \u2245 toProfinite.op \u22d9 G\n\u22a2 \u2200 (j : CostructuredArrow toProfinite.op S),\n    colimit.\u03b9 (CostructuredArrow.proj toProfinite.op S \u22d9 toProfinite.op \u22d9 F) j \u226b\n        colimit.desc (CostructuredArrow.proj toProfinite.op S \u22d9 toProfinite.op \u22d9 F)\n          (toProfinite.op.costructuredArrowMapCocone (toProfinite.op \u22d9 F)\n            (toProfinite.op.pointwiseLeftKanExtension (toProfinite.op \u22d9 G))\n            (i.hom \u226b toProfinite.op.pointwiseLeftKanExtensionUnit (toProfinite.op \u22d9 G)) S) =\n      colimit.\u03b9 (CostructuredArrow.proj toProfinite.op S \u22d9 toProfinite.op \u22d9 F) j \u226b\n        colimMap (whiskerLeft (CostructuredArrow.proj toProfinite.op S) i.hom)",["aesop"]],["Condensed/Discrete/Colimit.lean",113,"case w\nF G : Profinite\u1d52\u1d56 \u2964 Type (u + 1)\nS : Profinite\u1d52\u1d56\ni : toProfinite.op \u22d9 F \u2245 toProfinite.op \u22d9 G\n\u22a2 \u2200 (j : CostructuredArrow toProfinite.op S),\n    colimit.\u03b9 (CostructuredArrow.proj toProfinite.op S \u22d9 toProfinite.op \u22d9 G) j \u226b\n        colimit.desc (CostructuredArrow.proj toProfinite.op S \u22d9 toProfinite.op \u22d9 G)\n          (toProfinite.op.costructuredArrowMapCocone (toProfinite.op \u22d9 G)\n            (toProfinite.op.pointwiseLeftKanExtension (toProfinite.op \u22d9 F))\n            (i.inv \u226b toProfinite.op.pointwiseLeftKanExtensionUnit (toProfinite.op \u22d9 F)) S) =\n      colimit.\u03b9 (CostructuredArrow.proj toProfinite.op S \u22d9 toProfinite.op \u22d9 G) j \u226b\n        colimMap (whiskerLeft (CostructuredArrow.proj toProfinite.op S) i.inv)",["aesop"]],["Condensed/Discrete/Colimit.lean",378,"case w\nF G : LightProfinite\u1d52\u1d56 \u2964 Type u\nS : LightProfinite\u1d52\u1d56\ni : toLightProfinite.op \u22d9 F \u2245 toLightProfinite.op \u22d9 G\n\u22a2 \u2200 (j : CostructuredArrow toLightProfinite.op S),\n    colimit.\u03b9 (CostructuredArrow.proj toLightProfinite.op S \u22d9 toLightProfinite.op \u22d9 F) j \u226b\n        colimit.desc (CostructuredArrow.proj toLightProfinite.op S \u22d9 toLightProfinite.op \u22d9 F)\n          (toLightProfinite.op.costructuredArrowMapCocone (toLightProfinite.op \u22d9 F)\n            (toLightProfinite.op.pointwiseLeftKanExtension (toLightProfinite.op \u22d9 G))\n            (i.hom \u226b toLightProfinite.op.pointwiseLeftKanExtensionUnit (toLightProfinite.op \u22d9 G)) S) =\n      colimit.\u03b9 (CostructuredArrow.proj toLightProfinite.op S \u22d9 toLightProfinite.op \u22d9 F) j \u226b\n        colimMap (whiskerLeft (CostructuredArrow.proj toLightProfinite.op S) i.hom)",["aesop"]],["Condensed/Discrete/Colimit.lean",387,"case w\nF G : LightProfinite\u1d52\u1d56 \u2964 Type u\nS : LightProfinite\u1d52\u1d56\ni : toLightProfinite.op \u22d9 F \u2245 toLightProfinite.op \u22d9 G\n\u22a2 \u2200 (j : CostructuredArrow toLightProfinite.op S),\n    colimit.\u03b9 (CostructuredArrow.proj toLightProfinite.op S \u22d9 toLightProfinite.op \u22d9 G) j \u226b\n        colimit.desc (CostructuredArrow.proj toLightProfinite.op S \u22d9 toLightProfinite.op \u22d9 G)\n          (toLightProfinite.op.costructuredArrowMapCocone (toLightProfinite.op \u22d9 G)\n            (toLightProfinite.op.pointwiseLeftKanExtension (toLightProfinite.op \u22d9 F))\n            (i.inv \u226b toLightProfinite.op.pointwiseLeftKanExtensionUnit (toLightProfinite.op \u22d9 F)) S) =\n      colimit.\u03b9 (CostructuredArrow.proj toLightProfinite.op S \u22d9 toLightProfinite.op \u22d9 G) j \u226b\n        colimMap (whiskerLeft (CostructuredArrow.proj toLightProfinite.op S) i.inv)",["aesop"]],["NumberTheory/Divisors.lean",58,"n x\u2081 x\u2082 : \u2115\nx\u271d : \u2115 \u00d7 \u2115\nx y : \u2115\nhx\u2081 :\n  (x, y) \u2208\n    (fun x \u21a6\n        let y := n / x;\n        if x * y = n then some (x, y) else none)\n      x\u2081\nhx\u2082 :\n  (x, y) \u2208\n    (fun x \u21a6\n        let y := n / x;\n        if x * y = n then some (x, y) else none)\n      x\u2082\n\u22a2 x\u2081 = x\u2082",["aesop"]],["NumberTheory/Divisors.lean",568,"n x y : \u2115\n\u22a2 ((\u2203 a b, (a * b = n \u2227 \u00acn = 0) \u2227 a = x \u2227 False) \u2228 \u2203 a b, (a * b = n \u2227 \u00acn = 0) \u2227 (a = 0 \u2227 x = 0) \u2227 b = y + 1) \u2194\n    (x * (y + 1) = 0 \u2227 n = 0) \u2227 \u00acn = 0",["aesop"]],["NumberTheory/Divisors.lean",572,"n x y : \u2115\n\u22a2 (0 = n \u2227 \u00acn = 0) \u2227 y = 0 \u2194 ((x + 1) * y = 0 \u2227 n = 0) \u2227 \u00acn = 0",["aesop"]],["NumberTheory/Divisors.lean",583,"n x y : \u2115\n\u22a2 ((\u2203 a b, a * b = n + 1 \u2227 a = x \u2227 b = y + 1) \u2228 \u2203 a b, a * b = n + 1 \u2227 (a = 0 \u2227 x = 0) \u2227 False) \u2194\n    x * (y + 1) = n + 1 \u2227 \u00acFalse",["aesop"]],["NumberTheory/Divisors.lean",663,"a b : \u2124\n\u22a2 (a, b) \u2208 divisorsAntidiag 1 \u2228 (a, b) \u2208 divisorsAntidiag 2 \u2228 (a, b) \u2208 divisorsAntidiag 3 \u2194\n    (a, b) = (1, 1) \u2228\n      (a, b) = (-1, -1) \u2228\n        (a, b) = (1, 2) \u2228\n          (a, b) = (2, 1) \u2228\n            (a, b) = (-1, -2) \u2228\n              (a, b) = (-2, -1) \u2228 (a, b) = (1, 3) \u2228 (a, b) = (3, 1) \u2228 (a, b) = (-1, -3) \u2228 (a, b) = (-3, -1)",["aesop"]],["NumberTheory/Divisors.lean",675,"a b : \u2124\nh\u2080 : a = 0 \u2194 b = 0\n\u22a2 a * b = 0 \u2228\n      (a, b) \u2208 divisorsAntidiag 1 \u2228\n        (a, b) \u2208 divisorsAntidiag 2 \u2228 (a, b) \u2208 divisorsAntidiag 3 \u2228 (a, b) \u2208 divisorsAntidiag 4 \u2194\n    (a, b) = (0, 0) \u2228\n      (a, b) = (1, 1) \u2228\n        (a, b) = (-1, -1) \u2228\n          (a, b) = (1, 2) \u2228\n            (a, b) = (2, 1) \u2228\n              (a, b) = (-1, -2) \u2228\n                (a, b) = (-2, -1) \u2228\n                  (a, b) = (1, 3) \u2228\n                    (a, b) = (3, 1) \u2228\n                      (a, b) = (-1, -3) \u2228\n                        (a, b) = (-3, -1) \u2228\n                          (a, b) = (4, 1) \u2228\n                            (a, b) = (1, 4) \u2228 (a, b) = (-4, -1) \u2228 (a, b) = (-1, -4) \u2228 (a, b) = (2, 2) \u2228 (a, b) = (-2, -2)",["aesop"]],["Topology/Algebra/UniformGroup/Basic.lean",146,"case h.e'_3.h.e\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : UniformGroup \u03b1\ns : Set \u03b1\nhs : TotallyBounded s\n\u22a2 Inv.inv = image fun x \u21a6 x\u207b\u00b9",["aesop"]],["Topology/Algebra/UniformGroup/Basic.lean",385,"case mk.left.hf.hm.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nG : Type u_5\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b9\u00b2 : IsTopologicalAddGroup \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b2\ninst\u271d\u2079 : TopologicalSpace \u03b3\ninst\u271d\u2078 : AddCommGroup \u03b3\ninst\u271d\u2077 : IsTopologicalAddGroup \u03b3\ninst\u271d\u2076 : TopologicalSpace \u03b4\ninst\u271d\u2075 : AddCommGroup \u03b4\ninst\u271d\u2074 : UniformSpace G\ninst\u271d\u00b3 : AddCommGroup G\ne : \u03b2 \u2192+ \u03b1\nde : IsDenseInducing \u21d1e\nf : \u03b4 \u2192+ \u03b3\ndf : IsDenseInducing \u21d1f\n\u03c6 : \u03b2 \u2192+ \u03b4 \u2192+ G\nh\u03c6 : Continuous fun p \u21a6 (\u03c6 p.1) p.2\ninst\u271d\u00b2 : UniformAddGroup G\ninst\u271d\u00b9 : T0Space G\ninst\u271d : CompleteSpace G\nx\u2080 : \u03b1\ny\u2080 : \u03b3\nU : Set (\u03b1 \u00d7 \u03b3)\nh : U \u2208 \ud835\udcdd (x\u2080, y\u2080)\nx : \u03b1 \u00d7 \u03b3\nx_in : x \u2208 U\nz : \u03b2 \u00d7 \u03b4\nz_x : Prod.map (\u21d1e) (\u21d1f) z = x\n\u22a2 Prod.map (\u21d1e) (\u21d1f) z \u2208 U",["aesop"]],["Data/Matrix/Kronecker.lean",117,"case a.mk.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_4\n\u03b3 : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : Zero \u03b2\ninst\u271d\u2074 : Zero \u03b3\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : DecidableEq p\ni\u2081 : l\nj\u2081 : m\ni\u2082 : n\nj\u2082 : p\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nhf\u2081 : \u2200 (b : \u03b2), f 0 b = 0\nhf\u2082 : \u2200 (a : \u03b1), f a 0 = 0\na : \u03b1\nb : \u03b2\ni\u2081' : l\ni\u2082' : n\nj\u2081' : m\nj\u2082' : p\n\u22a2 f (if i\u2081 = i\u2081' \u2227 j\u2081 = j\u2081' then a else 0) (if i\u2082 = i\u2082' \u2227 j\u2082 = j\u2082' then b else 0) =\n    if (i\u2081, i\u2082) = (i\u2081', i\u2082') \u2227 (j\u2081, j\u2082) = (j\u2081', j\u2082') then f a b else 0",["aesop"]],["Combinatorics/Colex.lean",336,"\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns t : Finset \u03b1\n\u22a2 (\u2200 (hst : s \u2260 t), (s \u2206 t).max' \u22ef \u2208 t) \u2227 { ofColex := s } \u2260 { ofColex := t } \u2194 \u2203 (hst : s \u2260 t), (s \u2206 t).max' \u22ef \u2208 t",["aesop"]],["Data/Finset/Basic.lean",126,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nhs : s.Nontrivial\n\u22a2 \u2200 (a_1 : \u03b1), a_1 \u2208 s \u2227 a_1 \u2260 a \u2192 a_1 \u2208 s.erase a",["aesop"]],["Data/Finset/Basic.lean",166,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na : \u03b1\nhs : a \u2208 s\nht : a \u2209 t\n\u22a2 s.erase a = t \u2194 s = insert a t",["aesop"]],["Data/Finset/Basic.lean",226,"case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na b : \u03b1\nhab : a \u2260 b\nhb : b \u2208 s\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 s.erase a \\ s.erase b \u2194 a\u271d \u2208 {b}",["aesop"]],["Data/Finset/Sups.lean",614,"\u03b1 : Type u_2\ninst\u271d : BooleanAlgebra \u03b1\ns : Finset \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u2203 a \u2208 s\u1d9c\u02e2, p a) \u2194 \u2203 a \u2208 s, p a\u1d9c",["aesop"]],["Data/Finset/Sups.lean",643,"case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : BooleanAlgebra \u03b1\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\na\u271d : \u03b1\n\u22a2 (\u2203 a \u2208 s, \u2203 b, b\u1d9c \u2208 t \u2227 a \u2293 b = a\u271d) \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2293 b\u1d9c = a\u271d",["aesop"]],["Order/SupClosed.lean",85,"\u03b1 : Type u_3\ninst\u271d : SemilatticeSup \u03b1\ns : Set \u03b1\na : \u03b1\nhs : SupClosed s\nha : a \u2208 upperBounds s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2294 b \u2208 insert a s",["aesop"]],["Order/SupClosed.lean",91,"\u03b1 : Type u_3\ninst\u271d : SemilatticeSup \u03b1\ns : Set \u03b1\na : \u03b1\nh : SupClosed s\nha : a \u2208 lowerBounds s\nha' : \u2200 b \u2208 s, a \u2264 b\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2294 b \u2208 insert a s",["aesop"]],["Order/SupClosed.lean",162,"\u03b1 : Type u_3\ninst\u271d : SemilatticeInf \u03b1\ns : Set \u03b1\na : \u03b1\nhs : InfClosed s\nha : a \u2208 upperBounds s\nha' : \u2200 b \u2208 s, b \u2264 a\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2293 b \u2208 insert a s",["aesop"]],["Order/SupClosed.lean",167,"\u03b1 : Type u_3\ninst\u271d : SemilatticeInf \u03b1\ns : Set \u03b1\na : \u03b1\nh : InfClosed s\nha : a \u2208 lowerBounds s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 insert a s \u2192 a_1 \u2293 b \u2208 insert a s",["aesop"]],["Data/PFun.lean",578,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192. \u03b3\ng : \u03b2 \u2192. \u03b4\n\u22a2 (f.comp \u2191Prod.fst).prodLift (g.comp \u2191Prod.snd) = f.prodMap g",["aesop"]],["Data/PFun.lean",582,"\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 (PFun.id \u03b1).prodMap (PFun.id \u03b2) = PFun.id (\u03b1 \u00d7 \u03b2)",["aesop"]],["Data/Finsupp/Defs.lean",336,"\u03b1 : Type u_1\nM : Type u_5\nN : Type u_7\ninst\u271d\u00b9 : Zero M\ninst\u271d : Zero N\ne : M \u2192 N\nhe\u2080 : e 0 = 0\ng : \u03b1 \u2192\u2080 N\nf : \u03b1 \u2192 M\nh : \u2200 (i : \u03b1), e (f i) = g i\n\u22a2 \u2200 (a : \u03b1), (\u2191g.support).indicator f a \u2260 0 \u2192 a \u2208 g.support",["aesop"]],["Order/Disjoint.lean",88,"\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\na b : \u03b1\nhab : Disjoint a b\n\u22a2 a = b \u2194 a = \u22a5 \u2227 b = \u22a5",["aesop"]],["Order/Disjoint.lean",251,"\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderTop \u03b1\na b : \u03b1\nhab : Codisjoint a b\n\u22a2 a = b \u2194 a = \u22a4 \u2227 b = \u22a4",["aesop"]],["Algebra/Polynomial/Laurent.lean",146,"R : Type u_1\ninst\u271d : Semiring R\nt : R\nn : \u2124\n\u22a2 (if 0 = n then t else 0) = if n = 0 then t else 0",["aesop"]],["LinearAlgebra/FiniteDimensional/Basic.lean",362,"K : Type u\nV : Type v\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\n\u03b9 : Type u_1\nf : \u03b9 \u2192 V \u2192\u2097[K] V\ni : \u03b9\ns : Finset \u03b9\nhi : i \u2209 s\ncomm : (\u2191(insert i s)).Pairwise (Commute on f)\nh : (insert i s).SupIndep fun i \u21a6 ker (f i)\nih : ker (s.noncommProd f \u22ef) = \u2a06 x \u2208 s, ker (f x)\nj : \u03b9\nhj : j \u2208 s\n\u22a2 i \u2260 j",["aesop"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",284,"V : Type u\nG : SimpleGraph V\nu v\u271d : V\np : G.Walk u v\u271d\nhp : p.IsPath\nhnp : \u00acp.Nil\nv : V\nhadj1 : \u2203 i, (p.getVert i = u \u2227 p.getVert (i + 1) = p.snd \u2228 p.getVert i = p.snd \u2227 p.getVert (i + 1) = u) \u2227 i < p.length\ni : \u2115\nright\u271d : i < p.length\nhl : p.getVert i = u \u2227 p.getVert (i + 1) = v\n\u22a2 p.getVert i = p.getVert 0",["aesop"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",285,"case h.intro.intro.inl\nV : Type u\nG : SimpleGraph V\nu v\u271d : V\np : G.Walk u v\u271d\nhp : p.IsPath\nhnp : \u00acp.Nil\nv : V\nhadj1 : \u2203 i, (p.getVert i = u \u2227 p.getVert (i + 1) = p.snd \u2228 p.getVert i = p.snd \u2227 p.getVert (i + 1) = u) \u2227 i < p.length\ni : \u2115\nright\u271d : i < p.length\nhl : p.getVert i = u \u2227 p.getVert (i + 1) = v\nthis : i = 0\n\u22a2 v = p.snd",["aesop"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",288,"V : Type u\nG : SimpleGraph V\nu v\u271d : V\np : G.Walk u v\u271d\nhp : p.IsPath\nhnp : \u00acp.Nil\nv : V\nhadj1 : \u2203 i, (p.getVert i = u \u2227 p.getVert (i + 1) = p.snd \u2228 p.getVert i = p.snd \u2227 p.getVert (i + 1) = u) \u2227 i < p.length\ni : \u2115\nright\u271d : i < p.length\nhr : p.getVert i = v \u2227 p.getVert (i + 1) = u\n\u22a2 p.getVert (i + 1) = p.getVert 0",["aesop"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",369,"case h.intro.intro.inl.intro\nV : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nv : V\nh : \u00aci = 0\nh' : i < p.length\nhadj1 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i - 1) \u2228\n        p.getVert i_1 = p.getVert (i - 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\nhadj2 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i + 1) \u2228\n        p.getVert i_1 = p.getVert (i + 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\ni' : \u2115\nright\u271d : i' < p.length\nhl2 : p.getVert (i' + 1) = v\nhl1 : i' = i\n\u22a2 v = p.getVert (i - 1) \u2228 v = p.getVert (i + 1)",["aesop"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",372,"case h.intro.intro.inr.intro\nV : Type u\nG : SimpleGraph V\nu : V\ni : \u2115\np : G.Walk u u\nhpc : p.IsCycle\nv : V\nh : \u00aci = 0\nh' : i < p.length\nhadj1 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i - 1) \u2228\n        p.getVert i_1 = p.getVert (i - 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\nhadj2 :\n  \u2203 i_1,\n    (p.getVert i_1 = p.getVert i \u2227 p.getVert (i_1 + 1) = p.getVert (i + 1) \u2228\n        p.getVert i_1 = p.getVert (i + 1) \u2227 p.getVert (i_1 + 1) = p.getVert i) \u2227\n      i_1 < p.length\ni' : \u2115\nright\u271d : i' < p.length\nhr1 : p.getVert i' = v\nhr2 : i' + 1 = i\n\u22a2 v = p.getVert (i - 1) \u2228 v = p.getVert (i + 1)",["aesop"]],["Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",379,"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u u\nhpc : p.IsCycle\ni : \u2115\nhi : p.getVert i = v \u2227 i \u2264 p.length\nhe : i = 0 \u2228 i = p.length\n\u22a2 u = v",["aesop"]],["Order/SupIndep.lean",425,"\u03b1 : Type u_1\n\u03b9 : Type u_3\ninst\u271d : CompleteLattice \u03b1\nt : \u03b9 \u2192 \u03b1\nht : iSupIndep t\nh_ne_bot : \u2200 (i : \u03b9), t i \u2260 \u22a5\n\u22a2 univ = {i | t i \u2260 \u22a5}",["aesop"]],["Data/Matroid/Restrict.lean",144,"\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 \u2200 \u2983I : Set \u03b1\u2984, I \u2286 (M \u21be M.E).E \u2192 ((M \u21be M.E).Indep I \u2194 M.Indep I)",["aesop"]],["CategoryTheory/Functor/KanExtension/Pointwise.lean",411,"case h\u03b3\nC : Type u_1\nD : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : Category.{u_6, u_1} C\ninst\u271d\u00b2 : Category.{u_4, u_2} D\ninst\u271d\u00b9 : Category.{u_5, u_3} H\nL : C \u2964 D\nF : C \u2964 H\ninst\u271d : L.HasPointwiseLeftKanExtension F\nG : D \u2964 H\n\u03b1 : F \u27f6 L \u22d9 G\nY : D\n\u03b2 : L.pointwiseLeftKanExtension F \u27f6 G :=\n  { app := fun Y \u21a6 colimit.desc (CostructuredArrow.proj L Y \u22d9 F) (L.costructuredArrowMapCocone F G \u03b1 Y), naturality := \u22ef }\n\u22a2 L.pointwiseLeftKanExtensionUnit F \u226b\n      whiskerLeft L ((L.pointwiseLeftKanExtension F).descOfIsLeftKanExtension (L.pointwiseLeftKanExtensionUnit F) G \u03b1) =\n    L.pointwiseLeftKanExtensionUnit F \u226b whiskerLeft L \u03b2",["aesop"]],["CategoryTheory/Functor/KanExtension/Pointwise.lean",511,"case h\u03b3\nC : Type u_1\nD : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : Category.{u_6, u_1} C\ninst\u271d\u00b2 : Category.{u_4, u_2} D\ninst\u271d\u00b9 : Category.{u_5, u_3} H\nL : C \u2964 D\nF : C \u2964 H\ninst\u271d : L.HasPointwiseRightKanExtension F\nG : D \u2964 H\n\u03b1 : L \u22d9 G \u27f6 F\nY : D\n\u03b2 : G \u27f6 L.pointwiseRightKanExtension F :=\n  { app := fun Y \u21a6 limit.lift (StructuredArrow.proj Y L \u22d9 F) (L.structuredArrowMapCone F G \u03b1 Y), naturality := \u22ef }\n\u22a2 whiskerLeft L ((L.pointwiseRightKanExtension F).liftOfIsRightKanExtension (L.pointwiseRightKanExtensionCounit F) G \u03b1) \u226b\n      L.pointwiseRightKanExtensionCounit F =\n    whiskerLeft L \u03b2 \u226b L.pointwiseRightKanExtensionCounit F",["aesop"]],["RingTheory/MvPolynomial/Homogeneous.lean",361,"R : Type u_5\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nN : \u2115\nIH : \u2200 {F : MvPolynomial (Fin N) R} {n : \u2115}, F.IsHomogeneous n \u2192 F \u2260 0 \u2192 \u2191n \u2264 #R \u2192 \u2203 r, (eval r) F \u2260 0\nF : MvPolynomial (Fin (N + 1)) R\nn : \u2115\nhF : F.IsHomogeneous n\nhF\u2080 : F \u2260 0\nhnR : \u2191n \u2264 #R\nhdeg : ((finSuccEquiv R N) F).natDegree < n + 1\ni : \u2115\nhi : ((finSuccEquiv R N) F).coeff i \u2260 0\nhin : i \u2264 n\nhFn : ((finSuccEquiv R N) F).coeff n = 0\n\u22a2 i = n \u2192 i < n",["aesop"]],["Algebra/Lie/TraceForm.lean",178,"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : LieAlgebra R L\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieModule R L M\ninst\u271d : LieRing.IsNilpotent L\nB : LinearMap.BilinForm R M\nm\u2080 m\u2081 : M\nhm\u2080 : m\u2080 \u2208 genWeightSpace M 0\nhm\u2081 : m\u2081 \u2208 posFittingComp R L M\nhB : \u2200 (x : L) (k : \u2115) (m n : M), (B m) ((\u03c6 x ^ k) n) = (-1) ^ k \u2022 (B ((\u03c6 x ^ k) m)) n\nthis : \u2200 (x : L), \u2200 m \u2208 posFittingCompOf R M x, (B m\u2080) m = 0\n\u22a2 \u2200 (y z : M), (B m\u2080) y = 0 \u2192 (B m\u2080) z = 0 \u2192 (B m\u2080) (y + z) = 0",["aesop"]],["Geometry/Manifold/Instances/Real.lean",215,"n : \u2115\n\u22a2 {x | \u2200 (i : Fin n), 0 \u2264 x i} = univ.pi fun i \u21a6 Ici 0",["aesop"]],["Algebra/Category/Grp/Basic.lean",559,"\u03b1 : Type u\n\u22a2 \u2200 (x y : Aut \u03b1),\n    { toFun := fun g \u21a6 Iso.toEquiv g, map_one' := \u22ef }.toFun (x * y) =\n      { toFun := fun g \u21a6 Iso.toEquiv g, map_one' := \u22ef }.toFun x *\n        { toFun := fun g \u21a6 Iso.toEquiv g, map_one' := \u22ef }.toFun y",["aesop"]],["Algebra/Category/Grp/Basic.lean",562,"\u03b1 : Type u\n\u22a2 (fun g \u21a6 Equiv.toIso g) 1 = 1",["aesop"]],["Algebra/Category/Grp/Basic.lean",563,"\u03b1 : Type u\n\u22a2 \u2200 (x y : Equiv.Perm \u03b1),\n    { toFun := fun g \u21a6 Equiv.toIso g, map_one' := \u22ef }.toFun (x * y) =\n      { toFun := fun g \u21a6 Equiv.toIso g, map_one' := \u22ef }.toFun x *\n        { toFun := fun g \u21a6 Equiv.toIso g, map_one' := \u22ef }.toFun y",["aesop"]],["LinearAlgebra/Finsupp/LinearCombination.lean",390,"\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nv : \u03b1 \u2192 M\nx : M\ns : Set \u03b1\nx\u271d\u00b9 : \u2203 t, \u2191t \u2286 s \u2227 \u2203 c, \u2211 i : { x // x \u2208 t }, c i \u2022 v \u2191i = x\nt : Finset \u03b1\nht : \u2191t \u2286 s\nc : { x // x \u2208 t } \u2192 R\nhx : \u2211 i : { x // x \u2208 t }, c i \u2022 v \u2191i = x\na : { x // x \u2208 t }\nx\u271d : a \u2208 Finset.univ\n\u22a2 v \u2191a \u2208 v '' s",["aesop"]],["Algebra/Module/Submodule/Pointwise.lean",504,"case intro.intro.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Monoid S\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN : Submodule R M\ninst\u271d : SMulCommClass R R M\ns t : Set R\nx : Submodule R M\nn\u271d : M\nw\u271d\u00b9 : R\nleft\u271d\u00b9 : w\u271d\u00b9 \u2208 s\nw\u271d : R\nleft\u271d : w\u271d \u2208 t\na\u271d : n\u271d \u2208 x\n\u22a2 w\u271d\u00b9 \u2022 w\u271d \u2022 n\u271d \u2208 s \u2022 t \u2022 x",["aesop"]],["Algebra/Category/ModuleCat/Basic.lean",308,"R : Type u\ninst\u271d : Ring R\nX\u2081 X\u2082 : Type v\nX Y : ModuleCat R\ni : X \u2245 Y\n\u22a2 Hom.hom i.inv \u2218\u2097 Hom.hom i.hom = LinearMap.id",["aesop"]],["Order/BooleanSubalgebra.lean",217,"\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : BooleanAlgebra \u03b1\ninst\u271d\u00b9 : BooleanAlgebra \u03b2\ninst\u271d : BooleanAlgebra \u03b3\nL M : BooleanSubalgebra \u03b1\nf : BoundedLatticeHom \u03b1 \u03b2\ns t : Set \u03b1\na b : \u03b1\n_S : BooleanSubalgebra \u03b1\n_a : \u03b1\n\u22a2 _a \u2208 \u22a5 \u2192 _a \u2208 _S",["aesop"]],["Data/Set/Finite/Lattice.lean",219,"\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhimage : (f '' s).Finite\nhfibers : \u2200 x \u2208 f '' s, (s \u2229 f \u207b\u00b9' {x}).Finite\nx : \u03b1\n\u22a2 x \u2208 s \u2192 x \u2208 \u22c3 i \u2208 f '' s, s \u2229 f \u207b\u00b9' {i}",["aesop"]],["Algebra/Ring/CentroidHom.lean",513,"\u03b1 : Type u_5\ninst\u271d : NonUnitalNonAssocCommSemiring \u03b1\na : \u03b1\n\u22a2 (L a = L a \u2227 \u2200 g \u2208 Set.range \u21d1L, g * L a = L a * g) \u2194 \u2200 (b : \u03b1), Commute (L b) (L a)",["aesop"]],["Algebra/Module/Presentation/Basic.lean",114,"A : Type u\ninst\u271d : Ring A\nrelations : Relations A\n\u22a2 relations.toQuotient \u2218\u2097 relations.map = 0",["aesop"]],["Algebra/Module/Presentation/Basic.lean",152,"A : Type u\ninst\u271d\u00b2 : Ring A\nrelations : Relations A\nM : Type v\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module A M\nsolution : relations.Solution M\n\u22a2 solution.\u03c0 \u2218\u2097 relations.map = 0",["aesop"]],["Algebra/Module/Presentation/Basic.lean",188,"A : Type u\ninst\u271d\u2074 : Ring A\nrelations : Relations A\nM : Type v\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module A M\nsolution : relations.Solution M\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nf : M \u2192\u2097[A] N\nr : relations.R\n\u22a2 (Finsupp.linearCombination A fun g \u21a6 f (solution.var g)) = f \u2218\u2097 solution.\u03c0",["aesop"]],["Algebra/Module/Presentation/Basic.lean",391,"A : Type u\ninst\u271d\u2074 : Ring A\nrelations : Relations A\nM : Type v\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\ne : M \u2243\u2097[A] N\n\u22a2 (solution.postcomp \u2191e).fromQuotient = \u2191e \u2218\u2097 solution.fromQuotient",["aesop"]],["Algebra/Module/Presentation/Basic.lean",462,"A : Type u\ninst\u271d\u00b2 : Ring A\nrelations : Relations A\nM : Type v\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentationCore\n\u22a2 h.down.desc (ofQuotient relations) \u2218\u2097 solution.fromQuotient = LinearMap.id",["aesop"]],["Analysis/CStarAlgebra/ContinuousFunctionalCalculus/Instances.lean",115,"case h.e'_3\n\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u2078 : RCLike \ud835\udd5c\ninst\u271d\u2077 : NonUnitalNormedRing A\ninst\u271d\u2076 : StarRing A\ninst\u271d\u2075 : NormedSpace \ud835\udd5c A\ninst\u271d\u2074 : IsScalarTower \ud835\udd5c A A\ninst\u271d\u00b3 : SMulCommClass \ud835\udd5c A A\ninst\u271d\u00b2 : StarModule \ud835\udd5c A\np : A \u2192 Prop\np\u2081 : Unitization \ud835\udd5c A \u2192 Prop\nhp\u2081 : \u2200 {x : A}, p\u2081 \u2191x \u2194 p x\na : A\nha : p a\ninst\u271d\u00b9 : ContinuousFunctionalCalculus \ud835\udd5c p\u2081\ninst\u271d : CompleteSpace A\nf : C(\u2191(\u03c3\u2099 \ud835\udd5c a), \ud835\udd5c)\u2080\nh\u2081 : (cfc\u2099Aux \u22ef a ha) f \u2208 closure (\u21d1(cfc\u2099Aux \u22ef a ha) '' \u2191(NonUnitalStarAlgebra.adjoin \ud835\udd5c {ContinuousMapZero.id \u22ef}))\nthis : Continuous Unitization.fst\n\u22a2 Set.range \u21d1(Unitization.inrNonUnitalStarAlgHom \ud835\udd5c A) = Unitization.fst \u207b\u00b9' {0}",["aesop"]],["CategoryTheory/SmallObject/Iteration/Basic.lean",358,"C : Type u\ninst\u271d\u2075 : Category.{v, u} C\nJ : Type w\n\u03a6 : SuccStruct C\ninst\u271d\u2074 : LinearOrder J\ninst\u271d\u00b3 : SuccOrder J\ninst\u271d\u00b2 : OrderBot J\ninst\u271d\u00b9 : HasIterationOfShape J C\ninst\u271d : WellFoundedLT J\nj : J\niter\u2081 iter\u2082 : \u03a6.Iteration j\nthis : iter\u2081.F = iter\u2082.F\n\u22a2 iter\u2081 = iter\u2082",["aesop"]],["Data/Set/Insert.lean",497,"\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\n\u22a2 Prod.fst \u207b\u00b9' {a} = range fun x \u21a6 (a, x)",["aesop"]],["Data/Set/Insert.lean",500,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\n\u22a2 Prod.snd \u207b\u00b9' {b} = range fun x \u21a6 (x, b)",["aesop"]],["Order/Interval/Set/Image.lean",24,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\na : \u03b1\nh : MonotoneOn f (Ici a)\nx\u271d\u00b9 : \u03b1\nx\u271d : x\u271d\u00b9 \u2208 Ici a\n\u22a2 f x\u271d\u00b9 \u2208 Ici (f a)",["aesop"]],["Order/Interval/Set/Image.lean",27,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nb : \u03b1\nh : MonotoneOn f (Iic b)\nx\u271d\u00b9 : \u03b1\nx\u271d : x\u271d\u00b9 \u2208 Iic b\n\u22a2 f x\u271d\u00b9 \u2208 Iic (f b)",["aesop"]],["Order/Interval/Set/Image.lean",34,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\na : \u03b1\nh : AntitoneOn f (Ici a)\nx\u271d\u00b9 : \u03b1\nx\u271d : x\u271d\u00b9 \u2208 Ici a\n\u22a2 f x\u271d\u00b9 \u2208 Iic (f a)",["aesop"]],["Order/Interval/Set/Image.lean",37,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nb : \u03b1\nh : AntitoneOn f (Iic b)\nx\u271d\u00b9 : \u03b1\nx\u271d : x\u271d\u00b9 \u2208 Iic b\n\u22a2 f x\u271d\u00b9 \u2208 Ici (f b)",["aesop"]],["Algebra/Polynomial/Degree/Lemmas.lean",325,"case refine_1\nR : Type u\ninst\u271d : Semiring R\np : R[X]\nhp : p.natDegree = 1\nh : p = 0\n\u22a2 False",["aesop"]],["RepresentationTheory/Basic.lean",248,"case hsmul\nk : Type u_1\nG : Type u_2\nV : Type u_3\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : AddCommMonoid V\ninst\u271d : Module k V\n\u03c1 : Representation k G V\nx : MonoidAlgebra k G\nv : \u03c1.asModule\ns : k\ny : MonoidAlgebra k G\nhy : \u2200 (t : k), (t \u2022 y) \u2022 v = t \u2022 y \u2022 v\nt : k\n\u22a2 t \u2022 s \u2022 y \u2022 v = t \u2022 (s \u2022 y) \u2022 v",["aesop"]],["Analysis/Convex/Jensen.lean",216,"\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b2 : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u2075 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Module \ud835\udd5c \u03b2\ninst\u271d : OrderedSMul \ud835\udd5c \u03b2\ns : Set E\nf : E \u2192 \u03b2\nt : Finset \u03b9\nw : \u03b9 \u2192 \ud835\udd5c\np : \u03b9 \u2192 E\nhf : StrictConvexOn \ud835\udd5c s f\nh\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nh\u2081 : \u2211 i \u2208 t, w i = 1\nhmem : \u2200 i \u2208 t, p i \u2208 s\ni : \u03b9\nx\u271d : i \u2208 t\n\u22a2 w i \u2022 p i \u2260 0 \u2192 w i \u2260 0",["aesop"]],["Analysis/Convex/Jensen.lean",217,"\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b2 : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u2075 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Module \ud835\udd5c \u03b2\ninst\u271d : OrderedSMul \ud835\udd5c \u03b2\ns : Set E\nf : E \u2192 \u03b2\nt : Finset \u03b9\nw : \u03b9 \u2192 \ud835\udd5c\np : \u03b9 \u2192 E\nhf : StrictConvexOn \ud835\udd5c s f\nh\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nh\u2081 : \u2211 i \u2208 t, w i = 1\nhmem : \u2200 i \u2208 t, p i \u2208 s\nhw : \u2200 i \u2208 t, w i \u2022 p i \u2260 0 \u2192 w i \u2260 0\ni : \u03b9\nx\u271d : i \u2208 t\n\u22a2 w i \u2022 f (p i) \u2260 0 \u2192 w i \u2260 0",["aesop"]],["CategoryTheory/GlueData.lean",426,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData' C\ni j k : D.J\nhij : \u00aci = j\nhik : \u00aci = k\nhjk : \u00acj = k\nthis : j \u2260 i\n\u22a2 D.f j i \u22ef \u226b eqToHom \u22ef = eqToHom \u22ef \u226b if h : j = i then eqToHom \u22ef else eqToHom \u22ef \u226b D.f j i h",["aesop"]],["CategoryTheory/GradedObject/Unitor.lean",59,"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst\u271d\u2075 : Category.{?u.7514, u_1} C\ninst\u271d\u2074 : Category.{?u.7518, u_2} D\ninst\u271d\u00b3 : Zero I\ninst\u271d\u00b2 : DecidableEq I\ninst\u271d\u00b9 : HasInitial C\nF : C \u2964 D \u2964 D\nX : C\ne : F.obj X \u2245 \ud835\udfed D\ninst\u271d : \u2200 (Y : D), PreservesColimit (Functor.empty C) (F.flip.obj Y)\np : I \u00d7 J \u2192 J\nhp\u271d : \u2200 (j : J), p (0, j) = j\nY\u271d Y' : GradedObject J D\n\u03c6 : Y\u271d \u27f6 Y'\nhp : \u2200 (j : J), p (0, j) = j\nY : GradedObject J D\nj : J\na : I \u00d7 J\nha\u271d : p a = j\nha : a.1 = 0\n\u22a2 Y a.2 = Y j",["aesop"]],["CategoryTheory/GradedObject/Unitor.lean",171,"C : Type u_1\nD : Type u_2\nI : Type u_3\nJ : Type u_4\ninst\u271d\u2075 : Category.{?u.79432, u_1} C\ninst\u271d\u2074 : Category.{?u.79436, u_2} D\ninst\u271d\u00b3 : Zero I\ninst\u271d\u00b2 : DecidableEq I\ninst\u271d\u00b9 : HasInitial C\nF : D \u2964 C \u2964 D\nY : C\ne : F.flip.obj Y \u2245 \ud835\udfed D\ninst\u271d : \u2200 (X : D), PreservesColimit (Functor.empty C) (F.obj X)\np : J \u00d7 I \u2192 J\nhp\u271d : \u2200 (j : J), p (j, 0) = j\nX\u271d X' : GradedObject J D\n\u03c6 : X\u271d \u27f6 X'\nhp : \u2200 (j : J), p (j, 0) = j\nX : GradedObject J D\nj : J\na : J \u00d7 I\nha\u271d : p a = j\nha : a.2 = 0\n\u22a2 X a.1 = X j",["aesop"]],["Topology/LocallyConstant/Algebra.lean",383,"X : Type u_1\nY : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\n\u03b1 : Type u_3\nR\u271d : Type u_4\nR : Type u_5\nZ : Type u_6\ninst\u271d\u00b9 : MulOneClass Y\ninst\u271d : MulOneClass Z\nf : Y \u2192* Z\n\u22a2 map (\u21d1f) 1 = 1",["aesop"]],["Topology/LocallyConstant/Algebra.lean",392,"X : Type u_1\nY : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\n\u03b1 : Type u_3\nR\u271d\u00b9 : Type u_4\nR\u271d : Type u_5\nZ : Type u_6\nR : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid Y\ninst\u271d\u00b2 : Module R Y\ninst\u271d\u00b9 : AddCommMonoid Z\ninst\u271d : Module R Z\nf : Y \u2192\u2097[R] Z\n\u22a2 \u2200 (x y : LocallyConstant X Y), map (\u21d1f) (x + y) = map (\u21d1f) x + map (\u21d1f) y",["aesop"]],["Topology/LocallyConstant/Algebra.lean",407,"X : Type u_1\nY : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\n\u03b1 : Type u_3\nR\u271d\u00b9 : Type u_4\nR\u271d : Type u_5\nZ : Type u_6\nR : Type u_7\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring Y\ninst\u271d\u00b2 : Algebra R Y\ninst\u271d\u00b9 : Semiring Z\ninst\u271d : Algebra R Z\nf : Y \u2192\u2090[R] Z\nx\u271d : R\n\u22a2 (\u2191\u2191(mapRingHom \u2191f)).toFun ((algebraMap R (LocallyConstant X Y)) x\u271d) = (algebraMap R (LocallyConstant X Z)) x\u271d",["aesop"]],["Analysis/Complex/UpperHalfPlane/Basic.lean",178,"z : \u210d\nn : \u2115\nh1 : 0 < (\u2191z).im\n\u22a2 \u2191z \u2260 \u2191n",["aesop"]],["Analysis/Complex/UpperHalfPlane/Basic.lean",183,"z : \u210d\nn : \u2124\nh1 : 0 < (\u2191z).im\n\u22a2 \u2191z \u2260 \u2191n",["aesop"]],["Data/Set/NAry.lean",52,"\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\np : \u03b3 \u2192 Prop\n\u22a2 (\u2200 z \u2208 image2 f s t, p z) \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, p (f x y)",["aesop"]],["Analysis/SpecialFunctions/ContinuousFunctionalCalculus/PosPart/Basic.lean",241,"case refine_1\nA : Type u_1\ninst\u271d\u00b9\u00b9 : NonUnitalRing A\ninst\u271d\u00b9\u2070 : Module \u211d A\ninst\u271d\u2079 : SMulCommClass \u211d A A\ninst\u271d\u2078 : IsScalarTower \u211d A A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : NonUnitalContinuousFunctionalCalculus \u211d IsSelfAdjoint\ninst\u271d\u2074 : PartialOrder A\ninst\u271d\u00b3 : StarOrderedRing A\ninst\u271d\u00b2 : NonnegSpectrumClass \u211d A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\na b c : A\nhabc : a = b - c\nhbc : b * c = 0\nhb : autoParam (0 \u2264 b) _auto\u271d\nhc : autoParam (0 \u2264 c) _auto\u271d\nhb' : IsSelfAdjoint b\nhc' : IsSelfAdjoint (-c)\nha : IsSelfAdjoint a\ns : Set \u211d := \u03c3\u2099 \u211d a \u222a \u03c3\u2099 \u211d b \u222a \u03c3\u2099 \u211d (-c)\nhs : CompactSpace \u2191s\na\u271d : \u211d\n\u22a2 a\u271d \u2208 \u03c3\u2099 \u211d a \u2192 a\u271d \u2208 s\n```\n---\n```lean\ncase refine_2\nA : Type u_1\ninst\u271d\u00b9\u00b9 : NonUnitalRing A\ninst\u271d\u00b9\u2070 : Module \u211d A\ninst\u271d\u2079 : SMulCommClass \u211d A A\ninst\u271d\u2078 : IsScalarTower \u211d A A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : NonUnitalContinuousFunctionalCalculus \u211d IsSelfAdjoint\ninst\u271d\u2074 : PartialOrder A\ninst\u271d\u00b3 : StarOrderedRing A\ninst\u271d\u00b2 : NonnegSpectrumClass \u211d A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\na b c : A\nhabc : a = b - c\nhbc : b * c = 0\nhb : autoParam (0 \u2264 b) _auto\u271d\nhc : autoParam (0 \u2264 c) _auto\u271d\nhb' : IsSelfAdjoint b\nhc' : IsSelfAdjoint (-c)\nha : IsSelfAdjoint a\ns : Set \u211d := \u03c3\u2099 \u211d a \u222a \u03c3\u2099 \u211d b \u222a \u03c3\u2099 \u211d (-c)\nhs : CompactSpace \u2191s\na\u271d : \u211d\n\u22a2 a\u271d \u2208 \u03c3\u2099 \u211d b \u2192 a\u271d \u2208 s\n```\n---\n```lean\ncase refine_3\nA : Type u_1\ninst\u271d\u00b9\u00b9 : NonUnitalRing A\ninst\u271d\u00b9\u2070 : Module \u211d A\ninst\u271d\u2079 : SMulCommClass \u211d A A\ninst\u271d\u2078 : IsScalarTower \u211d A A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : NonUnitalContinuousFunctionalCalculus \u211d IsSelfAdjoint\ninst\u271d\u2074 : PartialOrder A\ninst\u271d\u00b3 : StarOrderedRing A\ninst\u271d\u00b2 : NonnegSpectrumClass \u211d A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\na b c : A\nhabc : a = b - c\nhbc : b * c = 0\nhb : autoParam (0 \u2264 b) _auto\u271d\nhc : autoParam (0 \u2264 c) _auto\u271d\nhb' : IsSelfAdjoint b\nhc' : IsSelfAdjoint (-c)\nha : IsSelfAdjoint a\ns : Set \u211d := \u03c3\u2099 \u211d a \u222a \u03c3\u2099 \u211d b \u222a \u03c3\u2099 \u211d (-c)\nhs : CompactSpace \u2191s\na\u271d : \u211d\n\u22a2 a\u271d \u2208 \u03c3\u2099 \u211d (-c) \u2192 a\u271d \u2208 s",["aesop"]],["Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean",268,"A : Type u_1\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : TopologicalSpace A\ninst\u271d\u00b9 : Algebra \u211d A\ninst\u271d : ContinuousFunctionalCalculus \u211d\u22650 fun a \u21a6 0 \u2264 a\na : A\nx y : \u211d\nha : 0 \u2209 spectrum \u211d\u22650 a\nz : \u211d\u22650\nhz : z \u2208 spectrum \u211d\u22650 a\n\u22a2 z \u2260 0",["aesop"]],["AlgebraicGeometry/PullbackCarrier.lean",52,"case mk.mk\nX Y S : Scheme\nf : X \u27f6 S\ng : Y \u27f6 S\nx\u271d\u00b9 : \u2191\u2191X.toPresheafedSpace\ny\u271d\u00b9 : \u2191\u2191Y.toPresheafedSpace\ns\u271d\u00b9 : \u2191\u2191S.toPresheafedSpace\nhx\u271d\u00b9 : (ConcreteCategory.hom f.base) x\u271d\u00b9 = s\u271d\u00b9\nhy\u271d\u00b9 : (ConcreteCategory.hom g.base) y\u271d\u00b9 = s\u271d\u00b9\nx\u271d : \u2191\u2191X.toPresheafedSpace\ny\u271d : \u2191\u2191Y.toPresheafedSpace\ns\u271d : \u2191\u2191S.toPresheafedSpace\nhx\u271d : (ConcreteCategory.hom f.base) x\u271d = s\u271d\nhy\u271d : (ConcreteCategory.hom g.base) y\u271d = s\u271d\nex : { x := x\u271d\u00b9, y := y\u271d\u00b9, s := s\u271d\u00b9, hx := hx\u271d\u00b9, hy := hy\u271d\u00b9 }.x = { x := x\u271d, y := y\u271d, s := s\u271d, hx := hx\u271d, hy := hy\u271d }.x\ney : { x := x\u271d\u00b9, y := y\u271d\u00b9, s := s\u271d\u00b9, hx := hx\u271d\u00b9, hy := hy\u271d\u00b9 }.y = { x := x\u271d, y := y\u271d, s := s\u271d, hx := hx\u271d, hy := hy\u271d }.y\n\u22a2 x\u271d\u00b9 = x\u271d \u2227 y\u271d\u00b9 = y\u271d \u2227 s\u271d\u00b9 = s\u271d",["aesop"]],["Data/Matrix/ColumnRowPartitioned.lean",132,"R : Type u_1\nm : Type u_2\nn\u2081 : Type u_6\nn\u2082 : Type u_7\nx1 x2 : Matrix m n\u2081 R\ny1 y2 : Matrix m n\u2082 R\n\u22a2 (\u2200 (i : m) (j : n\u2081 \u2295 n\u2082), x1.fromCols y1 i j = x2.fromCols y2 i j) \u2192\n    (\u2200 (i : m) (j : n\u2081), x1 i j = x2 i j) \u2227 \u2200 (i : m) (j : n\u2082), y1 i j = y2 i j",["aesop"]],["Algebra/MvPolynomial/Monad.lean",344,"\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_3\nS : Type u_4\nT : Type u_5\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : CommSemiring T\nf : \u03c3 \u2192 MvPolynomial \u03c4 R\n\u22a2 \u2200 {\u03b1 \u03b2 : Type u_6} (f : MvPolynomial (\u03b1 \u2192 \u03b2) R) (x : MvPolynomial \u03b1 R),\n    (do\n        let x_1 \u2190 f\n        x_1 <$> x) =\n      f <*> x",["aesop"]],["Data/Finset/Defs.lean",114,"\u03b1 : Type u_1\ns : Finset \u03b1\na : \u03b1\n\u22a2 (\u2200 b \u2208 s, \u00aca = b) \u2194 a \u2209 s",["aesop"]],["Data/Finset/Defs.lean",115,"\u03b1 : Type u_1\ns : Finset \u03b1\na : \u03b1\n\u22a2 (\u2200 b \u2208 s, \u00acb = a) \u2194 a \u2209 s",["aesop"]],["Analysis/Analytic/OfScalars.lean",196,"case neg.hs.refine_1.refine_1\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedRing E\ninst\u271d : NormedAlgebra \ud835\udd5c E\nc : \u2115 \u2192 \ud835\udd5c\nr : \u211d\u22650\nhr : r \u2260 0\nhc : Tendsto (fun n \u21a6 \u2016c n.succ\u2016 / \u2016c n\u2016) atTop (\ud835\udcdd \u2191r)\nr' : \u211d\u22650\nhr' : r' * r < 1\nhrz : \u00acr' = 0\n\u22a2 \u2200 (x : \u2115), \u2016c x.succ\u2016 / \u2016c x\u2016 \u2260 0 \u2192 \u2016\u2016c x\u2016 * \u2191r' ^ x\u2016 \u2260 0",["aesop"]],["Analysis/Analytic/OfScalars.lean",252,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedRing E\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c E\nc : \u2115 \u2192 \ud835\udd5c\ninst\u271d : NormOneClass E\nhc : Tendsto (fun n \u21a6 \u2016c n.succ\u2016 / \u2016c n\u2016) atTop atTop\nthis : (ofScalars E c).radius \u2264 0\n\u22a2 (ofScalars E c).radius = 0",["aesop"]],["CategoryTheory/Products/Basic.lean",173,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nx y : C \u00d7 D\nf : x \u27f6 y\n\u22a2 f = (\ud835\udfd9 x.1, f.2) \u226b (f.1, \ud835\udfd9 y.2)",["aesop"]],["CategoryTheory/Products/Basic.lean",179,"C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nx y : C \u00d7 D\nf : x \u27f6 y\n\u22a2 f = (f.1, \ud835\udfd9 x.2) \u226b (\ud835\udfd9 y.1, f.2)",["aesop"]],["CategoryTheory/Category/Basic.lean",218,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nP : Prop\ninst\u271d : Decidable P\nX Y Z : C\nf : X \u27f6 Y\ng g' : Y \u27f6 Z\n\u22a2 (f \u226b if P then g else g') = if P then f \u226b g else f \u226b g'",["aesop"]],["CategoryTheory/Category/Basic.lean",221,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nP : Prop\ninst\u271d : Decidable P\nX Y Z : C\nf f' : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 (if P then f else f') \u226b g = if P then f \u226b g else f' \u226b g",["aesop"]],["CategoryTheory/Category/Basic.lean",225,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nP : Prop\ninst\u271d : Decidable P\nX Y Z : C\nf : X \u27f6 Y\ng : P \u2192 (Y \u27f6 Z)\ng' : \u00acP \u2192 (Y \u27f6 Z)\n\u22a2 (f \u226b if h : P then g h else g' h) = if h : P then f \u226b g h else f \u226b g' h",["aesop"]],["CategoryTheory/Category/Basic.lean",229,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nP : Prop\ninst\u271d : Decidable P\nX Y Z : C\nf : P \u2192 (X \u27f6 Y)\nf' : \u00acP \u2192 (X \u27f6 Y)\ng : Y \u27f6 Z\n\u22a2 (if h : P then f h else f' h) \u226b g = if h : P then f h \u226b g else f' h \u226b g",["aesop"]],["Analysis/Normed/Group/SemiNormedGrp/Kernels.lean",134,"X Y : SemiNormedGrp\nf : X \u27f6 Y\n\u22a2 f \u226b ofHom (Hom.hom f).range.normedMk = 0 \u226b ofHom (Hom.hom f).range.normedMk",["aesop"]],["Data/Prod/Basic.lean",21,"\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1 \u00d7 \u03b2\ny : \u03b2 \u00d7 \u03b1\n\u22a2 x.swap = y \u2194 x = y.swap",["aesop"]],["Algebra/Lie/Abelian.lean",108,"R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\n\u22a2 (\u2200 (x : L), (\u2200 (m : M), \u2045x, m\u2046 = 0) \u2192 x = 0) \u2194 \u2200 (m : L), m \u2208 LieModule.ker R L M \u2194 m \u2208 \u22a5",["aesop"]],["RingTheory/IntegralClosure/IntegrallyClosed.lean",81,"case h.e'_3\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\nhf : Function.Injective \u21d1f\ninj : Function.Injective \u21d1(algebraMap R B)\ncl : \u2200 {x : B}, IsIntegral R x \u2194 \u2203 y, (algebraMap R B) y = x\n\u22a2 \u21d1f \u2218 \u21d1(algebraMap R A) = \u21d1(algebraMap R B)",["aesop"]],["RingTheory/IntegralClosure/IntegrallyClosed.lean",83,"case mk.refine_2.intro\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\nhf : Function.Injective \u21d1f\ninj : Function.Injective \u21d1(algebraMap R B)\ncl : \u2200 {x : B}, IsIntegral R x \u2194 \u2203 y, (algebraMap R B) y = x\nx\u271d : A\nhx : IsIntegral R x\u271d\ny : R\nfx_eq : (algebraMap R B) y = f x\u271d\n\u22a2 \u2203 y, (algebraMap R A) y = x\u271d",["aesop"]],["RingTheory/IntegralClosure/IntegrallyClosed.lean",86,"case mk.refine_3.intro\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\nhf : Function.Injective \u21d1f\ninj : Function.Injective \u21d1(algebraMap R B)\ncl : \u2200 {x : B}, IsIntegral R x \u2194 \u2203 y, (algebraMap R B) y = x\ny : R\n\u22a2 IsIntegral R (f ((algebraMap R A) y))",["aesop"]],["RingTheory/IntegralClosure/IntegrallyClosed.lean",111,"case mp.mk\nR : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra R A\nalgebraMap_injective'\u271d : Function.Injective \u21d1(algebraMap R A)\ncl : \u2200 {x : A}, IsIntegral R x \u2194 \u2203 y, (algebraMap R A) y = x\n\u22a2 Function.Injective \u21d1(algebraMap R A) \u2227 \u2200 {x : A}, IsIntegral R x \u2192 \u2203 y, (algebraMap R A) y = x",["aesop"]],["Combinatorics/SetFamily/Shadow.lean",105,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nt : Finset \u03b1\n\u22a2 (\u2203 s \u2208 \ud835\udc9c, \u2203 a \u2209 t, insert a t = s) \u2194 \u2203 a \u2209 t, insert a t \u2208 \ud835\udc9c",["aesop"]],["Combinatorics/SetFamily/Shadow.lean",122,"case succ\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nk : \u2115\nih : \u2200 {t : Finset \u03b1}, t \u2208 \u2202 ^[k] \ud835\udc9c \u2194 \u2203 u, #u = k \u2227 Disjoint t u \u2227 t \u222a u \u2208 \ud835\udc9c\nt : Finset \u03b1\n\u22a2 (\u2203 a \u2209 t, \u2203 u, #u = k \u2227 Disjoint (insert a t) u \u2227 insert a t \u222a u \u2208 \ud835\udc9c) \u2194\n    \u2203 u, (\u2203 a t, a \u2209 t \u2227 insert a t = u \u2227 #t = k) \u2227 Disjoint t u \u2227 t \u222a u \u2208 \ud835\udc9c",["aesop"]],["Combinatorics/SetFamily/Shadow.lean",215,"\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\n\ud835\udc9c : Finset (Finset \u03b1)\nt : Finset \u03b1\n\u22a2 (\u2203 s \u2208 \ud835\udc9c, \u2203 a \u2208 t, t.erase a = s) \u2194 \u2203 a \u2208 t, t.erase a \u2208 \ud835\udc9c",["aesop"]],["CategoryTheory/Sites/Equivalence.lean",100,"C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nK : GrothendieckTopology D\ne : C \u224c D\nG : D \u2964 C\nA : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} A\ninst\u271d : IsDenseSubsite K J e.inverse\n\u22a2 \u2200 {X Y : Sheaf J A} (f : X \u27f6 Y),\n    (\ud835\udfed (Sheaf J A)).map f \u226b\n        ((fun F \u21a6\n              { hom := { val := (isoWhiskerRight e.op.unitIso F.val).hom },\n                inv := { val := (isoWhiskerRight e.op.unitIso F.val).inv }, hom_inv_id := \u22ef, inv_hom_id := \u22ef })\n            Y).hom =\n      ((fun F \u21a6\n              { hom := { val := (isoWhiskerRight e.op.unitIso F.val).hom },\n                inv := { val := (isoWhiskerRight e.op.unitIso F.val).inv }, hom_inv_id := \u22ef, inv_hom_id := \u22ef })\n            X).hom \u226b\n        (functor J K e A \u22d9 inverse J K e A).map f",["aesop"]],["CategoryTheory/Sites/Equivalence.lean",108,"C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nJ : GrothendieckTopology C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nK : GrothendieckTopology D\ne : C \u224c D\nG : D \u2964 C\nA : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} A\ninst\u271d : IsDenseSubsite K J e.inverse\n\u22a2 \u2200 {X Y : Sheaf K A} (f : X \u27f6 Y),\n    (inverse J K e A \u22d9 functor J K e A).map f \u226b\n        ((fun F \u21a6\n              { hom := { val := (isoWhiskerRight e.op.counitIso F.val).hom },\n                inv := { val := (isoWhiskerRight e.op.counitIso F.val).inv }, hom_inv_id := \u22ef, inv_hom_id := \u22ef })\n            Y).hom =\n      ((fun F \u21a6\n              { hom := { val := (isoWhiskerRight e.op.counitIso F.val).hom },\n                inv := { val := (isoWhiskerRight e.op.counitIso F.val).inv }, hom_inv_id := \u22ef, inv_hom_id := \u22ef })\n            X).hom \u226b\n        (\ud835\udfed (Sheaf K A)).map f",["aesop"]],["RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean",148,"case h\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nk : \u2115\nf : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R\n\u22a2 \u2200 (p : Finset \u03c3 \u00d7 \u03c3),\n    p \u2208 filter (fun t \u21a6 #t.1 = k) (MvPolynomial.NewtonIdentities.pairs \u03c3 k) \u2194 p.1 \u2208 powersetCard k univ \u2227 p.2 \u2208 p.1",["aesop"]],["RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean",156,"case hab\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nk : \u2115\na : \u2115 \u00d7 \u2115\nha : a \u2208 filter (fun a \u21a6 a.1 < k) (antidiagonal k)\nf : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R\np : Finset \u03c3 \u00d7 \u03c3\nhp : #p.1 = a.1\n\u22a2 #p.1 < k",["aesop"]],["RingTheory/MvPolynomial/Symmetric/NewtonIdentities.lean",157,"case h\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : DecidableEq \u03c3\ninst\u271d : Fintype \u03c3\nk : \u2115\na : \u2115 \u00d7 \u2115\nha : a \u2208 filter (fun a \u21a6 a.1 < k) (antidiagonal k)\nf : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R\np : Finset \u03c3 \u00d7 \u03c3\nhp : #p.1 = a.1\nthis : #p.1 \u2264 k\n\u22a2 p \u2208 MvPolynomial.NewtonIdentities.pairs \u03c3 k",["aesop"]],["Data/Nat/Factorization/Defs.lean",47,"a b m n\u271d p n : \u2115\n\u22a2 \u2200 (a : \u2115), Prime a \u2192 (a \u2223 n \u2227 \u00acn = 0 \u2194 \u00aca = 1 \u2227 \u00acn = 0 \u2227 a \u2223 n)",["aesop"]],["LinearAlgebra/PerfectPairing/Restrict.lean",115,"case add\nR : Type u_1\nM : Type u_2\nN : Type u_3\ninst\u271d\u00b9\u2076 : CommRing R\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : AddCommGroup N\ninst\u271d\u00b9\u00b2 : Module R N\np : PerfectPairing R M N\nS : Type u_4\nM' : Type u_5\nN' : Type u_6\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : Algebra S R\ninst\u271d\u2079 : Module S M\ninst\u271d\u2078 : Module S N\ninst\u271d\u2077 : IsScalarTower S R M\ninst\u271d\u2076 : IsScalarTower S R N\ninst\u271d\u2075 : NoZeroSMulDivisors S R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module S M'\ninst\u271d\u00b9 : AddCommGroup N'\ninst\u271d : Module S N'\ni : M' \u2192\u2097[S] M\nj : N' \u2192\u2097[S] N\nhi : Injective \u21d1i\nhN : span R \u2191(LinearMap.range j) = \u22a4\nhp : \u2200 (m : M') (n : N'), (p (i m)) (j n) \u2208 (algebraMap S R).range\nf : M' \u2192\u2097[S] N' \u2192\u2097[S] S := i.restrictScalarsRange j (Algebra.linearMap S R) \u22ef p.toLin hp\nx : M'\nhx : f x = 0\nn x\u271d y\u271d : N\nhx\u271d : x\u271d \u2208 span R \u2191(LinearMap.range j)\nhy\u271d : y\u271d \u2208 span R \u2191(LinearMap.range j)\na\u271d\u00b9 : (p (i x)) x\u271d = 0\na\u271d : (p (i x)) y\u271d = 0\n\u22a2 (p.toLin (i x)) x\u271d + (p.toLin (i x)) y\u271d = 0",["aesop"]],["LinearAlgebra/PerfectPairing/Restrict.lean",116,"case smul\nR : Type u_1\nM : Type u_2\nN : Type u_3\ninst\u271d\u00b9\u2076 : CommRing R\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : AddCommGroup N\ninst\u271d\u00b9\u00b2 : Module R N\np : PerfectPairing R M N\nS : Type u_4\nM' : Type u_5\nN' : Type u_6\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : Algebra S R\ninst\u271d\u2079 : Module S M\ninst\u271d\u2078 : Module S N\ninst\u271d\u2077 : IsScalarTower S R M\ninst\u271d\u2076 : IsScalarTower S R N\ninst\u271d\u2075 : NoZeroSMulDivisors S R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module S M'\ninst\u271d\u00b9 : AddCommGroup N'\ninst\u271d : Module S N'\ni : M' \u2192\u2097[S] M\nj : N' \u2192\u2097[S] N\nhi : Injective \u21d1i\nhN : span R \u2191(LinearMap.range j) = \u22a4\nhp : \u2200 (m : M') (n : N'), (p (i m)) (j n) \u2208 (algebraMap S R).range\nf : M' \u2192\u2097[S] N' \u2192\u2097[S] S := i.restrictScalarsRange j (Algebra.linearMap S R) \u22ef p.toLin hp\nx : M'\nhx : f x = 0\nn : N\na\u271d\u00b9 : R\nx\u271d : N\nhx\u271d : x\u271d \u2208 span R \u2191(LinearMap.range j)\na\u271d : (p (i x)) x\u271d = 0\n\u22a2 a\u271d\u00b9 \u2022 (p.toLin (i x)) x\u271d = 0",["aesop"]],["Data/Finset/Union.lean",151,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : \u03b1 \u2192 Finset \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 (insert a s).biUnion t = t a \u222a s.biUnion t",["aesop"]],["Data/Finset/Union.lean",155,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u2081 s\u2082 : Finset \u03b1\nt\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2\ninst\u271d : DecidableEq \u03b2\nhs : s\u2081 = s\u2082\nht : \u2200 a \u2208 s\u2081, t\u2081 a = t\u2082 a\n\u22a2 s\u2081.biUnion t\u2081 = s\u2082.biUnion t\u2082",["aesop"]],["Combinatorics/Schnirelmann.lean",155,"case e_s.h.mk.e_a.e_a.e_s.h\nA : Set \u2115\ninst\u271d\u00b9 : DecidablePred fun x \u21a6 x \u2208 A\nB : Set \u2115\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 B\nh : \u2200 n > 0, n \u2208 A \u2194 n \u2208 B\nn : \u2115\nhn : 0 < n\nx : \u2115\n\u22a2 x \u2208 filter (fun a \u21a6 a \u2208 A) (Ioc 0 \u2191\u27e8n, hn\u27e9) \u2194 x \u2208 filter (fun a \u21a6 a \u2208 B) (Ioc 0 \u2191\u27e8n, hn\u27e9)",["aesop"]],["Combinatorics/Schnirelmann.lean",160,"A : Set \u2115\ninst\u271d\u00b9 : DecidablePred fun x \u21a6 x \u2208 A\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 insert 0 A\n\u22a2 \u2200 n > 0, n \u2208 insert 0 A \u2194 n \u2208 A",["aesop"]],["Combinatorics/Schnirelmann.lean",165,"A : Set \u2115\ninst\u271d\u00b9 : DecidablePred fun x \u21a6 x \u2208 A\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 A \\ {0}\n\u22a2 \u2200 n > 0, n \u2208 A \\ {0} \u2194 n \u2208 A",["aesop"]],["Combinatorics/Schnirelmann.lean",169,"A : Set \u2115\ninst\u271d\u00b9 : DecidablePred fun x \u21a6 x \u2208 A\nB : Set \u2115\ninst\u271d : DecidablePred fun x \u21a6 x \u2208 B\nh : A = B\n\u22a2 \u2200 n > 0, n \u2208 A \u2194 n \u2208 B",["aesop"]],["Algebra/Lie/LieTheorem.lean",63,"case h\nR : Type u_1\nL : Type u_2\nA : Type u_3\nV : Type u_4\ninst\u271d\u00b9\u2079 : CommRing R\ninst\u271d\u00b9\u2078 : IsPrincipalIdealRing R\ninst\u271d\u00b9\u2077 : IsDomain R\ninst\u271d\u00b9\u2076 : CharZero R\ninst\u271d\u00b9\u2075 : LieRing L\ninst\u271d\u00b9\u2074 : LieAlgebra R L\ninst\u271d\u00b9\u00b3 : LieRing A\ninst\u271d\u00b9\u00b2 : LieAlgebra R A\ninst\u271d\u00b9\u00b9 : Bracket L A\ninst\u271d\u00b9\u2070 : Bracket A L\ninst\u271d\u2079 : AddCommGroup V\ninst\u271d\u2078 : Module R V\ninst\u271d\u2077 : Module.Free R V\ninst\u271d\u2076 : Module.Finite R V\ninst\u271d\u2075 : LieRingModule L V\ninst\u271d\u2074 : LieModule R L V\ninst\u271d\u00b3 : LieRingModule A V\ninst\u271d\u00b2 : LieModule R A V\ninst\u271d\u00b9 : IsLieTower L A V\ninst\u271d : IsLieTower A L V\n\u03c7 : A \u2192 R\nz : L\nv : V\nhv : \u2200 (x : A), \u2045x, v\u2046 = \u03c7 x \u2022 v\na : A\nhv' : v \u2260 0\nU' : \u2115 \u2192o Submodule R V :=\n  { toFun := fun n \u21a6 Submodule.span R {x | \u2203 i < n, ((toEnd R L V) z ^ i) v = x}, monotone' := \u22ef }\nn : \u2115\n\u22a2 \u2200 a < n, \u2203 b < n + 1, ((toEnd R L V) z ^ b) v = ((toEnd R L V) z ^ (a + 1)) v",["aesop"]],["Algebra/Order/Antidiag/Pi.lean",119,"case refine_2.h\n\u03b9 : Type u_1\n\u03bc : Type u_2\n\u03bc' : Type u_3\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : AddCommMonoid \u03bc\ninst\u271d\u00b9 : HasAntidiagonal \u03bc\ninst\u271d : DecidableEq \u03bc\nn\u271d : \u03bc\ns : Finset \u03b9\nn : \u03bc\ne\u2081 e\u2082 : { x // x \u2208 s } \u2243 Fin #s\nf : \u03b9 \u2192 \u03bc\ng : Fin #s \u2192 \u03bc\nthis : \u2211 x : Fin #s, g ((e\u2082.symm.trans e\u2081) x) = \u2211 x : Fin #s, g x\n\u22a2 \u2211 i : Fin #s, g i = n \u2227 { toFun := fun f i \u21a6 if hi : i \u2208 s then f (e\u2081 \u27e8i, hi\u27e9) else 0, inj' := \u22ef } g = f \u2194\n    \u2211 i : Fin #s, ((e\u2081.symm.trans e\u2082).arrowCongr (Equiv.refl \u03bc)) g i = n \u2227\n      { toFun := fun f i \u21a6 if hi : i \u2208 s then f (e\u2082 \u27e8i, hi\u27e9) else 0, inj' := \u22ef }\n          (((e\u2081.symm.trans e\u2082).arrowCongr (Equiv.refl \u03bc)) g) =\n        f",["aesop"]],["Algebra/Order/Antidiag/Pi.lean",227,"case h.mpr.intro.intro\n\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : DecidableEq (\u03b9 \u2192 \u2115)\ns : Finset \u03b9\nm n : \u2115\nhn : n \u2260 0\nf : \u03b9 \u2192 \u2115\nhfsum : s.sum f = n * m\nhfsup : \u2200 (i : \u03b9), f i \u2260 0 \u2192 i \u2208 s\nhfdvd : \u2200 i \u2208 s, n \u2223 f i\nthis : \u2200 (i : \u03b9), n \u2223 f i\n\u22a2 \u2200 (i : \u03b9), n \u2264 f i \u2192 i \u2208 s",["aesop"]],["Algebra/Group/Graph.lean",56,"G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Monoid G\ninst\u271d : Monoid H\nf : G \u2192* H\n\u22a2 f.mgraph = mrange ((id G).prod f)",["aesop"]],["Algebra/Group/Graph.lean",171,"G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group H\nf : G \u2192* H\n\u22a2 f.graph = ((id G).prod f).range",["aesop"]],["Combinatorics/SimpleGraph/Connectivity/WalkDecomp.lean",192,"case nil\nV : Type u\nG : SimpleGraph V\nw : V\ninst\u271d : DecidableEq V\nu : V\nn : \u2115\nhw\u271d : w \u2208 nil.support\nhn : n \u2264 (nil.takeUntil w hw\u271d).length\nhw : w = u\n\u22a2 (nil.takeUntil w hw\u271d).getVert n = nil.getVert n",["aesop"]],["Data/Set/Sups.lean",155,"case h\n\u03b1 : Type u_2\ninst\u271d : SemilatticeSup \u03b1\ns t : Set \u03b1\na x\u271d : \u03b1\n\u22a2 x\u271d \u2208 {b | b \u2208 s \u22bb t \u2227 b \u2264 a} \u2194 x\u271d \u2208 {b | b \u2208 s \u2227 b \u2264 a} \u22bb {b | b \u2208 t \u2227 b \u2264 a}",["aesop"]],["Data/Set/Sups.lean",284,"case h\n\u03b1 : Type u_2\ninst\u271d : SemilatticeInf \u03b1\ns t : Set \u03b1\na x\u271d : \u03b1\n\u22a2 x\u271d \u2208 {b | b \u2208 s \u22bc t \u2227 a \u2264 b} \u2194 x\u271d \u2208 {b | b \u2208 s \u2227 a \u2264 b} \u22bc {b | b \u2208 t \u2227 a \u2264 b}",["aesop"]],["GroupTheory/QuotientGroup/Defs.lean",150,"G : Type u\ninst\u271d : Group G\nN : Subgroup G\nnN : N.Normal\n\u22a2 Subgroup.map (mk' N) N = \u22a5",["aesop"]],["AlgebraicTopology/SimplicialSet/StdSimplex.lean",162,"n : \u2115\nS : Finset (Fin (n + 1))\nU V : SimplexCategory\u1d52\u1d56\ni : U \u27f6 V\n\u22a2 (fun U \u21a6 {f | Finset.image \u21d1(Hom.toOrderHom (objEquiv f)) \u22a4 \u2264 S}) U \u2286\n    \u0394[n].map i \u207b\u00b9' (fun U \u21a6 {f | Finset.image \u21d1(Hom.toOrderHom (objEquiv f)) \u22a4 \u2264 S}) V",["aesop"]],["AlgebraicTopology/SimplicialSet/StdSimplex.lean",173,"n : \u2115\nS\u2081 S\u2082 : Finset (Fin (n + 1))\n\u22a2 face S\u2081 \u2293 face S\u2082 = face (S\u2081 \u2293 S\u2082)",["aesop"]],["LinearAlgebra/RootSystem/Base.lean",186,"case neg\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\nP : RootPairing \u03b9 R M N\nb : P.Base\ninst\u271d\u00b9 : CharZero R\ninst\u271d : Fintype \u03b9\nf\u271d : \u03b9 \u2192 \u2124\nhf : \u2211 j : \u03b9, f\u271d j \u2022 P.root j \u2208 range \u21d1P.root\nhf\u2080\u271d : Function.support f\u271d \u2286 b.support\nf : \u03b9 \u2192 \u2124\nhf\u2080 : Function.support f \u2286 b.support\n_i : Fintype \u2191b.support\nf' : \u2191b.support \u2192 \u2124 := fun i \u21a6 f \u2191i\nc : \u2191b.support \u2192 \u2115\nhc : \u2200 (i : \u2191b.support), \u2191(c i) = f' i\ni : \u03b9\nhi : i \u2209 Function.support f\n\u22a2 0 i \u2264 f i",["aesop"]],["CategoryTheory/FiberedCategory/BasedCategory.lean",203,"case h\n\ud835\udcae : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} \ud835\udcae\n\ud835\udcb3 : BasedCategory \ud835\udcae\n\ud835\udcb4 : BasedCategory \ud835\udcae\nF G : \ud835\udcb3 \u2964\u1d47 \ud835\udcb4\n\u03b1 : F \u27f6 G\nx\u271d : IsIso ((forgetful \ud835\udcb3 \ud835\udcb4).map \u03b1)\n\u22a2 \u03b1 \u226b { toNatTrans := inv ((forgetful \ud835\udcb3 \ud835\udcb4).map \u03b1), isHomLift' := \u22ef } = \ud835\udfd9 F \u2227\n    { toNatTrans := inv ((forgetful \ud835\udcb3 \ud835\udcb4).map \u03b1), isHomLift' := \u22ef } \u226b \u03b1 = \ud835\udfd9 G",["aesop"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",130,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ni j : \u03b9\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nh : 0 < P.pairingIn \u2124 i j\nh' : i \u2260 j\n_i : NoZeroSMulDivisors \u2124 M\nhli : LinearIndependent R ![P.root i, P.root j]\naux\u2081 : P.coxeterWeightIn \u2124 i j \u2208 {0, 1, 2, 3, 4}\naux\u2082 : P.coxeterWeightIn \u2124 i j \u2260 4\naux\u2083 : P.coxeterWeightIn \u2124 i j \u2260 0\n\u22a2 P.coxeterWeightIn \u2124 i j \u2208 {1, 2, 3}",["aesop"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",139,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ni j : \u03b9\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nh : 0 < P.pairingIn \u2124 i j\nh' : i \u2260 j\n_i : NoZeroSMulDivisors \u2124 M\nthis :\n  (P.pairingIn \u2124 i j, P.pairingIn \u2124 j i) \u2208\n    {(0, 0), (1, 1), (-1, -1), (1, 2), (2, 1), (-1, -2), (-2, -1), (1, 3), (3, 1), (-1, -3), (-3, -1), (4, 1), (1, 4),\n      (-4, -1), (-1, -4), (2, 2), (-2, -2)}\nhli : P.pairingIn \u2124 i j * P.pairingIn \u2124 j i = 4\n\u22a2 (P.pairingIn \u2124 i j, P.pairingIn \u2124 j i) \u2208 {(1, 4), (2, 2), (4, 1)}",["aesop"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",204,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nb : P.Base\ni j k : \u03b9\nhij : i \u2260 j\nhi : i \u2208 b.support\nhj : j \u2208 b.support\nhkj : k \u2260 j\nhm : P.pairingIn \u2124 j k \u2264 0\nl : \u03b9\nhl : P.root l = P.root k + P.root i - P.root j\nhli : l \u2260 i\nhkl : P.pairingIn \u2124 l k \u2264 0\nhki : P.pairingIn \u2124 i k \u2264 -2\nhk' : P.root i \u2260 -P.root k\naux : P.pairingIn \u2124 i k = -2 \u2192 \u00acP.pairingIn \u2124 k i = -2\nthis :\n  (P.pairingIn \u2124 i k, P.pairingIn \u2124 k i) \u2208\n    {(0, 0), (1, 1), (-1, -1), (1, 2), (2, 1), (-1, -2), (-2, -1), (1, 3), (3, 1), (-1, -3), (-3, -1), (4, 1), (1, 4),\n      (-4, -1), (-1, -4), (2, 2), (-2, -2)}\n\u22a2 P.pairingIn \u2124 k i = -1",["aesop"]],["LinearAlgebra/RootSystem/Finite/Lemmas.lean",227,"\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R N\nP : RootPairing \u03b9 R M N\ninst\u271d\u2075 : Finite \u03b9\ninst\u271d\u2074 : CharZero R\ninst\u271d\u00b3 : P.IsCrystallographic\ninst\u271d\u00b2 : NoZeroDivisors R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : NoZeroSMulDivisors R N\nb : P.Base\ni j k : \u03b9\nhij : i \u2260 j\nhi : i \u2208 b.support\nhj : j \u2208 b.support\nhkj : P.root k \u2260 -P.root i\nhk' : P.root k - P.root j \u2208 range \u21d1P.root\n_i : InvolutiveNeg \u03b9 := P.indexNeg\nhk : P.root (-k) + P.root j - P.root i \u2208 range \u21d1P.root\n\u22a2 -k \u2260 i",["aesop"]],["CategoryTheory/Quotient.lean",62,"C\u271d : Type ?u.1144\ninst\u271d\u00b2 : Category.{?u.1148, ?u.1144} C\u271d\nr : HomRel C\u271d\nC : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Category.{u_4, u_2} D\nF : C \u2964 D\nX\u271d Y\u271d : C\n\u22a2 \u2200 {x y : X\u271d \u27f6 Y\u271d}, F.homRel x y \u2192 F.homRel y x",["aesop"]],["CategoryTheory/Quotient.lean",63,"C\u271d : Type ?u.1144\ninst\u271d\u00b2 : Category.{?u.1148, ?u.1144} C\u271d\nr : HomRel C\u271d\nC : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Category.{u_4, u_2} D\nF : C \u2964 D\nX\u271d Y\u271d : C\n\u22a2 \u2200 {x y z : X\u271d \u27f6 Y\u271d}, F.homRel x y \u2192 F.homRel y z \u2192 F.homRel x z",["aesop"]],["CategoryTheory/Quotient.lean",64,"C\u271d : Type ?u.1144\ninst\u271d\u00b2 : Category.{?u.1148, ?u.1144} C\u271d\nr : HomRel C\u271d\nC : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Category.{u_4, u_2} D\nF : C \u2964 D\n\u22a2 \u2200 {X Y Z : C} (f : X \u27f6 Y) {g g' : Y \u27f6 Z}, F.homRel g g' \u2192 F.homRel (f \u226b g) (f \u226b g')",["aesop"]],["CategoryTheory/Quotient.lean",65,"C\u271d : Type ?u.1144\ninst\u271d\u00b2 : Category.{?u.1148, ?u.1144} C\u271d\nr : HomRel C\u271d\nC : Type u_1\nD : Type u_2\ninst\u271d\u00b9 : Category.{u_3, u_1} C\ninst\u271d : Category.{u_4, u_2} D\nF : C \u2964 D\n\u22a2 \u2200 {X Y Z : C} {f f' : X \u27f6 Y} (g : Y \u27f6 Z), F.homRel f f' \u2192 F.homRel (f \u226b g) (f' \u226b g)",["aesop"]],["Data/Matrix/Basis.lean",255,"n : Type u_3\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : Semiring \u03b1\ni j k : n\nM : Matrix n n \u03b1\nhM : Commute (stdBasisMatrix i j 1) M\nhkj : k \u2260 j\nthis : (stdBasisMatrix i j 1 * M) i k = (M * stdBasisMatrix i j 1) i k\n\u22a2 M j k = 0",["aesop"]],["Data/Matrix/Basis.lean",260,"n : Type u_3\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : Semiring \u03b1\ni j k : n\nM : Matrix n n \u03b1\nhM : Commute (stdBasisMatrix i j 1) M\nhki : k \u2260 i\nthis : (stdBasisMatrix i j 1 * M) k j = (M * stdBasisMatrix i j 1) k j\n\u22a2 M k i = 0",["aesop"]],["Data/Matrix/Basis.lean",265,"n : Type u_3\n\u03b1 : Type u_5\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\ninst\u271d : Semiring \u03b1\ni j : n\nM : Matrix n n \u03b1\nhM : Commute (stdBasisMatrix i j 1) M\nthis : (stdBasisMatrix i j 1 * M) i j = (M * stdBasisMatrix i j 1) i j\n\u22a2 M i i = M j j",["aesop"]],["Algebra/Module/CharacterModule.lean",48,"R : Type uR\ninst\u271d\u00b3 : CommRing R\nA : Type uA\ninst\u271d\u00b2 : AddCommGroup A\nA' : Type u_1\ninst\u271d\u00b9 : AddCommGroup A'\nB : Type uB\ninst\u271d : AddCommGroup B\nx\u271d\u00b2 x\u271d\u00b9 : CharacterModule A\nx\u271d : (fun c \u21a6 (\u2191c).toFun) x\u271d\u00b2 = (fun c \u21a6 (\u2191c).toFun) x\u271d\u00b9\n\u22a2 x\u271d\u00b2 = x\u271d\u00b9",["aesop"]],["Algebra/Module/CharacterModule.lean",119,"R : Type uR\ninst\u271d\u2076 : CommRing R\nA : Type uA\ninst\u271d\u2075 : AddCommGroup A\nA' : Type u_1\ninst\u271d\u2074 : AddCommGroup A'\nB : Type uB\ninst\u271d\u00b3 : AddCommGroup B\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : Module R A'\ninst\u271d : Module R B\nr : R\nc : A \u2192\u2097[R] CharacterModule B\nx : A \u2297[R] B\n\u22a2 \u2200 (x y : A \u2297[R] B),\n    ({ toFun := fun c \u21a6 liftAddHom c.toAddMonoidHom \u22ef, map_add' := \u22ef }.toFun (r \u2022 c)) x =\n        ((RingHom.id R) r \u2022 { toFun := fun c \u21a6 liftAddHom c.toAddMonoidHom \u22ef, map_add' := \u22ef }.toFun c) x \u2192\n      ({ toFun := fun c \u21a6 liftAddHom c.toAddMonoidHom \u22ef, map_add' := \u22ef }.toFun (r \u2022 c)) y =\n          ((RingHom.id R) r \u2022 { toFun := fun c \u21a6 liftAddHom c.toAddMonoidHom \u22ef, map_add' := \u22ef }.toFun c) y \u2192\n        ({ toFun := fun c \u21a6 liftAddHom c.toAddMonoidHom \u22ef, map_add' := \u22ef }.toFun (r \u2022 c)) (x + y) =\n          ((RingHom.id R) r \u2022 { toFun := fun c \u21a6 liftAddHom c.toAddMonoidHom \u22ef, map_add' := \u22ef }.toFun c) (x + y)",["aesop"]],["Analysis/Convex/Visible.lean",53,"\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module \ud835\udd5c V\ninst\u271d : AddTorsor V P\ns : Set P\nx y : P\nhxy : x \u2260 y\n\u22a2 (\u2200 \u2983z : P\u2984, z \u2208 s \u2192 \u2200 (x_1 : \ud835\udd5c), 0 < x_1 \u2192 x_1 < 1 \u2192 \u00ac(lineMap x y) x_1 = z) \u2194\n    \u2200 (\u03b4 : \ud835\udd5c), 0 < \u03b4 \u2192 \u03b4 < 1 \u2192 (lineMap x y) \u03b4 \u2209 s",["aesop"]],["Analysis/Convex/Visible.lean",120,"\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u2077 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module \ud835\udd5c V\ns : Set V\nx y : V\ninst\u271d\u2074 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b3 : OrderTopology \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace V\ninst\u271d\u00b9 : IsTopologicalAddGroup V\ninst\u271d : ContinuousSMul \ud835\udd5c V\nhsxy : IsVisible \ud835\udd5c s x y\nhy : y \u2208 interior s\nhxy : x \u2260 y\nhmem\u271d : \u2200\u1da0 (\u03b4 : \ud835\udd5c) in \ud835\udcdd[>] 0, (lineMap y x) \u03b4 \u2208 s\n\u03b4 : \ud835\udd5c\nhmem : (lineMap y x) \u03b4 \u2208 s\nhsbt : \u03b4 \u2208 Set.Ioo 0 1\n\u22a2 Sbtw \ud835\udd5c y ((lineMap y x) \u03b4) x",["aesop"]],["MeasureTheory/Measure/Dirac.lean",84,"\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : Countable \u03b1\n\u03bc \u03bd : Measure \u03b1\nh : \u2200 (a : \u03b1), \u03bc {a} = \u03bd {a}\n\u22a2 \u2200 s \u2208 range singleton, \u03bc.restrict s = \u03bd.restrict s",["aesop"]],["Data/Finset/Sym.lean",57,"case inl\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Finset \u03b1\nha : a \u2208 s\n\u22a2 \u2200 x \u2208 s, s(a, x) \u2208 s.sym2",["aesop"]],["CategoryTheory/Limits/Shapes/FunctorToTypes.lean",155,"case a\nC : Type u\ninst\u271d : Category.{v, u} C\nF G : C \u2964 Type w\na : C\nz w : (F \u2a2f G).obj a\nh1 : Limits.prod.fst.app a z = Limits.prod.fst.app a w\nh2 : Limits.prod.snd.app a z = Limits.prod.snd.app a w\n\u22a2 (binaryProductEquiv F G a) z = (binaryProductEquiv F G a) w",["aesop"]],["CategoryTheory/Limits/Shapes/FunctorToTypes.lean",230,"C : Type u\ninst\u271d : Category.{v, u} C\nF G : C \u2964 Type w\n\u22a2 Limits.coprod.inl \u226b (colimit.isoColimitCocone (binaryCoproductColimitCocone F G)).hom = coprod.inl",["aesop"]],["Topology/Order/LawsonTopology.lean",91,"\u03b1 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsLawson \u03b1\n\u22a2 {s | \u2203 t, t.Finite \u2227 \u2203 u, IsOpen u \u2227 (\u2191(upperClosure t))\u1d9c \u2229 u = s} =\n    {c |\n      \u2203 a \u2208 {s | \u2203 t, t.Finite \u2227 (\u2191(upperClosure t))\u1d9c = s},\n        \u2203 b \u2208 {U | IsOpen U}, \u21d1WithLower.toLower \u207b\u00b9' a \u2229 \u21d1WithScott.toScott \u207b\u00b9' b = c}",["aesop"]],["RingTheory/Ideal/Maximal.lean",172,"\u03b1 : Type u\ninst\u271d : CommSemiring \u03b1\nS : Submonoid \u03b1\ndisjoint : Disjoint \u2191\u22a4 \u2191S\nmaximally_disjoint : \u2200 (J : Ideal \u03b1), \u22a4 < J \u2192 \u00acDisjoint \u2191J \u2191S\nthis : 1 \u2208 \u2191S\n\u22a2 False",["aesop"]],["Algebra/Polynomial/Module/AEval.lean",140,"case h\nR : Type ?u.120663\nA : Type ?u.120666\nM : Type ?u.120693\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\na : A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module A M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsScalarTower R A M\nq : Submodule R[X] (AEval R M a)\nx\u271d : AEval R M a\n\u22a2 x\u271d \u2208\n      (fun p \u21a6 { toAddSubmonoid := AddSubmonoid.map (of R M a) (\u2191p).toAddSubmonoid, smul_mem' := \u22ef })\n        ((fun q \u21a6 \u27e8(Submodule.orderIsoMapComap (of R M a)).symm (Submodule.restrictScalars R q), \u22ef\u27e9) q) \u2194\n    x\u271d \u2208 q",["aesop"]],["Combinatorics/SimpleGraph/Operations.lean",116,"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\ne : Sym2 V\nhe : e \u2208 G.edgeFinset \\ G.incidenceFinset t\nthis : t \u2209 e\n\u22a2 \u2200 b \u2208 image (fun x \u21a6 s(x, t)) (G.neighborFinset s), e \u2260 b",["aesop"]],["Combinatorics/SimpleGraph/Operations.lean",127,"case e_a.e_a.H\nV : Type u_1\nG : SimpleGraph V\ns t : V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\nhn : \u00acG.Adj s t\ninc : G.incidenceFinset t \u2286 G.edgeFinset\n\u22a2 \u2200 \u2983a\u2081 a\u2082 : V\u2984, (fun x \u21a6 s(x, t)) a\u2081 = (fun x \u21a6 s(x, t)) a\u2082 \u2192 a\u2081 = a\u2082",["aesop"]],["Combinatorics/SimpleGraph/Operations.lean",138,"case e_a.e_a.H\nV : Type u_1\nG : SimpleGraph V\ns t : V\ninst\u271d\u00b2 : DecidableEq V\ninst\u271d\u00b9 : Fintype V\ninst\u271d : DecidableRel G.Adj\nha : G.Adj s t\ninc : G.incidenceFinset t \u2286 G.edgeFinset\n\u22a2 \u2200 \u2983a\u2081 a\u2082 : V\u2984, (fun x \u21a6 s(x, t)) a\u2081 = (fun x \u21a6 s(x, t)) a\u2082 \u2192 a\u2081 = a\u2082",["aesop"]],["Combinatorics/SimpleGraph/Operations.lean",163,"case Adj.h.h.a\nV : Type u_1\ns x\u271d\u00b9 x\u271d : V\n\u22a2 (x\u271d\u00b9 = s \u2227 x\u271d = s \u2228 x\u271d\u00b9 = s \u2227 x\u271d = s) \u2227 x\u271d\u00b9 \u2260 x\u271d \u2194 \u22a5.Adj x\u271d\u00b9 x\u271d",["aesop"]],["RingTheory/MatrixAlgebra.lean",208,"n : Type u_3\nR : Type u_5\nA : Type u_6\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\ni j : n\nx : A\n\u22a2 \u2200 (p : n \u00d7 n), i = p.1 \u2227 j = p.2 \u2194 p = (i, j)",["aesop"]],["Combinatorics/SimpleGraph/Triangle/Counting.lean",129,"\u03b1 : Type u_1\nG : SimpleGraph \u03b1\ninst\u271d : DecidableRel G.Adj\n\u03b5 : \u211d\ns t\u271d u : Finset \u03b1\ndst : 2 * \u03b5 \u2264 \u2191(G.edgeDensity s t\u271d)\nhst : G.IsUniform \u03b5 s t\u271d\ndsu : 2 * \u03b5 \u2264 \u2191(G.edgeDensity s u)\nusu : G.IsUniform \u03b5 s u\ndtu : 2 * \u03b5 \u2264 \u2191(G.edgeDensity t\u271d u)\nutu : G.IsUniform \u03b5 t\u271d u\nh\u2081 : \u2191(#(SimpleGraph.badVertices G \u03b5 s t\u271d)) \u2264 \u2191(#s) * \u03b5\nh\u2082 : \u2191(#(SimpleGraph.badVertices G \u03b5 s u)) \u2264 \u2191(#s) * \u03b5\nX' : Finset \u03b1 := s \\ (SimpleGraph.badVertices G \u03b5 s t\u271d \u222a SimpleGraph.badVertices G \u03b5 s u)\nthis :\n  (X'.biUnion fun x \u21a6\n      image (fun x_1 \u21a6 (x, x_1)) (G.interedges (filter (fun y \u21a6 G.Adj x y) t\u271d) (filter (fun y \u21a6 G.Adj x y) u))) \u2286\n    filter\n      (fun x \u21a6\n        match x with\n        | (a, b, c) => G.Adj a b \u2227 G.Adj a c \u2227 G.Adj b c)\n      (s \u00d7\u02e2 t\u271d \u00d7\u02e2 u)\na : \u03b1\na\u271d\u00b9 : a \u2208 \u2191X'\nb : \u03b1\na\u271d : b \u2208 \u2191X'\nt : a \u2260 b\n\u22a2 \u2200 (a_1 a_2 b_1 a_3 b_2 : \u03b1),\n    (a_3, b_2) \u2208 G.interedges (filter (fun y \u21a6 G.Adj a y) t\u271d) (filter (fun y \u21a6 G.Adj a y) u) \u2192\n      a = a_1 \u2192\n        a_3 = a_2 \u2192\n          b_2 = b_1 \u2192\n            \u2200 (a b_3 : \u03b1),\n              (a, b_3) \u2208 G.interedges (filter (fun y \u21a6 G.Adj b y) t\u271d) (filter (fun y \u21a6 G.Adj b y) u) \u2192\n                b = a_1 \u2192 a = a_2 \u2192 \u00acb_3 = b_1",["aesop"]],["Data/Finset/SDiff.lean",180,"case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na b : \u03b1\nhab : a \u2260 b\nha : a \u2209 s\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 insert a s \\ insert b s \u2194 a\u271d \u2208 {a}",["aesop"]],["Combinatorics/Additive/Energy.lean",122,"case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Mul \u03b1\ns t : Finset \u03b1\n\u22a2 \u2200 \u2983x : \u03b1\u2984,\n    x \u2208 \u2191s * \u2191t \u2192\n      \u2200 \u2983y : \u03b1\u2984,\n        y \u2208 \u2191s * \u2191t \u2192\n          \u00acx = y \u2192\n            \u2200 (a b a_1 b_1 : \u03b1),\n              a \u2208 s \u2192\n                b \u2208 t \u2192\n                  a * b = x \u2192\n                    a_1 \u2208 s \u2192 b_1 \u2208 t \u2192 a_1 * b_1 = x \u2192 a \u2208 s \u2192 b \u2208 t \u2192 a * b = y \u2192 a_1 \u2208 s \u2192 b_1 \u2208 t \u2192 \u00aca_1 * b_1 = y",["aesop"]],["GroupTheory/Coxeter/Matrix.lean",108,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn : \u2115\n\u22a2 \u2200 (i i' : Fin n),\n    i \u2260 i' \u2192 Matrix.of (fun i j \u21a6 if i = j then 1 else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2) i i' \u2260 1",["aesop"]],["GroupTheory/Coxeter/Matrix.lean",123,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn : \u2115\n\u22a2 (Matrix.of fun i j \u21a6\n        if i = j then 1\n        else\n          if \u2191i = n - 1 \u2227 \u2191j = n - 2 \u2228 \u2191j = n - 1 \u2227 \u2191i = n - 2 then 4\n          else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2).transpose =\n    Matrix.of fun i j \u21a6\n      if i = j then 1\n      else if \u2191i = n - 1 \u2227 \u2191j = n - 2 \u2228 \u2191j = n - 1 \u2227 \u2191i = n - 2 then 4 else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2",["aesop"]],["GroupTheory/Coxeter/Matrix.lean",125,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn : \u2115\n\u22a2 \u2200 (i i' : Fin n),\n    i \u2260 i' \u2192\n      Matrix.of\n          (fun i j \u21a6\n            if i = j then 1\n            else\n              if \u2191i = n - 1 \u2227 \u2191j = n - 2 \u2228 \u2191j = n - 1 \u2227 \u2191i = n - 2 then 4 else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2)\n          i i' \u2260\n        1",["aesop"]],["GroupTheory/Coxeter/Matrix.lean",143,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn : \u2115\n\u22a2 (Matrix.of fun i j \u21a6\n        if i = j then 1\n        else\n          if \u2191i = n - 1 \u2227 \u2191j = n - 3 \u2228 \u2191j = n - 1 \u2227 \u2191i = n - 3 then 3\n          else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2).transpose =\n    Matrix.of fun i j \u21a6\n      if i = j then 1\n      else if \u2191i = n - 1 \u2227 \u2191j = n - 3 \u2228 \u2191j = n - 1 \u2227 \u2191i = n - 3 then 3 else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2",["aesop"]],["GroupTheory/Coxeter/Matrix.lean",145,"B : Type u_1\nB' : Type u_2\ne : B \u2243 B'\nM : CoxeterMatrix B\nn : \u2115\n\u22a2 \u2200 (i i' : Fin n),\n    i \u2260 i' \u2192\n      Matrix.of\n          (fun i j \u21a6\n            if i = j then 1\n            else\n              if \u2191i = n - 1 \u2227 \u2191j = n - 3 \u2228 \u2191j = n - 1 \u2227 \u2191i = n - 3 then 3 else if \u2191j + 1 = \u2191i \u2228 \u2191i + 1 = \u2191j then 3 else 2)\n          i i' \u2260\n        1",["aesop"]],["Algebra/Homology/Double.lean",54,"C : Type u_1\ninst\u271d\u00b2 : Category.{?u.156, u_1} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\nX\u2080 X\u2081 : C\nf : X\u2080 \u27f6 X\u2081\n\u03b9 : Type u_2\nc : ComplexShape \u03b9\ni\u2080 i\u2081 : \u03b9\nhi\u2080\u2081 : c.Rel i\u2080 i\u2081\ni j : \u03b9\nhij : \u00acc.Rel i j\n\u22a2 \u00ac(i = i\u2080 \u2227 j = i\u2081 \u2227 i\u2080 \u2260 i\u2081)",["aesop"]],["CategoryTheory/Presentable/IsCardinalFiltered.lean",169,"\u03ba : Cardinal.{w}\nh\u03ba : Fact \u03ba.IsRegular\n\u03b9 : Type w\nf : \u03b9 \u2192 \u03ba.ord.toType\nhs : Cardinal.mk \u03b9 < \u03ba\nx\u271d : { x // x \u2208 Set.range f }\n\u22a2 \u2203 a, (fun i \u21a6 \u27e8f i, \u22ef\u27e9) a = x\u271d",["aesop"]],["Order/CompleteSublattice.lean",50,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nf : CompleteLatticeHom \u03b1 \u03b2\ncarrier : Set \u03b1\nsSupClosed' : \u2200 \u2983s : Set \u03b1\u2984, s \u2286 carrier \u2192 sSup s \u2208 carrier\nsInfClosed' : \u2200 \u2983s : Set \u03b1\u2984, s \u2286 carrier \u2192 sInf s \u2208 carrier\nx : \u03b1\nhx : x \u2208 carrier\ny : \u03b1\nhy : y \u2208 carrier\nthis : x \u2294 y = sSup {x, y}\nz : \u03b1\nhz : z \u2208 {x, y}\n\u22a2 z \u2208 carrier",["aesop"]],["Order/CompleteSublattice.lean",53,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nf : CompleteLatticeHom \u03b1 \u03b2\ncarrier : Set \u03b1\nsSupClosed' : \u2200 \u2983s : Set \u03b1\u2984, s \u2286 carrier \u2192 sSup s \u2208 carrier\nsInfClosed' : \u2200 \u2983s : Set \u03b1\u2984, s \u2286 carrier \u2192 sInf s \u2208 carrier\nx : \u03b1\nhx : x \u2208 carrier\ny : \u03b1\nhy : y \u2208 carrier\nthis : x \u2293 y = sInf {x, y}\nz : \u03b1\nhz : z \u2208 {x, y}\n\u22a2 z \u2208 carrier",["aesop"]],["Algebra/Category/AlgebraCat/Basic.lean",192,"R : Type u\ninst\u271d : CommRing R\nx\u271d\u00b9 : Type u\nx\u271d : AlgebraCat R\nf : (free R).obj x\u271d\u00b9 \u27f6 x\u271d\n\u22a2 (fun f \u21a6 ofHom ((FreeAlgebra.lift R) f)) ((fun f \u21a6 (FreeAlgebra.lift R).symm (Hom.hom f)) f) = f",["aesop"]],["CategoryTheory/Functor/FunctorHom.lean",54,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF\u271d G\u271d : C \u2964 D\nF G A : C \u2964 Type w\nx\u271d : F \u2297 A \u27f6 G\n\u22a2 (fun a \u21a6\n        {\n          app := fun X x \u21a6\n            match x with\n            | (x, y) => a.app X y x,\n          naturality := \u22ef })\n      ((fun a \u21a6 { app := fun X y x \u21a6 a.app X (x, y), naturality := \u22ef }) x\u271d) =\n    x\u271d",["aesop"]],["CategoryTheory/Functor/FunctorHom.lean",152,"case w.h.h.h\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u'\ninst\u271d : Category.{v', u'} D\nF G : C \u2964 D\nf : \ud835\udfd9_ (C \u2964 Type (max v' v u)) \u27f6 F.functorHom G\nX : C\na : (\ud835\udfd9_ (C \u2964 Type (max v' v u))).obj X\nY : C\n\u03c6 : X \u27f6 Y\nthis : (f.app Y PUnit.unit).app Y (\ud835\udfd9 Y) = (f.app X PUnit.unit).app Y (\u03c6 \u226b \ud835\udfd9 Y)\n\u22a2 (((fun f \u21a6 { app := fun x x_1 \u21a6 HomObj.ofNatTrans f, naturality := \u22ef })\n              ((fun f \u21a6\n                  { app := fun X \u21a6 (f.app X PUnit.unit).app X (\ud835\udfd9 (Opposite.unop (Opposite.op X))), naturality := \u22ef })\n                f)).app\n          X a).app\n      Y \u03c6 =\n    (f.app X a).app Y \u03c6",["aesop"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",76,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 biprod.desc (f \u226b biprod.inl) (biprod.lift (-\ud835\udfd9 Y) g) \u226b biprod.snd = biprod.snd \u226b g",["aesop"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",93,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 biprod.lift (kernel.\u03b9 (f \u226b g)) (kernel.\u03b9 (f \u226b g) \u226b f) \u226b biprod.desc (f \u226b biprod.inl) (biprod.lift (-\ud835\udfd9 Y) g) = 0",["aesop"]],["CategoryTheory/Abelian/DiagramLemmas/KernelCokernelComp.lean",149,"C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 cokernel.map f (f \u226b g) (\ud835\udfd9 X) g \u22ef \u226b cokernel.map (f \u226b g) g f (\ud835\udfd9 Z) \u22ef = 0",["aesop"]],["Algebra/Module/Presentation/Differentials.lean",96,"case e_s\nR : Type u\nS : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\npres : Presentation R S\n\u03c6 : (pres.rels \u2192\u2080 S) \u2192\u2097[pres.Ring] pres.toExtension.Cotangent :=\n  { toFun := \u21d1(hom\u2081 pres), map_add' := \u22ef, map_smul' := \u22ef }\nh\u2081 : Function.Surjective \u21d1Extension.Cotangent.mk\n\u22a2 (Subtype.val '' Set.range fun r \u21a6 \u27e8pres.relation r, \u22ef\u27e9) = Set.range pres.relation",["aesop"]],["Probability/Kernel/Proper.lean",59,"X : Type u_1\n\ud835\udcd1 \ud835\udce7 : MeasurableSpace X\n\u03c0 : Kernel X X\nh\ud835\udcd1\ud835\udce7 : \ud835\udcd1 \u2264 \ud835\udce7\n\u22a2 (\u2200 \u2983B : Set X\u2984 (hB : MeasurableSet B) (x : X) (s : Set X),\n      MeasurableSet s \u2192 ((\u03c0.restrict \u22ef) x) s = B.indicator (fun x \u21a6 1) x * (\u03c0 x) s) \u2194\n    \u2200 \u2983A : Set X\u2984,\n      MeasurableSet A \u2192 \u2200 \u2983B : Set X\u2984 (hB : MeasurableSet B) (x : X), ((\u03c0.restrict \u22ef) x) A = B.indicator 1 x * (\u03c0 x) A",["aesop"]],["Data/Int/CardIntervalMod.lean",50,"case h\na b r : \u2124\nhr : 0 < r\nx : \u2124\n\u22a2 ((a \u2264 x \u2227 x < b) \u2227 \u2203 c, x = c * r) \u2194 \u2203 a_1, (a \u2264 a_1 * r \u2227 a_1 * r < b) \u2227 { toFun := fun x \u21a6 x * r, inj' := \u22ef } a_1 = x",["aesop"]],["Data/Int/CardIntervalMod.lean",58,"case h\na b r : \u2124\nhr : 0 < r\nx : \u2124\n\u22a2 ((a < x \u2227 x \u2264 b) \u2227 \u2203 c, x = c * r) \u2194 \u2203 a_1, (a < a_1 * r \u2227 a_1 * r \u2264 b) \u2227 { toFun := fun x \u21a6 x * r, inj' := \u22ef } a_1 = x",["aesop"]],["Analysis/InnerProductSpace/Positive.lean",124,"\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : CompleteSpace E\nf : E \u2192L[\ud835\udd5c] E\nc : \u211d\u22650\nhc : 0 < c\nh : \u2200 (x : E), \u2016x\u2016 ^ 2 * \u2191c \u2264 \u2016\u27eaf x, x\u27eb_\ud835\udd5c\u2016\nh_anti : AntilipschitzWith c\u207b\u00b9 \u21d1f\n_inst : CompleteSpace \u21a5(LinearMap.range f)\nx : E\nhx : x \u2208 (LinearMap.range f)\u15ee\nthis : \u2016x\u2016 ^ 2 * \u2191c = 0\n\u22a2 x = 0",["aesop"]],["Algebra/Homology/ShortComplex/ModuleCat.lean",55,"R : Type u\ninst\u271d : Ring R\nS : ShortComplex (ModuleCat R)\n\u22a2 LinearMap.ker (ModuleCat.Hom.hom S.g) \u2264 LinearMap.range (ModuleCat.Hom.hom S.f) \u2194\n    LinearMap.range (ModuleCat.Hom.hom S.f) = LinearMap.ker (ModuleCat.Hom.hom S.g)",["aesop"]],["Algebra/Homology/ShortComplex/ModuleCat.lean",83,"R : Type u\ninst\u271d : Ring R\nS : ShortComplex (ModuleCat R)\nX\u2081 X\u2082 X\u2083 : ModuleCat R\nf : X\u2081 \u27f6 X\u2082\ng : X\u2082 \u27f6 X\u2083\nhfg : LinearMap.range (ModuleCat.Hom.hom f) \u2264 LinearMap.ker (ModuleCat.Hom.hom g)\n\u22a2 f \u226b g = 0",["aesop"]],["Algebra/Homology/ShortComplex/ModuleCat.lean",94,"R : Type u\ninst\u271d : Ring R\nS : ShortComplex (ModuleCat R)\nx y : \u2191S.X\u2081\n\u22a2 (fun x \u21a6 \u27e8(ConcreteCategory.hom S.f) x, \u22ef\u27e9) (x + y) =\n    (fun x \u21a6 \u27e8(ConcreteCategory.hom S.f) x, \u22ef\u27e9) x + (fun x \u21a6 \u27e8(ConcreteCategory.hom S.f) x, \u22ef\u27e9) y",["aesop"]],["Algebra/Homology/ShortComplex/ModuleCat.lean",95,"R : Type u\ninst\u271d : Ring R\nS : ShortComplex (ModuleCat R)\na : R\nx : \u2191S.X\u2081\n\u22a2 { toFun := fun x \u21a6 \u27e8(ConcreteCategory.hom S.f) x, \u22ef\u27e9, map_add' := \u22ef }.toFun (a \u2022 x) =\n    (RingHom.id R) a \u2022 { toFun := fun x \u21a6 \u27e8(ConcreteCategory.hom S.f) x, \u22ef\u27e9, map_add' := \u22ef }.toFun x",["aesop"]],["Algebra/Homology/ShortComplex/ModuleCat.lean",114,"R : Type u\ninst\u271d : Ring R\nS : ShortComplex (ModuleCat R)\n\u22a2 ModuleCat.ofHom (LinearMap.ker (ModuleCat.Hom.hom S.g)).subtype \u226b S.g = 0",["aesop"]],["Algebra/Homology/ShortComplex/ModuleCat.lean",116,"R : Type u\ninst\u271d : Ring R\nS : ShortComplex (ModuleCat R)\n\u22a2 (ModuleCat.kernelIsLimit S.g).lift (KernelFork.of\u03b9 S.f \u22ef) \u226b S.moduleCatHomology\u03c0 = 0",["aesop"]],["Combinatorics/Enumerative/InclusionExclusion.lean",84,"case pos.intro.e_s\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nG : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddCommGroup G\ns : Finset \u03b9\nS : \u03b9 \u2192 Finset \u03b1\nf : \u03b1 \u2192 G\nt : Finset \u03b9\na\u271d : t \u2208 s.powerset\ni : \u03b9\nhi : i \u2208 t\n\u22a2 t.inf' \u22ef S = filter (fun x \u21a6 \u2200 i \u2208 t, x \u2208 S i) (s.biUnion S)",["aesop"]],["Analysis/NormedSpace/FunctionSeries.lean",64,"\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : CompleteSpace F\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b2 \u2192 F\nu : \u03b9 \u2192 \u211d\nhu : Summable u\ns : Set \u03b2\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nt : Finset \u03b9\nht : \u2200 (b : Finset \u03b9), t \u2286 b \u2192 \u2211' (a : { x // x \u2209 b }), u \u2191a < \u03b5\nN : Set \u03b9\nhN : N \u2208 cofinite\nHN : \u2200 y \u2208 N, \u2200 x \u2208 s, \u2016f y x\u2016 \u2264 u y\nn : Finset \u03b9\nhn : Finite.toFinset hN \u222a t \u2286 n\nx : \u03b2\nhx : x \u2208 s\n\u22a2 \u2200 a \u2209 Finite.toFinset hN, \u2016f a x\u2016 \u2264 u a",["aesop"]],["Analysis/NormedSpace/FunctionSeries.lean",72,"\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : CompleteSpace F\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b2 \u2192 F\nu : \u03b9 \u2192 \u211d\nhu : Summable u\ns : Set \u03b2\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nt : Finset \u03b9\nht : \u2200 (b : Finset \u03b9), t \u2286 b \u2192 \u2211' (a : { x // x \u2209 b }), u \u2191a < \u03b5\nN : Set \u03b9\nhN : N \u2208 cofinite\nHN : \u2200 y \u2208 N, \u2200 x \u2208 s, \u2016f y x\u2016 \u2264 u y\nn : Finset \u03b9\nhn : Finite.toFinset hN \u222a t \u2286 n\nx : \u03b2\nhx : x \u2208 s\nA : Summable fun n \u21a6 \u2016f n x\u2016\ni : \u03b9\nhi : i \u2208 fun x \u21a6 x \u2209 n\nthis : i \u2209 Finite.toFinset hN\n\u22a2 i \u2208 N",["aesop"]],["CategoryTheory/Subpresheaf/Basic.lean",75,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\nG G' : Subpresheaf F\nx\u271d\u2074 : Set (Subpresheaf F)\nx\u271d\u00b3 : Subpresheaf F\nx\u271d\u00b2 : x\u271d\u00b3 \u2208 x\u271d\u2074\nx\u271d\u00b9 : C\u1d52\u1d56\nx\u271d : F.obj x\u271d\u00b9\n\u22a2 x\u271d \u2208 x\u271d\u00b3.obj x\u271d\u00b9 \u2192 x\u271d \u2208 (sSup x\u271d\u2074).obj x\u271d\u00b9",["aesop"]],["CategoryTheory/Subpresheaf/Basic.lean",76,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\nG G' : Subpresheaf F\nx\u271d\u2074 : Set (Subpresheaf F)\nx\u271d\u00b3 : Subpresheaf F\nx\u271d\u00b2 : \u2200 b \u2208 x\u271d\u2074, b \u2264 x\u271d\u00b3\nx\u271d\u00b9 : C\u1d52\u1d56\nx\u271d : F.obj x\u271d\u00b9\n\u22a2 x\u271d \u2208 (sSup x\u271d\u2074).obj x\u271d\u00b9 \u2192 x\u271d \u2208 x\u271d\u00b3.obj x\u271d\u00b9",["aesop"]],["CategoryTheory/Subpresheaf/Basic.lean",82,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\nG G' : Subpresheaf F\nx\u271d\u2074 : Set (Subpresheaf F)\nx\u271d\u00b3 : Subpresheaf F\nx\u271d\u00b2 : x\u271d\u00b3 \u2208 x\u271d\u2074\nx\u271d\u00b9 : C\u1d52\u1d56\nx\u271d : F.obj x\u271d\u00b9\n\u22a2 x\u271d \u2208 (sInf x\u271d\u2074).obj x\u271d\u00b9 \u2192 x\u271d \u2208 x\u271d\u00b3.obj x\u271d\u00b9",["aesop"]],["CategoryTheory/Subpresheaf/Basic.lean",83,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\nG G' : Subpresheaf F\nx\u271d\u2074 : Set (Subpresheaf F)\nx\u271d\u00b3 : Subpresheaf F\nx\u271d\u00b2 : \u2200 b \u2208 x\u271d\u2074, x\u271d\u00b3 \u2264 b\nx\u271d\u00b9 : C\u1d52\u1d56\nx\u271d : F.obj x\u271d\u00b9\n\u22a2 x\u271d \u2208 x\u271d\u00b3.obj x\u271d\u00b9 \u2192 x\u271d \u2208 (sInf x\u271d\u2074).obj x\u271d\u00b9",["aesop"]],["CategoryTheory/Subpresheaf/Basic.lean",130,"C : Type u\ninst\u271d : Category.{v, u} C\nF : C\u1d52\u1d56 \u2964 Type w\nS\u2081 S\u2082 T : Subpresheaf F\n\u22a2 (S\u2081 \u2294 S\u2082) \u2293 T = S\u2081 \u2293 T \u2294 S\u2082 \u2293 T",["aesop"]],["CategoryTheory/Subpresheaf/Basic.lean",134,"C : Type u\ninst\u271d : Category.{v, u} C\nF : C\u1d52\u1d56 \u2964 Type w\n\u03b9 : Type u_1\nS : \u03b9 \u2192 Subpresheaf F\nT : Subpresheaf F\n\u22a2 (\u2a06 i, S i) \u2293 T = \u2a06 i, S i \u2293 T",["aesop"]],["Order/Interval/Set/SuccPred.lean",57,"case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nx : \u03b1\n\u22a2 a \u2264 x \u2192 a = x \u2192 x \u2264 b",["aesop"]],["Order/Interval/Set/SuccPred.lean",61,"case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 succ b\nx : \u03b1\n\u22a2 x = succ b \u2228 x \u2264 b \u2192 x = succ b \u2192 a \u2264 x",["aesop"]],["Order/Interval/Set/SuccPred.lean",102,"case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nx : \u03b1\n\u22a2 x \u2264 b \u2192 x = b \u2192 a \u2264 x",["aesop"]],["Order/Interval/Set/SuccPred.lean",106,"case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nh : pred a \u2264 b\nx : \u03b1\n\u22a2 x = pred a \u2228 a \u2264 x \u2192 x = pred a \u2192 x \u2264 b",["aesop"]],["CategoryTheory/Subpresheaf/Image.lean",37,"C : Type u\ninst\u271d : Category.{v, u} C\nF : C\u1d52\u1d56 \u2964 Type w\n\u22a2 range (\ud835\udfd9 F) = \u22a4",["aesop"]],["CategoryTheory/Subpresheaf/Image.lean",40,"C : Type u\ninst\u271d : Category.{v, u} C\nF : C\u1d52\u1d56 \u2964 Type w\nG : Subpresheaf F\n\u22a2 range G.\u03b9 = G",["aesop"]],["CategoryTheory/Subpresheaf/Image.lean",108,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\nf : F \u27f6 F'\ng : F' \u27f6 F''\nx\u271d\u00b2 : C\u1d52\u1d56\nx\u271d\u00b9 : F''.obj x\u271d\u00b2\nx\u271d : x\u271d\u00b9 \u2208 (range (f \u226b g)).obj x\u271d\u00b2\n\u22a2 x\u271d\u00b9 \u2208 (range g).obj x\u271d\u00b2",["aesop"]],["CategoryTheory/Subpresheaf/Image.lean",124,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' : C\u1d52\u1d56 \u2964 Type w\nf : F \u27f6 F'\n\u22a2 \u22a4.image f = range f",["aesop"]],["CategoryTheory/Subpresheaf/Image.lean",128,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' : C\u1d52\u1d56 \u2964 Type w\n\u03b9 : Type u_1\nG : \u03b9 \u2192 Subpresheaf F\nf : F \u27f6 F'\n\u22a2 (\u2a06 i, G i).image f = \u2a06 i, (G i).image f",["aesop"]],["CategoryTheory/Subpresheaf/Image.lean",131,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\nG : Subpresheaf F\nf : F \u27f6 F'\ng : F' \u27f6 F''\n\u22a2 G.image (f \u226b g) = (G.image f).image g",["aesop"]],["CategoryTheory/Subpresheaf/Image.lean",134,"C : Type u\ninst\u271d : Category.{v, u} C\nF F' F'' : C\u1d52\u1d56 \u2964 Type w\nf : F \u27f6 F'\ng : F' \u27f6 F''\n\u22a2 range (f \u226b g) = (range f).image g",["aesop"]],["CategoryTheory/Subpresheaf/Image.lean",150,"C : Type u\ninst\u271d : Category.{v, u} C\nF : C\u1d52\u1d56 \u2964 Type w\nG : Subpresheaf F\n\u22a2 G.preimage (\ud835\udfd9 F) = G",["aesop"]],["CategoryTheory/EffectiveEpi/Comp.lean",42,"case a\nC : Type u_1\ninst\u271d\u00b9 : Category.{?u.13, u_1} C\n\u03b1 : Type u_2\nB : C\nX Y : \u03b1 \u2192 C\nf : (a : \u03b1) \u2192 X a \u27f6 B\ng : (a : \u03b1) \u2192 Y a \u27f6 X a\ni : (a : \u03b1) \u2192 X a \u27f6 Y a\nhi : \u2200 (a : \u03b1), i a \u226b g a = \ud835\udfd9 (X a)\ninst\u271d : EffectiveEpiFamily X f\nW\u271d : C\ne : (a : \u03b1) \u2192 Y a \u27f6 W\u271d\nw : \u2200 {Z : C} (a\u2081 a\u2082 : \u03b1) (g\u2081 : Z \u27f6 Y a\u2081) (g\u2082 : Z \u27f6 Y a\u2082), g\u2081 \u226b g a\u2081 \u226b f a\u2081 = g\u2082 \u226b g a\u2082 \u226b f a\u2082 \u2192 g\u2081 \u226b e a\u2081 = g\u2082 \u226b e a\u2082\na : \u03b1\n\u22a2 ((g a \u226b i a) \u226b g a) \u226b f a = g a \u226b f a",["aesop"]],["Algebra/Module/Presentation/Cokernel.lean",110,"A : Type u\ninst\u271d\u2078 : Ring A\nM\u2081 : Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\ninst\u271d\u2077 : AddCommGroup M\u2081\ninst\u271d\u2076 : Module A M\u2081\ninst\u271d\u2075 : AddCommGroup M\u2082\ninst\u271d\u2074 : Module A M\u2082\ninst\u271d\u00b3 : AddCommGroup M\u2083\ninst\u271d\u00b2 : Module A M\u2083\npres\u2082 : Presentation A M\u2082\nf : M\u2081 \u2192\u2097[A] M\u2082\n\u03b9 : Type w\u2081\ng\u2081 : \u03b9 \u2192 M\u2081\ndata : pres\u2082.CokernelData f g\u2081\nhg\u2081 : Submodule.span A (Set.range g\u2081) = \u22a4\nN\u271d : Type w\ninst\u271d\u00b9 : AddCommGroup N\u271d\ninst\u271d : Module A N\u271d\ns : (pres\u2082.cokernelRelations data).Solution N\u271d\n\u22a2 (pres\u2082.cokernelSolution data).postcomp\n      ((fun {N} [AddCommGroup N] [Module A N] s \u21a6\n          (LinearMap.range f).liftQ (\u22ef.desc { var := s.var, linearCombination_var_relation := \u22ef }) \u22ef)\n        s) =\n    s",["aesop"]],["CategoryTheory/Sites/LocallyFullyFaithful.lean",58,"C : Type uC\ninst\u271d\u00b9 : Category.{vC, uC} C\nD : Type uD\ninst\u271d : Category.{vD, uD} D\nG : C \u2964 D\nJ : GrothendieckTopology C\nK : GrothendieckTopology D\nU V : C\nf\u2081 f\u2082 : U \u27f6 V\n\u22a2 \u2200 {Y Z : C} {f : Y \u27f6 U}, (fun x i \u21a6 i \u226b f\u2081 = i \u226b f\u2082) Y f \u2192 \u2200 (g : Z \u27f6 Y), (fun x i \u21a6 i \u226b f\u2081 = i \u226b f\u2082) Z (g \u226b f)",["aesop"]],["RingTheory/TwoSidedIdeal/Lattice.lean",81,"R : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\ns : Set (TwoSidedIdeal R)\nI : TwoSidedIdeal R\nh : \u2200 b \u2208 s, b.ringCon \u2264 I.ringCon\n\u22a2 \u2200 b \u2208 ringCon '' s, b \u2264 I.ringCon",["aesop"]],["RingTheory/TwoSidedIdeal/Lattice.lean",82,"R : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\ns : Set (TwoSidedIdeal R)\nI : TwoSidedIdeal R\nhI : I \u2208 s\n\u22a2 I.ringCon \u2208 ringCon '' s",["aesop"]],["RingTheory/TwoSidedIdeal/Lattice.lean",95,"R : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\ns : Set (TwoSidedIdeal R)\nI : TwoSidedIdeal R\nh : \u2200 b \u2208 s, I.ringCon \u2264 b.ringCon\n\u22a2 \u2200 b \u2208 ringCon '' s, I.ringCon \u2264 b",["aesop"]],["RingTheory/TwoSidedIdeal/Lattice.lean",96,"R : Type u_1\ninst\u271d : NonUnitalNonAssocRing R\ns : Set (TwoSidedIdeal R)\nI : TwoSidedIdeal R\nhI : I \u2208 s\n\u22a2 I.ringCon \u2208 ringCon '' s",["aesop"]],["Topology/OmegaCompletePartialOrder.lean",60,"case h.e'_5.h.h.e\n\u03b1 : Type u\ninst\u271d : OmegaCompletePartialOrder \u03b1\ns : Set (Set \u03b1)\nhs : \u2200 t \u2208 s, \u03c9ScottContinuous fun x \u21a6 x \u2208 t\nx\u271d : \u03b1\n\u22a2 Membership.mem (\u22c3\u2080 s) = sSup s",["aesop"]],["Control/Bifunctor.lean",118,"F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082\ninst\u271d : Bifunctor F\n\u22a2 \u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (x : \u03b1 \u2295 \u03b2), bimap id id x = x",["aesop"]],["Control/Bifunctor.lean",119,"F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082\ninst\u271d : Bifunctor F\n\u22a2 \u2200 {\u03b1\u2080 \u03b1\u2081 \u03b1\u2082 : Type u_1} {\u03b2\u2080 \u03b2\u2081 \u03b2\u2082 : Type u_2} (f : \u03b1\u2080 \u2192 \u03b1\u2081) (f' : \u03b1\u2081 \u2192 \u03b1\u2082) (g : \u03b2\u2080 \u2192 \u03b2\u2081) (g' : \u03b2\u2081 \u2192 \u03b2\u2082) (x : \u03b1\u2080 \u2295 \u03b2\u2080),\n    bimap f' g' (bimap f g x) = bimap (f' \u2218 f) (g' \u2218 g) x",["aesop"]],["Algebra/Homology/ShortComplex/Ab.lean",45,"S : ShortComplex Ab\n\u22a2 \u2200 (a b : \u2191S.X\u2081),\n    (fun x \u21a6 \u27e8(ConcreteCategory.hom S.f) x, \u22ef\u27e9) (a + b) =\n      (fun x \u21a6 \u27e8(ConcreteCategory.hom S.f) x, \u22ef\u27e9) a + (fun x \u21a6 \u27e8(ConcreteCategory.hom S.f) x, \u22ef\u27e9) b",["aesop"]],["Topology/ContinuousMap/StarOrdered.lean",91,"\u03b1 : Type u_1\ninst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : Zero \u03b1\nR : Type u_2\ninst\u271d\u2077 : TopologicalSpace R\ninst\u271d\u2076 : OrderedCommSemiring R\ninst\u271d\u2075 : NoZeroDivisors R\ninst\u271d\u2074 : StarRing R\ninst\u271d\u00b3 : StarOrderedRing R\ninst\u271d\u00b2 : IsTopologicalSemiring R\ninst\u271d\u00b9 : ContinuousStar R\ninst\u271d : StarOrderedRing C(\u03b1, R)\np\u271d p : C(\u03b1, R)\np_mem : p \u2208 AddSubmonoid.closure (Set.range fun s \u21a6 star s * s)\nhp' : \u2200 (f g : C(\u03b1, R)\u2080), \u2191g = \u2191f + p \u2192 \u2203 p \u2208 AddSubmonoid.closure (Set.range fun s \u21a6 star s * s), g = f + p\nf g : C(\u03b1, R)\u2080\ns : C(\u03b1, R)\nhp : \u2191g = \u2191f + star s * s + p\nh\u2080 : (star s * s + p) 0 = 0\np'\u2080 : 0 \u2264 p 0\ns\u2089 : (star s * s) 0 = 0\n\u22a2 s 0 = 0",["aesop"]],["Algebra/Category/ModuleCat/Kernels.lean",27,"R : Type u\ninst\u271d : Ring R\nM N : ModuleCat R\nf : M \u27f6 N\n\u22a2 \u219f(LinearMap.ker (Hom.hom f)).subtype \u226b f = 0",["aesop"]],["CategoryTheory/MorphismProperty/Concrete.lean",51,"case h.e'_3\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nFC : C \u2192 C \u2192 Type u_1\nCC : C \u2192 Type u_2\ninst\u271d\u00b9 : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\ninst\u271d : ConcreteCategory C FC\nX : C\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 X)) = id",["aesop"]],["CategoryTheory/MorphismProperty/Concrete.lean",61,"case h.e'_3\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nFC : C \u2192 C \u2192 Type u_1\nCC : C \u2192 Type u_2\ninst\u271d\u00b9 : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\ninst\u271d : ConcreteCategory C FC\nX : C\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 X)) = id",["aesop"]],["CategoryTheory/MorphismProperty/Concrete.lean",71,"case h.e'_3\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nFC : C \u2192 C \u2192 Type u_1\nCC : C \u2192 Type u_2\ninst\u271d\u00b9 : (X Y : C) \u2192 FunLike (FC X Y) (CC X) (CC Y)\ninst\u271d : ConcreteCategory C FC\nX : C\n\u22a2 \u21d1(ConcreteCategory.hom (\ud835\udfd9 X)) = id",["aesop"]],["Order/Filter/Ultrafilter/Basic.lean",40,"case h.e'_1.h.e'_5\n\u03b1 : Type u\n\u03b2 : Type v\nf : Ultrafilter \u03b1\nis : Set \u03b2\nP : \u03b2 \u2192 \u03b1 \u2192 Prop\nhis : is.Finite\n\u22a2 {x | \u2203 a \u2208 is, P a x} = \u22c3 i \u2208 is, P i",["aesop"]],["CategoryTheory/Localization/Bousfield.lean",119,"case h.e'_3.h\nC : Type u_1\nD : Type u_2\ninst\u271d\u00b3 : Category.{u_4, u_1} C\ninst\u271d\u00b2 : Category.{u_3, u_2} D\nF : C \u2964 D\nG : D \u2964 C\nadj : G \u22a3 F\ninst\u271d\u00b9 : F.Full\ninst\u271d : F.Faithful\nX : D\nY : C\ne_1\u271d : ((G \u22d9 F).obj X \u27f6 F.obj Y) = (F.obj (G.obj X) \u27f6 F.obj Y)\ne_2\u271d : ((\ud835\udfed D).obj X \u27f6 F.obj Y) = (X \u27f6 F.obj Y)\n\u22a2 (fun g \u21a6 adj.unit.app X \u226b g) =\n    (fun f \u21a6 adj.unit.app X \u226b F.map f) \u2218 \u21d1(Functor.FullyFaithful.ofFullyFaithful F).homEquiv.symm",["aesop"]],["RingTheory/LocalRing/LocalSubring.lean",106,"R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\nK : Type u_3\ninst\u271d\u00b9 : Field K\nA : Subring K\nP : Ideal \u21a5A\ninst\u271d : P.IsPrime\nx\u271d : \u21a5A\ns : \u21a5P.primeCompl\ny : \u21a5A\nt : \u21a5P.primeCompl\ne :\n  (IsLocalization.liftAlgHom \u22ef) (IsLocalization.mk' (Localization.AtPrime P) x\u271d s) =\n    (IsLocalization.liftAlgHom \u22ef) (IsLocalization.mk' (Localization.AtPrime P) y t)\nx : \u21a5P.primeCompl\n\u22a2 \u2191x \u2260 0",["aesop"]],["CategoryTheory/Subpresheaf/Equalizer.lean",44,"C : Type u\ninst\u271d : Category.{v, u} C\nF\u2081 F\u2082 : C\u1d52\u1d56 \u2964 Type w\nA : Subpresheaf F\u2081\nf : A.toPresheaf \u27f6 F\u2082\n\u22a2 Subpresheaf.equalizer f f = A",["aesop"]],["CategoryTheory/Sites/Coherent/Comparison.lean",91,"case h.e'_5.h\nC : Type u_1\ninst\u271d\u00b2 : Category.{u_2, u_1} C\ninst\u271d\u00b9 : Preregular C\ninst\u271d : FinitaryPreExtensive C\nB : C\nS : Sieve B\nY\u271d : C\nI : Type\nw\u271d : Finite I\nX : I \u2192 C\nf : (a : I) \u2192 X a \u27f6 Y\u271d\nhT : EffectiveEpiFamily X f\nR Y : C\ni\u271d : Unit\n\u03c8 : R \u27f6 \u2210 fun i \u21a6 X i\nthis :\n  generate (Presieve.ofArrows X fun i \u21a6 Sigma.\u03b9 X i) \u2264 Sieve.pullback (Sigma.desc f) (generate (Presieve.ofArrows X f))\ne_4\u271d : \u2210 X = \u2210 X\n\u22a2 (Sigma.desc fun i \u21a6 Sigma.\u03b9 X i) = \ud835\udfd9 (\u2210 X)",["aesop"]],["Algebra/Module/Presentation/Tensor.lean",81,"A : Type u\ninst\u271d\u2076 : CommRing A\nM\u2081 : Type v\u2081\nM\u2082 : Type v\u2082\ninst\u271d\u2075 : AddCommGroup M\u2081\ninst\u271d\u2074 : AddCommGroup M\u2082\ninst\u271d\u00b3 : Module A M\u2081\ninst\u271d\u00b2 : Module A M\u2082\nrelations\u2081 : Relations A\nrelations\u2082 : Relations A\nsolution\u2081 : relations\u2081.Solution M\u2081\nsolution\u2082 : relations\u2082.Solution M\u2082\nh\u2081 : solution\u2081.IsPresentation\nh\u2082 : solution\u2082.IsPresentation\nN\u271d : Type w\ninst\u271d\u00b9 : AddCommGroup N\u271d\ninst\u271d : Module A N\u271d\nx\u271d : (relations\u2081.tensor relations\u2082).Solution N\u271d\n\u22a2 (solution\u2081.tensor solution\u2082).postcomp\n      ((fun {N} [AddCommGroup N] [Module A N] s \u21a6\n          (uncurry A M\u2081 M\u2082 N)\n            (h\u2081.desc\n              { var := fun g\u2081 \u21a6 h\u2082.desc { var := fun g\u2082 \u21a6 s.var (g\u2081, g\u2082), linearCombination_var_relation := \u22ef },\n                linearCombination_var_relation := \u22ef }))\n        x\u271d) =\n    x\u271d",["aesop"]],["AlgebraicTopology/SimplicialSet/Degenerate.lean",85,"case h.mp.intro.intro.intro.intro.intro.intro.intro\nX : SSet\nn m : \u2115\nhm : m < n + 1\ny : X _\u298bm\u298c\ni : Fin (n + 1)\n\u03b8 : \u298bn\u298c \u27f6 \u298bm\u298c\nhf : Epi (SimplexCategory.\u03c3 i \u226b \u03b8)\n\u22a2 X.map (SimplexCategory.\u03c3 i \u226b \u03b8).op y \u2208 \u22c3 i, Set.range (SimplicialObject.\u03c3 X i)",["aesop"]],["Data/Matrix/Hadamard.lean",123,"case inl\n\u03b1 : Type u_1\nm : Type u_2\nn : Type u_3\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : MulZeroClass \u03b1\nia : m\nja : n\nib : m\njb : n\na b : \u03b1\nh\u271d : \u00acia = ib\n\u22a2 ((of fun i' j' \u21a6 if ia = i' \u2227 ja = j' then a else 0) \u2299 of fun i' j' \u21a6 if ib = i' \u2227 jb = j' then b else 0) = 0\n```\n---\n```lean\ncase inr\n\u03b1 : Type u_1\nm : Type u_2\nn : Type u_3\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : MulZeroClass \u03b1\nia : m\nja : n\nib : m\njb : n\na b : \u03b1\nh\u271d : \u00acja = jb\n\u22a2 ((of fun i' j' \u21a6 if ia = i' \u2227 ja = j' then a else 0) \u2299 of fun i' j' \u21a6 if ib = i' \u2227 jb = j' then b else 0) = 0",["aesop"]],["Order/Filter/Cocardinal.lean",42,"\u03b1 : Type u\n\u22a2 cocardinal \u03b1 isRegular_aleph0 = cofinite",["aesop"]],["Order/Filter/Cocardinal.lean",50,"\u03b1 : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\nS : Set (Set \u03b1)\nhS : #\u2191S < c\nhSs : \u2200 s \u2208 S, s \u2208 cocardinal \u03b1 hreg\n\u22a2 \u2200 (i : \u2191(compl '' S)), #\u2191\u2191i < c",["aesop"]],["Data/Finsupp/Pointwise.lean",55,"\u03b1 : Type u\u2081\n\u03b2 : Type u\u2082\ninst\u271d : MulZeroClass \u03b2\ng\u2081 g\u2082 : \u03b1 \u2192\u2080 \u03b2\nx : \u03b1\nhx : x \u2208 (g\u2081 * g\u2082).support\n\u22a2 x \u2208 g\u2081.support",["aesop"]],["Data/Finsupp/Pointwise.lean",59,"\u03b1 : Type u\u2081\n\u03b2 : Type u\u2082\ninst\u271d : MulZeroClass \u03b2\ng\u2081 g\u2082 : \u03b1 \u2192\u2080 \u03b2\nx : \u03b1\nhx : x \u2208 (g\u2081 * g\u2082).support\n\u22a2 x \u2208 g\u2082.support",["aesop"]],["Algebra/Category/ModuleCat/Presheaf/Free.lean",40,"C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nR : C\u1d52\u1d56 \u2964 RingCat\nF : C\u1d52\u1d56 \u2964 Type u\n\u22a2 \u2200 (X : C\u1d52\u1d56),\n    (fun {X Y} f \u21a6 ModuleCat.freeDesc fun x \u21a6 ModuleCat.freeMk (F.map f x)) (\ud835\udfd9 X) =\n      (ModuleCat.restrictScalarsId' (RingCat.Hom.hom (R.map (\ud835\udfd9 X))) \u22ef).inv.app\n        ((fun X \u21a6 (ModuleCat.free \u2191(R.obj X)).obj (F.obj X)) X)",["aesop"]],["CategoryTheory/Limits/Shapes/CombinedProducts.lean",57,"C : Type u\u2081\ninst\u271d : Category.{u\u2082, u\u2081} C\n\u03b9\u2081 : Type u_1\n\u03b9\u2082 : Type u_2\nX : C\nf\u2081 : \u03b9\u2081 \u2192 C\nf\u2082 : \u03b9\u2082 \u2192 C\nc\u2081 : Fan f\u2081\nc\u2082 : Fan f\u2082\nbc : BinaryFan c\u2081.pt c\u2082.pt\nh\u2081 : IsLimit c\u2081\nh\u2082 : IsLimit c\u2082\nh : IsLimit bc\ns : Fan (Sum.elim f\u2081 f\u2082)\nm : s.pt \u27f6 (mk bc.pt (c\u2081.combPairHoms c\u2082 bc)).pt\nhm : \u2200 (j : \u03b9\u2081 \u2295 \u03b9\u2082), m \u226b (mk bc.pt (c\u2081.combPairHoms c\u2082 bc)).proj j = s.proj j\na : \u03b9\u2081\n\u22a2 (m \u226b proj bc WalkingPair.left) \u226b c\u2081.proj a =\n    ((fun s \u21a6\n            IsLimit.desc h fun i \u21a6\n              WalkingPair.casesOn (motive := fun t \u21a6 i = t \u2192 (s.pt \u27f6 WalkingPair.casesOn i c\u2081.pt c\u2082.pt)) i\n                (fun h \u21a6 \u22ef \u25b8 IsLimit.desc h\u2081 fun a \u21a6 s.proj (Sum.inl a))\n                (fun h \u21a6 \u22ef \u25b8 IsLimit.desc h\u2082 fun a \u21a6 s.proj (Sum.inr a)) \u22ef)\n          s \u226b\n        proj bc WalkingPair.left) \u226b\n      c\u2081.proj a",["aesop"]],["CategoryTheory/Limits/Shapes/CombinedProducts.lean",92,"C : Type u\u2081\ninst\u271d : Category.{u\u2082, u\u2081} C\n\u03b9\u2081 : Type u_1\n\u03b9\u2082 : Type u_2\nX : C\nf\u2081 : \u03b9\u2081 \u2192 C\nf\u2082 : \u03b9\u2082 \u2192 C\nc\u2081 : Cofan f\u2081\nc\u2082 : Cofan f\u2082\nbc : BinaryCofan c\u2081.pt c\u2082.pt\nh\u2081 : IsColimit c\u2081\nh\u2082 : IsColimit c\u2082\nh : IsColimit bc\ns : Cofan (Sum.elim f\u2081 f\u2082)\nm : (mk bc.pt (c\u2081.combPairHoms c\u2082 bc)).pt \u27f6 s.pt\nhm : \u2200 (j : \u03b9\u2081 \u2295 \u03b9\u2082), (mk bc.pt (c\u2081.combPairHoms c\u2082 bc)).inj j \u226b m = s.inj j\na : \u03b9\u2081\n\u22a2 c\u2081.inj a \u226b inj bc WalkingPair.left \u226b m =\n    c\u2081.inj a \u226b\n      inj bc WalkingPair.left \u226b\n        (fun s \u21a6\n            IsColimit.desc h fun i \u21a6\n              WalkingPair.casesOn (motive := fun t \u21a6 i = t \u2192 (WalkingPair.casesOn i c\u2081.pt c\u2082.pt \u27f6 s.pt)) i\n                (fun h \u21a6 \u22ef \u25b8 IsColimit.desc h\u2081 fun a \u21a6 s.inj (Sum.inl a))\n                (fun h \u21a6 \u22ef \u25b8 IsColimit.desc h\u2082 fun a \u21a6 s.inj (Sum.inr a)) \u22ef)\n          s",["aesop"]],["Data/List/Triplewise.lean",34,"\u03b1 : Type u_1\na : \u03b1\nl : List \u03b1\np : \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 (a :: l = [] \u2228 \u2203 a_1 l_1, Pairwise (p a_1) l_1 \u2227 Triplewise p l_1 \u2227 a :: l = a_1 :: l_1) \u2194\n    Pairwise (p a) l \u2227 Triplewise p l",["aesop"]],["Topology/ContinuousMap/Ordered.lean",25,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PartialOrder \u03b2\nf g : C(\u03b1, \u03b2)\nx\u271d : (fun f \u21a6 f.toFun) f = (fun f \u21a6 f.toFun) g\n\u22a2 f = g",["aesop"]],["Geometry/Group/Growth/QuotientInter.lean",48,"G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DecidableEq G\nH : Subgroup G\ninst\u271d\u00b9 : DecidablePred fun x \u21a6 x \u2208 H\ninst\u271d : H.Normal\nA : Finset G\nm n : \u2115\n\u03c0 : G \u2192* G \u29f8 H := QuotientGroup.mk' H\n\u03c6 : G \u29f8 H \u2192 G := invFunOn (\u21d1\u03c0) (\u2191A ^ m)\nh\u03c6 : Set.InjOn \u03c6 (\u21d1\u03c0 '' (\u2191A ^ m))\nh\u03c6A : \u2200 {a : G \u29f8 H}, a \u2208 \u21d1\u03c0 '' (\u2191A ^ m) \u2192 \u03c6 a \u2208 A ^ m\nh\u03c0\u03c6 : \u2200 {a : G \u29f8 H}, a \u2208 \u21d1\u03c0 '' (\u2191A ^ m) \u2192 \u03c0 (\u03c6 a) = a\na\u2081 b\u2081 : G\nhb\u2081 : b\u2081 \u2208 \u2191A ^ m\nha\u2081 : a\u2081 \u2208 H\na\u2082 b\u2082 : G\nhb\u2082 : b\u2082 \u2208 \u2191A ^ m\nha\u2082 : a\u2082 \u2208 H\nhab : \u03c6 (\u03c0 b\u2081) * a\u2081 = \u03c6 (\u03c0 b\u2082) * a\u2082\nh\u03c0a\u2081 : \u03c0 a\u2081 = 1\nh\u03c0a\u2082 : \u03c0 a\u2082 = 1\nh\u03c0b : \u03c0 b\u2081 = \u03c0 b\u2082\n\u22a2 \u03c6 (\u03c0 b\u2081) = \u03c6 (\u03c0 b\u2082) \u2227 a\u2081 = a\u2082",["aesop"]],["Data/Set/Constructions.lean",84,"\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : \u2200 \u2983s : Set \u03b1\u2984, s \u2208 S \u2192 \u2200 \u2983t : Set \u03b1\u2984, t \u2208 S \u2192 s \u2229 t \u2208 S\ns : Set \u03b1\nhs : s \u2208 insert univ S\nt : Set \u03b1\nht : t \u2208 insert univ S\n\u22a2 s \u2229 t \u2208 insert univ S",["aesop"]],["Data/Finset/PImage.lean",71,"\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b2\nf g : \u03b1 \u2192. \u03b2\ninst\u271d\u00b9 : (x : \u03b1) \u2192 Decidable (f x).Dom\ninst\u271d : (x : \u03b1) \u2192 Decidable (g x).Dom\ns t : Finset \u03b1\nh\u2081 : s = t\nh\u2082 : \u2200 x \u2208 t, f x = g x\n\u22a2 pimage f s = pimage g t",["aesop"]],["Analysis/InnerProductSpace/ProdL2.lean",75,"\ud835\udd5c : Type u_1\n\u03b9\u2081 : Type u_2\n\u03b9\u2082 : Type u_3\nE : Type u_4\nF : Type u_5\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c F\ninst\u271d\u00b9 : Fintype \u03b9\u2081\ninst\u271d : Fintype \u03b9\u2082\nv : OrthonormalBasis \u03b9\u2081 \ud835\udd5c E\nw : OrthonormalBasis \u03b9\u2082 \ud835\udd5c F\n\u22a2 (\u2200 (a : \u03b9\u2081),\n      (((v.toBasis.prod w.toBasis).map (WithLp.linearEquiv 2 \ud835\udd5c (E \u00d7 F)).symm).toOrthonormalBasis \u22ef) (Sum.inl a) =\n        Sum.elim (\u21d1(LinearMap.inl \ud835\udd5c E F) \u2218 \u21d1v) (\u21d1(LinearMap.inr \ud835\udd5c E F) \u2218 \u21d1w) (Sum.inl a)) \u2227\n    \u2200 (b : \u03b9\u2082),\n      (((v.toBasis.prod w.toBasis).map (WithLp.linearEquiv 2 \ud835\udd5c (E \u00d7 F)).symm).toOrthonormalBasis \u22ef) (Sum.inr b) =\n        Sum.elim (\u21d1(LinearMap.inl \ud835\udd5c E F) \u2218 \u21d1v) (\u21d1(LinearMap.inr \ud835\udd5c E F) \u2218 \u21d1w) (Sum.inr b)",["aesop"]],["CategoryTheory/Distributive/Cartesian.lean",72,"C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : ChosenFiniteProducts C\ninst\u271d\u00b9 : HasBinaryCoproducts C\ninst\u271d : IsCartesianDistributive C\nA B Z : C\nf g : Z \u27f6 (pair A B).obj { as := WalkingPair.left }\nhe : f \u226b (BinaryCofan.mk coprod.inl coprod.inr).inl = g \u226b (BinaryCofan.mk coprod.inl coprod.inr).inl\n\u03b9 : A \u27f6 A \u2a3f B := coprod.inl\nthis : Mono (Z \u25c1 \u03b9)\n\u22a2 lift (\ud835\udfd9 Z) f \u226b Z \u25c1 \u03b9 = lift (\ud835\udfd9 Z) g \u226b Z \u25c1 \u03b9",["aesop"]],["CategoryTheory/Limits/Shapes/PiProd.lean",47,"C : Type u_1\nI : Type u_2\ninst\u271d\u2077 : Category.{?u.4723, u_1} C\nX Y : I \u2192 C\nf : (i : I) \u2192 X i \u27f6 Y i\nP : I \u2192 Prop\ninst\u271d\u2076 : HasProduct X\ninst\u271d\u2075 : HasProduct Y\ninst\u271d\u2074 : HasProduct fun i \u21a6 X \u2191i\ninst\u271d\u00b3 : HasProduct fun i \u21a6 X \u2191i\ninst\u271d\u00b2 : HasProduct fun i \u21a6 Y \u2191i\ninst\u271d\u00b9 : HasProduct fun i \u21a6 Y \u2191i\ninst\u271d : (i : I) \u2192 Decidable (P i)\n\u22a2 \u2200 (s : BinaryFan (\u220f\u1d9c fun i \u21a6 X \u2191i) (\u220f\u1d9c fun i \u21a6 X \u2191i)),\n    ((fun s \u21a6\n            lift fun b \u21a6\n              if h : P b then s.\u03c0.app { as := WalkingPair.left } \u226b \u03c0 (fun i \u21a6 X \u2191i) \u27e8b, h\u27e9\n              else s.\u03c0.app { as := WalkingPair.right } \u226b \u03c0 (fun i \u21a6 X \u2191i) \u27e8b, h\u27e9)\n          s \u226b\n        map' Subtype.val fun x \u21a6 \ud835\udfd9 (X \u2191x)) =\n      s.snd",["aesop"]],["Algebra/Module/Presentation/Free.lean",42,"A : Type u\ninst\u271d\u00b3 : Ring A\nrelations : Relations A\nM : Type v\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module A M\ninst\u271d : IsEmpty relations.R\n\u22a2 \u2200 {N : Type w} [inst : AddCommGroup N] [inst_1 : Module A N] (s : relations.Solution N),\n    relations.solutionFinsupp.postcomp ((fun {N} [AddCommGroup N] [Module A N] s \u21a6 Finsupp.linearCombination A s.var) s) =\n      s",["aesop"]],["Order/Interval/Set/InitialSeg.lean",25,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nj : \u03b1\nx\u271d\u00b2 x\u271d\u00b9 : \u2191(Iic j)\nx\u271d :\n  (fun x \u21a6\n        match x with\n        | \u27e8j_1, hj\u27e9 => j_1)\n      x\u271d\u00b2 =\n    (fun x \u21a6\n        match x with\n        | \u27e8j_1, hj\u27e9 => j_1)\n      x\u271d\u00b9\n\u22a2 x\u271d\u00b2 = x\u271d\u00b9",["aesop"]],["Order/Interval/Set/InitialSeg.lean",26,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nj : \u03b1\n\u22a2 \u2200 {a b : \u2191(Iic j)},\n    {\n            toFun := fun x \u21a6\n              match x with\n              | \u27e8j_1, hj\u27e9 => j_1,\n            inj' := \u22ef }\n          a <\n        {\n            toFun := fun x \u21a6\n              match x with\n              | \u27e8j_1, hj\u27e9 => j_1,\n            inj' := \u22ef }\n          b \u2194\n      a < b",["aesop"]],["Order/Interval/Set/InitialSeg.lean",35,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nj : \u03b1\nx\u271d\u00b2 x\u271d\u00b9 : \u2191(Iio j)\nx\u271d :\n  (fun x \u21a6\n        match x with\n        | \u27e8j_1, hj\u27e9 => j_1)\n      x\u271d\u00b2 =\n    (fun x \u21a6\n        match x with\n        | \u27e8j_1, hj\u27e9 => j_1)\n      x\u271d\u00b9\n\u22a2 x\u271d\u00b2 = x\u271d\u00b9",["aesop"]],["Order/Interval/Set/InitialSeg.lean",36,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nj : \u03b1\n\u22a2 \u2200 {a b : \u2191(Iio j)},\n    {\n            toFun := fun x \u21a6\n              match x with\n              | \u27e8j_1, hj\u27e9 => j_1,\n            inj' := \u22ef }\n          a <\n        {\n            toFun := fun x \u21a6\n              match x with\n              | \u27e8j_1, hj\u27e9 => j_1,\n            inj' := \u22ef }\n          b \u2194\n      a < b",["aesop"]],["Order/Interval/Set/InitialSeg.lean",37,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nj : \u03b1\n\u22a2 \u2200 (b : \u03b1),\n    b \u2208\n        range\n          \u21d1{\n              toFun := fun x \u21a6\n                match x with\n                | \u27e8j_1, hj\u27e9 => j_1,\n              inj' := \u22ef, map_rel_iff' := \u22ef } \u2194\n      b < j",["aesop"]],["Order/Interval/Set/InitialSeg.lean",48,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ni j : \u03b1\nh : i \u2264 j\nx\u271d\u00b2 x\u271d\u00b9 : \u2191(Iic i)\nx\u271d :\n  (fun x \u21a6\n        match x with\n        | \u27e8k, hk\u27e9 => \u27e8k, \u22ef\u27e9)\n      x\u271d\u00b2 =\n    (fun x \u21a6\n        match x with\n        | \u27e8k, hk\u27e9 => \u27e8k, \u22ef\u27e9)\n      x\u271d\u00b9\n\u22a2 x\u271d\u00b2 = x\u271d\u00b9",["aesop"]],["Order/Interval/Set/InitialSeg.lean",49,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ni j : \u03b1\nh : i \u2264 j\n\u22a2 \u2200 {a b : \u2191(Iic i)},\n    {\n            toFun := fun x \u21a6\n              match x with\n              | \u27e8k, hk\u27e9 => \u27e8k, \u22ef\u27e9,\n            inj' := \u22ef }\n          a <\n        {\n            toFun := fun x \u21a6\n              match x with\n              | \u27e8k, hk\u27e9 => \u27e8k, \u22ef\u27e9,\n            inj' := \u22ef }\n          b \u2194\n      a < b",["aesop"]],["Order/Interval/Set/InitialSeg.lean",58,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ni j : \u03b1\nh : i \u2264 j\nx\u271d\u00b2 x\u271d\u00b9 : \u2191(Iio i)\nx\u271d :\n  (fun x \u21a6\n        match x with\n        | \u27e8k, hk\u27e9 => \u27e8k, \u22ef\u27e9)\n      x\u271d\u00b2 =\n    (fun x \u21a6\n        match x with\n        | \u27e8k, hk\u27e9 => \u27e8k, \u22ef\u27e9)\n      x\u271d\u00b9\n\u22a2 x\u271d\u00b2 = x\u271d\u00b9",["aesop"]],["Order/Interval/Set/InitialSeg.lean",59,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ni j : \u03b1\nh : i \u2264 j\n\u22a2 \u2200 {a b : \u2191(Iio i)},\n    {\n            toFun := fun x \u21a6\n              match x with\n              | \u27e8k, hk\u27e9 => \u27e8k, \u22ef\u27e9,\n            inj' := \u22ef }\n          a <\n        {\n            toFun := fun x \u21a6\n              match x with\n              | \u27e8k, hk\u27e9 => \u27e8k, \u22ef\u27e9,\n            inj' := \u22ef }\n          b \u2194\n      a < b",["aesop"]],["Order/Interval/Set/InitialSeg.lean",60,"\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\ni j : \u03b1\nh : i \u2264 j\n\u22a2 \u2200 (b : \u2191(Iic j)),\n    b \u2208\n        range\n          \u21d1{\n              toFun := fun x \u21a6\n                match x with\n                | \u27e8k, hk\u27e9 => \u27e8k, \u22ef\u27e9,\n              inj' := \u22ef, map_rel_iff' := \u22ef } \u2194\n      b < \u27e8i, h\u27e9",["aesop"]],["Combinatorics/SimpleGraph/Connectivity/Represents.lean",49,"case intro\nV : Type u\nG : SimpleGraph V\nC : Set G.ConnectedComponent\ns : Set V\nc : G.ConnectedComponent\nhrep : Represents s C\nh : c \u2208 C\na : V\nha : (fun x \u21a6 x \u2208 s \u2229 c.supp) a \u2227 \u2200 (y : V), (fun x \u21a6 x \u2208 s \u2229 c.supp) y \u2192 y = a\n\u22a2 \u2203 x, s \u2229 c.supp = {x}",["aesop"]],["Analysis/Normed/Group/CocompactMap.lean",37,"E : Type u_2\nF : Type u_3\n\ud835\udcd5 : Type u_4\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedAddCommGroup F\nf : \ud835\udcd5\ninst\u271d\u00b2 : ProperSpace F\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : CocompactMapClass \ud835\udcd5 E F\n\u03b5 : \u211d\nh : \u21d1f \u207b\u00b9' (closedBall 0 \u03b5)\u1d9c \u2208 cocompact E\nr : \u211d\nhr : (closedBall 0 r)\u1d9c \u2286 \u21d1f \u207b\u00b9' (closedBall 0 \u03b5)\u1d9c\nx : E\nhx : r < \u2016x\u2016\nthis : x \u2208 \u21d1f \u207b\u00b9' (closedBall 0 \u03b5)\u1d9c\n\u22a2 \u03b5 < \u2016f x\u2016",["aesop"]],["Data/List/Count.lean",36,"\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np : \u03b1 \u2192 Bool\nl : List \u03b1\na : \u03b1\n\u22a2 (if a \u2208 filter p l then (filter p l).length - 1 else (filter p l).length) =\n    (filter p l).length - if a \u2208 l \u2227 p a = true then 1 else 0",["aesop"]],["LinearAlgebra/Matrix/Permutation.lean",46,"n : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq n\n\u03c3 : Perm n\ninst\u271d\u00b9 : Semiring R\ninst\u271d : StarRing R\n\u22a2 (of fun i j \u21a6 star (Perm.permMatrix R \u03c3\u207b\u00b9 i j)) = Perm.permMatrix R \u03c3\u207b\u00b9",["aesop"]],["Analysis/Normed/Group/ZeroAtInfty.lean",31,"E : Type u_1\nF : Type u_2\n\ud835\udcd5 : Type u_3\ninst\u271d\u00b3 : SeminormedAddGroup E\ninst\u271d\u00b2 : SeminormedAddCommGroup F\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : ZeroAtInftyContinuousMapClass \ud835\udcd5 E F\nf : \ud835\udcd5\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh : (fun x \u21a6 \u2016f x\u2016) \u207b\u00b9' Metric.ball 0 \u03b5 \u2208 cocompact E\nr : \u211d\nhr : (Metric.closedBall 0 r)\u1d9c \u2286 (fun x \u21a6 \u2016f x\u2016) \u207b\u00b9' Metric.ball 0 \u03b5\nx : E\nhr' : r < \u2016x\u2016\nthis : x \u2208 (fun x \u21a6 \u2016f x\u2016) \u207b\u00b9' Metric.ball 0 \u03b5\n\u22a2 \u2016f x\u2016 < \u03b5",["aesop"]],["Analysis/Normed/Group/ZeroAtInfty.lean",33,"case h.a\nE : Type u_1\nF : Type u_2\n\ud835\udcd5 : Type u_3\ninst\u271d\u00b3 : SeminormedAddGroup E\ninst\u271d\u00b2 : SeminormedAddCommGroup F\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : ZeroAtInftyContinuousMapClass \ud835\udcd5 E F\nf : \ud835\udcd5\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh : (fun x \u21a6 \u2016f x\u2016) \u207b\u00b9' Metric.ball 0 \u03b5 \u2208 cocompact E\nr : \u211d\nhr : (Metric.closedBall 0 r)\u1d9c \u2286 (fun x \u21a6 \u2016f x\u2016) \u207b\u00b9' Metric.ball 0 \u03b5\nx : E\nhr' : r < \u2016x\u2016\n\u22a2 x \u2208 (Metric.closedBall 0 r)\u1d9c",["aesop"]],["Analysis/Normed/Group/ZeroAtInfty.lean",48,"case h\nE : Type u_1\nF : Type u_2\ninst\u271d\u00b2 : SeminormedAddGroup E\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : ProperSpace E\nf : E \u2192 F\nh : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 r, \u2200 (x : E), r < \u2016x\u2016 \u2192 \u2016f x\u2016 < \u03b5\ns : Set \u211d\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nhs : Metric.ball 0 \u03b5 \u2286 s\nr : \u211d\nhr : \u2200 (x : E), r < \u2016x\u2016 \u2192 \u2016f x\u2016 < \u03b5\na\u271d : E\n\u22a2 a\u271d \u2208 (Metric.closedBall 0 r)\u1d9c \u2192 a\u271d \u2208 (fun x \u21a6 \u2016f x\u2016) \u207b\u00b9' s",["aesop"]],["Data/Fintype/Sigma.lean",24,"\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Fintype (\u03ba i)\ns : Finset \u03b9\nf : Sigma \u03ba \u2192 Set \u03b1\n\u22a2 \u22c3 ij \u2208 s.sigma fun x \u21a6 Finset.univ, f ij = \u22c3 i \u2208 s, \u22c3 j, f \u27e8i, j\u27e9",["aesop"]],["Data/Fintype/Sigma.lean",27,"\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Fintype (\u03ba i)\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 \u22c3 i \u2208 s, \u22c3 j, f i j = \u22c3 ij \u2208 s.sigma fun x \u21a6 Finset.univ, f ij.fst ij.snd",["aesop"]],["Data/Fintype/Sigma.lean",30,"\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Fintype (\u03ba i)\ns : Finset \u03b9\nf : Sigma \u03ba \u2192 Set \u03b1\n\u22a2 \u22c2 ij \u2208 s.sigma fun x \u21a6 Finset.univ, f ij = \u22c2 i \u2208 s, \u22c2 j, f \u27e8i, j\u27e9",["aesop"]],["Data/Fintype/Sigma.lean",34,"\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Fintype (\u03ba i)\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 \u22c2 i \u2208 s, \u22c2 j, f i j = \u22c2 ij \u2208 s.sigma fun x \u21a6 Finset.univ, f ij.fst ij.snd",["aesop"]]]}],"mathlib_url":"https://github.com/leanprover-community/mathlib4/tree/db4c8abb9243cf1b6c77c8e544c7c851495af16a/Mathlib/"}